{"meta":{"title":"小李博客","subtitle":"","description":"","author":"小李博客","url":"http://xiaoliblog.cn","root":"/"},"pages":[{"title":"","text":"html, body { background: #28254C; font-family: 'Ubuntu'; } * { box-sizing: border-box; } .box { width: 350px; height: 100%; max-height: 600px; min-height: 450px; background: #332F63; border-radius: 20px; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); padding: 30px 50px; } .box .box__ghost { padding: 15px 25px 25px; position: absolute; left: 50%; top: 30%; transform: translate(-50%, -30%); } .box .box__ghost .symbol:nth-child(1) { opacity: .2; animation: shine 4s ease-in-out 3s infinite; } .box .box__ghost .symbol:nth-child(1):before, .box .box__ghost .symbol:nth-child(1):after { content: ''; width: 12px; height: 4px; background: #fff; position: absolute; border-radius: 5px; bottom: 65px; left: 0; } .box .box__ghost .symbol:nth-child(1):before { transform: rotate(45deg); } .box .box__ghost .symbol:nth-child(1):after { transform: rotate(-45deg); } .box .box__ghost .symbol:nth-child(2) { position: absolute; left: -5px; top: 30px; height: 18px; width: 18px; border: 4px solid; border-radius: 50%; border-color: #fff; opacity: .2; animation: shine 4s ease-in-out 1.3s infinite; } .box .box__ghost .symbol:nth-child(3) { opacity: .2; animation: shine 3s ease-in-out .5s infinite; } .box .box__ghost .symbol:nth-child(3):before, .box .box__ghost .symbol:nth-child(3):after { content: ''; width: 12px; height: 4px; background: #fff; position: absolute; border-radius: 5px; top: 5px; left: 40px; } .box .box__ghost .symbol:nth-child(3):before { transform: rotate(90deg); } .box .box__ghost .symbol:nth-child(3):after { transform: rotate(180deg); } .box .box__ghost .symbol:nth-child(4) { opacity: .2; animation: shine 6s ease-in-out 1.6s infinite; } .box .box__ghost .symbol:nth-child(4):before, .box .box__ghost .symbol:nth-child(4):after { content: ''; width: 15px; height: 4px; background: #fff; position: absolute; border-radius: 5px; top: 10px; right: 30px; } .box .box__ghost .symbol:nth-child(4):before { transform: rotate(45deg); } .box .box__ghost .symbol:nth-child(4):after { transform: rotate(-45deg); } .box .box__ghost .symbol:nth-child(5) { position: absolute; right: 5px; top: 40px; height: 12px; width: 12px; border: 3px solid; border-radius: 50%; border-color: #fff; opacity: .2; animation: shine 1.7s ease-in-out 7s infinite; } .box .box__ghost .symbol:nth-child(6) { opacity: .2; animation: shine 2s ease-in-out 6s infinite; } .box .box__ghost .symbol:nth-child(6):before, .box .box__ghost .symbol:nth-child(6):after { content: ''; width: 15px; height: 4px; background: #fff; position: absolute; border-radius: 5px; bottom: 65px; right: -5px; } .box .box__ghost .symbol:nth-child(6):before { transform: rotate(90deg); } .box .box__ghost .symbol:nth-child(6):after { transform: rotate(180deg); } .box .box__ghost .box__ghost-container { background: #fff; width: 100px; height: 100px; border-radius: 100px 100px 0 0; position: relative; margin: 0 auto; animation: upndown 3s ease-in-out infinite; } .box .box__ghost .box__ghost-container .box__ghost-eyes { position: absolute; left: 50%; top: 45%; height: 12px; width: 70px; } .box .box__ghost .box__ghost-container .box__ghost-eyes .box__eye-left { width: 12px; height: 12px; background: #332F63; border-radius: 50%; margin: 0 10px; position: absolute; left: 0; } .box .box__ghost .box__ghost-container .box__ghost-eyes .box__eye-right { width: 12px; height: 12px; background: #332F63; border-radius: 50%; margin: 0 10px; position: absolute; right: 0; } .box .box__ghost .box__ghost-container .box__ghost-bottom { display: flex; position: absolute; top: 100%; left: 0; right: 0; } .box .box__ghost .box__ghost-container .box__ghost-bottom div { flex-grow: 1; position: relative; top: -10px; height: 20px; border-radius: 100%; background-color: #fff; } .box .box__ghost .box__ghost-container .box__ghost-bottom div:nth-child(2n) { top: -12px; margin: 0 -0px; border-top: 15px solid #332F63; background: transparent; } .box .box__ghost .box__ghost-shadow { height: 20px; box-shadow: 0 50px 15px 5px #3B3769; border-radius: 50%; margin: 0 auto; animation: smallnbig 3s ease-in-out infinite; } .box .box__description { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); } .box .box__description .box__description-container { color: #fff; text-align: center; width: 200px; font-size: 16px; margin: 0 auto; } .box .box__description .box__description-container .box__description-title { font-size: 24px; letter-spacing: .5px; } .box .box__description .box__description-container .box__description-text { color: #8C8AA7; line-height: 20px; margin-top: 20px; } .box .box__description .box__button { display: block; position: relative; background: #FF5E65; border: 1px solid transparent; border-radius: 50px; height: 50px; text-align: center; text-decoration: none; color: #fff; line-height: 50px; font-size: 18px; padding: 0 70px; white-space: nowrap; margin-top: 25px; transition: background .5s ease; overflow: hidden; } .box .box__description .box__button:before { content: ''; position: absolute; width: 20px; height: 100px; background: #fff; bottom: -25px; left: 0; border: 2px solid #fff; transform: translateX(-50px) rotate(45deg); transition: transform .5s ease; } .box .box__description .box__button:hover { background: transparent; border-color: #fff; } .box .box__description .box__button:hover:before { transform: translateX(250px) rotate(45deg); } @keyframes upndown { 0% { transform: translateY(5px); } 50% { transform: translateY(15px); } 100% { transform: translateY(5px); } } @keyframes smallnbig { 0% { width: 90px; } 50% { width: 100px; } 100% { width: 90px; } } @keyframes shine { 0% { opacity: .2; } 25% { opacity: .1; } 50% { opacity: .2; } 100% { opacity: .2; } }","path":"404/404.css","date":"02-19","excerpt":""},{"title":"404","text":"(・∀・*) 网页走丢了 404 Not Found 页面走丢了，回首页看看? 返回主页 var pageX = window.innerWidth; var pageY = window.innerHeight; var mouseY=pageX; var mouseX=pageY; $(document).mousemove(function( event ) { //verticalAxis mouseY = event.pageY; yAxis = (pageY/2-mouseY)/pageY*300; //horizontalAxis mouseX = event.pageX / -pageX; xAxis = -mouseX * 100 - 100; $('.box__ghost-eyes').css({ 'transform': 'translate('+ xAxis +'%,-'+ yAxis +'%)' }); });","path":"/404.html","date":"02-19","excerpt":""},{"title":"","text":"小李博客 🍀博主信息 软件工程专业在读生，正在为考研准备中💪 热爱技术，业余时间唯一的爱好就是玩指弹吉他🎸，是指弹大神Tommy Emmanuel的铁杆粉丝 目标是成长为一名优秀的全栈开发工程师👨‍💻 🌍项目经历 HTML+CSS实现响应式科技公司官网 Hexo+GitHub搭建个人博客 VUE+Element UI+SSM+微信支付实现前后端完整电商闭环 Spring+SpringMVC+MyBatis实现小米商城 Nodejs实现多人博客系统 SpringBoot+Vue实现云E办网上办公普通 SpringBoot+Vue+Bootstrap搭建个人博客 Java微服务+分布式+全栈实现尚医通项目 🏆获证经历 大学生英语四六级证书 国家计算机等级考试二级(Java) NACG认证 JAVA开发工程师 全国软考职称认证 中级软件设计师 😘博客介绍 Hexo框架+Butterfly主题 博客搭建流程来源于B站UP主CodeSheep 页面美化创意来源于小康博主 搭建个人的博客的初衷是为了有一个属于自己的云笔记平台 博客中的部分图片源于网络，侵删 本博客文章采用 CC BY-NC-SA 4.0协议，转载请注明出处 🎯Java后端技能栈 🎯web前端技能栈","path":"about/index.html","date":"11-19","excerpt":""},{"title":"说说","text":"","path":"artitalk/index.html","date":"11-20","excerpt":""},{"title":"分类","text":"","path":"categories/index.html","date":"11-15","excerpt":""},{"title":"图库","text":"","path":"images/index.html","date":"11-20","excerpt":""},{"title":"友情链接","text":"欢迎各位小伙伴来我的博客！ 如需交换友链请提供以下信息在评论区哦！ 12345name: 小李博客 #博客名称link: https://xiaoliblog.cn/ #博客URLavatar: https://cdn.jsdelivr.net/gh/xiaoliblog/MyCDNRepo/img/headerimg.png #头像链接descr: 越努力越幸运 #简短的介绍自己的博客或座右铭siteshot: https://cdn.jsdelivr.net/gh/xiaoliblog/ScreenShot@gh-pages/xiaoliblog.cn.jpg","path":"link/index.html","date":"01-18","excerpt":""},{"title":"音乐","text":"","path":"music/index.html","date":"11-19","excerpt":""},{"title":"留言板","text":"来自小李博客的留言: 有什么想问的？ 有什么想说的？ 有什么想吐槽的？ 欢迎在评论区留言哦~","path":"messageboard/index.html","date":"01-07","excerpt":""},{"title":"吉他谱","text":"sing 经典弹唱吉他谱 fingerstyle 经典指弹吉他谱","path":"photograph/index.html","date":"01-25","excerpt":""},{"title":"Tommy Emmanuel","text":"Stay Close To Me Since we met Mombasa Angelina These who wait Over the rainbow Windy and warm Strutting It Drive time","path":"photograph/fingerstyle.html","date":"01-25","excerpt":""},{"title":"吉他弹唱谱","text":"红豆弹唱演示请戳👉https://www.bilibili.com/video/BV1EV411B7m4 遇见 我是一只鱼","path":"photograph/sing.html","date":"01-25","excerpt":""},{"title":"标签页","text":"","path":"tags/index.html","date":"11-15","excerpt":""},{"title":"","text":"/* Name: Kimbie (dark) Author: Jan T. Sott License: Creative Commons Attribution-ShareAlike 4.0 Unported License URL: https://github.com/idleberg/Kimbie-highlight.js */ /* Kimbie Comment */ .hljs-comment, .hljs-quote { color: #d6baad; } /* Kimbie Red */ .hljs-variable, .hljs-template-variable, .hljs-tag, .hljs-name, .hljs-selector-id, .hljs-selector-class, .hljs-regexp, .hljs-meta { color: #dc3958; } /* Kimbie Orange */ .hljs-number, .hljs-built_in, .hljs-builtin-name, .hljs-literal, .hljs-type, .hljs-params, .hljs-deletion, .hljs-link { color: #f79a32; } /* Kimbie Yellow */ .hljs-title, .hljs-section, .hljs-attribute { color: #f06431; } /* Kimbie Green */ .hljs-string, .hljs-symbol, .hljs-bullet, .hljs-addition { color: #889b4a; } /* Kimbie Purple */ .hljs-keyword, .hljs-selector-tag, .hljs-function { color: #98676a; } .hljs { display: block; overflow-x: auto; background: #221a0f; color: #d3af86; padding: 0.5em; } .hljs-emphasis { font-style: italic; } .hljs-strong { font-weight: bold; }","path":"self/Kimbiedark.css","date":"01-26","excerpt":""},{"title":"","text":"工具箱 | 小李博客 关于本页 本页面收集了比较常用或者实用的网站，相当于一个小小的导航页面。 整个页面由 Viggo 开发，完全开源，如果你也喜欢，欢迎去其 Github 点亮 star。 关于 Viggo Designer. Viggo. Full-time UI designer with an enduring interest in Coding. 一个全职的用户界面设计师，优秀的前端开发工程师，擅长 WEB 开发、WEB 设计、UI/UX 设计，对编程，拍照和单车有着持久的兴趣，生活在广州；如果您想招收此方面的人才，Viggo 无疑是一个很好的选择。 关于 小李博客 小李博客 在校本科软件工程大三学生，主攻 Java开发、爬虫和前端。 一个正在努力的在校本科生，倾向于 Java开发、网络爬虫、数据分析、数据可视化、WEB 前端方面的学习，热爱吉他指弹，一直坚持自己的云笔记博客，越努力越幸运！ COPYRIGHT 2020 - 2021 WEBSTACK 丨 DESIGNED BY VIGGO 丨 CHANGED BY 小李博客 -->","path":"box/about/index.html","date":"04-29","excerpt":""},{"title":"","text":"工具箱 | 小李博客 速查手册 开发社区 代码托管 语言文档 开源框架 常用工具 站长工具 HOT IT工具箱 文件处理 HOT 设计素材 效率软件 HOT 技能训练 在线平台 高校平台 游戏编程 HOT Pythoner 文档资料 博客收藏 学习资源 组织社区 爬虫相关 HOT 学习教程 在线视频 博客论坛 学习平台 服务平台 云服务商 众包平台 更多导航 关于本页 隐藏/显示侧边栏 博客首页 友情链接 评论留言 关于博主 (function (a, h, g, f, e, d, c, b) { b = function () { d = h.createElement(g); c = h.getElementsByTagName(g)[0]; d.src = e; d.charset = \"utf-8\"; d.async = 1; c.parentNode.insertBefore(d, c) }; a[\"SeniverseWeatherWidgetObject\"] = f; a[f] || (a[f] = function () { (a[f].q = a[f].q || []).push(arguments) }); a[f].l = +new Date(); if (a.attachEvent) { a.attachEvent(\"onload\", b) } else { a.addEventListener(\"load\", b, false) } }(window, document, \"script\", \"SeniverseWeatherWidget\", \"//cdn.sencdn.com/widget2/static/js/bundle.js?t=\" + parseInt((new Date().getTime() / 100000000).toString(), 10))); window.SeniverseWeatherWidget('show', { flavor: \"slim\", location: \"WX4FBXXFKE4F\", geolocation: true, language: \"auto\", unit: \"c\", theme: \"auto\", token: \"a39cd5a0-4024-4cb2-85c6-0250317058db\", hover: \"enabled\", container: \"tp-weather-widget\" }) 速查手册 CSS参考-MDN 快速进入MDN的CSS参考手册 Web API参考-MDN 快速进入MDN的Web API参考手册 事件参考-MDN 快速进入MDN的事件参考手册 Git Book 官方Git教程 GitHub Actions手册 官方Git教程 Staticfile CDN 免费、快速、开放的 CDN 服务 BootCDN 稳定、快速、免费的前端开源项目 CDN 加速服务 腾讯软件中心 装机必备软件，免费下载 收藏猫插件 不错的插件库 开发社区 Stack Overflow 全球最受程序员欢迎的开发社区 CSDN 全球最大中文IT社区，为IT专业技术人员提供最全面的信息传播和服务平台 博客园 代码改变世界 V2EX V2EX = way to explore 掘金 一个帮助开发者成长的社区 SegmentFault 改变并提升人们获取知识的方式和效率，帮助更多的开发者获得成长与成功 开源中国 国内最大的开源技术社区 ITeye ITeye软件开发交流社区 - Java编程 Spring框架 Ajax技术 agile敏捷软件开发 ruby on rails实践 51CTO 技术成就梦想 ITPUB 全球最大的学习分享平台 知乎 国内最受欢迎的知识性问答社区 简书 创作你的创作 云+社区 来自腾讯的开发者技术分享社区 云栖社区 阿里云面向开发者的开放型技术平台 代码托管 Github 全球最大的面向开源及私有软件项目的托管平台 Gitlab 支持无限的公有项目和私有项目的代码托管平台 Bitbucket 同时支持 Git 和 Mercurial 这两个版本控制软件，免费的私有仓库，支持5人以内的合作开发 SourceForge 又称 SF.net，是开源软件开发者进行开发管理的集中式场所 Coding 国内首个一站式云端软件服务平台 Gitee 国内最大的开源社区 OSChina 的代码托管平台 阿里云代码托管 阿里云旗下代码托管平台 百度效率云 百度云旗下的 Git 代码托管平台 Vercel 基于Hexo引擎模板开发的网站托管工具 语言文档 Zeal 脱机文档浏览器，包含196种语言API文档，支持Windows、Linux和macOS Dash 适用于Mac OS平台的软件编程文档管理工具,可以浏览API文档,以及管理代码片段工具。自带了丰富的API文档,涉及各种主流的编程语言和框架 DevDocs 在快速，有条理和可搜索的界面中结合了多个API文档，可以在移动设备上离线运行，并且可以安装在Chrome上 C/C++ C/C++ API 文档 C# C# API 文档 Java Java API 文档 .NET .NET API 文档 PHP PHP API 文档 JavaScript JavaScript API 文档 Python Python API 文档 Android Android API 文档 iOS iOS API 文档 SQL SQL API 文档 Swift Swift API 文档 Ruby Ruby API 文档 GO GO API 文档 R R API 文档 MATLAB MATLAB API 文档 Node.js Node.js API 文档 HTML HTML API 文档 CSS CSS API 文档 Redis Redis API 文档 MongoDB MongoDB API 文档 Django Django API 文档 Pug Pug模板引擎中文文档 npm 中文文档 npm 是 JavaScript 世界的包管理工具,并且是 Node.js 平台的默认包管理工具。通过 npm 可以安装、共享、分发代码,管理项目依赖关系 开源框架 Spring Spring框架是一个开放源代码的J2EE应用程序框架 Spring MVC Spring MVC是一款优秀的、基于MVC思想的应用框架,它是Spring的一个子框架 MyBatis MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射 Spring Boot 高效的微服务开发框架 Vue.js Vue.js是一款渐进式的JavaScript框架 vue-element-admin vue-element-admin 是一个后台前端解决方案，它基于 vue 和 element-ui实现 Node.js Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时 React React用于构建用户界面的 JavaScript 库 Bootstrap Bootstrap 是最受欢迎的 HTML、CSS 和 JS 框架，用于开发响应式布局、移动设备优先的 WEB 项目 Lay UI 开源模块化前端 UI 框架 Element UI 一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库 Semantic UI 用户界面就是 Web 的语言 Tailwind CSS Tailwind CSS 是一个功能类优先的 CSS 框架 Hexo Hexo 是一个基于nodejs 的静态博客网站生成器，作者是来自台湾的 Tommy Chen Git Git 是一个开源的分布式版本控制系统, Maven Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理 Webpack Webpack 是一个模块打包器 animejs anime.js是一个强大的用来制作动画的javascript库 glidejs glidejs是一个好用的轮播组件 Isotope Isotope.js 超好看前端响应式JS插件 动态实现瀑布流布局排版、筛选、排序等功能 ScrollReveal scrollReveal.js 是一款页面滚动显示动画的 JavaScript，能让页面更加有趣，更吸引用户眼球 Smooth Scroll Smooth Scroll可以让链接跳转更加流畅 Animate 强大的跨平台的预设css3动画库 Axios Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中 jQuery custom content scroller jQuery滚动条插件jQuery custom content scroller支持横向滚动纵向滚动以及多种滚动显示效果 jQuery API 中文文档 jQuery API 中文文档 在线平台 LeetCode 全球极客挚爱的技术成长平台 Topcoder 全世界规模最大的程序竞赛网站，也会有一些算法竞赛，适合一些高端的或者搞ACM的，也会举办一些比赛 Codeforces 俄罗斯最大的算法比赛网站 Hihocoder 技术团队来自原北京大学POJ (PKU Online Judge)开发团队，收集了全球范围内很多地区、高校举办的比赛试题， 提供365天*24小时的在线提交、评判程序的服务 LintCode 被称作中文版的leetcode，也是可以做为编程能力提升的一个中转站 SPOJ 波兰的算法刷题网站 NEUQ OJ 一个在线的判题平台 洛谷 创办于2013年，致力于为参加noip、noi、acm的选手提供清爽、快捷的编程体验 牛客网 中国最大的IT题库 C语言网 在这里可以参加包括ACM、NOI在内的各种C/C++/java程序比赛，也可以DIY举办各类程序比赛活动！ 计蒜客 计蒜客OI题库致力于为参加noi、noip、信息学竞赛的选手提供优秀的Online Judge系统 高校平台 POJ 北京大学程序在线评测系统 FDU OJ 复旦大学程序在线评测系统 TJ OJ 同济大学程序在线评测系统 USTC OJ 中国科学技术大学程序在线评测系统 ZOJ 浙江大学程序在线评测系统 HDU OJ 杭州电子科技大学程序在线评测系统 CSU-ACM 中南大学程序在线评测系统 HOJX 哈尔滨工业大学程序在线评测系统 HRBUST OJ 哈尔滨理工大学程序在线评测系统 PowerOJ 西南科技大学程序在线评测系统 SCU OJ 四川大学程序在线评测系统 FZU CoidngOJ 福州大学程序在线评测系统 NBUT OJ 宁波工程学院程序在线评测系统 Lutece 电子科技大学程序在线评测系统 武汉大学 ACM 协会 武汉大学 ACM 协会 ZJUT OJ 浙江工业大学程序在线评测系统 游戏编程 CheckiO 面向初学者和高级程序员的编码游戏，使用Python和JavaScript解决棘手的挑战和有趣的任务，从而提高您的编码技能 Coding Games 支持包括PHP、C、JavaScript在内的20多种编程语言。用户界面功能强大，可以定制 Codewars 一个外国的在线练习编程的网站,做题的过程类似打怪,做题升级,而且可以看到别人的解法,里面有很多巧妙的写法可以学习 CodeCombat 一个面向学生的游戏和CS学习平台。这是一个社区项目，有数百玩家自愿提供支持。支持语言包括Java、JS、Python、Lua、CoffeeScript Screeps 在游戏中学习JavaScript。世界上第一款针对程序员的MMO沙盒游戏 VIM Adventures 玩游戏的时候学VIM Cyber-Dojo 一个提供给程序员们练习写程序的地方。支持语言包括JavaScript、Java、Python、PHP、Ruby和很多其他语言 Elevator Saga 电梯编程游戏，跟随关卡解决所有挑站，使用语言为JavaScript Ruby Quiz 一个Ruby程序员提供的每周编程挑战项目 hacker.org 这项挑战由一系列本设计来强化你黑客技巧的解密、诡计、测试、烧脑环节组成。想要通关本系列，你必须学会解密、编码、渗透 Ruby Warrior 玩游戏学Ruby，通过Ruby脚本来控制一个Warrior通过每一关，每一关的代码难度都会有所增加，使玩家逐渐了解Ruby基本的函数、控制、变量、数组等语言特性的用法 文档资料 Python 官方文档 Python 官方文档 Python 标准库 Python 标准库 Python Requests Python Requests 文档 Python Urllib Python Urllib 文档 Python Selenium Python Selenium 中文翻译文档 正则表达式 Python 正则表达式官方文档 Beautiful Soup Beautiful Soup 文档 Scrapy Scrapy 爬虫框架官方文档 PySpider PySpider 爬虫框架官方文档 Matplotlib Matplotlib 2D绘图库 官方中文文档 Numpy Numpy 科学计算 官方中文文档 Pandas Pandas 结构化数据分析 官方中文文档 博客收藏 廖雪峰 廖雪峰的官方网站 - 研究互联网产品和技术，提供原创中文精品教程 崔庆才 崔庆才的个人博客,专注PHP,Python,爬虫,深度学习,机器学习,数据分析 莫烦Python 专注Python、机器学习、深度学习 唐松 专注Python网络爬虫, 数据科学, 数据挖掘, 数据分析 捕蛇者说 编程、程序员、Python FxxkPython 学习python的正确姿势 wistbean Python 大佬 Piglei Python 大佬 TendCode Python 大佬 追梦人物的博客 Python Django 大佬 the5fire 《Django企业开发实战》作者，关注Python、Django、Vim、Linux、Web开发 小明明S À DOMICILE 《Python Web开发实战》作者，Python 大佬 Python之禅 Python 大佬 Python 知识圈 Python知识圈 - 实用的Python教程网站 Python 教程网 小詹学Python，专注Python学习 烂笔头 j_hao104 Python大佬 咸鱼日常 专注Python爬虫，有许多JS逆向文章 AnSheng Python 全栈大佬 夏溪辰 云栖社区特邀爬虫工程师，Python大佬 高级农民工 Python大佬 云爬虫技术研究笔记 Lateautumn4lin 爬虫开发工程师，多年反爬虫破解经验，沉迷数据分析和黑客增长，CSDN博客专家，华为云享专家 云爬虫技术研究笔记(CSDN) Lateautumn4lin 爬虫开发工程师，多年反爬虫破解经验，沉迷数据分析和黑客增长，CSDN博客专家，华为云享专家 Jack Cui CSDN博客专家，Python 大佬 学习资源 Python爬虫人工智能学习教程 Python爬虫人工智能学习教程分享 Python 中文学习大本营 Python 中文学习大本营 Python 资源大全中文版 Python 资源大全中文版 组织社区 PyChina Python 中国社区 PyCon China 中国 Python 开发者大会 蠎周刊 蠎周刊 - 汇集全球蠎事儿 爬虫相关 镀金的天空 GlidedSky 镀金的天空，在线爬虫练习题库 夜幕爬虫安全论坛 一个专注于爬虫与 PC/Web/ 移动端安全领域技术交流的社区，社区由夜幕团队 NightTeam 创办，旨在提升开发者对爬虫与软件安全防护的理解 西刺免费代理IP 每日更新免费HTTP代理，所有代理均为6675端口高匿代理，可隐藏IP 爬虫IP代理池 爬虫IP代理池 云打码 采用全球领先的秒传识别系统，50%图片零秒识别，人工平均处理时间0-3秒 超级鹰 专业的验证码云端识别服务,让验证码识别更快速、更准确、更强大 八爪鱼采集器 一款使用简单、功能强大的网络爬虫工具，完全可视化操作，无需编写代码，内置海量模板，支持任意网络数据抓取 Python 逆向 Python 逆向相关资源 Python 爬虫集合 Python 爬虫集合 Python 入门网络爬虫之精华版 Python 入门网络爬虫之精华版 爬虫项目进阶实战 Python3 爬虫项目进阶实战、JS加解密、逆向教程、css 加密、字体加密 Python 模拟登陆一些大型网站 Python 模拟登陆一些大型网站 系统化学习 Python 爬虫 系统化学习 Python 爬虫 Python3 网络爬虫实战 Python3 网络爬虫实战 在线视频 腾讯课堂 腾讯推出的专业在线教育平台，聚合大量优质教育机构和名师 网易云课堂 网易旗下一个专注职业技能提升的在线学习平台。立足于实用性的要求，与多家教育培训机构和行业的专家、讲师建立合作 中国大学 MOOC 中国大学MOOC(慕课)，国家精品课程在线学习平台 黑马程序员 致力于培养中级程序员，是业内以口碑闻名的IT教育培训机构 课工场 更可靠的IT就业教育平台，针对大学生量身定制人工智能、大数据、云计算、区块链、Java大数据开发等大学生IT培训课程 极客学院 极客学院作为中国专业IT职业在线教育平台,拥有海量高清IT职业课程,涵盖30+个技术领域 慕课网 慕课网（IMOOC）是IT技能学习平台。慕课网(IMOOC)提供了丰富的移动端开发、php开发、web前端、android开发以及html5等视频教程资源公开课 尚硅谷 尚硅谷Java培训，谷粉与老学员为你推荐的Java培训、Web前端培训、前端培训、大数据培训、Python培训；0基础入学，学员就业起薪屡创新高！ 实验楼 国内领先的IT在线编程及在线实训学习平台，专业导师提供精选的实践项目，创新的技术使得学习者无需配置繁琐的本地环境，随时在线流畅使用 优达学城 Udacity是来自硅谷的前沿技术平台，为广大学子提供WEB前端开发、Python/JAVA编程、IOS/Android开发、人工智能开发等一系列在线课程及实战项目，满足学员灵活的学习需求 51CTO学院 51CTO学院IT职业在线教育平台是依托12年行业品牌、1400万IT技术用户建立的专业IT技能学习培训平台，已签约1000多位技术专家发布了12万个自学式实战视频教程 CSDN 学院 CSDN 学院作为IT在线教育平台,涵盖人工智能、考试认证、移动开发、大数据技术领域职业课程 老男孩IT教育 隶属北京一天天教育科技有限公司,是一直专注于Linux培训、Linux系统及架构师培训、Python培训、网络安全培训，大数据实战的高端培训机构 千锋教育 千锋教育 - 坚持教育初心，坚持面授品质，IT培训良心品牌 博客论坛 鱼C工作室 鱼C工作室-免费编程视频教学|Python教学|Web开发教学|全栈开发教学|C语言教学|汇编教学|Win32开发|加密与解密|Linux教学 吾爱破解 致力于软件安全与病毒分析的前沿，丰富的技术版块交相辉映，由无数热衷于软件加密解密及反病毒爱好者共同维护 廖雪峰 廖雪峰的官方网站 - 研究互联网产品和技术，提供原创中文精品教程 崔庆才 崔庆才的个人博客,专注PHP,Python,爬虫,深度学习,机器学习,数据分析 莫烦Python 专注Python、机器学习、深度学习 唐松 专注Python网络爬虫, 数据科学, 数据挖掘, 数据分析 阮一峰 上海财经大学世界经济博士研究生，计算机科普博主，对自由软件有着坚定不移的信念 学习平台 菜鸟教程 提供了编程的基础技术教程, 介绍了HTML、CSS、Javascript、Python，Java，Ruby，C，PHP , MySQL等各种编程语言的基础知识 W3school 领先的 Web 技术教程 C语言网 C语言网 - 领先实用的编程在线学习网站 前端网 前端网，最好的自学web前端网站 牛客网 牛客网 - 互联网求职神器和备考学习平台 How2J How2J的Java教程, 内容涵盖J2SE、WEB前端、J2EE、框架技术等全面的Java内容 站长工具 新浪短网址 多种后缀短网址生成 百度短网址 百度旗下专业的网址缩短服务 站长工具 - 站长之家 站长工具,SEO工具,权重查询,收录查询,PR查询,ICP备案查询,whois查询,友情链接查询,反向链接查询,网站测试,IP查询,Alexa查询 阿里云 whois 查询 whois查询,域名whois,域名注册信息,whois查询工具,whois信息,域名信息 NnameBeta 国际域名搜索、域名注册、国别域名注册、域名比价 Domcomp 域名比价，Domain Name Price and Availability. 仿站工具箱 在线仿站工具箱 超级 SEO 外链工具 网站自动化宣传机器/免费的超级外链工具可批量增加外链 百度站长平台 百度搜索资源平台 - 让网站更具价值 搜狗站长平台 搜狗站长平台 - 全面掌握在搜狗搜索中的数据表现 360 站长平台 360 站长平台 - 给网站带来更多流量和展现 Google 站长平台 Google 网站站长 - 支持、学习、互动交流和 Search Console – Google Bing 网站管理员工具 Bing 网站管理员工具 百度广告联盟 百度广告联盟为您的流量增值 Google AdSense Google 广告平台 百度统计 百度统计 — 最大的中文网站分析平台 友盟+ 国内领先的第三方全域数据智能服务商 ICP/IP地址/域名信息备案管理系统 工业和信息化部ICP/IP地址/域名信息备案管理系统 全国互联网安全管理服务平台 公安备案网 - 全国互联网安全管理服务平台 IT工具箱 在线工具 - 程序员的工具箱 站长工具、代码格式化、压缩、加密、解密、下载链接转换等 在线工具 - OSCHINA.NET社区 常用文档、常用对照表、代码处理、Html/Js/Css工具、加密/转码工具等 记磊工具箱 Dns检测、CSS格式化、超级Ping、端口扫描等 孟坤工具箱 css一键美化、文本差异比较、代码高亮等 Syntax Highlight Syntax Highlight Code In Word Documents，在Word文档中插入漂亮的代码 Text to ASCII Art Generator Text to ASCII Art Generator，字符串转成 ASCII 码图案 MDEditor 开源在线 Markdown 编辑器 临时邮箱 匿名注册不常用的网站/论坛，保护隐私免骚扰 SM.MS SM 免费图床，每个文件最大支持 5MB 路过图床 免费公共图床，支持最大10MB、批量上传 Greasy Fork 安全、实用的用户脚本大全 Hello World 大全 收集了大约481种 Hello World 程序，涵盖了目前已知的所有编程语言，另加上 67 人类语言 动画展示各种路径搜索算法 动画展示各种路径搜索算法 IT eBooks 可以下载IT电子书籍的网站（英文） GEEKTyper 在线模拟黑客工作的虚拟桌面系统，提供多种黑客工作的场景 免费计算机编程类中文书籍 免费计算机编程类中文书籍 EaseUS Partition Master 磁盘分区管理软件，不用重装系统，就可以重新划分磁盘空间 蓝奏云 天下武功，为快不破 在线正则表达式测试 在线正则表达式测试工具 哔哩哔哩工具 bilibili在线工具 html2jade 将html转为jade的在线转换工具 fastmock 服务于前后端分离项目的接口 MOCK 平台 ProcessOn ProcessOn是一个在线协作绘图平台,为用户提供最强大、易用的作图工具!支持在线创作流程图、思维导图、组织结构图、网络拓扑图、BPMN、UML图、UI界面原型设计、iOS界面原型设计等 MindLine思维导图 快速高效在线制作思维导图工具 PlantUML PlantUML是一个用来绘制UML 图的Java库。支持的UML图包括:时序图、用例图、组件图、活动图。 NATAPP.CN 内网穿透工具，开启您的内网穿透之旅 Sunny-Ngrok 提供免费内网穿透服务，免费服务器支持绑定自定义域名 GoEasy 快速打造您的web实时通讯体系 文件处理 Convertio 在线文件转换工具，支持超过309种不同的文档、图像、电子表格、电子书、文档、演示文稿、音频和视频格式 Office-Converter 免费在线转换视频，在线音频转换，在线图形转换，在线文档转换和在线压缩格式 TinyPNG PNG/JPG图片在线压缩利器 Squoosh Google开源在线压缩、调整工具，支持WebP ILoveIMG 永远免费的在线图片处理工具，可在线编辑，压缩、裁剪、转换、水印等 Smallpdf Smallpdf - A Free Solution to all your PDF Problems,PDF压缩、转换、分割、合并等 PHOTOMOSH 故障艺术在线生成，可以输出jpg、gif和视频 稿定抠图 免费在线抠图软件,图片快速换背景-抠白底图 U钙网 完全免费的LOGO在线设计制作工具 SVGOMG SVG在线压缩平台 在线图片透明圆角处理 在线图片透明圆角处理 草料二维码 国内创建二维码在线应用 Logaster 在线免费创建简单logo及名片设计 Preloaders Loading 懒加载动画在线制作 Loading 制作GIF、SVG、CSS加载动画图标 waifu2x 图片智能无损放大2倍，适合动漫、插画等 智图 腾讯ISUX前端团队开发的一个专门用于图片压缩和图片格式转换的平台 音乐免费下载 全网音乐免费下载工具 OK资源采集 OK资源采集-最新影视资源大全 网易见外工作台 针对视频、图片、文档、音频都可以进行翻译转写操作，每天两小时免费使用 HiPDF 一站式解决所有PDF相关的问题 视频鱼 在线下载各大网站视频的网站 ScreenToGif 开源、轻量级却非常强大的录屏软件，快速将屏幕录制成高清GIF 设计素材 Iconfont 阿里巴巴矢量图标库，提供矢量图标下载、在线存储、格式转换等功能 Font Awesome 一个基于CSS 和 LESS 的字体和图标工具包 Flaticon 海量扁平化免费的图标库 icons8 独特系统平台风格和web图标库，下载免费图标，音乐 千图网 海量原创设计模板免费下载 昵图网 国内海量平面免费素材下载 千库网 免费 png 图片背景素材下载 Pexels 才华横溢的摄影作者在这里免费分享最精彩的素材照片和视频 必应壁纸 必应每日高清壁纸 Piqsels 精美的免版税图库 私藏字体 优质字体免费下载站 第一 PPT 网 免费 PPT 模板下载 吾道幻灯片 全新的office生产力工具，支持演示文稿、PPT模板、协同办公，可以帮助用户轻松创建具有视觉吸引力的幻灯片 Mixkit 免费、高质量、可商用的视频素材分享网站 The Stocks 对各大图片网站进行整合，免费优质图片下载 极简壁纸 高质量精品壁纸网站 NASA Image and Video Library 美国国家航天局的官方库，从此太空类的素材再也不是问题 Unsplash 质量超高的免费图片素材库，无需注册，直接下载 WordArt 文字云工具 Cool Backgrounds Cool Backgrounds在线配色 webkul webkul完美的调色板 uigradients 渐变色素材网 adobe color Adobe家的配色 adobe color Adobe家的配色 Fotor懒设计 创意图文设计神器 Shields IO GitHub徽标生成器 Simpleicons Simple Icons是一个收录了常见品牌svg图标素材的网站 效率软件 分流抢票 全程自动抢票,自动抢候补,自动识别验证码,多线程秒单、稳定捡漏,支持多天、多车次、多席别、多乘客等功能 PanDownload 百度网盘下载神器 Quicker 为常用操作建立捷径，PC 快捷动作面板，让效率触手可及! 万彩办公大师 免费、轻松处理文档/音视频/图片的工具 LICEcap 简洁易用的动画屏幕录制软件，它可将屏幕录像的内容直接保存为高质量（每帧颜色数量可超过256）GIF动态图片格式 Snipaste 简单但强大的截图工具，支持截图 + 贴图 FSCapture 一个强大的，轻量级的，功能齐全的屏幕捕获工具 Everything 速度最快的的文件搜索工具 DeskPins 顶置任意窗口 TrafficMonitor 一个用于显示当前网速、CPU及内存利用率的桌面悬浮窗软件 PicGo 由 electronic-vue 构建的简单而精美的图片上传工具 PowerToys 微软为 Windows 系统推出的一系列免费实用小工具合集 Dism++ 一款根据微软底层的架构结构设计的一个系统维护工具，全球第一款基于 CBS 的 Dism GUI 实现 ColorPix 屏幕取色小工具 CCleaner 一款免费的系统优化和隐私保护工具 GifCam 集录制与剪辑为一体的屏幕 GIF 动画制作工具，录制后的动画可以逐帧编辑 EV录屏 一款免费并且不添加水印的录屏工具 Fliqlo 一款极简主义的时钟屏保软件 Fences 栅栏管理桌面，使桌面更加整洁有条理 Q-dir 多窗口文件整理工具 WGestures 鼠标手势工具 XMind 一个全功能的思维导图和头脑风暴软件 速盘 免登录，自动查询提取码，极速的度盘下载工具 f.lux 国外开源的护眼软件，通过根据时间调节屏幕颜色，减少蓝光对视力的影响 云服务商 阿里云 阿里云 - 为了无法计算的价值 腾讯云 腾讯云 - 产业智变 云启未来 百度云 百度云 - 计算无限可能 华为云 华为云 - +智能，见未来 京东云 京东云 - 遇见无限可能 西部数码 西部数码 - 云服务器、虚拟主机、域名注册17年知名云计算服务提供商！ 景安云 景安云 - 专业的数据中心服务商 七牛云 七牛云 - 国内领先的企业级云服务商 又拍云 又拍云 - 加速在线业务-CDN-云存储 美橙互联 美橙互联 - 域名注册、企业建站、云服务器、企业网络推广整体解决方案服务商！ UCloud UCloud - 中立 安全 可信赖的云计算服务商 AWS AWS 云服务 - 专业的大数据和云计算服务以及云解决方案提供商 Microsoft Azure Azure. Invent with purpose. GoDaddy GoDaddy - 提供域名注册和互联网主机服务的美国公司 Cloudflare Cloudflare - 网络性能和安全公司 jsDelivr jsDelivr - A free, fast, and reliable Open Source CDN for npm and GitHub 众包平台 猿急送 专注于 IT 众包领域，职位内容大多集中于 UI 设计、产品设计、程序开发、产品运营等需求 开源众包 开源中国旗下外包网站，项目大多是团队的整包项目，适合多人组团接单 外包大师 PMCAFF旗下的一个众包开发平台，目前以技术开发为主，以众包开发和自有开发相结合形式运营 人人开发 集可视化开发，应用市场，威客众包，PaaS云于一体的企业级应用服务平台 快码 提供智能硬件、各种智能共享项目解决方案，为互联网创业者提供APP、小程序、公众号开发。 我爱方案网 专注于硬件类外包，电子方案开发供应链众包平台，软件外包，方案，硬件开发方案，硬件设计开发 英选 提供可信赖的定制开发外包服务，包括企业品牌官网、电商系统及创新定制产品开发 智筹 为企业&创业者提供互联网高级人才直租服务。按次直租，解决临时、突发问题；按月直租，建立长期兼职合作；按任务直租，解决有明确预算的外包任务 开发邦 互联网软件定制开发与软件外包开发服务，十年互联网软件定制开发经验 码市 Coding 推出的互联网软件外包服务平台，意在连接需求方与广大开发者。让项目的需求方快速的找到合适的开发者，完成项目开发工作 自由职客 自由职客是权威的IT互联网行业灵活用工交易平台，外包，众包，兼职，招聘，erp，sap 解放号 解放号众包平台提供软件开发外包、人力驻场服务等软件项目外包服务。解放号的软件项目交付全流程可视化监控与全生命周期管理能力 程序员客栈 领先的程序员自由工作平台，38万+优秀开发者，您的专属云端开发团队，BAT级别的开发者，标准化的服务和交付 码易 智网易联旗下IT软件服务平台，集软件商城、企业应用、电商软件、crm软件、商务服务平台于一体的一站式软件外包开发服务平台 电鸭社区 电鸭社区旨在推动自由工作方式在国内渐进式发展，区别于传统方式的工作职位，倡导「只工作，不上班」的工作心态 Sxsoft 中国最早的外包服务平台，18年口碑服务，20万程序员、100+专业软件开发公司，专注解决各类软件开发需求 实现网 为企业提供BAT等名企背景的、靠谱的开发设计兼职人才和自由职业者，满足企业项目外包、驻场开发、远程兼职、技术咨询等短期人力需求 智城外包网 零佣金开发资源平台，认证担保，全程无忧，专业的软件外包网和项目外包、项目开发、人力外派、短期招聘、人力资源交易平台 更多导航 创造狮导航 创造狮，一个创意工作者的导航，专注分享正版优质设计、前端、产品、运营的书签导航，设计教程、设计规范、颜色搭配、灵感创意、前端框架、开发者工具、互联网新品推荐、运营数据分析、自媒体和工具利器好用的分类导航大全 大数据导航 大数据导航，以大数据产业为主，大数据工具为辅，给用户提供一个更加快速找到大数据相关的工具平台 优设导航 优设网站导航为设计师提供ps教程、UI设计、素材下载、高清图库、配色方案、用户体验、网页设计等全方位设计师网站导航指引 牛导航 实用工具导航 聚BT 聚BT - 聚合最优质的BT、磁力资源 ShareHub ShareHub - 资源和工具的集合 狼牌工作网址导航 工具，资源，方法，All IN ONE的办公工作网址导航 编程导航 发现编程世界的满天星辰 ✨ COPYRIGHT 2018 - 2020 WEBSTACK 丨 DESIGNED BY VIGGO 丨 CHANGED BY 小李博客 $(document).ready(function() { $(document).on('click', '.has-sub', function(){ var _this = $(this) if(!$(this).hasClass('expanded')) { setTimeout(function(){ _this.find('ul').attr(\"style\",\"\") }, 300); } else { $('.has-sub ul').each(function(id,ele){ var _that = $(this) if(_this.find('ul')[0] != ele) { setTimeout(function(){ _that.attr(\"style\",\"\") }, 300); } }) } }) $('.user-info-menu .hidden-sm').click(function(){ if($('.sidebar-menu').hasClass('collapsed')) { $('.has-sub.expanded > ul').attr(\"style\",\"\") } else { $('.has-sub.expanded > ul').show() } }) $(\"#main-menu li ul li\").click(function() { $(this).siblings('li').removeClass('active'); // 删除其他兄弟元素的样式 $(this).addClass('active'); // 添加当前元素的样式 }); $(\"a.smooth\").click(function(ev) { ev.preventDefault(); public_vars.$mainMenu.add(public_vars.$sidebarProfile).toggleClass('mobile-is-visible'); ps_destroy(); $(\"html, body\").animate({ scrollTop: $($(this).attr(\"href\")).offset().top - 30 }, { duration: 500, easing: \"swing\" }); }); return false; }); var href = \"\"; var pos = 0; $(\"a.smooth\").click(function(e) { $(\"#main-menu li\").each(function() { $(this).removeClass(\"active\"); }); $(this).parent(\"li\").addClass(\"active\"); e.preventDefault(); href = $(this).attr(\"href\"); pos = $(href).position().top - 30; });","path":"box/index.html","date":"05-11","excerpt":""}],"posts":[{"title":"SpringBoot🍃微服务架构介绍","text":"微服务架构 微服务架构（Microservice Architecture）是一种架构概念，旨在通过将功能分解到各个离散的服务中以实现对解决方案的解耦。它要求我们在开发一个应用的时候，这个应用必须构建成一系列小服务的组合：可以通过HTTP的方式进行互通。要学习微服务架构先了解一下过去的单体应用架构 单体应用架构 所谓单体应用架构（all in one）是指，我们将一个应用的中的所有应用服务都封装在一个应用中 无论是ERP、CRM或是其他什么系统，你都把数据库访问，web访问， 等等各个功能放到一个war包内 这样做的好处是，易于开发和测试；也十分方便部署；当需要扩展时，只需要将war复制多份，然后放到多个服务器上，再做个负载均衡就可以了 单体应用架构的缺点是，哪怕我要修改一个非常小的地方，我都需要停掉整个服务，重新打包、部署这个应用war包。特别是对于一个大型应用，我们不可能吧所有内容都放在一个应用里面，如何维护、如何分工合作都是问题 微服务架构 all in one的架构方式，我们把所有的功能单元放在一个应用里面。然后我们把整个应用部署到服务器上。如果负载能力不行，我们将整个应用进行水平复制，进行扩展，然后在负载均衡 所谓微服务架构，就是打破之前all in one的架构方式，把每个功能元素独立出来。把独立出来的功能元素的动态组合，需要的功能元素才去拿来组合，需要多一些时可以整合多个功能元素。所以微服务架构是对功能元索进行复制，而没有对整个应用进行复制 微服务架构思想由Martin Fowler（马丁富勒）提出，他国际著名的OO专家，敏捷开发方法的创始人之一，现为ThoughtWorks公司的首席科学家。在面向对象分析设计、UML、模式、软件开发方法学、XP、重构等方面，都是世界顶级的专家，现为Thought Works公司的首席科学家 关于微服务架构可以查阅他的论文：https://martinfowler.com/articles/microservices.html 如何构建 一个大型系统的微服务架构，就像一个复杂交织的神经网络，每一个神经元就是一个功能元素，它们各自完成自己的功能，然后通过http相互请求调用 比如一个电商系统，查缓存、连数据库、浏览页面、结账、支付等服务都是一个个独立的功能服务，都被微化了，它们作为一个个微服务共同构建了一个庞大的系统。如果修改其中的一个功能，只需要更新升级其中一个功能服务单元即可 但是这种庞大的系统架构给部署和运维带来很大的难度。于是, Spring为我们带来了构建大型分布式微服务的全套、全程产品: 构建一个个功能独立的微服务应用单元，可以使用SpringBoot, 可以帮我们快速构建一个应用 大型分布式网络服务的调用，这部分由Spring Cloud来完成，实现分布式 在分布式中间,进行流式数据计算、批处理，我们有spring cloud data flow. Spring为我们想清楚了整个从开始构建应用到大型分布式应用全流程方案 SpringBootSpringBoot简介 SpringBoot就是一个javaweb的开发框架，和SpringMVC类似，对比其他javaweb框架的好处，官方说是简化开发，约定大于配置， you can “just run”，能迅速的开发web应用，几行代码开发一个HTTP接口 随着 Spring 不断的发展，涉及的领域越来越多，项目整合开发需要配合各种各样的文件，慢慢变得不那么易用简单，违背了最初的理念，甚至人称配置地狱。Spring Boot 正是在这样的一个背景下被抽象出来的开发框架，目的为了让大家更容易的使用 Spring 、更容易的集成各种常用的中间件、开源软件 Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以约定大于配置的核心思想，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用 简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，Spring Boot整合了所有的框架 SpringBoot项目创建 Spring官方提供了非常方便的工具让我们快速构建应用 Spring Initializr：https://start.spring.io/ 项目创建方式一：使用Spring Initializr 的 Web页面创建项目 打开 https://start.spring.io/ 填写项目信息 点击【Generate Project】按钮生成项目；下载此项目 解压项目包，并用IDEA以Maven项目导入，一路下一步即可，直到项目导入完毕 如果是第一次使用，可能速度会比较慢，包比较多、需要耐心等待一切就绪 项目创建方式二：使用 IDEA 直接创建项目 创建一个新项目 在右侧选择spring initalizr ， 可以看到默认就是去官网的快速构建工具那里实现 填写项目信息 选择初始化的组件（初学勾选 Web 即可） 填写项目路径 等待项目构建成功 项目结构 通过上面步骤完成了基础项目的创建。就会自动生成以下文件。 程序的主启动类 一个 application.properties 配置文件 一个 测试类 一个 pom.xml 打开pom.xml，看看Spring Boot项目的依赖","path":"page/SpringBoot01.html","date":"06-01","excerpt":"","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://xiaoliblog.cn/tags/SpringBoot/"}]},{"title":"实现图片上传至阿里云OSS存储","text":"OSS对象存储服务OSS简介 阿里云对象存储服务（Object Storage Service，简称OSS），是阿里云对外提供的海量、安全、低成本、高可靠的云存储服务。通过提供的简单的REST接口，在任何时间、任何地点、任何互联网设备上进行上传和下载数据。基于OSS，可以搭建出各种多媒体分享网站、网盘、个人和企业数据备份等基于大规模数据的服务 简单来说，OSS就是一个可以上传、下载、分享文件的服务，这一点从实用意义上来说与网盘是差不多的。OSS相比较网盘的优点在于其数据安全性更高（数据多重冗余备份，不易丢失）、使用可靠性更高（上下行速度等皆有保障），同时其还提供API接口和丰富的SDK包，而其缺点是带来一定的使用成本，但是目前此成本还是很低的。在今天，很多免费网盘都倒下了，有些网盘走向付费使用的道路，而其安全、可靠性又没有得到有效的提高，这也使得OSS的优势更加明显 参考阿里云官网什么是对象存储OSS CSDN博文《阿里云OSS(对象存储服务)简介》:https://blog.csdn.net/m0_37897502/article/details/80702805 OSS相关概念 存储类型（Storage Class） OSS提供标准、低频访问、归档三种存储类型，全面覆盖从热到冷的各种数据存储场景 标准存储类型提供通用的对象存储服务，适合频繁访问、有热点存在的各类音视频、图片、网站静态资源的存储，支持高吞吐计算场景，适合各类计算资源的存储。 低频访问存储类型适合长期保存、较少访问的数据（平均每月访问频率1到2次），适合各类移动应用、智能设备、企业数据的备份，低频访问支持实时数据访问。 归档存储类型在三种存储类型中单价最低，适合需要长周期保存的档案数据、医疗影像、科学资料、影视素材，能有效优化长期存储成本。保存为归档存储类型的数据，恢复到可读取状态需要等待1分钟的解冻时间 存储空间（Bucket） 存储空间是您用于存储对象（Object）的容器，所有的对象都必须隶属于某个存储空间。存储空间具有各种配置属性，包括地域、访问权限、存储类型等。您可以根据实际需求，创建不同类型的存储空间来存储不同的数据 同一个存储空间的内部是扁平的，没有文件系统的目录等概念，所有的对象都直接隶属于其对应的存储空间。 每个用户可以拥有多个存储空间。 存储空间的名称在 OSS 范围内必须是全局唯一的，一旦创建之后无法修改名称。 存储空间内部的对象数目没有限制 对象（Object） 对象是OSS存储数据的基本单元，也被称为OSS的文件。对象由元信息（Object Meta）、用户数据（Data）和文件名（Key）组成。对象由存储空间内部唯一的Key来标识。对象元信息是一组键值对，表示了对象的一些属性，例如最后修改时间、大小等信息，同时您也可以在元信息中存储一些自定义的信息 地域（Region） 地域表示OSS的数据中心所在物理位置。您可以根据费用、请求来源等选择合适的地域创建Bucket。一般来说，距离用户更近的 Region 访问速度更快 Region是在创建 Bucket 的时候指定的，一旦指定之后就不允许更改，该 Bucket 下所有的 Object 都存储在对应的数据中心，目前不支持 Object 级别的 Region 设置 访问域名（Endpoint） Endpoint 表示 OSS 对外服务的访问域名。OSS 以 HTTP RESTful API 的形式对外提供服务，当访问不同的 Region 的时候，需要不同的域名。通过内网和外网访问同一个 Region 所需要的 Endpoint 也是不同的。例如杭州 Region 的外网 Endpoint 是 oss-cn-hangzhou.aliyuncs.com，内网 Endpoint 是 oss-cn-hangzhou-internal.aliyuncs.com 访问密钥（AccessKey） AccessKey，简称 AK，指的是访问身份验证中用到的 AccessKeyId 和AccessKeySecret。OSS 通过使用 AccessKeyId 和 AccessKeySecret 对称加密的方法来验证某个请求的发送者身份。AccessKeyId 用于标识用户，AccessKeySecret 是用户用于加密签名字符串和 OSS 用来验证签名字符串的密钥，其中 AccessKeySecret 必须保密。对于 OSS 来说，AccessKey 的来源有： Bucket 的拥有者申请的 AccessKey。 被 Bucket 的拥有者通过 RAM 授权给第三方请求者的 AccessKey。 被 Bucket 的拥有者通过 STS 授权给第三方请求者的 AccessKey。 开通OSS云存储服务资源包购买 首先去阿里云购买对象存储OSS资源包：https://www.aliyun.com/product/oss/ 有两种方式 第一种是【按量收费】，只需要开通OSS，就可以直接用OSS服务了，不需要付款什么的，按量收费，从我们的阿里云账户直接扣钱，边用边扣的模式 还有一种是【买套餐包月包年】，需要我们到页面付款一次结清 只供学习的话推荐默认标准型存储包5元半年即可 B 创建Bucket 然后在控制台新建Bucket。Bucket的作用：相当于一个存储图片的仓库。然后下图就是配置仓库的信息，我们通过这个仓库的信息把图片上传到这个仓库里面 上传图片 在【文件管理】中，可直接上传图片，在浏览器访问到https://origins-xiaoliblog.oss-cn-shanghai.aliyuncs.com/headerimg.jpg 在【数据处理】-&gt;【图片处理】中，可添加水印的样式 在【图片处理】下的【访问设置】中，选择自定义分隔符，在图片路径后拼接分隔符与水印的规格名称，就能给图片添加上水印 开启【原图保护功能】的话，如果把路径后的水印规则给去掉，就不能访问该图片了 PicGo实现上传图片下载PicGo PicGo是一个开源项目，可以用来快捷上传图片到图床。 下载地址：https://github.com/Molunerfinn/PicGo 添加用户 推荐最好是单独创建一个用户来单独操作OSS（用户的定义就是需要访问云资源的人员或应用程序），这样给这个用户赋予单独的访问OSS的权限，更加安全方便 进入【RAM访问控制】-【人员管理】-【用户】-【新建用户】 之后进行用户配置，注意要勾选【编程访问】，控制台密码登录可以不选择，登录名称，显示名称自己设定，如下图所示： 确定后得到创建用户的信息，这里要记下AccessKey ID 和 AccessKeySecret，之后配置PICGO用到，因为这个界面关掉之后就不好找了，所以最好记在记事本里 设置【用户权限】，使得用户只能访问OSS的服务。点击添加权限，如下图所示： 配置图床 点击阿里云账号头像，进入【Accesskey管理】，并点击【创建AccessKey】 复制Accesskey和AccesskeySecret 存储空间名就是Bucket的名字 存储区域到阿里云OSS控制台去找，例如下图中存储区域就是 oss-cn-shanghai 存储路径是存储图片的位置，要求以/结尾。 自定义域名可以不填写 Java实现图片上传简单上传 更多可阅读其开发者指南，很丰富，很多花式上传下载 SDK源码请参见GitHub。更多信息请参见OSS Java SDK API文档 详细操作参考官方文档：https://developer.aliyun.com/article/702854 首先导入SDK依赖 1234567891011121314151617181920212223242526272829303132&lt;!-- 阿里云oss --&gt;&lt;dependency&gt; &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt; &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt; &lt;version&gt;3.10.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/commons-codec/commons-codec --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.10&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;&lt;!--文件上传--&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt;&lt;/dependency&gt;&lt;!--上传阿里云OSS--&gt;&lt;!-- https://mvnrepository.com/artifact/org.jdom/jdom --&gt;&lt;dependency&gt; &lt;groupId&gt;org.jdom&lt;/groupId&gt; &lt;artifactId&gt;jdom&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt; 参数常量封装 创建一个用于封装常量的类OSSClientConstants，便于修改 12345678910111213//阿里云OSS参数常量类public class OSSClientConstants &#123; //阿里云API的外网域名 以上海为例，其他按情况填写 public static final String ENDPOINT = &quot;oss-cn-shanghai.aliyuncs.com&quot;; //阿里云API的密钥Access Key ID public static final String ACCESS_KEY_ID = &quot;&lt;yourAccessKeyId&gt;&quot;; //阿里云API的密钥Access Key Secret public static final String ACCESS_KEY_SECRET = &quot;&lt;yourAccessKeySecret&gt;&quot;; //阿里云API的bucket名称 public static final String BUCKET_NAME = &quot;origins-xiaoliblog&quot;; //Bucket 域名即外网访问的域名 public static final String BUCKET_URL= &quot;http://origins-xiaoliblog.oss-cn-shanghai.aliyuncs.com/&quot;;&#125; 构建工具类 构建一个工具类AliyunOSSClientUtil用于封装对OSS对象存储的操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143@Component //实例化 便于在控制器中自动装配public class AliyunOSSClientUtil &#123; //阿里云API的内或外网域名 private static String ENDPOINT; //阿里云API的密钥Access Key ID private static String ACCESS_KEY_ID; //阿里云API的密钥Access Key Secret private static String ACCESS_KEY_SECRET; //阿里云API的bucket名称 private static String BUCKET_NAME; //Bucket 域名即外网访问的域名 private static String BUCKET_URL; //日期格式化对象 private static SimpleDateFormat SDF = new SimpleDateFormat(&quot;yyyymmdd&quot;); //日期格式化对象 //初始化属性 static &#123; ENDPOINT = OSSClientConstants.ENDPOINT; ACCESS_KEY_ID = OSSClientConstants.ACCESS_KEY_ID; ACCESS_KEY_SECRET = OSSClientConstants.ACCESS_KEY_SECRET; BUCKET_NAME = OSSClientConstants.BUCKET_NAME; BUCKET_URL = OSSClientConstants.BUCKET_URL; &#125; /** * 获取阿里云OSS客户端对象 * @return ossClient */ public OSSClient getOSSClient() &#123; //创建一个OSSClient对象 OSSClient ossClient = new OSSClient(ENDPOINT, ACCESS_KEY_ID, ACCESS_KEY_SECRET); //通过连接对象判断Bucket仓库是否存在 if(ossClient.doesBucketExist(BUCKET_NAME))&#123; System.out.println(BUCKET_NAME+&quot;仓库存在&quot;); &#125;else&#123; //如果没有就通过API接口创建Bucket仓库 System.out.println(&quot;Bucket不存在，创建新的Bucket:&quot;+BUCKET_NAME); CreateBucketRequest bucketRequest = new CreateBucketRequest(null); //设置Bucket名称 bucketRequest.setBucketName(BUCKET_NAME); //设置权限:公共读 bucketRequest.setCannedACL(CannedAccessControlList.PublicRead); //创建新Bucket ossClient.createBucket(bucketRequest); &#125; return ossClient; &#125; /** * 创建模拟文件夹 * @param ossClient oss连接 * @param bucketName 存储空间 * @param folder 模拟文件夹名如&quot;qj_nanjing/&quot; * @return 文件夹名 */ public String createFolder(OSSClient ossClient,String bucketName,String folder) &#123; //判断文件夹是否存在，不存在则创建 if(!ossClient.doesObjectExist(bucketName,folder))&#123; //创建文件夹 ossClient.putObject(bucketName,folder,new ByteArrayInputStream(new byte[0])); System.out.println(&quot;创建文件夹成功&quot;); //得到文件夹名 OSSObject ossObject = ossClient.getObject(bucketName,folder); String fileDir = ossObject.getKey(); System.out.println(&quot;文件名为：&quot;+fileDir); return fileDir; &#125; return folder; &#125; /** * 上传图片至OSS * * @param multipartFile 文件对象F * @param FileType 文件类型F * @return url 返回文件访问路径 */ //MultipartFile是一个封装了文件信息的对象 public String uploadDocument(MultipartFile multipartFile,String FileType)&#123; //获得OSS连接 OSSClient ossClient = this.getOSSClient(); //获取文件的后缀 String suffix = multipartFile.getOriginalFilename(); suffix = suffix.substring(suffix.lastIndexOf(&quot;.&quot;)); //.后面的 //获得当前上传日期 String date = SDF.format(new Date()); //通过UUID名来避免文件重名 String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;,&quot;&quot;); //组合文件名称 String filename = FileType + &quot;/&quot; + date + &quot;/&quot; + uuid + suffix; String url = null; //通过OSSClient获得上传文件后返回的url try &#123; ossClient.putObject(BUCKET_NAME,filename,new ByteArrayInputStream(multipartFile.getBytes())); url = BUCKET_URL + filename; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; //关闭连接 ossClient.shutdown(); &#125; return url; &#125; /** * 通过文件名判断并获取OSS服务文件上传时文件的contentType * @param multipartFile 文件对象 * @return 文件的contentType */ public String getContentType(MultipartFile multipartFile)&#123; //获取文件的后缀 String suffix = multipartFile.getOriginalFilename(); suffix = suffix.substring(suffix.lastIndexOf(&quot;.&quot;)); //.后面的 if(&quot;.bmp&quot;.equalsIgnoreCase(suffix)) &#123; return &quot;image/bmp&quot;; &#125; if(&quot;.gif&quot;.equalsIgnoreCase(suffix)) &#123; return &quot;image/gif&quot;; &#125; if(&quot;.jpeg&quot;.equalsIgnoreCase(suffix) || &quot;.jpg&quot;.equalsIgnoreCase(suffix) || &quot;.png&quot;.equalsIgnoreCase(suffix) ) &#123; return &quot;image/jpeg&quot;; &#125; if(&quot;.html&quot;.equalsIgnoreCase(suffix)) &#123; return &quot;text/html&quot;; &#125; if(&quot;.txt&quot;.equalsIgnoreCase(suffix)) &#123; return &quot;text/plain&quot;; &#125; if(&quot;.vsd&quot;.equalsIgnoreCase(suffix)) &#123; return &quot;application/vnd.visio&quot;; &#125; if(&quot;.ppt&quot;.equalsIgnoreCase(suffix) || &quot;pptx&quot;.equalsIgnoreCase(suffix)) &#123; return &quot;application/vnd.ms-powerpoint&quot;; &#125; if(&quot;.doc&quot;.equalsIgnoreCase(suffix) || &quot;docx&quot;.equalsIgnoreCase(suffix)) &#123; return &quot;application/msword&quot;; &#125; if(&quot;.xml&quot;.equalsIgnoreCase(suffix)) &#123; return &quot;text/xml&quot;; &#125; //默认返回类型 return &quot;image/jpeg&quot;; &#125;&#125; 接口测试 客户端代码 1234567&lt;fieldset&gt; &lt;legend&gt;文件上传&lt;/legend&gt; &lt;form action=&quot;upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 文件提交：&lt;input type=&quot;file&quot; name=&quot;file&quot; size=&quot;20&quot;/&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt; &lt;/form&gt;&lt;/fieldset&gt; 创建控制器UploadController用于接收前端请求并调用工具类 ```java@Controllerpublic class UploadController { @Autowired AliyunOSSClientUtil ossClientUtil; @RequestMapping(“/upload”) @ResponseBody //JSON字符串格式 RequestParm为了使其和表单的name一致 public String uploadtest(@RequestParam(“file”) MultipartFile multipartFile){ String FileType = ossClientUtil.getContentType(multipartFile); String url = ossClientUtil.uploadDocument(multipartFile,FileType); System.out.println(“路径:”+url); return “文件上传成功!”; }}``","path":"page/OSS.html","date":"05-15","excerpt":"","tags":[{"name":"企业常用技术","slug":"企业常用技术","permalink":"http://xiaoliblog.cn/tags/%E4%BC%81%E4%B8%9A%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF/"}]},{"title":"小米商城🍃首页商品模块","text":"首页数据加载 首页中需要的数据从后台获取并添加 商品类型 每种类型下的商品 业务层处理 商品类型：com.xiaomi.service.GoodsTypeService 商品： com.xiaomi.service.GoodsShippingService 首页控制器 com.xiaomi.controller.IndexController ，加载首页数据的控制器⽅法，前端网页中通过 JQuery Ajax 请求获取数据 然后开发首页视图：index.jsp渲染展示商品 商品类型","path":"page/xiaomi02.html","date":"05-13","excerpt":"","tags":[{"name":"SSM","slug":"SSM","permalink":"http://xiaoliblog.cn/tags/SSM/"}]},{"title":"小米商城🍃用户模块","text":"小米商城数据库设计 商城项⽬：（⼩⽶商城：Business -to- Customer B2C） 核⼼元素：⽤户、商品 扩展元素： ⽤户 –&gt; 收货地址、⽤户扩展资料… 商品 –&gt; 商品图⽚、商品类型、商品套餐、售后服务… 元素都可以抽象成实体类型，就是对应了数据库中的 table 表格 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213-- 创建数据库DROP DATABASE xiaomi;CREATE DATABASE xiaomi DEFAULT CHARSET &#x27;utf8&#x27;;USE xiaomi;-- ----------------------------- 创建数据表-- 用户CREATE TABLE `consumer` ( `id` INT AUTO_INCREMENT PRIMARY KEY COMMENT &#x27;用户编号&#x27;, `username` VARCHAR(50) NOT NULL COMMENT &#x27;用户账号&#x27;, `password` VARCHAR(50) NOT NULL COMMENT &#x27;用户密码&#x27;, `email` VARCHAR(50) DEFAULT &#x27;待完善&#x27; COMMENT &#x27;电子邮箱&#x27;, `phone` VARCHAR(20) DEFAULT &#x27;待完善&#x27; COMMENT &#x27;联系方式&#x27;);-- 商品类型表CREATE TABLE `goods_type`( `id` INT AUTO_INCREMENT PRIMARY KEY COMMENT &#x27;商品类型编号&#x27;, `name` VARCHAR(100) NOT NULL COMMENT &#x27;商品类型名称&#x27;, `pid` INT COMMENT &#x27;上级类型&#x27;);-- 商品配置CREATE TABLE `goods_configure` ( `id` INT AUTO_INCREMENT PRIMARY KEY COMMENT &#x27;配置编号&#x27;, `info` VARCHAR(200) NOT NULL COMMENT &#x27;配置描述&#x27;, `goods_id` INT NOT NULL COMMENT &#x27;所属商品&#x27;);-- 商品套餐CREATE TABLE `goods_package` ( `id` INT AUTO_INCREMENT PRIMARY KEY COMMENT &#x27;套餐编号&#x27;, `info` VARCHAR(200) NOT NULL COMMENT &#x27;套餐描述&#x27;, `goods_id` INT NOT NULL COMMENT &#x27;所属商品&#x27;);-- 商品服务-售后服务CREATE TABLE `goods_service` ( `id` INT AUTO_INCREMENT PRIMARY KEY COMMENT &#x27;服务编号&#x27;, `info` VARCHAR(200) NOT NULL COMMENT &#x27;服务描述&#x27;, `goods_id` INT NOT NULL COMMENT &#x27;所属商品&#x27;);-- 商品表CREATE TABLE `goods` ( `id` INT AUTO_INCREMENT PRIMARY KEY COMMENT &#x27;商品编号&#x27;, `name` VARCHAR(100) NOT NULL COMMENT &#x27;商品名称&#x27;, `price` DOUBLE NOT NULL COMMENT &#x27;商品单价&#x27;, `stock` INT DEFAULT 0 COMMENT &#x27;商品库存&#x27;, `goods_type_id` INT NOT NULL COMMENT &#x27;商品类型&#x27;, `remark` TEXT COMMENT &#x27;商品描述&#x27;);-- 商品图片表CREATE TABLE `goods_images`( `id` INT AUTO_INCREMENT PRIMARY KEY COMMENT &#x27;图片编号&#x27;, `path` VARCHAR(200) NOT NULL COMMENT &#x27;图片路径&#x27;, `title` VARCHAR(100) DEFAULT &#x27;小米品质&#x27; COMMENT &#x27;图片主题&#x27;, `alt` VARCHAR(100) DEFAULT &#x27;小米品质&#x27; COMMENT &#x27;图片描述&#x27;, `goods_id` INT NOT NULL COMMENT &#x27;所属商品&#x27;);-- 购物车表CREATE TABLE `goods_cart` ( `id` INT AUTO_INCREMENT PRIMARY KEY COMMENT &#x27;购物编号&#x27;, `goods_id` INT NOT NULL COMMENT &#x27;商品编号&#x27;, `buy_count` INT DEFAULT 1 COMMENT &#x27;购买数量&#x27;, `add_date` DATETIME COMMENT &#x27;添加时间&#x27;, `subtotal` DOUBLE COMMENT &#x27;小计金额&#x27;, `consumer_id` INT NOT NULL COMMENT &#x27;所属用户&#x27;);-- 订单CREATE TABLE `goods_order`( `id` VARCHAR(50) PRIMARY KEY COMMENT &#x27;订单编号&#x27;, `order_date` DATETIME COMMENT &#x27;下单时间&#x27;, `consumer_id` INT NOT NULL COMMENT &#x27;所属用户&#x27;, `status` VARCHAR(10) DEFAULT &#x27;待付款&#x27; COMMENT &#x27;订单状态(待付款|已付款|已发货|已收货)&#x27;, `goods_shipping_address_id` INT NOT NULL COMMENT &#x27;收货地址&#x27;);-- 订单商品CREATE TABLE `goods_order_item` ( `id` VARCHAR(50) PRIMARY KEY COMMENT &#x27;订单编号&#x27;, `goods_id` INT NOT NULL COMMENT &#x27;购买商品编号&#x27;, `goods_img` VARCHAR(200) NOT NULL COMMENT &#x27;商品图片&#x27;, `goods_price` DOUBLE NOT NULL COMMENT &#x27;成交金额&#x27;, `goods_count` INT NOT NULL COMMENT &#x27;成交数量&#x27;, `goods_subtotal` DOUBLE COMMENT &#x27;小计金额&#x27;, `goods_order_id` varchar(50) NOT NULL COMMENT &#x27;所属订单&#x27;);-- 收货地址CREATE TABLE `goods_shipping_address` ( `id` VARCHAR(50) PRIMARY KEY COMMENT &#x27;地址编号&#x27;, `name` VARCHAR(50) NOT NULL COMMENT &#x27;收货人姓名&#x27;, `phone` VARCHAR(20) NOT NULL COMMENT &#x27;收货人联系方式&#x27;, `email` VARCHAR(20) COMMENT &#x27;收货人电子邮箱&#x27;, `province` VARCHAR(10) COMMENT &#x27;省区&#x27;, `city` VARCHAR(10) COMMENT &#x27;市区&#x27;, `country` VARCHAR(10) COMMENT &#x27;县区&#x27;, `street` VARCHAR(100) COMMENT &#x27;街道&#x27;, `remark` TEXT COMMENT &#x27;描述&#x27;, `consumer_id` INT NOT NULL COMMENT &#x27;所属用户&#x27;);-- 新增商品类型INSERT INTO goods_type(id, NAME, pid)VALUES(101, &quot;手机电话&quot;, NULL), (102, &quot;电视盒子&quot;, NULL), (103, &quot;笔记本 平板&quot;, NULL), (104, &quot;家电 插线板&quot;, NULL), (105, &quot;出行 穿戴&quot;, NULL), (106, &quot;智能 路由器&quot;, NULL), (107, &quot;电源 配件&quot;, NULL), (108, &quot;健康 儿童&quot;, NULL), (109, &quot;耳机 音箱&quot;, NULL), (110, &quot;生活 箱包&quot;, NULL), (10001, &quot;小米CC&quot;, 101), (10002, &quot;RedMi Note&quot;, 101), (10003, &quot;黑鲨手机&quot;, 101), (20001, &quot;小米电视4A&quot;, 102), (20002, &quot;小米电视Pro&quot;, 102), (20003, &quot;全面屏电视&quot;, 102), (30001, &quot;小米笔记本&quot;, 103), (30002, &quot;小米游戏本&quot;, 103);-- 新增商品数据INSERT INTO goods(`name`, `price`, `stock`, `goods_type_id`, `remark`)VALUES(&quot;小米CC9e&quot;, 3499.0, 100, 10001, &quot;8GB+256GB&quot;), (&quot;小米CC9e&quot;, 2799.0, 100, 10001, &quot;6GB+256GB&quot;), (&quot;小米CC9e&quot;, 3099.0, 100, 10001, &quot;8GB+128GB&quot;), (&quot;小米CC9 Pro&quot;, 3499, 50, 10001, &quot;8GB+256GB&quot;), (&quot;小米CC9 Pro&quot;, 2799.0, 100, 10001, &quot;6GB+256GB&quot;), (&quot;小米CC9 Pro&quot;, 3099.0, 100, 10001, &quot;8GB+128GB&quot;), (&quot;红米8&quot;, 699.0, 100, 10002, &quot;4GB+128GB 5000mAh&quot;), (&quot;红米8A&quot;, 699.0, 100, 10002, &quot;4GB+128GB 5000mAh 31天超长续航&quot;), (&quot;红米7A&quot;, 579.0, 100, 10002, &quot;3GB+128GB 小巧大电量，持久又流畅&quot;), (&quot;黑鲨手机2 Pro&quot;, 2999.0, 100, 10003, &quot;12GB+128GB 骁龙855 Plus旗舰处理器 / 全系标配12GB大运存 / 液冷3.0+，全域液冷升级 / 电竞级屏幕压感，操作快人一步 / 独显DC调光2.0 护眼全新升级&quot;), (&quot;黑鲨手机2 Pro&quot;, 3499.0, 100, 10003, &quot;12GB+256GB 骁龙855 Plus旗舰处理器 / 全系标配12GB大运存 / 液冷3.0+，全域液冷升级 / 电竞级屏幕压感，操作快人一步 / 独显DC调光2.0 护眼全新升级&quot;), (&quot;黑鲨手机2 Pro&quot;, 3999.0, 100, 10003, &quot;12GB+512GB 骁龙855 Plus旗舰处理器 / 全系标配12GB大运存 / 液冷3.0+，全域液冷升级 / 电竞级屏幕压感，操作快人一步 / 独显DC调光2.0 护眼全新升级&quot;), (&quot;小米电视5 75英寸&quot;, 7999.0, 100, 20001, &quot;「小米电视新品火爆预约中！」全面屏设计 / 金属机身 / 4K广色域屏幕 /纤薄机身 / 内置小爱同学 / 3GB+32GB大存储 / 支持8K视频内容&quot;), (&quot;小米电视5 Pro 75英寸&quot;, 9999.0, 100, 20002, &quot;「小米电视新品火爆预约中！」量子点屏幕 / 全面屏设计 / 超薄金属机身 / 4GB+64GB大存储 / MEMC运动补偿 / 内置小爱同学 / 支持8K视频内容&quot;), (&quot;小米全面屏电视Pro 65英寸E65S&quot;, 3399.0, 100, 20003, &quot;时尚金属全面屏设计 / 搭载Amlogic T972超强悍处理器 / 4K超高清画质 细腻如真 / 支持8K视频解码 / 2G+32G超大存储 / 内置小爱同学 语音控制更方便 / 智能Patchwall汇聚海量好内容&quot;), (&quot;小米全面屏电视Pro 55英寸E55S&quot;, 3499.0, 100, 20003, &quot;时尚金属全面屏设计 / 搭载Amlogic T972超强悍处理器 / 4K超高清画质 细腻如真 / 支持8K视频解码 / 2G+32G超大存储 / 内置小爱同学 语音控制更方便 / 智能Patchwall汇聚海量好内容&quot;), (&quot;小米笔记本 13.3&quot;, 4499.0, 100, 30001, &quot;第八代四核处理器，显卡再升级&quot;), (&quot;小米笔记本Air 12.5\\&quot;2019款\\&quot;&quot;, 3999.0, 100, 30001, &quot;全高清屏幕 / 长续航全金属 / 超窄边框 / 像杂志一样随身携带 / 哈曼高品质扬声器&quot;), (&quot;小米笔记本15.6\\&quot; 2019款 独显版&quot;, 4699.0, 100, 30001, &quot;独立显卡/ 英特尔四核处理器 / 最高512G高速固态硬盘 / 独立数字键盘 / 全面均衡的国民轻薄本&quot;), (&quot;小米笔记本15.6\\&quot; 2019款 集显版&quot;, 4499.0, 100, 30001, &quot;高速固态硬盘 / 独立数字键盘 / 全面均衡的国民轻薄本&quot;), (&quot;Pro 15 增强版 i7 16GB&quot;, 6999.0, 100, 30001, &quot;全新十代酷睿处理器 / 大满贯接口 / 100%sRGB高色域 / 全尺寸背光键盘&quot;), (&quot;小米笔记本Pro 15.6\\&quot; 2019款&quot;, 5999.0, 100, 30001, &quot;NVIDIA MX250 2G独显 / 第八代Intel处理器 / PCIe 高速固态硬盘 / 72%NTSC高色域全高清屏 / 更强悍的专业笔记本&quot;), (&quot;Pro 15.6\\&quot; GTX显卡&quot;, 7499.0, 100, 30001, &quot;全新第八代英特尔酷睿处理器 ／ 升级金属双风扇 ／ 带宽提升80% ／ 15.6\\&quot;全高清大屏超窄边大视野&quot;), (&quot;小米游戏本15.6&quot;, 7999.0, 100, 30002, &quot;i5 8G 1T+256G 1060 6G&quot;), (&quot;小米游戏本15.6&quot;, 8999.0, 100, 30002, &quot; i7 16G 512G 1060 6G &quot;), (&quot;小米游戏本15.6&quot;, 7999.0, 100, 30002, &quot; i5 8G 512G 1060 6G &quot;), (&quot;小米游戏本15.6&quot;, 6699.0, 100, 30002, &quot; i5 8G 1T+256G 1050Ti 4G &quot;), (&quot;小米游戏本15.6&quot;, 8999.0, 100, 30002, &quot; i7 16G 1T+256G 1060 6G &quot;);-- 添加商品对应的图片：主要是图片路径~具体图片已经包含在项目文件夹中INSERT INTO goods_images(path, title, alt, goods_id)VALUES(&quot;static/images/goodsImage/1_1.jpg&quot;, &quot;8GB+256GB&quot;, &quot;8GB+256GB&quot;, 1), (&quot;static/images/goodsImage/1_2.jpg&quot;, &quot;8GB+256GB&quot;, &quot;8GB+256GB&quot;, 1), (&quot;static/images/goodsImage/2_1.jpg&quot;, &quot;8GB+256GB&quot;, &quot;6GB+256GB&quot;, 2), (&quot;static/images/goodsImage/2_2.jpg&quot;, &quot;8GB+256GB&quot;, &quot;6GB+256GB&quot;, 2), (&quot;static/images/goodsImage/3_1.jpg&quot;, &quot;8GB+256GB&quot;, &quot;8GB+256GB&quot;, 3), (&quot;static/images/goodsImage/3_2.jpg&quot;, &quot;8GB+256GB&quot;, &quot;8GB+256GB&quot;, 3), (&quot;static/images/goodsImage/3_2.jpg&quot;, &quot;8GB+256GB&quot;, &quot;8GB+256GB&quot;, 3), (&quot;static/images/goodsImage/4_1.jpg&quot;, &quot;小米CC9 Pro&quot;, &quot;8GB+128GB&quot;, 4), (&quot;static/images/goodsImage/4_2.jpg&quot;, &quot;小米CC9 Pro&quot;, &quot;8GB+256GB&quot;, 4), (&quot;static/images/goodsImage/5_1.jpg&quot;, &quot;小米CC9 Pro&quot;, &quot;8GB+256GB&quot;, 5), (&quot;static/images/goodsImage/5_2.jpg&quot;, &quot;小米CC9 Pro&quot;, &quot;8GB+256GB&quot;, 5), (&quot;static/images/goodsImage/6_1.jpg&quot;, &quot;小米CC9 Pro&quot;, &quot;8GB+256GB&quot;, 6), (&quot;static/images/goodsImage/6_2.jpg&quot;, &quot;小米CC9 Pro&quot;, &quot;8GB+256GB&quot;, 6), (&quot;static/images/goodsImage/7_1.jpg&quot;, &quot;8GB+256GB&quot;, &quot;8GB+256GB&quot;, 7), (&quot;static/images/goodsImage/7_2.jpg&quot;, &quot;8GB+256GB&quot;, &quot;8GB+256GB&quot;, 7), (&quot;static/images/goodsImage/8_1.jpg&quot;, &quot;8GB+256GB&quot;, &quot;8GB+256GB&quot;, 8), (&quot;static/images/goodsImage/8_2.jpg&quot;, &quot;8GB+256GB&quot;, &quot;8GB+256GB&quot;, 8), (&quot;static/images/goodsImage/9_1.jpg&quot;, &quot;红米7A&quot;, &quot;8GB+256GB&quot;, 9), (&quot;static/images/goodsImage/9_2.jpg&quot;, &quot;红米7A&quot;, &quot;8GB+256GB&quot;, 9), (&quot;static/images/goodsImage/9_3.jpg&quot;, &quot;红米7A&quot;, &quot;8GB+256GB&quot;, 9), (&quot;static/images/goodsImage/9_4.jpg&quot;, &quot;红米7A&quot;, &quot;8GB+256GB&quot;, 9), (&quot;static/images/goodsImage/10_1.jpg&quot;, &quot;黑鲨手机2 Pro&quot;, &quot;8GB+256GB&quot;, 10), (&quot;static/images/goodsImage/10_2.jpg&quot;, &quot;黑鲨手机2 Pro&quot;, &quot;8GB+256GB&quot;, 10), (&quot;static/images/goodsImage/11_1.jpg&quot;, &quot;黑鲨手机2 Pro&quot;, &quot;8GB+256GB&quot;, 11), (&quot;static/images/goodsImage/11_2.jpg&quot;, &quot;黑鲨手机2 Pro&quot;, &quot;8GB+256GB&quot;, 11), (&quot;static/images/goodsImage/12_1.jpg&quot;, &quot;黑鲨手机2 Pro&quot;, &quot;8GB+256GB&quot;, 12), (&quot;static/images/goodsImage/12_2.jpg&quot;, &quot;黑鲨手机2 Pro&quot;, &quot;8GB+256GB&quot;, 12), (&quot;static/images/goodsImage/13_1.jpg&quot;, &quot;小米电视5 75英寸&quot;, &quot;8GB+256GB&quot;, 13), (&quot;static/images/goodsImage/13_2.jpg&quot;, &quot;小米电视5 75英寸&quot;, &quot;8GB+256GB&quot;, 13), (&quot;static/images/goodsImage/14_1.jpg&quot;, &quot;小米电视5 Pro 75英寸&quot;, &quot;8GB+256GB&quot;, 14), (&quot;static/images/goodsImage/14_2.jpg&quot;, &quot;小米电视5 Pro 75英寸&quot;, &quot;8GB+256GB&quot;, 14), (&quot;static/images/goodsImage/15_1.jpg&quot;, &quot;小米全面屏电视Pro 65英寸E65S&quot;, &quot;8GB+256GB&quot;, 15), (&quot;static/images/goodsImage/15_2.jpg&quot;, &quot;小米全面屏电视Pro 65英寸E65S&quot;, &quot;8GB+256GB&quot;, 15), (&quot;static/images/goodsImage/16_1.jpg&quot;, &quot;小米全面屏电视Pro 55英寸E55S&quot;, &quot;8GB+256GB&quot;, 16), (&quot;static/images/goodsImage/16_2.jpg&quot;, &quot;小米全面屏电视Pro 55英寸E55S&quot;, &quot;8GB+256GB&quot;, 16), (&quot;static/images/goodsImage/17_1.png&quot;, &quot;小米笔记本 13.3&quot;, &quot;8GB+256GB&quot;, 17), (&quot;static/images/goodsImage/17_2.png&quot;, &quot;小米笔记本 13.3&quot;, &quot;8GB+256GB&quot;, 17), (&quot;static/images/goodsImage/18_1.jpg&quot;, &quot;小米笔记本Air 12.5\\&quot;2019款\\&quot;&quot;, &quot;8GB+256GB&quot;, 18), (&quot;static/images/goodsImage/18_2.jpg&quot;, &quot;小米笔记本Air 12.5\\&quot;2019款\\&quot;&quot;, &quot;8GB+256GB&quot;, 18), (&quot;static/images/goodsImage/19_1.png&quot;, &quot;小米笔记本15.6\\&quot; 2019款 独显版&quot;, &quot;8GB+256GB&quot;, 19), (&quot;static/images/goodsImage/19_2.png&quot;, &quot;小米笔记本15.6\\&quot; 2019款 独显版&quot;, &quot;8GB+256GB&quot;, 19), (&quot;static/images/goodsImage/20_1.png&quot;, &quot;小米笔记本15.6\\&quot; 2019款 集显版&quot;, &quot;8GB+256GB&quot;, 20), (&quot;static/images/goodsImage/20_2.png&quot;, &quot;小米笔记本15.6\\&quot; 2019款 集显版&quot;, &quot;8GB+256GB&quot;, 20), (&quot;static/images/goodsImage/21_1.png&quot;, &quot;Pro 15 增强版 i7 16GB&quot;, &quot;8GB+256GB&quot;, 21), (&quot;static/images/goodsImage/21_2.jpg&quot;, &quot;Pro 15 增强版 i7 16GB&quot;, &quot;8GB+256GB&quot;, 21), (&quot;static/images/goodsImage/22_1.jpg&quot;, &quot;小米笔记本Pro 15.6\\&quot; 2019款&quot;, &quot;8GB+256GB&quot;, 22), (&quot;static/images/goodsImage/22_2.jpg&quot;, &quot;小米笔记本Pro 15.6\\&quot; 2019款&quot;, &quot;8GB+256GB&quot;, 22), (&quot;static/images/goodsImage/22_1.jpg&quot;, &quot;Pro 15.6\\&quot; GTX显卡&quot;, &quot;8GB+256GB&quot;, 23), (&quot;static/images/goodsImage/23_2.jpg&quot;, &quot;Pro 15.6\\&quot; GTX显卡&quot;, &quot;8GB+256GB&quot;, 23), (&quot;static/images/goodsImage/24_1.jpg&quot;, &quot;小米游戏本15.6&quot;, &quot;8GB+256GB&quot;, 24), (&quot;static/images/goodsImage/24_2.jpg&quot;, &quot;小米游戏本15.6&quot;, &quot;8GB+256GB&quot;, 24), (&quot;static/images/goodsImage/25_1.jpg&quot;, &quot;小米游戏本15.6&quot;, &quot;8GB+256GB&quot;, 25), (&quot;static/images/goodsImage/25_2.jpg&quot;, &quot;小米游戏本15.6&quot;, &quot;8GB+256GB&quot;, 25), (&quot;static/images/goodsImage/26_1.png&quot;, &quot;小米游戏本15.6&quot;, &quot;8GB+256GB&quot;, 26), (&quot;static/images/goodsImage/26_2.png&quot;, &quot;小米游戏本15.6&quot;, &quot;8GB+256GB&quot;, 26), (&quot;static/images/goodsImage/27_1.jpg&quot;, &quot;小米游戏本15.6&quot;, &quot;8GB+256GB&quot;, 27), (&quot;static/images/goodsImage/27_2.jpg&quot;, &quot;小米游戏本15.6&quot;, &quot;8GB+256GB&quot;, 27), (&quot;static/images/goodsImage/28_1.png&quot;, &quot;小米游戏本15.6&quot;, &quot;8GB+256GB&quot;, 28), (&quot;static/images/goodsImage/28_2.png&quot;, &quot;小米游戏本15.6&quot;, &quot;8GB+256GB&quot;, 28); 导入相关依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;!--引入项目依赖的jar包 --&gt; &lt;!-- SpringMVC、Spring --&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependencies&gt; &lt;!--引入pageHelper分页插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MBG 逆向工程--&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis.generator/mybatis-generator-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 返回json字符串的支持 --&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.8.8&lt;/version&gt; &lt;/dependency&gt; &lt;!--JSR303数据校验支持；tomcat7及以上的服务器， tomcat7以下的服务器：el表达式。额外给服务器的lib包中替换新的标准的el --&gt; &lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-validator --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.4.1.Final&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring-Jdbc --&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Spring-test --&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring面向切面编程 --&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aspects --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--MyBatis --&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MyBatis整合Spring的适配包 --&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池、驱动 --&gt; &lt;!-- https://mvnrepository.com/artifact/com.mchange/c3p0 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.41&lt;/version&gt; &lt;/dependency&gt; &lt;!-- （jstl，servlet-api，junit） --&gt; &lt;!-- https://mvnrepository.com/artifact/jstl/jstl --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;!--服务器上有就剔除掉--&gt; &lt;/dependency&gt; &lt;!--JSP--&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp/javax.servlet.jsp-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.3.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- junit --&gt; &lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.ibatis&lt;/groupId&gt; &lt;artifactId&gt;ibatis-core&lt;/artifactId&gt; &lt;version&gt;3.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; mybatis逆向工程 逆向⼯程 是通过数据库中已经存在的数据表，反向⽣成 java 中的实体类 (⽣成对应的ORM持久层代码) 配置逆向⼯程的⽣成规则，就是描述数据库中那些表，⽣成对应的 java 中的实体类，同时⽣成映射配置⽂件。这个⽣成规则就是⼀个普通的配置⽂件 在项⽬的主⽬录中创建⼀个配置⽂件：mybatis-generator-config.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/xiaomi&quot; userId=&quot;root&quot; password=&quot;root&quot;&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver &gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt; &lt;/javaTypeResolver&gt; &lt;javaModelGenerator targetPackage=&quot;com.xiaomi.pojo&quot; targetProject=&quot;./src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;sqlMapGenerator targetPackage=&quot;mapper&quot; targetProject=&quot;./src/main/resources&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.xiaomi.dao&quot; targetProject=&quot;./src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;table tableName=&quot;consumer&quot; domainObjectName=&quot;Consumer&quot;&gt;&lt;/table&gt; &lt;table tableName=&quot;goods&quot; domainObjectName=&quot;Goods&quot;&gt;&lt;/table&gt; &lt;table tableName=&quot;goods_images&quot; domainObjectName=&quot;GoodsImages&quot;&gt;&lt;/table&gt; &lt;table tableName=&quot;goods_type&quot; domainObjectName=&quot;GoodsType&quot;&gt;&lt;/table&gt; &lt;table tableName=&quot;goods_service&quot; domainObjectName=&quot;GoodsService&quot;&gt;&lt;/table&gt; &lt;table tableName=&quot;goods_package&quot; domainObjectName=&quot;GoodsPackage&quot;&gt;&lt;/table&gt; &lt;table tableName=&quot;goods_configure&quot; domainObjectName=&quot;GoodsConfigure&quot;&gt;&lt;/table&gt; &lt;table tableName=&quot;goods_cart&quot; domainObjectName=&quot;GoodsCart&quot;&gt;&lt;/table&gt; &lt;table tableName=&quot;goods_order&quot; domainObjectName=&quot;GoodsOrder&quot;&gt;&lt;/table&gt; &lt;table tableName=&quot;goods_order_item&quot; domainObjectName=&quot;GoodsOrderItem&quot;&gt;&lt;/table&gt; &lt;table tableName=&quot;goods_shipping_address&quot; domainObjectName=&quot;GoodsShippingAddress&quot;&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 通过配置⽂件指定的⽣成规则，⾃动构建实体类和数据访问类，参考官⽅⽂档 1234567891011121314151617181920212223import org.junit.Test;import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.internal.DefaultShellCallback;import java.io.File;import java.util.ArrayList;import java.util.List;public class MBGTest1 &#123; @Test public void test() throws Exception &#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File(&quot;mybatis-generator-config.xml&quot;); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); &#125;&#125; SSM项目整合 spring 配置⽂件： src/main/resources/applicationContext.xml springMVC 配置⽂件： src/main/resources/springMVC.xml mybatis 配置⽂件： src/main/resources/mybatis-config.xml 数据源配置⽂件： src/main/resources/db.properties 项⽬启动时，框架初始化，需要在 web.xml 中添加启动配置 在项⽬中创建对应的空的配置⽂件，同时给项⽬添加 web ⽀持 参考SSM高级整合即可 单元测试 首先是Spring测试 123456789101112131415161718192021222324252627282930313233343536373839404142@RunWith(SpringJUnit4ClassRunner.class)@WebAppConfiguration@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)public class DaoTest &#123; @Autowired private ConsumerMapper consumerMapper; private MockMvc mockMvc; @Autowired private WebApplicationContext context; @Test //测试客户 public void testConsumerInsert() &#123; System.out.println(consumerMapper); // 创建consumer对象 Consumer consumer = new Consumer(&quot;damu&quot;, &quot;123&quot;); // 将consumer对象增加到数据库中 consumerMapper.insertSelective(consumer); System.out.println(&quot;数据insert执行完成&quot;); &#125; @Test //查找客户 public void testConsumerSelectById() &#123; Consumer consumer = consumerMapper.selectByPrimaryKey(1); System.out.println(consumer); &#125; @Test public void testConsumerSelectByExample() &#123; // 创建一个查询条件【账号+密码】 ConsumerExample ce = new ConsumerExample(); ce.createCriteria().andUsernameEqualTo(&quot;damu&quot;) .andPasswordEqualTo(&quot;123&quot;); // 查询数据 List&lt;Consumer&gt; consumers = consumerMapper.selectByExample(ce); consumers.forEach(consumer-&gt; System.out.println(consumer)); &#125;&#125; 登录模块响应数据封装 关于数据接⼝，提供给客户端调⽤，并且返回符合标准预期的数据访问接⼝，通常会有如下的要求 固定格式的参数，根据需求提供给调⽤接⼝即可 返回数据—错误码：快捷判断响应结果是否正确的错误标志，HTTP：200正确;404资源未找到;500错误 返回数据—错误描述：针对某错误码具体错误信息的描述 返回数据—-数据封装：具体包含的⼀个或者多个数据 定义一个工具类ResponseMessage 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class ResponseMessage &#123; private String errorCode; //错误码 private String errorMsg; //错误描述 private Map&lt;String, Object&gt; objectMap = new HashMap&lt;&gt;(); //数据封装 public String getErrorCode() &#123; return errorCode; &#125; public void setErrorCode(String errorCode) &#123; this.errorCode = errorCode; &#125; public String getErrorMsg() &#123; return errorMsg; &#125; public void setErrorMsg(String errorMsg) &#123; this.errorMsg = errorMsg; &#125; public Map&lt;String, Object&gt; getObjectMap() &#123; return objectMap; &#125; public void setObjectMap(Map&lt;String, Object&gt; objectMap) &#123; this.objectMap = objectMap; &#125; public ResponseMessage addObject(String key, Object value) &#123; this.objectMap.put(key, value); return this; //方便链式调用 &#125; public static ResponseMessage success() &#123; ResponseMessage rm = new ResponseMessage(); rm.setErrorCode(&quot;100&quot;); rm.setErrorMsg(&quot;处理成功&quot;); return rm; &#125; public static ResponseMessage error() &#123; ResponseMessage rm = new ResponseMessage(); rm.setErrorCode(&quot;200&quot;); rm.setErrorMsg(&quot;处理失败&quot;); return rm; &#125;&#125; 控制器配置 首先在service层创建用户业务ConumerService，调用Dao层方法 12345678910111213141516171819@Servicepublic class ConsumerService &#123; @Autowired private ConsumerMapper consumerMapper; //根据账户密码查询客户 public Consumer findConsumerWithUsernameAndPassword(Consumer consumer) &#123; // 创建一个条件对象 ConsumerExample ce = new ConsumerExample(); ce.createCriteria().andUsernameEqualTo(consumer.getUsername()) .andPasswordEqualTo(consumer.getPassword()); // 根据条件对象查询数据 List&lt;Consumer&gt; consumerList = consumerMapper.selectByExample(ce); // 判断返回结果 return consumerList != null &amp;&amp; consumerList.size() == 1 ? consumerList.get(0) : null; &#125;&#125; 创建控制器ConsumerController 1234567891011121314151617181920212223242526@Controller@RequestMapping(&quot;/consumer&quot;)public class ConsumerController &#123; @Autowired private ConsumerService consumerService; //乱码处理 @PostMapping(value=&quot;/login/auth&quot;, produces = &#123;&quot;application/json;charset=UTF-8&quot;&#125;) @ResponseBody // 序列化--&gt; 类型转换--&gt; jackson --&gt; json public ResponseMessage login(@RequestParam String username, @RequestParam String password, HttpSession session) &#123; /* 重构：登录业务 1. 验证账号+密码 2. 登记用户 -- 会话跟踪【session】 */ System.out.println(&quot;接受到请求：/consumer/login/auth&quot;); System.out.println(&quot;账号：&quot; + username + &quot;; 密码：&quot; + password); Consumer consumer = new Consumer(username, password); consumer = consumerService.findConsumerWithUsernameAndPassword(consumer); System.out.println(&quot;登录结果：&quot; + consumer); // 记录登录用户 session.setAttribute(&quot;loginConsumer&quot;, consumer); return consumer != null ? ResponseMessage.success() : ResponseMessage.error(); &#125;&#125; Web单元测试12345678910111213141516171819202122232425262728@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123;&quot;classpath:applicationContext.xml&quot;, &quot;classpath:springMVC.xml&quot;&#125;)@WebAppConfigurationpublic class WebTest &#123; // 声明一个模拟请求的对象 private MockMvc mockMvc; // 需要一个web容器 @Autowired private WebApplicationContext context; @Before public void setUp() &#123; mockMvc = MockMvcBuilders.webAppContextSetup(context).build(); &#125; @Test public void testLogin() throws Exception &#123; MvcResult mvcResult = mockMvc.perform( MockMvcRequestBuilders.post(&quot;/consumer/login/auth&quot;) .param(&quot;username&quot;, &quot;damu&quot;) .param(&quot;password&quot;, &quot;123&quot;)).andReturn(); // javax.servlet.http.HttpServletResponse 没有找到 // tomcat没有配置，容器依赖没有加载 // jsp / servlet System.out.println(mvcResult.getResponse().getContentAsString()); &#125;&#125; 登录页请求 修改login.jsp网页视图 需要引入 JQuery Ajax 异步登录脚本 1234567891011121314151617181920212223242526272829$(function() &#123; // 点击登录按钮时，发送ajax请求 $(&quot;#login-btn&quot;).click(function() &#123; // 发送ajax请求 $.ajax(&#123; url: &quot;/consumer/login/auth&quot;, //控制器请求地址 method: &quot;post&quot;, data: &#123; &quot;username&quot;: $(&quot;#username&quot;).val(), &quot;password&quot;: $(&quot;#password&quot;).val() &#125;, success:function(response) &#123; console.log(&quot;请求发送成功&quot;); console.log(response); if(response.errorCode === &quot;100&quot;) &#123; // 登录成功 alert(&quot;恭喜，用户登录成功！&quot;); //弹窗提示 window.location = &quot;/index.jsp&quot;; //跳转到首页 &#125; else &#123; // 登录失败 $(&quot;#error-username&quot;).text(&quot;账号或者密码有误，请重新登录&quot;).css(&#123;&quot;color&quot;: &quot;red&quot;&#125;); //显示提示信息 &#125; &#125;, error: function() &#123; console.log(&quot;请求发送失败..&quot;); &#125; &#125;); &#125;);&#125;); 注册模块控制器配置 在service层用户业务ConumerService，增加注册方法，并调用Dao层方法 12345678910111213public String register(Consumer consumer) &#123; // 验证用户的账号是否存在 ConsumerExample ce = new ConsumerExample(); ce.createCriteria().andUsernameEqualTo(consumer.getUsername()); // 根据条件对象查询数据 List&lt;Consumer&gt; consumerList = consumerMapper.selectByExample(ce); if (consumerList != null &amp;&amp; consumerList.size() &gt; 0) &#123; return &quot;注册失败，账号已经存在，请使用其他账号注册&quot;; &#125; // 添加用户 consumerMapper.insertSelective(consumer); return &quot;注册成功&quot;;&#125; 123456789101112131415@PostMapping(&quot;/register&quot;)@ResponseBodypublic ResponseMessage register(@RequestParam String username, @RequestParam String password) &#123; // 创建用户对象 Consumer consumer = new Consumer(username, password); // 注册用户 String result = consumerService.register(consumer); // 判断结果 if (result.contains(&quot;注册成功&quot;)) &#123; return ResponseMessage.success(); &#125; return ResponseMessage.error().addObject(&quot;msg&quot;, result);&#125; 注册页请求 修改register.jsp视图 12345678910111213141516171819202122232425$(function() &#123; // 点击注册按钮时，发送请求 $(&quot;#register-btn&quot;).click(function() &#123; // 发送Ajax请求 $.ajax(&#123; url: &quot;/consumer/register&quot;, method: &quot;POST&quot;, data: &#123; &quot;username&quot;: $(&quot;#username&quot;).val(), &quot;password&quot;: $(&quot;#password&quot;).val() &#125;, success: function(response) &#123; if(response.errorCode === &quot;100&quot;) &#123; alert(&quot;Congratulations，账号注册成功，请登录吧&quot;); window.location = &quot;/views/login.jsp&quot;; &#125;else&#123; $(&quot;#errorMsg&quot;).text(response.objectMap.msg).css(&#123;&quot;color&quot;: &quot;red&quot;&#125;); &#125; &#125;, error: function() &#123; $(&quot;#errorMsg&quot;).text(&quot;请求迷路了，小二正在赶来的路上，请稍后再试..&quot;).css(&#123;&quot;color&quot;: &quot;red&quot;&#125;); &#125; &#125;); &#125;);&#125;);","path":"page/xiaomi01.html","date":"05-13","excerpt":"","tags":[{"name":"SSM","slug":"SSM","permalink":"http://xiaoliblog.cn/tags/SSM/"}]},{"title":"SSM高级整合🍃删除模块","text":"删除模块 可以单选进行单个删除 可以多选进行多个删除 点击删除会有是否删除的提示信息 单个删除 URI:/emp/id DELETE 在EmployeeService中添加删除方法 123456789101112 public void deleteEmp(Integer id) &#123; // TODO Auto-generated method stub employeeMapper.deleteByPrimaryKey(id); &#125;public void deleteBatch(List&lt;Integer&gt; ids) &#123; // TODO Auto-generated method stub EmployeeExample example = new EmployeeExample(); EmployeeExample.Criteria criteria = example.createCriteria(); //delete from xxx where emp_id in(1,2,3) criteria.andEmpIdIn(ids); employeeMapper.deleteByExample(example); &#125; 在控制器EmployeeController中添加单个删除的方法 123456789101112131415161718192021//单个批量二合一//批量删除：1-2-3//单个删除：1 @ResponseBody @RequestMapping(value=&quot;/emp/&#123;ids&#125;&quot;,method=RequestMethod.DELETE) public Msg deleteEmp(@PathVariable(&quot;ids&quot;)String ids)&#123; //批量删除 if(ids.contains(&quot;-&quot;))&#123; List&lt;Integer&gt; del_ids = new ArrayList&lt;&gt;(); String[] str_ids = ids.split(&quot;-&quot;); //组装id的集合 for (String string : str_ids) &#123; del_ids.add(Integer.parseInt(string)); &#125; employeeService.deleteBatch(del_ids); &#125;else&#123; Integer id = Integer.parseInt(ids); employeeService.deleteEmp(id); &#125; return Msg.success(); &#125; 单个删除发送Ajax 12345678910111213141516171819//单个删除 $(document).on(&quot;click&quot;,&quot;.delete_btn&quot;,function()&#123; //1、弹出是否确认删除对话框 var empName = $(this).parents(&quot;tr&quot;).find(&quot;td:eq(2)&quot;).text(); var empId = $(this).attr(&quot;del-id&quot;); //alert($(this).parents(&quot;tr&quot;).find(&quot;td:eq(1)&quot;).text()); if(confirm(&quot;确认删除【&quot;+empName+&quot;】吗？&quot;))&#123; //确认，发送ajax请求删除即可 $.ajax(&#123; url:&quot;$&#123;APP_PATH&#125;/emp/&quot;+empId, type:&quot;DELETE&quot;, success:function(result)&#123; alert(result.msg); //回到本页 to_page(currentPage); &#125; &#125;); &#125; &#125;); 全选/全不选 实现页面全选和全不选的效果 1234567891011121314//完成全选/全不选功能 $(&quot;#check_all&quot;).click(function()&#123; //attr获取checked是undefined，布尔类型用prop; //我们这些dom原生的属性；attr获取自定义属性的值； //prop修改和读取dom原生属性的值 $(&quot;.check_item&quot;).prop(&quot;checked&quot;,$(this).prop(&quot;checked&quot;)); &#125;); //check_item $(document).on(&quot;click&quot;,&quot;.check_item&quot;,function()&#123; //判断当前选择中的元素是否5个 var flag = $(&quot;.check_item:checked&quot;).length==$(&quot;.check_item&quot;).length; $(&quot;#check_all&quot;).prop(&quot;checked&quot;,flag); &#125;); 批量删除12345678910111213141516171819202122232425262728//点击全部删除，就批量删除 $(&quot;#emp_delete_all_btn&quot;).click(function()&#123; // var empNames = &quot;&quot;; var del_idstr = &quot;&quot;; $.each($(&quot;.check_item:checked&quot;),function()&#123; //this empNames += $(this).parents(&quot;tr&quot;).find(&quot;td:eq(2)&quot;).text()+&quot;,&quot;; //组装员工id字符串 del_idstr += $(this).parents(&quot;tr&quot;).find(&quot;td:eq(1)&quot;).text()+&quot;-&quot;; &#125;); //去除empNames多余的, empNames = empNames.substring(0, empNames.length-1); //去除删除的id多余的- del_idstr = del_idstr.substring(0, del_idstr.length-1); if(confirm(&quot;确认删除【&quot;+empNames+&quot;】吗？&quot;))&#123; //发送ajax请求删除 $.ajax(&#123; url:&quot;$&#123;APP_PATH&#125;/emp/&quot;+del_idstr, type:&quot;DELETE&quot;, success:function(result)&#123; alert(result.msg); //回到当前页面 to_page(currentPage); &#125; &#125;); &#125; &#125;); 总结","path":"page/ssmcrud05.html","date":"05-09","excerpt":"","tags":[{"name":"SSM","slug":"SSM","permalink":"http://xiaoliblog.cn/tags/SSM/"}]},{"title":"SSM高级整合🍃修改模块","text":"修改模块 点击编辑按钮弹出编辑输入框 实现思路 点击编辑弹出用户修改模态框（显示用户信息） 点击更新，完成用户修改 模态框 修改index.jsp文件，新增修改模态框 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!-- 员工修改的模态框 --&gt;&lt;div class=&quot;modal fade&quot; id=&quot;empUpdateModal&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;myModalLabel&quot;&gt; &lt;div class=&quot;modal-dialog&quot; role=&quot;document&quot;&gt; &lt;div class=&quot;modal-content&quot;&gt; &lt;div class=&quot;modal-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-label=&quot;Close&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;&lt;/button&gt; &lt;h4 class=&quot;modal-title&quot;&gt;员工修改&lt;/h4&gt; &lt;/div&gt; &lt;div class=&quot;modal-body&quot;&gt; &lt;form class=&quot;form-horizontal&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;col-sm-2 control-label&quot;&gt;empName&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;p class=&quot;form-control-static&quot; id=&quot;empName_update_static&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;col-sm-2 control-label&quot;&gt;email&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;email&quot; class=&quot;form-control&quot; id=&quot;email_update_input&quot; placeholder=&quot;email@atguigu.com&quot;&gt; &lt;span class=&quot;help-block&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;col-sm-2 control-label&quot;&gt;gender&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;label class=&quot;radio-inline&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; id=&quot;gender1_update_input&quot; value=&quot;M&quot; checked=&quot;checked&quot;&gt; 男 &lt;/label&gt; &lt;label class=&quot;radio-inline&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; id=&quot;gender2_update_input&quot; value=&quot;F&quot;&gt; 女 &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;col-sm-2 control-label&quot;&gt;deptName&lt;/label&gt; &lt;div class=&quot;col-sm-4&quot;&gt; &lt;!-- 部门提交部门id即可 --&gt; &lt;select class=&quot;form-control&quot; name=&quot;dId&quot;&gt; &lt;/select&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=&quot;modal-footer&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;关闭&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot; id=&quot;emp_update_btn&quot;&gt;更新&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 绑定事件 给编辑按钮绑定事件，弹出模态框。注意单纯绑定是绑定不上的，因为数据是Ajax之后取到的 12345678910111213141516//1、我们是按钮创建之前就绑定了click，所以绑定不上。因为数据是Ajax发送之后得到的//1）、可以在创建按钮的时候绑定。 2）、绑定点击.live()//jquery新版没有live，使用on进行替代$(document).on(&quot;click&quot;,&quot;.edit_btn&quot;,function()&#123; //alert(&quot;edit&quot;); //1、查出部门信息，并显示部门列表 getDepts(&quot;#empUpdateModal select&quot;); //2、查出员工信息，显示员工信息，方法在下面有讲解 getEmp($(this).attr(&quot;edit-id&quot;)); //3、把员工的id传递给模态框的更新按钮 $(&quot;#emp_update_btn&quot;).attr(&quot;edit-id&quot;,$(this).attr(&quot;edit-id&quot;)); $(&quot;#empUpdateModal&quot;).modal(&#123; backdrop:&quot;static&quot; &#125;);&#125;); 显示信息 首先在EmployeeService 123456789101112@Servicepublic class EmployeeService &#123; @Autowired EmployeeMapper employeeMapper; //按照员工id查询员工 public Employee getEmp(Integer id) &#123; // TODO Auto-generated method stub Employee employee = employeeMapper.selectByPrimaryKey(id); return employee; &#125;&#125; 在EmployeeController控制器中添加方法，id来源于请求路径中 123456789//根据id查询员工 @RequestMapping(value=&quot;/emp/&#123;id&#125;&quot;,method=RequestMethod.GET) @ResponseBody public Msg getEmp(@PathVariable(&quot;id&quot;)Integer id)&#123; Employee employee = employeeService.getEmp(id); return Msg.success().add(&quot;emp&quot;, employee); &#125; 发送Ajax请求 1234567891011121314function getEmp(id)&#123; $.ajax(&#123; url:&quot;$&#123;APP_PATH&#125;/emp/&quot;+id, type:&quot;GET&quot;, success:function(result)&#123; //console.log(result); var empData = result.extend.emp; $(&quot;#empName_update_static&quot;).text(empData.empName); $(&quot;#email_update_input&quot;).val(empData.email); $(&quot;#empUpdateModal input[name=gender]&quot;).val([empData.gender]); $(&quot;#empUpdateModal select&quot;).val([empData.dId]); &#125; &#125;);&#125; Ajax发送PUT请求 点击更新，更新员工信息，关掉对话框并回到当前位置 123456789101112131415161718192021222324252627//点击更新，更新员工信息 $(&quot;#emp_update_btn&quot;).click(function()&#123; //验证邮箱是否合法 //1、校验邮箱信息 var email = $(&quot;#email_update_input&quot;).val(); var regEmail = /^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]&#123;2,6&#125;)$/; if(!regEmail.test(email))&#123; show_validate_msg(&quot;#email_update_input&quot;, &quot;error&quot;, &quot;邮箱格式不正确&quot;); return false; &#125;else&#123; show_validate_msg(&quot;#email_update_input&quot;, &quot;success&quot;, &quot;&quot;); &#125; //2、发送ajax请求保存更新的员工数据 $.ajax(&#123; url:&quot;$&#123;APP_PATH&#125;/emp/&quot;+$(this).attr(&quot;edit-id&quot;), type:&quot;PUT&quot;, data:$(&quot;#empUpdateModal form&quot;).serialize(), success:function(result)&#123; //alert(result.msg); //1、关闭对话框 $(&quot;#empUpdateModal&quot;).modal(&quot;hide&quot;); //回到当前页面 to_page(currentPage); &#125; &#125;); &#125;); 控制器 在EmployeeService业务层中添加方法 1234public void updateEmp(Employee employee) &#123; // TODO Auto-generated method stub employeeMapper.updateByPrimaryKeySelective(employee); &#125; 在控制器EmployeeController中增加保存更新员工的方法 12345678@ResponseBody @RequestMapping(value=&quot;/emp/&#123;empId&#125;&quot;,method=RequestMethod.PUT) public Msg saveEmp(Employee employee,HttpServletRequest request)&#123; System.out.println(&quot;请求体中的值：&quot;+request.getParameter(&quot;gender&quot;)); System.out.println(&quot;将要更新的员工数据：&quot;+employee); employeeService.updateEmp(employee); return Msg.success() ; &#125; 如果直接发送ajax=PUT形式的请求，封装的数据变为 1Employee [empId=1014, empName=null, gender=null, email=null, dId=null] 问题：请求体中有数据；但是Employee对象封装不上 Tomcat原因： 将请求体中的数据，封装一个map request.getParameter(&quot;empName&quot;)就会从这个map中取值。 SpringMVC封装POJO对象的时候。会把POJO中每个属性的值，request.getParamter(&quot;email&quot;); AJAX发送PUT请求出现问题 PUT请求，请求体中的数据，request.getParameter(&quot;empName&quot;)拿不到 Tomcat一看是PUT不会封装请求体中的数据为map，只有POST形式的请求才封装请求体为map 解决方案：我们要能支持直接发送PUT之类的请求还要封装请求体中的数据 配置上HttpPutFormContentFilter；他的作用是将请求体中的数据解析包装成一个map request被重新包装，request.getParameter()被重写，就会从自己封装的map中取数据 123456789&lt;!--web.xml中配置--&gt; &lt;filter&gt; &lt;filter-name&gt;HttpPutFormContentFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HttpPutFormContentFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;HttpPutFormContentFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;","path":"page/ssmcrud04.html","date":"05-09","excerpt":"","tags":[{"name":"SSM","slug":"SSM","permalink":"http://xiaoliblog.cn/tags/SSM/"}]},{"title":"SSM高级整合🍃新增模块","text":"新增模块 点击新增按钮会弹出一个输入界面 实现思路 在index.jsp页面点击”按钮”，弹出新增对话框 去数据库查询部门列表，显示在对话框中 用户输入数据并进行校验完成保存 jQuery前端校验+Ajax用户名重复校验+重要数据配上后端校验和数据库唯一约束 Restful风格URI： /emp/&#123;id&#125; GET查询员工 /emp 发POST即保存员工 /emp/&#123;id&#125; PUT请求修改员工 /epm/&#123;id&#125; DELETE删除员工 模态框 弹出来的界面可以使用Boostrap提供的JavaScript插件模态框实现 修改index.jsp文件，新增模态框 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!-- 员工添加的模态框 --&gt;&lt;div class=&quot;modal fade&quot; id=&quot;empAddModal&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;myModalLabel&quot;&gt; &lt;div class=&quot;modal-dialog&quot; role=&quot;document&quot;&gt; &lt;div class=&quot;modal-content&quot;&gt; &lt;div class=&quot;modal-header&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-label=&quot;Close&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;&lt;/button&gt; &lt;h4 class=&quot;modal-title&quot; id=&quot;myModalLabel&quot;&gt;员工添加&lt;/h4&gt; &lt;/div&gt; &lt;div class=&quot;modal-body&quot;&gt; &lt;form class=&quot;form-horizontal&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;col-sm-2 control-label&quot;&gt;empName&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;empName&quot; class=&quot;form-control&quot; id=&quot;empName_add_input&quot; placeholder=&quot;empName&quot;&gt; &lt;span class=&quot;help-block&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;col-sm-2 control-label&quot;&gt;email&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;email&quot; class=&quot;form-control&quot; id=&quot;email_add_input&quot; placeholder=&quot;email@atguigu.com&quot;&gt; &lt;span class=&quot;help-block&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;col-sm-2 control-label&quot;&gt;gender&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;label class=&quot;radio-inline&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; id=&quot;gender1_add_input&quot; value=&quot;M&quot; checked=&quot;checked&quot;&gt; 男 &lt;/label&gt; &lt;label class=&quot;radio-inline&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; id=&quot;gender2_add_input&quot; value=&quot;F&quot;&gt; 女 &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;col-sm-2 control-label&quot;&gt;deptName&lt;/label&gt; &lt;div class=&quot;col-sm-4&quot;&gt; &lt;!-- 部门提交部门id即可 --&gt; &lt;select class=&quot;form-control&quot; name=&quot;dId&quot;&gt; &lt;/select&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=&quot;modal-footer&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;关闭&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot; id=&quot;emp_save_btn&quot;&gt;保存&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 给新增按钮绑定事件 1234567//点击新增按钮弹出模态框。 $(&quot;#emp_add_modal_btn&quot;).click(function()&#123; //弹出模态框 $(&quot;#empAddModal&quot;).modal(&#123; backdrop:&quot;static&quot; &#125;); &#125;); 发现Ajax请求 模态框弹出之前应该发送Ajax请求，弹出部门信息显示在下拉列表中 1234567891011121314151617181920//清空表单样式及内容 function reset_form(ele)&#123; $(ele)[0].reset(); //清空表单样式 $(ele).find(&quot;*&quot;).removeClass(&quot;has-error has-success&quot;); $(ele).find(&quot;.help-block&quot;).text(&quot;&quot;); &#125; //点击新增按钮弹出模态框。 $(&quot;#emp_add_modal_btn&quot;).click(function()&#123; //清除表单数据（表单完整重置（表单的数据，表单的样式）） reset_form(&quot;#empAddModal form&quot;); //s$(&quot;&quot;)[0].reset(); //发送ajax请求，查出部门信息，显示在下拉列表中 getDepts(&quot;#empAddModal select&quot;); //弹出模态框 $(&quot;#empAddModal&quot;).modal(&#123; backdrop:&quot;static&quot; &#125;); &#125;); 发送Ajax的方法getDepts() 12345678910111213141516171819202122//查出所有的部门信息并显示在下拉列表中function getDepts(ele)&#123; //清空之前下拉列表的值 $(ele).empty(); $.ajax(&#123; //需要一个控制器处理请求 url:&quot;$&#123;APP_PATH&#125;/depts&quot;, type:&quot;GET&quot;, success:function(result)&#123; //&#123;&quot;code&quot;:100,&quot;msg&quot;:&quot;处理成功！&quot;, //&quot;extend&quot;:&#123;&quot;depts&quot;:[&#123;&quot;deptId&quot;:1,&quot;deptName&quot;:&quot;开发部&quot;&#125;,&#123;&quot;deptId&quot;:2,&quot;deptName&quot;:&quot;测试部&quot;&#125;]&#125;&#125; //console.log(result); //显示部门信息在下拉列表中 //$(&quot;#empAddModal select&quot;).append(&quot;&quot;) $.each(result.extend.depts,function()&#123; var optionEle = $(&quot;&lt;option&gt;&lt;/option&gt;&quot;).append(this.deptName).attr(&quot;value&quot;,this.deptId); optionEle.appendTo(ele); &#125;); &#125; &#125;);&#125; 控制器处理请求 先创建业务层DepartmentService 12345678910111213@Servicepublic class DepartmentService &#123; @Autowired private DepartmentMapper departmentMapper; public List&lt;Department&gt; getDepts() &#123; //查出的所有部门信息 List&lt;Department&gt; list = departmentMapper.selectByExample(null); return list; &#125;&#125; 创建一个控制器DepartmentController处理和部门有关的请求 1234567891011121314@Controllerpublic class DepartmentController &#123; @Autowired private DepartmentService departmentService; /*返回所有部门信息*/ @RequestMapping(&quot;/depts&quot;) @ResponseBody public Msg getDepts()&#123; List&lt;Department&gt; list = departmentService.getDepts(); return Msg.success().add(&quot;depts&quot;,list); &#125;&#125; 实现保存模块控制器 点击保存，模态框中填写的表单数据提交给服务器进行保存 首先在EmployeeService中新增员工保存方法 1234567891011@Servicepublic class EmployeeService &#123; @Autowired EmployeeMapper employeeMapper;//员工保存 public void saveEmp(Employee employee) &#123; // TODO Auto-generated method stub employeeMapper.insertSelective(employee); &#125;&#125; 在EmployeeController中新增员工保存的方法 12345678910111213141516171819202122// 员工保存//1、支持JSR303校验///2、导入Hibernate-Validator @RequestMapping(value=&quot;/emp&quot;,method=RequestMethod.POST) @ResponseBody public Msg saveEmp(@Valid Employee employee,BindingResult result)&#123; if(result.hasErrors())&#123; //校验失败，应该返回失败，在模态框中显示校验失败的错误信息 Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); List&lt;FieldError&gt; errors = result.getFieldErrors(); for (FieldError fieldError : errors) &#123; System.out.println(&quot;错误的字段名：&quot;+fieldError.getField()); System.out.println(&quot;错误信息：&quot;+fieldError.getDefaultMessage()); map.put(fieldError.getField(), fieldError.getDefaultMessage()); &#125; return Msg.fail().add(&quot;errorFields&quot;, map); &#125;else&#123; employeeService.saveEmp(employee); return Msg.success(); &#125; &#125; 发送Ajax 取得表单的值后发送Ajax给服务器，后端控制器处理请求，调用方法插入到数据库中 服务器返回JSON结果，保存成功就关闭模态框并跳转到最后一页 1234567891011121314151617181920212223242526272829303132333435363738394041424344//点击保存，保存员工。 $(&quot;#emp_save_btn&quot;).click(function()&#123; //1、模态框中填写的表单数据提交给服务器进行保存 //1、先对要提交给服务器的数据进行校验 if(!validate_add_form())&#123; return false; &#125;; //1、判断之前的ajax用户名校验是否成功。如果成功。 if($(this).attr(&quot;ajax-va&quot;)==&quot;error&quot;)&#123; return false; &#125; //2、发送ajax请求保存员工 $.ajax(&#123; url:&quot;$&#123;APP_PATH&#125;/emp&quot;, type:&quot;POST&quot;, //jQuery中拿取表单内容的方法 data:$(&quot;#empAddModal form&quot;).serialize(), success:function(result)&#123; //alert(result.msg); if(result.code == 100)&#123; //员工保存成功； //1、关闭模态框 $(&quot;#empAddModal&quot;).modal(&#x27;hide&#x27;); //2、来到最后一页，显示刚才保存的数据 //发送ajax请求显示最后一页数据即可 to_page(totalRecord); &#125;else&#123; //显示失败信息 //console.log(result); //有哪个字段的错误信息就显示哪个字段的； if(undefined != result.extend.errorFields.email)&#123; //显示邮箱错误信息 show_validate_msg(&quot;#email_add_input&quot;, &quot;error&quot;, result.extend.errorFields.email); &#125; if(undefined != result.extend.errorFields.empName)&#123; //显示员工名字的错误信息 show_validate_msg(&quot;#empName_add_input&quot;, &quot;error&quot;, result.extend.errorFields.empName); &#125; &#125; &#125; &#125;); &#125;); 数据校验功能 需要对提交保存的数据进行校验 表单校验 校验表单数据 12345678910111213141516171819202122232425262728//校验表单数据 function validate_add_form()&#123; //1、拿到要校验的数据，使用正则表达式 var empName = $(&quot;#empName_add_input&quot;).val(); var regName = /(^[a-zA-Z0-9_-]&#123;6,16&#125;$)|(^[\\u2E80-\\u9FFF]&#123;2,5&#125;)/; if(!regName.test(empName))&#123; //alert(&quot;用户名可以是2-5位中文或者6-16位英文和数字的组合&quot;); show_validate_msg(&quot;#empName_add_input&quot;, &quot;error&quot;, &quot;用户名可以是2-5位中文或者6-16位英文和数字的组合&quot;); return false; &#125;else&#123; show_validate_msg(&quot;#empName_add_input&quot;, &quot;success&quot;, &quot;&quot;); &#125;; //2、校验邮箱信息 var email = $(&quot;#email_add_input&quot;).val(); var regEmail = /^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]&#123;2,6&#125;)$/; if(!regEmail.test(email))&#123; //alert(&quot;邮箱格式不正确&quot;); //应该清空这个元素之前的样式 show_validate_msg(&quot;#email_add_input&quot;, &quot;error&quot;, &quot;邮箱格式不正确&quot;); /* $(&quot;#email_add_input&quot;).parent().addClass(&quot;has-error&quot;); $(&quot;#email_add_input&quot;).next(&quot;span&quot;).text(&quot;邮箱格式不正确&quot;); */ return false; &#125;else&#123; show_validate_msg(&quot;#email_add_input&quot;, &quot;success&quot;, &quot;&quot;); &#125; return true; &#125; 提示信息 用到了Bootstrap中的校验状态样式 12345678910111213//显示校验结果的提示信息 function show_validate_msg(ele,status,msg)&#123; //清除当前元素的校验状态 $(ele).parent().removeClass(&quot;has-success has-error&quot;); $(ele).next(&quot;span&quot;).text(&quot;&quot;); if(&quot;success&quot;==status)&#123; $(ele).parent().addClass(&quot;has-success&quot;); $(ele).next(&quot;span&quot;).text(msg); &#125;else if(&quot;error&quot; == status)&#123; $(ele).parent().addClass(&quot;has-error&quot;); $(ele).next(&quot;span&quot;).text(msg); &#125; &#125; 用户名校验 需要异步校验用户名是否重复，当输入框改变就校验用户名 在EmployeeService中新增方法 12345678910111213141516171819202122@Servicepublic class EmployeeService &#123; @Autowired EmployeeMapper employeeMapper; /** * 检验用户名是否可用 * * @param empName * @return true：代表当前姓名可用 fasle：不可用 */ public boolean checkUser(String empName) &#123; // TODO Auto-generated method stub EmployeeExample example = new EmployeeExample(); //查询条件 EmployeeExample.Criteria criteria = example.createCriteria(); //拼装条件 criteria.andEmpNameEqualTo(empName); //返回查到的记录数 long count = employeeMapper.countByExample(example); return count == 0; //为0表示没有记录，当前用户名可用 &#125; 修改EmployeeController新增用户名校验的方法，记得和前端的校验规则统一起来 1234567891011121314151617@ResponseBody @RequestMapping(&quot;/checkuser&quot;) public Msg checkuser(@RequestParam(&quot;empName&quot;)String empName)&#123; //先判断用户名是否是合法的表达式; String regx = &quot;(^[a-zA-Z0-9_-]&#123;6,16&#125;$)|(^[\\u2E80-\\u9FFF]&#123;2,5&#125;)&quot;; if(!empName.matches(regx))&#123; return Msg.fail().add(&quot;va_msg&quot;, &quot;用户名必须是6-16位数字和字母的组合或者2-5位中文&quot;); &#125; //数据库用户名重复校验 boolean b = employeeService.checkUser(empName); if(b)&#123; return Msg.success(); //可用 &#125;else&#123; return Msg.fail().add(&quot;va_msg&quot;, &quot;用户名不可用&quot;); //返回提示信息 &#125; &#125; 发送Ajax请求校验用户名是否可用 12345678910111213141516171819//校验用户名是否可用$(&quot;#empName_add_input&quot;).change(function()&#123; //发送ajax请求校验用户名是否可用 var empName = this.value; $.ajax(&#123; url:&quot;$&#123;APP_PATH&#125;/checkuser&quot;, data:&quot;empName=&quot;+empName, type:&quot;POST&quot;, success:function(result)&#123; if(result.code==100)&#123; show_validate_msg(&quot;#empName_add_input&quot;,&quot;success&quot;,&quot;用户名可用&quot;); $(&quot;#emp_save_btn&quot;).attr(&quot;ajax-va&quot;,&quot;success&quot;); &#125;else&#123; show_validate_msg(&quot;#empName_add_input&quot;,&quot;error&quot;,result.extend.va_msg); $(&quot;#emp_save_btn&quot;).attr(&quot;ajax-va&quot;,&quot;error&quot;); &#125; &#125; &#125;);&#125;); 因为用户名是监听表单内容发生改变时调用，当如果表单内容不变时会出错，所以需要打开模态框就对表单进行清空 12345678910111213//清空表单样式及内容 function reset_form(ele)&#123; $(ele)[0].reset(); //清空表单样式 $(ele).find(&quot;*&quot;).removeClass(&quot;has-error has-success&quot;); $(ele).find(&quot;.help-block&quot;).text(&quot;&quot;); &#125; //点击新增按钮弹出模态框。 $(&quot;#emp_add_modal_btn&quot;).click(function()&#123; //清除表单数据（表单完整重置（表单的数据，表单的样式）） reset_form(&quot;#empAddModal form&quot;); &#125; 后端校验 前端校验很容易被人改动，不够安全。最完整的校验应该是前端校验+后端校验+数据库约束 可以使用JSR303进行校验，需要导入Hibernate-Validator包，在实体类员工Employee上给每一个字段加上相应要求 123456789101112131415161718192021public class Employee &#123; private Integer empId; @Pattern(regexp=&quot;(^[a-zA-Z0-9_-]&#123;6,16&#125;$)|(^[\\u2E80-\\u9FFF]&#123;2,5&#125;)&quot; ,message=&quot;用户名必须是2-5位中文或者6-16位英文和数字的组合&quot;) private String empName; private String gender; //@Email @Pattern(regexp=&quot;^([a-z0-9_\\\\.-]+)@([\\\\da-z\\\\.-]+)\\\\.([a-z\\\\.]&#123;2,6&#125;)$&quot;, message=&quot;邮箱格式不正确&quot;) private String email; private Integer dId; //希望查询员工的时候把部门信息也查询出来 private Department department; //getter,setter,无参和有参构造&#125; 修改控制器EmployeeController中的员工保存方法 12345678910111213141516171819202122232425/** * 员工保存 * 1、支持JSR303校验 * 2、导入Hibernate-Validator */@RequestMapping(value=&quot;/emp&quot;,method=RequestMethod.POST)@ResponseBodypublic Msg saveEmp(@Valid Employee employee,BindingResult result)&#123; if(result.hasErrors())&#123; //校验失败，应该返回失败，在模态框中显示校验失败的错误信息 Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); List&lt;FieldError&gt; errors = result.getFieldErrors(); for (FieldError fieldError : errors) &#123; System.out.println(&quot;错误的字段名：&quot;+fieldError.getField()); System.out.println(&quot;错误信息：&quot;+fieldError.getDefaultMessage()); map.put(fieldError.getField(), fieldError.getDefaultMessage()); &#125; return Msg.fail().add(&quot;errorFields&quot;, map); &#125;else&#123; employeeService.saveEmp(employee); return Msg.success(); &#125;&#125; 前端保存事件修改 1234567891011121314151617181920212223242526272829303132333435363738394041424344//点击保存，保存员工。 $(&quot;#emp_save_btn&quot;).click(function()&#123; //1、模态框中填写的表单数据提交给服务器进行保存 //1、先对要提交给服务器的数据进行校验 if(!validate_add_form())&#123; return false; &#125;; //1、判断之前的ajax用户名校验是否成功。如果成功。 if($(this).attr(&quot;ajax-va&quot;)==&quot;error&quot;)&#123; return false; &#125; //2、发送ajax请求保存员工 $.ajax(&#123; url:&quot;$&#123;APP_PATH&#125;/emp&quot;, type:&quot;POST&quot;, //jQuery中拿取表单内容的方法 data:$(&quot;#empAddModal form&quot;).serialize(), success:function(result)&#123; //alert(result.msg); if(result.code == 100)&#123; //员工保存成功； //1、关闭模态框 $(&quot;#empAddModal&quot;).modal(&#x27;hide&#x27;); //2、来到最后一页，显示刚才保存的数据 //发送ajax请求显示最后一页数据即可 to_page(totalRecord); &#125;else&#123; //显示失败信息 //console.log(result); //有哪个字段的错误信息就显示哪个字段的； if(undefined != result.extend.errorFields.email)&#123; //显示邮箱错误信息 show_validate_msg(&quot;#email_add_input&quot;, &quot;error&quot;, result.extend.errorFields.email); &#125; if(undefined != result.extend.errorFields.empName)&#123; //显示员工名字的错误信息 show_validate_msg(&quot;#empName_add_input&quot;, &quot;error&quot;, result.extend.errorFields.empName); &#125; &#125; &#125; &#125;); &#125;);","path":"page/ssmcrud03.html","date":"05-09","excerpt":"","tags":[{"name":"SSM","slug":"SSM","permalink":"http://xiaoliblog.cn/tags/SSM/"}]},{"title":"SSM高级整合🍃分页查询模块","text":"分页查询实现思路 首先访问index.jsp页面 index.jsp页面发送出查询员工列表请求 EmployeeController来接受请求，查出员工数据 来到list.jsp页面进行展示 规定查询请求`URL=”/emps” Restful风格URI： /emp/&#123;id&#125; GET查询员工 /emp 发POST即保存员工 /emp/&#123;id&#125; PUT请求修改员工 /epm/&#123;id&#125; DELETE删除员工 业务层 Service业务层要调用Dao及Mapper层的方法 创建EmployeeService业务层 123456789101112@Service //业务逻辑组件public class EmployeeService &#123; @Autowired //自动装配Mapper/Dao层 EmployeeMapper employeeMapper; //由于Mybatis逆向工程已经生成了查询所有的方法 //查询所有员工 public List&lt;Employee&gt; getAll() &#123; // TODO Auto-generated method stub return employeeMapper.selectByExampleWithDept(null); &#125;&#125; 分页插件 首先引入PageHelper分页插件的依赖 123456&lt;!--引入pageHelper分页插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.0.0&lt;/version&gt; &lt;/dependency&gt; 然后在mybatis-config.xml中注册 123456&lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;!--分页参数合理化 --&gt; &lt;property name=&quot;reasonable&quot; value=&quot;true&quot;/&gt; &lt;/plugin&gt;&lt;/plugins&gt; forEach方式控制器 创建EmployeeController控制器，控制器要掉Service业务层方法 123456789101112131415161718192021222324@Controllerpublic class EmployeeController &#123; @Autowired //自动装配Service层 EmployeeService employeeService; // 查询员工数据（分页查询），pn为PageNum第几页，defaultValue为默认值 // @RequestMapping(&quot;/emps&quot;) public String getEmps( @RequestParam(value = &quot;pn&quot;, defaultValue = &quot;1&quot;) Integer pn, Model model) &#123; // 这不是一个分页查询； // 引入PageHelper分页插件 // 在查询之前只需要调用，传入页码，以及每页的大小 PageHelper.startPage(pn, 5); // startPage后面紧跟的这个查询就是一个分页查询 List&lt;Employee&gt; emps = employeeService.getAll(); // 使用pageInfo包装查询后的结果，只需要将pageInfo交给页面就行了。 // 封装了详细的分页信息,包括有我们查询出来的数据，传入连续显示的页数 PageInfo page = new PageInfo(emps, 5); model.addAttribute(&quot;pageInfo&quot;, page); //作为属性对象发送给list视图，视图通过$&#123;&#125;取得数据 return &quot;list&quot;; //返回list.jsp &#125;&#125; 在WEB-INF下创建views文件夹存放视图，创建list.jsp显示员工信息的视图 默认只能访问index.jsp页面，所以要在index.jsp页面添加请求转发语句到emps请求，通过控制器来转到list.jsp视图· 1&lt;jsp:forward page=&quot;/emps&quot;&gt;&lt;jsp:forward&gt; 分页请求测试 新间一个MvcTest测试类，使用Spring测试模块提供的模拟测试请求功能，测试CRUD请求的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142//Spring4测试的时候，需要servlet3.0的支持@RunWith(SpringJUnit4ClassRunner.class)@WebAppConfiguration@ContextConfiguration(locations = &#123; &quot;classpath:applicationContext.xml&quot;, &quot;file:src/main/webapp/WEB-INF/dispatcherServlet-servlet.xml&quot; &#125;)public class MvcTest &#123; // 传入Springmvc的ioc @Autowired WebApplicationContext context; // 虚拟mvc请求，获取到处理结果。 MockMvc mockMvc; @Before //每次都要用，需要进行初始化 public void initMokcMvc() &#123; mockMvc = MockMvcBuilders.webAppContextSetup(context).build(); &#125; @Test public void testPage() throws Exception &#123; //模拟请求拿到返回值 MvcResult result = mockMvc.perform(MockMvcRequestBuilders.get(&quot;/emps&quot;).param(&quot;pn&quot;, &quot;5&quot;)) .andReturn(); //请求成功以后，请求域中会有pageInfo；我们可以取出pageInfo进行验证 MockHttpServletRequest request = result.getRequest(); PageInfo pi = (PageInfo) request.getAttribute(&quot;pageInfo&quot;); System.out.println(&quot;当前页码：&quot;+pi.getPageNum()); System.out.println(&quot;总页码：&quot;+pi.getPages()); System.out.println(&quot;总记录数：&quot;+pi.getTotal()); System.out.println(&quot;在页面需要连续显示的页码&quot;); int[] nums = pi.getNavigatepageNums(); for (int i : nums) &#123; System.out.print(&quot; &quot;+i); &#125; //获取员工数据 List&lt;Employee&gt; list = pi.getList(); for (Employee employee : list) &#123; System.out.println(&quot;ID：&quot;+employee.getEmpId()+&quot;==&gt;Name:&quot;+employee.getEmpName()); &#125; &#125;&#125; 测试拿到数据即可 搭建分页视图 使用Bootstrap搭建list.jsp分页显示页面 JSP页面头信息 123456&lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; web路径中不以/开始的相对路径，找资源，以当前资源的路径为基准，经常容易出问题。 以/开始的路径，找资源，以服务器的路径为标准(http://localhost:8080)；需要加上项目名 1234&lt;% pageContext.setAttribute(&quot;APP_PATH&quot;, request.getContextPath());%&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;$&#123;APP_PATH &#125;/static/js/jquery-1.12.4.min.js&quot;&gt;&lt;/script&gt;&lt;link href=&quot;$&#123;APP_PATH &#125;/static/bootstrap-3.3.7-dist/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;script src=&quot;$&#123;APP_PATH &#125;/static/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; 采用Bootstrap栅格系统搭建视图 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;!-- 搭建显示页面 --&gt;&lt;div class=&quot;container&quot;&gt; &lt;!-- 标题 --&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-12&quot;&gt; &lt;h1&gt;SSM-CRUD BY PL&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 按钮 --&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-4 col-md-offset-8&quot;&gt; &lt;button class=&quot;btn btn-primary&quot;&gt;新增&lt;/button&gt; &lt;button class=&quot;btn btn-danger&quot;&gt;删除&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 显示表格数据 --&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-12&quot;&gt; &lt;table class=&quot;table table-hover&quot;&gt; &lt;tr&gt; &lt;th&gt;#&lt;/th&gt; &lt;th&gt;empName&lt;/th&gt; &lt;th&gt;gender&lt;/th&gt; &lt;th&gt;email&lt;/th&gt; &lt;th&gt;deptName&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items=&quot;$&#123;pageInfo.list &#125;&quot; var=&quot;emp&quot;&gt; &lt;tr&gt; &lt;th&gt;$&#123;emp.empId &#125;&lt;/th&gt; &lt;th&gt;$&#123;emp.empName &#125;&lt;/th&gt; &lt;th&gt;$&#123;emp.gender==&quot;M&quot;?&quot;男&quot;:&quot;女&quot; &#125;&lt;/th&gt; &lt;th&gt;$&#123;emp.email &#125;&lt;/th&gt; &lt;!--部门信息--&gt; &lt;th&gt;$&#123;emp.department.deptName &#125;&lt;/th&gt; &lt;th&gt; &lt;button class=&quot;btn btn-primary btn-sm&quot;&gt; &lt;!--字体图标--&gt; &lt;span class=&quot;glyphicon glyphicon-pencil&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; 编辑 &lt;/button&gt; &lt;button class=&quot;btn btn-danger btn-sm&quot;&gt; &lt;span class=&quot;glyphicon glyphicon-trash&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; 删除 &lt;/button&gt; &lt;/th&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 显示分页信息 --&gt; &lt;div class=&quot;row&quot;&gt; &lt;!--分页文字信息 --&gt; &lt;div class=&quot;col-md-6&quot;&gt;当前 $&#123;pageInfo.pageNum &#125;页,总$&#123;pageInfo.pages &#125; 页,总 $&#123;pageInfo.total &#125; 条记录&lt;/div&gt; &lt;!-- 分页条信息 --&gt; &lt;div class=&quot;col-md-6&quot;&gt; &lt;nav aria-label=&quot;Page navigation&quot;&gt; &lt;ul class=&quot;pagination&quot;&gt; &lt;li&gt;&lt;a href=&quot;$&#123;APP_PATH &#125;/emps?pn=1&quot;&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;!--如果有上一页就发请求显示，否则则首页按钮和前进按钮禁用--&gt; &lt;c:if test=&quot;$&#123;pageInfo.hasPreviousPage &#125;&quot;&gt; &lt;li&gt;&lt;a href=&quot;$&#123;APP_PATH &#125;/emps?pn=$&#123;pageInfo.pageNum-1&#125;&quot; aria-label=&quot;Previous&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;laquo;&lt;/span&gt; &lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;!--拿到页码数--&gt; &lt;c:forEach items=&quot;$&#123;pageInfo.navigatepageNums &#125;&quot; var=&quot;page_Num&quot;&gt; &lt;!--判断当前页码是否是当前页，如果是则高亮显示--&gt; &lt;c:if test=&quot;$&#123;page_Num == pageInfo.pageNum &#125;&quot;&gt; &lt;!--发送请求--&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;$&#123;page_Num &#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;!--判断当前页码不是当前页，则取消高亮显示--&gt; &lt;c:if test=&quot;$&#123;page_Num != pageInfo.pageNum &#125;&quot;&gt; &lt;li&gt;&lt;a href=&quot;$&#123;APP_PATH &#125;/emps?pn=$&#123;page_Num &#125;&quot;&gt;$&#123;page_Num &#125;&lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;/c:forEach&gt; &lt;!--判断是否有下一页，有才显示，否则末尾按钮禁用--&gt; &lt;c:if test=&quot;$&#123;pageInfo.hasNextPage &#125;&quot;&gt; &lt;li&gt;&lt;a href=&quot;$&#123;APP_PATH &#125;/emps?pn=$&#123;pageInfo.pageNum+1 &#125;&quot; aria-label=&quot;Next&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;raquo;&lt;/span&gt; &lt;/a&gt;&lt;/li&gt; &lt;/c:if&gt; &lt;!--pages表示总页数--&gt; &lt;li&gt;&lt;a href=&quot;$&#123;APP_PATH &#125;/emps?pn=$&#123;pageInfo.pages&#125;&quot;&gt;末页&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 分页的参数和属性可以查看官方文档，可以合理运用三元运算符${emp.gender==&quot;M&quot;?&quot;男&quot;:&quot;女&quot; } JSON数据方式 以上只适用于浏览器客户端，对于安卓或者IOS等移动客户端是行不通的。所以可以通过返回JSON数据进行统一解析 使用纯Ajax进行查询，index.jsp页面直接发送ajax请求进行员工分页数据的查询 服务器将查出的数据，以JSON字符串的形式返回给浏览器 浏览器收到JS字符串，可以使用JS对JSON进行解析，使用JS通过DOM增删改改变页面 返回JSON。实现客户端的无关性 通用类 在实体包bean下创建通用的返回JSON的类Msg 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Msg &#123; //状态码 100-成功 200-失败 private int code; //提示信息 private String msg; //用户要返回给浏览器的数据 private Map&lt;String, Object&gt; extend = new HashMap&lt;String, Object&gt;(); public static Msg success()&#123; Msg result = new Msg(); result.setCode(100); result.setMsg(&quot;处理成功！&quot;); return result; &#125; public static Msg fail()&#123; Msg result = new Msg(); result.setCode(200); result.setMsg(&quot;处理失败！&quot;); return result; &#125; //实现链式调用 public Msg add(String key,Object value)&#123; this.getExtend().put(key, value); return this; &#125; public int getCode() &#123; return code; &#125; public void setCode(int code) &#123; this.code = code; &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; public Map&lt;String, Object&gt; getExtend() &#123; return extend; &#125; public void setExtend(Map&lt;String, Object&gt; extend) &#123; this.extend = extend; &#125;&#125; 控制器 修改EmployeeeController控制器，添加方法 123456789101112131415//导入jackson包。此包负责将pageInfo对象转为JSON字符串@RequestMapping(&quot;/emps&quot;)@ResponseBodypublic Msg getEmpsWithJson( @RequestParam(value = &quot;pn&quot;, defaultValue = &quot;1&quot;) Integer pn) &#123; // 引入PageHelper分页插件 // 在查询之前只需要调用，传入页码，以及每页的大小 PageHelper.startPage(pn, 5); // startPage后面紧跟的这个查询就是一个分页查询 List&lt;Employee&gt; emps = employeeService.getAll(); // 使用pageInfo包装查询后的结果，只需要将pageInfo交给页面就行了。 // 封装了详细的分页信息,包括有我们查询出来的数据，传入连续显示的页数 PageInfo page = new PageInfo(emps, 5); return Msg.success().add(&quot;pageInfo&quot;, page);&#125; 采用JSON格式化工具格式化结果如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&#123; &quot;code&quot;: 100, &quot;msg&quot;: &quot;处理成功！&quot;, &quot;extend&quot;: &#123; &quot;pageInfo&quot;: &#123; &quot;pageNum&quot;: 1, &quot;pageSize&quot;: 5, &quot;size&quot;: 5, &quot;startRow&quot;: 1, &quot;endRow&quot;: 5, &quot;total&quot;: 201, &quot;pages&quot;: 41, &quot;list&quot;: [&#123; &quot;empId&quot;: 1, &quot;empName&quot;: &quot;jerry&quot;, &quot;gender&quot;: &quot;M&quot;, &quot;email&quot;: &quot;jerry@pl.com&quot;, &quot;dId&quot;: 1, &quot;department&quot;: &#123; &quot;deptId&quot;: 1, &quot;deptName&quot;: &quot;开发部&quot; &#125; &#125;, &#123; &quot;empId&quot;: 2, &quot;empName&quot;: &quot;5f0a10&quot;, &quot;gender&quot;: &quot;M&quot;, &quot;email&quot;: &quot;5f0a10@pl.com&quot;, &quot;dId&quot;: 1, &quot;department&quot;: &#123; &quot;deptId&quot;: 1, &quot;deptName&quot;: &quot;开发部&quot; &#125; &#125;, &#123; &quot;empId&quot;: 3, &quot;empName&quot;: &quot;5c3ea1&quot;, &quot;gender&quot;: &quot;M&quot;, &quot;email&quot;: &quot;5c3ea1@pl.com&quot;, &quot;dId&quot;: 1, &quot;department&quot;: &#123; &quot;deptId&quot;: 1, &quot;deptName&quot;: &quot;开发部&quot; &#125; &#125;, &#123; &quot;empId&quot;: 4, &quot;empName&quot;: &quot;1c8592&quot;, &quot;gender&quot;: &quot;M&quot;, &quot;email&quot;: &quot;1c8592@pl.com&quot;, &quot;dId&quot;: 1, &quot;department&quot;: &#123; &quot;deptId&quot;: 1, &quot;deptName&quot;: &quot;开发部&quot; &#125; &#125;, &#123; &quot;empId&quot;: 5, &quot;empName&quot;: &quot;65b5b3&quot;, &quot;gender&quot;: &quot;M&quot;, &quot;email&quot;: &quot;65b5b3@pl.com&quot;, &quot;dId&quot;: 1, &quot;department&quot;: &#123; &quot;deptId&quot;: 1, &quot;deptName&quot;: &quot;开发部&quot; &#125; &#125;], &quot;prePage&quot;: 0, &quot;nextPage&quot;: 2, &quot;isFirstPage&quot;: true, &quot;isLastPage&quot;: false, &quot;hasPreviousPage&quot;: false, &quot;hasNextPage&quot;: true, &quot;navigatePages&quot;: 5, &quot;navigatepageNums&quot;: [1, 2, 3, 4, 5], &quot;navigateFirstPage&quot;: 1, &quot;navigateLastPage&quot;: 5, &quot;lastPage&quot;: 5, &quot;firstPage&quot;: 1 &#125; &#125;&#125; 视图修改 修改index.jsp页面，一进入首页就发送Ajax拿取数据并解析 同样要引入Boostrap框架，搭建的显示页面如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!-- 搭建显示页面 --&gt;&lt;div class=&quot;container&quot;&gt; &lt;!-- 标题 --&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-12&quot;&gt; &lt;h1&gt;SSM-CRUD BY PL&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 按钮 --&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-4 col-md-offset-8&quot;&gt; &lt;button class=&quot;btn btn-primary&quot; id=&quot;emp_add_modal_btn&quot;&gt;新增&lt;/button&gt; &lt;button class=&quot;btn btn-danger&quot; id=&quot;emp_delete_all_btn&quot;&gt;删除&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 显示表格数据 --&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-12&quot;&gt; &lt;table class=&quot;table table-hover&quot; id=&quot;emps_table&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt; &lt;input type=&quot;checkbox&quot; id=&quot;check_all&quot;/&gt; &lt;/th&gt; &lt;th&gt;#&lt;/th&gt; &lt;th&gt;empName&lt;/th&gt; &lt;th&gt;gender&lt;/th&gt; &lt;th&gt;email&lt;/th&gt; &lt;th&gt;deptName&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;!--发送Ajax构建表格体--&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 显示分页信息 --&gt; &lt;div class=&quot;row&quot;&gt; &lt;!--分页文字信息 --&gt; &lt;div class=&quot;col-md-6&quot; id=&quot;page_info_area&quot;&gt;&lt;/div&gt; &lt;!-- 分页条信息 --&gt; &lt;div class=&quot;col-md-6&quot; id=&quot;page_nav_area&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 发送Ajax请求1234567891011121314151617181920212223var totalRecord,currentPage; //全局变量，总记录数和当前页//1、页面加载完成以后，直接去发送ajax请求,要到分页数据$(function()&#123; //去首页 to_page(1);&#125;);function to_page(pn)&#123; $.ajax(&#123; url:&quot;$&#123;APP_PATH&#125;/emps&quot;, data:&quot;pn=&quot;+pn, type:&quot;GET&quot;, success:function(result)&#123; //console.log(result); //1、解析并显示员工数据 build_emps_table(result); //2、解析并显示分页信息 build_page_info(result); //3、解析显示分页条数据 build_page_nav(result); &#125; &#125;);&#125; 解析并显示员工数据 1234567891011121314151617181920212223242526272829303132333435363738394041function build_emps_table(result)&#123; //在传入新数据之前，需要清空table表格 $(&quot;#emps_table tbody&quot;).empty(); //对照JSON进行解析 var emps = result.extend.pageInfo.list; //遍历 $.each(emps,function(index,item)&#123; var checkBoxTd = $(&quot;&lt;td&gt;&lt;input type=&#x27;checkbox&#x27; class=&#x27;check_item&#x27;/&gt;&lt;/td&gt;&quot;); var empIdTd = $(&quot;&lt;td&gt;&lt;/td&gt;&quot;).append(item.empId); var empNameTd = $(&quot;&lt;td&gt;&lt;/td&gt;&quot;).append(item.empName); var genderTd = $(&quot;&lt;td&gt;&lt;/td&gt;&quot;).append(item.gender==&#x27;M&#x27;?&quot;男&quot;:&quot;女&quot;); var emailTd = $(&quot;&lt;td&gt;&lt;/td&gt;&quot;).append(item.email); var deptNameTd = $(&quot;&lt;td&gt;&lt;/td&gt;&quot;).append(item.department.deptName); /** &lt;button class=&quot;&quot;&gt; &lt;span class=&quot;&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt; 编辑 &lt;/button&gt; */ //addClass添加类名 append在元素内部添加DOM元素 var editBtn = $(&quot;&lt;button&gt;&lt;/button&gt;&quot;).addClass(&quot;btn btn-primary btn-sm edit_btn&quot;) .append($(&quot;&lt;span&gt;&lt;/span&gt;&quot;).addClass(&quot;glyphicon glyphicon-pencil&quot;)).append(&quot;编辑&quot;); //为编辑按钮添加一个自定义的属性，来表示当前员工id editBtn.attr(&quot;edit-id&quot;,item.empId); var delBtn = $(&quot;&lt;button&gt;&lt;/button&gt;&quot;).addClass(&quot;btn btn-danger btn-sm delete_btn&quot;) .append($(&quot;&lt;span&gt;&lt;/span&gt;&quot;).addClass(&quot;glyphicon glyphicon-trash&quot;)).append(&quot;删除&quot;); //为删除按钮添加一个自定义的属性来表示当前删除的员工id delBtn.attr(&quot;del-id&quot;,item.empId); var btnTd = $(&quot;&lt;td&gt;&lt;/td&gt;&quot;).append(editBtn).append(&quot; &quot;).append(delBtn); //var delBtn = //append方法执行完成以后还是返回原来的元素&lt;tr&gt;&lt;/tr&gt; $(&quot;&lt;tr&gt;&lt;/tr&gt;&quot;).append(checkBoxTd) .append(empIdTd) .append(empNameTd) .append(genderTd) .append(emailTd) .append(deptNameTd) .append(btnTd) .appendTo(&quot;#emps_table tbody&quot;); //添加到表格体中 &#125;);&#125; 解析并显示分页信息 123456789//解析左下角显示分页信息function build_page_info(result)&#123; $(&quot;#page_info_area&quot;).empty(); $(&quot;#page_info_area&quot;).append(&quot;当前&quot;+result.extend.pageInfo.pageNum+&quot;页,总&quot;+ result.extend.pageInfo.pages+&quot;页,总&quot;+ result.extend.pageInfo.total+&quot;条记录&quot;); totalRecord = result.extend.pageInfo.total; currentPage = result.extend.pageInfo.pageNum;&#125; 解析显示分页条数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//解析显示分页条，点击分页要能去下一页....function build_page_nav(result)&#123; //page_nav_area $(&quot;#page_nav_area&quot;).empty(); var ul = $(&quot;&lt;ul&gt;&lt;/ul&gt;&quot;).addClass(&quot;pagination&quot;); //构建元素 var firstPageLi = $(&quot;&lt;li&gt;&lt;/li&gt;&quot;).append($(&quot;&lt;a&gt;&lt;/a&gt;&quot;).append(&quot;首页&quot;).attr(&quot;href&quot;,&quot;#&quot;)); //转义字符&amp;laquo;表示&lt;前一页 var prePageLi = $(&quot;&lt;li&gt;&lt;/li&gt;&quot;).append($(&quot;&lt;a&gt;&lt;/a&gt;&quot;).append(&quot;&amp;laquo;&quot;)); //如果当前页没有前一页了，就禁掉首页和前一页按钮 if(result.extend.pageInfo.hasPreviousPage == false)&#123; firstPageLi.addClass(&quot;disabled&quot;); prePageLi.addClass(&quot;disabled&quot;); &#125;else&#123; //未禁用才绑定事件发请求 //为元素添加点击翻页的事件 firstPageLi.click(function()&#123; to_page(1); //首页 &#125;); prePageLi.click(function()&#123; //传入当前页页码并调用函数 to_page(result.extend.pageInfo.pageNum -1); &#125;); &#125; //转义字符&amp;raquo;表示&gt;下一页 var nextPageLi = $(&quot;&lt;li&gt;&lt;/li&gt;&quot;).append($(&quot;&lt;a&gt;&lt;/a&gt;&quot;).append(&quot;&amp;raquo;&quot;)); var lastPageLi = $(&quot;&lt;li&gt;&lt;/li&gt;&quot;).append($(&quot;&lt;a&gt;&lt;/a&gt;&quot;).append(&quot;末页&quot;).attr(&quot;href&quot;,&quot;#&quot;)); //如果当前页没有后一页了，就禁用末页和后一页按钮 if(result.extend.pageInfo.hasNextPage == false)&#123; nextPageLi.addClass(&quot;disabled&quot;); lastPageLi.addClass(&quot;disabled&quot;); &#125;else&#123; //未禁用才绑定事件发请求 nextPageLi.click(function()&#123; //传入页码并调用函数 to_page(result.extend.pageInfo.pageNum +1); &#125;); lastPageLi.click(function()&#123; //传入总页数，直接跳到最后一页 to_page(result.extend.pageInfo.pages); &#125;); &#125; //添加首页和前一页 的提示 ul.append(firstPageLi).append(prePageLi); //1,2，3遍历给ul中添加页码提示 $.each(result.extend.pageInfo.navigatepageNums,function(index,item)&#123; var numLi = $(&quot;&lt;li&gt;&lt;/li&gt;&quot;).append($(&quot;&lt;a&gt;&lt;/a&gt;&quot;).append(item)); if(result.extend.pageInfo.pageNum == item)&#123; numLi.addClass(&quot;active&quot;); //当前页高亮显示 &#125; numLi.click(function()&#123; to_page(item); &#125;); ul.append(numLi); &#125;); //添加下一页和末页 的提示 ul.append(nextPageLi).append(lastPageLi); //把ul加入到nav var navEle = $(&quot;&lt;nav&gt;&lt;/nav&gt;&quot;).append(ul); navEle.appendTo(&quot;#page_nav_area&quot;);&#125; PageHelper分页记得配置参数合理化参数","path":"page/ssmcrud02.html","date":"05-08","excerpt":"","tags":[{"name":"SSM","slug":"SSM","permalink":"http://xiaoliblog.cn/tags/SSM/"}]},{"title":"jQuery实现QQ音乐播放器🥳功能实现","text":"歌曲播放播放工具类封装 为了防止index.js代码过多，我们可以封装成一个工具类 新建一个player.js文件，在index.html中引入，注意要在index.js之前引入 123456789101112131415//闭包函数，为了使函数内部数据和外部数据隔绝(function (window) &#123; function Player() &#123; //封装一个类，返回原型上的 init()`方法，也就是通过 init()`创建类 return new Player.prototype.init(); &#125; //定义这个类的原型，将构造函数指向 Player，并定义 init 方法 Player.prototype = &#123; constructor: Player, init: function () &#123;&#125;, &#125;; //将 Player 原型上的 init 方法的原型指向 Player 的原型，将这个对象开放给 window Player.prototype.init.prototype = Player.prototype; window.Player = Player;&#125;)(window); 播放暂停 在 HTML 页面插入一个 audio 标签，用于播放音乐 1&lt;audio src=&quot;&quot;&gt;&lt;/audio&gt; 在index.js中引入 player 工具库，实例化一个 Player 对象，并且传入 audio 对象 123456789101112131415var $audio = $(&quot;audio&quot;);var player = new Player($audio);//修改加载歌曲列表的函数，把Ajax取到的数据给playerfunction getPlayerList() &#123; $.ajax(&#123; url: &quot;./source/musiclist.json&quot;, dataType: &quot;json&quot;, success: function (data) &#123; //得到Ajax取到的数据 player.musicList = data; //.... &#125;&#125; 当按钮被点击时，调用播放音乐的方法 实现播放 / 暂停音乐的方法，当创建音乐标签时，在标签中保存索引及音乐信息 1234567// 定义一个方法创建一条音乐function createMusicItem(index, music) &#123; var $item = $(...); $item.get(0).index = index; $item.get(0).music = music; return $item;&#125; 接收两个参数，分别为 index 和music 信息，定义一个遍历，用于记录当前索引，判断是否为同一首音乐 12345678910111213141516171819Player.prototype = &#123; currentIndex: -1, playMusic: function (index, music) &#123; // 判断是否是同一首音乐 if (this.currentIndex == index) &#123; // 同一首音乐 if (this.audio.paused) &#123; this.audio.play(); &#125; else &#123; this.audio.pause(); &#125; &#125; else &#123; // 不是同一首音乐 this.$audio.attr(&quot;src&quot;, music.link_url); this.audio.play(); this.currentIndex = index; &#125; &#125;,&#125;; 底部播放 / 暂停 / 上一首 / 下一首12345678910111213$musicPlay.click(function () &#123; // 判断有没有播放过音乐 if (player.currentIndex == -1) &#123; // 没有播放过 $(&quot;.list_music&quot;).eq(0).find(&quot;.list_menu_play&quot;).trigger(&quot;click&quot;); &#125; else &#123; // 已经播放过 $(&quot;.list_music&quot;) .eq(player.currentIndex) .find(&quot;.list_menu_play&quot;) .trigger(&quot;click&quot;); &#125;&#125;); 1234567891011121314// 5 监听底部控制区域上一首按钮的点击$(&quot;.music_pre&quot;).click(function () &#123; $(&quot;.list_music&quot;) .eq(player.preIndex()) .find(&quot;.list_menu_play&quot;) .trigger(&quot;click&quot;);&#125;);// 6 监听底部控制区域下一首按钮的点击$(&quot;.music_next&quot;).click(function () &#123; $(&quot;.list_music&quot;) .eq(player.nextIndex()) .find(&quot;.list_menu_play&quot;) .trigger(&quot;click&quot;);&#125;); 对象的 preIndex 与 nextIndex 方法用于处理索引 1234567891011121314preIndex: function () &#123; var index = this.currentIndex - 1; if (index &lt; 0) &#123; index = this.musicList.length - 1; &#125; return index;&#125;, nextIndex: function () &#123; var index = this.currentIndex + 1; if (index &gt; this.musicList.length - 1) &#123; index = 0; &#125; return index; &#125;, 删除歌曲 删除数据时需要注意的就是前台删除数据后，后台也无需保存数据。并且需要对标签保存的数据进行重新排序 123456789101112131415161718// 7. 监听删除按钮的点击$(&quot;.content_list&quot;).delegate(&quot;.list_menu_del&quot;, &quot;click&quot;, function () &#123; // 找到被点击的音乐 var $item = $(this).parents(&quot;.list_music&quot;); // 判断当前删除的是否是正在播放的 if ($item.get(0).index == player.currentIndex) &#123; $(&quot;.music_next&quot;).trigger(&quot;click&quot;); &#125; $item.remove(); player.changeMusic($item.get(0).index); // 重新排序 $(&quot;.list_music&quot;).each(function (index, ele) &#123; ele.index = index; $(ele) .find(&quot;.list_number&quot;) .text(index + 1); &#125;);&#125;); 删除后需要注意删除的数据是否是正在播放的音乐的前边，如果是需要将索引 - 1。否则会出现下一曲跳歌的现象 12345678changeMusic: function (index) &#123; // 删除对应的数据 this.musicList.splice(index, 1); //判断当前删除的是否是正在播放的前面的音乐 if (index &lt; this.currentIndex) &#123; this.currentIndex = this.currentIndex - 1; &#125;&#125;, 切换歌曲信息 更换歌曲信息涉及到的基本信息包括：右侧信息栏、图片、歌手、歌曲名、专辑名、底部控制条的名称、时间 实现这个这个功能也很简单，只是一些元素的替换。调用位置有两处 第一次获取歌曲时（成功）的回调 初始化列表的第一个音乐 当点击其他歌曲时 12345678910111213141516171819202122232425262728// 2. 初始化歌曲信息function initMusicInfo(music) &#123; // 获取对应的元素 var $musicImage = $(&quot;.song_info_pic img&quot;); var $musicName = $(&quot;.song_info_name a&quot;); var $musicSinger = $(&quot;.song_info_singer a&quot;); var $musicAblum = $(&quot;.song_info_ablum a&quot;); var $musicProgressName = $(&quot;.music_progress_name&quot;); var $musicProgressTime = $(&quot;.music_progress_time&quot;); var $musicBg = $(&quot;.mask_bg&quot;); // 给获取的到的元素赋值 $musicImage.attr(&quot;src&quot;, music.cover); $musicName.text(music.name); $musicSinger.text(music.singer); $musicAblum.text(music.album); $musicProgressName.text(music.name + &quot;/&quot; + music.singer); $musicProgressTime.text(&quot;00:00 / &quot; + music.time); $musicBg.css(&quot;background&quot;, &#x27;url(&quot;&#x27; + music.cover + &#x27;&quot;)&#x27;);&#125;$.ajax(&#123; success: function (data) &#123; initMusicInfo(data[0]); &#125;,&#125;);$(&quot;.content_list&quot;).delegate(&quot;.list_menu_play&quot;, &quot;click&quot;, function () &#123; // 3.6 切换歌曲信息 initMusicInfo($item.get(0).music);&#125;); 进度条的实现 获取被点击位置距离窗口的位置 获取默认距离窗口的位置 被点击的位置减去默认距离窗口的位置 点击进度条时，调整小圆点以及前景色的位置 12345678910111213progressClick: function () &#123; var $this = this; //this 是progress // 监听背景的点击 this.$progressBar.click(function (event) &#123; // 获取背景距离窗口默认的位置 var normalLeft = $(this).offset().left; // 获取点击的位置距离窗口默认的位置 var eventLeft = event.pageX; // 设置前景的宽度 $this.$progressLine.css(&quot;width&quot;, eventLeft - normalLeft); $this.$progressDot.css(&quot;left&quot;, eventLeft - normalLeft); &#125;);&#125;, 进度条的拖动 鼠标拖拽使用 mousemove 方法监听，但必须在鼠标按下后监听 实现逻辑与点击一致 鼠标抬起则释放 mousemove 事件即可 12345678910111213141516171819202122progressMove: function () &#123; var $this = this; // 1. 监听的鼠标的按下事件 this.$progressBar.mousedown(function () &#123; // 获取背景距离窗口默认的位置 var normalLeft = $(this).offset().left; // 2. 监听鼠标的移动事件 $(document).mousemove(function () &#123; // 获取点击的位置距离窗口默认的位置 var eventLeft = event.pageX; // 设置前景的宽度 $this.$progressLine.css(&quot;width&quot;, eventLeft - normalLeft); $this.$progressDot.css(&quot;left&quot;, eventLeft - normalLeft); &#125;); &#125;); // 3. 监听鼠标的抬起事件 $(document).mouseup(function () &#123; $(document).off(&quot;mousemove&quot;); &#125;);&#125;, 音乐时间、进度条同步 通过 timeupdate 事件监听是否播放，正在播放时，会不断触发这个事件。在事件内部通过 duration 与 currentTime 获取当前时长和总时长。 于是可以在 player 类中新增加方法 1234567891011121314151617181920212223242526272829303132musicTimeUpdate: function (callBack) &#123; var $this = this; this.$audio.on(&quot;timeupdate&quot;, function () &#123; var duration = $this.audio.duration; var currentTime = $this.audio.currentTime; var timeStr = $this.formatDate(currentTime, duration); callBack(currentTime, duration, timeStr); &#125;);&#125;, // 格式化时间 formatDate: function (currentTime, duration) &#123; // 结束时间 var endMin = parseInt(duration / 60); var endSec = parseInt(duration % 60); if (endMin &lt; 10) &#123; endMin = &quot;0&quot; + endMin; &#125; if (endSec &lt; 10) &#123; endSec = &quot;0&quot; + endSec; &#125; // 开始时间 var startMin = parseInt(currentTime / 60); var startSec = parseInt(currentTime % 60); if (startMin &lt; 10) &#123; startMin = &quot;0&quot; + startMin; &#125; if (startSec &lt; 10) &#123; startSec = &quot;0&quot; + startSec; &#125; return startMin + &quot;:&quot; + startSec + &quot; / &quot; + endMin + &quot;:&quot; + endSec; &#125;, 在我们的 index.js 中只需要调用这个方法即可 12345// 8. 监听播放的进度player.musicTimeUpdate(function (currentTime, duration, timeStr) &#123; // 同步时间 $(&quot;.music_progress_time&quot;).text(timeStr);&#125;); 同样的为进度条新增方法 setProgress 123456789setProgress: function (value) &#123; if (value &lt; 0 || value &gt; 100) return; this.$progressLine.css(&#123; width: value + &quot;%&quot;, &#125;); this.$progressDot.css(&#123; left: value + &quot;%&quot;, &#125;);&#125;, 这样完成后，在主函数中计算出当前时间所占比例即可调用此方法进行设置 1234567// 8. 监听播放的进度player.musicTimeUpdate(function (currentTime, duration, timeStr) &#123; // 同步进度条 // 计算播放比例 var value = (currentTime / duration) * 100; progress.setProgress(value);&#125;); 因为使用了百分比进行修改元素，那么 css 的定位方式也需要修改一下 123456.music_progress_info .music_progress_bar &#123; position: relative;&#125;.music_progress_bar .music_progress_dot &#123; position: absolute;&#125; 点击进度条与歌曲同步 实现思路： 计算出总时长除以已播放时长的比例 将歌曲进度设置为歌曲时长乘以上一步的比例 123456progress.progressClick(function (value) &#123; player.musicSeekTo(value);&#125;);progress.progressMove(function (value) &#123; player.musicSeekTo(value);&#125;); 123musicSeekTo: function (value) &#123; this.audio.currentTime = this.audio.duration * value;&#125;, 为了实现拖拽时声音能够继续播放，因此将设置的方法改到 mouseup 事件中 123456789101112131415161718192021222324252627progressMove: function (callBack) &#123; var $this = this; var normalLeft, eventLeft; // 1. 监听的鼠标的按下事件 this.$progressBar.mousedown(function () &#123; // 获取背景距离窗口默认的位置 normalLeft = $(this).offset().left; $this.isMove = true; // 2. 监听鼠标的移动事件 $(document).mousemove(function () &#123; // 获取点击的位置距离窗口默认的位置 eventLeft = event.pageX; // 设置前景的宽度 $this.$progressLine.css(&quot;width&quot;, eventLeft - normalLeft); $this.$progressDot.css(&quot;left&quot;, eventLeft - normalLeft); &#125;); &#125;); // 3. 监听鼠标的抬起事件 $(document).mouseup(function () &#123; $(document).off(&quot;mousemove&quot;); $this.isMove = false; // 计算进度条的比例 var value = (eventLeft - normalLeft) / $this.$progressBar.width(); callBack(value); &#125;);&#125;, 声音控制 声音控制与进度条控制几乎一致 1234567891011var $voiceBar = $(&quot;.music_voice_bar&quot;);var $voiceLine = $(&quot;.music_voice_line&quot;);var $voiceDot = $(&quot;.music_voice_dot&quot;);voicePregress = Progress($voiceBar, $voiceLine, $voiceDot);voicePregress.progressClick(function (value) &#123; player.musicVoiceSeekTo(value);&#125;);voicePregress.progressMove(function (value) &#123; player.musicVoiceSeekTo(value);&#125;);&#125; 接下来为 player 类新增方法即可 1234musicVoiceSeekTo: function (value) &#123; // 取值0~1 this.audio.volume = value;&#125;, bug 修复 音乐进度的跳转应为一个正常的数字 1234musicSeekTo: function (value) &#123; if (isNaN(value)) return; this.audio.currentTime = this.audio.duration * value;&#125;, 音量同理且音量范围为 0~1 123456musicVoiceSeekTo: function (value) &#123; if (isNaN(value)) return; if (value &lt; 0 || value &gt; 1) return; // 取值0~1 this.audio.volume = value;&#125;, 拖拽超出范围 12345678910111213progressMove: function (callBack) &#123; var barWidth = this.$progressBar.width(); // 1. 监听的鼠标的按下事件 this.$progressBar.mousedown(function () &#123; $(document).mousemove(function () &#123; var offset = eventLeft - normalLeft; if (offset &gt;= 0 &amp;&amp; offset &lt;= barWidth) &#123; // 设置前景的宽度 $this.$progressLine.css(&quot;width&quot;, eventLeft - normalLeft); $this.$progressDot.css(&quot;left&quot;, eventLeft - normalLeft); &#125; &#125;); &#125;); 歌词设置歌词解析并且加载 解析创建一个新的类用于解析歌词 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354(function (window) &#123; function Lyric(path) &#123; return new Lyric.prototype.init(path); &#125; Lyric.prototype = &#123; constructor: Lyric, init: function (path) &#123; this.path = path; &#125;, // 保存匹配的时间 times: [], // 保存匹配的歌词 lyrics: [], loadLyric: function (callBack) &#123; var $this = this; $.ajax(&#123; url: $this.path, dataType: &quot;text&quot;, success: function (data) &#123; $this.pareLyric(data); callBack(); &#125;, error: function (e) &#123;&#125;, &#125;); &#125;, // 解析歌词的方法 pareLyric: function (data) &#123; var $this = this; var array = data.split(&quot;\\n&quot;); // 正则表达式匹配内容 var timeReg = /\\[(\\d*:\\d*\\.\\d*)\\]/; // 遍历取出每一条歌词 $.each(array, function (index, ele) &#123; // 处理歌词 var lrc = ele.split(&quot;]&quot;)[1]; // 排除空字符串(没有歌词) if (lrc.length == 1) return true; $this.lyrics.push(lrc); var res = timeReg.exec(ele); if (res == null) return true; var timeStr = res[1]; var res2 = timeStr.split(&quot;:&quot;); var min = parseInt(res2[0]) * 60; var sec = parseFloat(res2[1]); var time = parseFloat(Number(min + sec).toFixed(2)); $this.times.push(time); &#125;); console.log($this.times); console.log($this.lyrics); &#125;, &#125;; Lyric.prototype.init.prototype = Lyric.prototype; window.Lyric = Lyric;&#125;)(window); 接下来只需要在自己的 JavaScript 中初始化这个类并且调用方法即可 123456789101112// 3. 初始化歌词信息function initMusicLyric(music) &#123; var lyric = new Lyric(music.link_lrc); var $lryicContainer = $(&quot;.song_lyric&quot;); lyric.loadLyric(function () &#123; // 创建歌词列表 $.each(lyric.lyrics, function (index, ele) &#123; var $item = $(&quot;&lt;li&gt;&quot; + ele + &quot;&lt;/li&gt;&quot;); $lryicContainer.append($item); &#125;); &#125;);&#125; 创建好了之后，还需要对样式进行一点点小的修改 1234.content_right .song_lyric &#123; height: 150px; overflow: hidden;&#125; 歌词同步 歌词同步需要在监听播放的进度中去设置 123456789101112// 8. 监听播放的进度player.musicTimeUpdate(function (currentTime, duration, timeStr) &#123; // 实现歌词的同步 var index = lyric.currentIndex(currentTime); var $item = $(&quot;.song_lyric li&quot;).eq(index); $item.addClass(&quot;cur&quot;); $item.siblings().removeClass(&quot;cur&quot;); if (index &lt;= 2) return; $(&quot;.song_lyric&quot;).css(&#123; marginTop: (-index + 2) * 30, &#125;);&#125;); 因为使用了 margin-top 滚动歌词，那么需要将 html 也该动 123&lt;div class=&quot;song_lyric_container&quot;&gt; &lt;ul class=&quot;song_lyric&quot;&gt;&lt;/ul&gt;&lt;/div&gt; 为了实现切换歌曲时，歌词也可以切换，也需要在切换歌曲时将保存的歌曲信息也切换 1234loadLyric: function (callBack) &#123; $this.times = []; $this.lyrics = [];&#125;, 1234567function initMusicLyric(music) &#123; $lryicContainer.html(&quot;&quot;);&#125;$(&quot;.content_list&quot;).delegate(&quot;.list_menu_play&quot;, &quot;click&quot;, function () &#123; // 3.7切换歌词信息 initMusicLyric($item.get(0).music);&#125;);","path":"page/project07.html","date":"05-08","excerpt":"","tags":[{"name":"项目案例","slug":"项目案例","permalink":"http://xiaoliblog.cn/tags/%E9%A1%B9%E7%9B%AE%E6%A1%88%E4%BE%8B/"}]},{"title":"SSM高级整合🍃基础模块","text":"项目简介 下载源码 功能点 分页 数据校验 = jquery前端校验+JSR303后端校验 ajax Rest风格的URI；使用HTTP协议请求方式的动词，来表示对资源的操作（GET（查询），POST（新增），PUT（修改），DELETE（删除） Restful风格URI： /emp/&#123;id&#125; GET查询员工 /emp 发POST即保存员工 /emp/&#123;id&#125; PUT请求修改员工 /epm/&#123;id&#125; DELETE删除员工 技术点 基础框架ssm（SpringMVC+Spring+MyBatis） 数据库MySQL 前端框架bootstrap快速搭建简洁美观的界面 项目的依赖管理Maven 分页pagehelper 逆向工程MyBatis Generator 环境搭建相关依赖 创建一个maven工程 引入项目依赖的jar包（spring、springmvc、 mybatis、 数据库连接池，驱动包， 其他（jstl，servlet-api，junit） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;!--引入项目依赖的jar包 --&gt;&lt;!-- SpringMVC、Spring --&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;&lt;dependencies&gt; &lt;!--引入pageHelper分页插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MBG 逆向工程--&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis.generator/mybatis-generator-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 返回json字符串的支持 --&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.8.8&lt;/version&gt; &lt;/dependency&gt; &lt;!--JSR303数据校验支持；tomcat7及以上的服务器， tomcat7以下的服务器：el表达式。额外给服务器的lib包中替换新的标准的el --&gt; &lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-validator --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.4.1.Final&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring-Jdbc --&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--Spring-test --&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring面向切面编程 --&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aspects --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--MyBatis --&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MyBatis整合Spring的适配包 --&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池、驱动 --&gt; &lt;!-- https://mvnrepository.com/artifact/com.mchange/c3p0 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.41&lt;/version&gt; &lt;/dependency&gt; &lt;!-- （jstl，servlet-api，junit） --&gt; &lt;!-- https://mvnrepository.com/artifact/jstl/jstl --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;!--服务器上有就剔除掉--&gt; &lt;/dependency&gt; &lt;!--JSP--&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp/javax.servlet.jsp-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.3.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- junit --&gt; &lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.ibatis&lt;/groupId&gt; &lt;artifactId&gt;ibatis-core&lt;/artifactId&gt; &lt;version&gt;3.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 目录结构123456789101112131415161718192021222324|--main |--java |--com.ssmcrud |--bean &#x2F;&#x2F;实体类 |--controller &#x2F;&#x2F;控制器 |--dao &#x2F;&#x2F;Mapper接口 |--service &#x2F;&#x2F;业务层 |--resources |--mapper &#x2F;&#x2F;存放mapper.xml |--applicationContext.xml &#x2F;&#x2F;配置SpringIOC，事务，数据源 |--dbconfig.properties |--mybatis-cofig.xml |--webapp |--static &#x2F;&#x2F;存放Bootstrap和js |--WEB-INF |--views &#x2F;&#x2F;存放jsp视图 |--dispacherServlet-servlet.xml &#x2F;&#x2F;SpringMVC配置视图解析器 |--index.jsp|--test |--java |--MapperTest &#x2F;&#x2F;Spring测试 |--MBGTest &#x2F;&#x2F;Mbatis逆向工程测试 |--MVCTest &#x2F;&#x2F;Spring MVC测试|--mgb.xml &#x2F;&#x2F;逆向工程配置文件 引入Bootstrap 在webapp下创建static存放静态文件，在index.jsp引入bootstrap前端框架和jQuery 12345678910111213&lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css&quot;/&gt;&lt;!--本地引入--&gt;&lt;% pageContext.setAttribute(&quot;APP_PATH&quot;, request.getContextPath()); %&gt;&lt;!-- web路径： 不以/开始的相对路径，找资源，以当前资源的路径为基准，经常容易出问题。 以/开始的相对路径，找资源，以服务器的路径为标准(http://localhost:3306)；需要加上项目名 http://localhost:3306/crud--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;$&#123;APP_PATH &#125;/static/jQuery/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;&lt;link href=&quot;$&#123;APP_PATH &#125;/static/bootstrap-3.3.7-dist/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;script src=&quot;$&#123;APP_PATH &#125;/static/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; 数据库 创建一个ssm_crud数据库，新建Department部门表tbl_dept和Employee员工表tbl_emp 配置文件web.xml配置 配置web.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!--启动spring的容器--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- Bootstraps the root web application context before servlet initialization --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--2、springmvc的前端控制器，拦截所有请求 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- Map all requests to the DispatcherServlet for handling --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 3、字符编码过滤器，一定要放在所有过滤器之前 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceRequestEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 4、使用Rest风格的URI，将页面普通的post请求转为指定的delete或者put请求 --&gt; &lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;HttpPutFormContentFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HttpPutFormContentFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;HttpPutFormContentFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; SpringMVC配置 在WEB-INF下创建dispatcherServlet-servlet.xml用于配置前端控制器 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd&quot;&gt; &lt;!--SpringMVC的配置文件，包含网站跳转逻辑的控制，配置 --&gt; &lt;context:component-scan base-package=&quot;com.ssmcrud&quot; use-default-filters=&quot;false&quot;&gt; &lt;!--只扫描控制器。 --&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;/context:component-scan&gt; &lt;!--配置视图解析器，方便页面返回 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--两个标准配置 --&gt; &lt;!-- 将springmvc不能处理的请求交给tomcat --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 能支持springmvc更高级的一些功能，JSR303校验，快捷的ajax...映射动态请求 --&gt; &lt;mvc:annotation-driven/&gt;&lt;/beans&gt; 配置Spring 创建dbconfig.properties数据库配置文件 1234jdbc.jdbcUrl=jdbc:mysql://localhost:3306/ssm_crudjdbc.driverClass=com.mysql.jdbc.Driverjdbc.user=rootjdbc.password=root 配置resources目录下的applicationContext.xml配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.ssmcrud&quot;&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot; /&gt; &lt;/context:component-scan&gt; &lt;!-- Spring的配置文件，这里主要配置和业务逻辑有关的 --&gt; &lt;!--=================== 数据源，事务控制，xxx ================--&gt; &lt;context:property-placeholder location=&quot;classpath:dbconfig.properties&quot; /&gt; &lt;bean id=&quot;pooledDataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.jdbcUrl&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.user&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--================== 配置和MyBatis的整合=============== --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 指定mybatis全局配置文件的位置 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;&gt;&lt;/property&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;pooledDataSource&quot;&gt;&lt;/property&gt; &lt;!-- 指定mybatis，mapper文件的位置 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置扫描器，将mybatis接口的实现加入到ioc容器中 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!--扫描所有dao接口的实现，加入到ioc容器中 --&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.ssmcrud.dao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置一个可以执行批量的sqlSession --&gt; &lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;constructor-arg name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;executorType&quot; value=&quot;BATCH&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!--============================================= --&gt; &lt;!-- ===============事务控制的配置 ================--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!--控制住数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;pooledDataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--开启基于注解的事务，使用xml配置形式的事务（必要主要的都是使用配置式） --&gt; &lt;aop:config&gt; &lt;!-- 切入点表达式 --&gt; &lt;aop:pointcut expression=&quot;execution(* com.ssmcrud.service..*(..))&quot; id=&quot;txPoint&quot;/&gt; &lt;!-- 配置事务增强 --&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPoint&quot;/&gt; &lt;/aop:config&gt; &lt;!--配置事务增强，事务如何切入 --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!-- 所有方法都是事务方法 --&gt; &lt;tx:method name=&quot;*&quot;/&gt; &lt;!--以get开始的所有方法 --&gt; &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- Spring配置文件的核心点（数据源、与mybatis的整合，事务控制） --&gt;&lt;/beans&gt; MyBatis逆向工程 配置mybatis-config.xml配置文件，使用mybatis的逆向工程生成对应的bean以及mapper MyBatis Generator官方文档：&lt;http://mybatis.org/generator/ &gt; 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.ssmcrud.bean&quot;/&gt; &lt;/typeAliases&gt; &lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;!--分页参数合理化 --&gt; &lt;property name=&quot;reasonable&quot; value=&quot;true&quot;/&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/configuration&gt; 在项目模块下创建mgb.xml配置文件，即与pom.xml同级 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt; &lt;/commentGenerator&gt; &lt;!-- 配置数据库连接 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/ssm_crud&quot; userId=&quot;root&quot; password=&quot;root&quot;&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt; &lt;/javaTypeResolver&gt; &lt;!-- 指定javaBean生成的位置 --&gt; &lt;javaModelGenerator targetPackage=&quot;com.ssmcrud.bean&quot; targetProject=&quot;.\\src\\main\\java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!--指定sql映射文件生成的位置 --&gt; &lt;sqlMapGenerator targetPackage=&quot;mapper&quot; targetProject=&quot;.\\src\\main\\resources&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 指定dao接口生成的位置，mapper接口 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.ssmcrud.dao&quot; targetProject=&quot;.\\src\\main\\java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!-- table指定每个表的生成策略 --&gt; &lt;table tableName=&quot;tbl_emp&quot; domainObjectName=&quot;Employee&quot;&gt;&lt;/table&gt; &lt;table tableName=&quot;tbl_dept&quot; domainObjectName=&quot;Department&quot;&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 在test测试包下创建MBGTest测试类 1234567891011121314151617181920212223242526package com.lzy.crud;import org.junit.Test;import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.internal.DefaultShellCallback;import java.io.File;import java.util.ArrayList;import java.util.List;public class MBGTest &#123; @Test public void test() throws Exception &#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File(&quot;mbg.xml&quot;); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); &#125;&#125; 生成结果如下 修改Mapper文件 自动生成的查询不包含联表查询，比如查询员工的同时显示部门号 首先在Employee实体类Bean中添加部门Department属性，并添加Get和Set方法 123456789//一个员工对应一个部门//希望查询员工的同时部门信息也查询private Department department;public Department getDepartment() &#123; return department;&#125;public void setDepartment(Department department) &#123; this.department = department;&#125; 在EmployeeMapper员工Dao接口中新增两个方法 1234//查询员工信息并带上部门信息List&lt;Employee&gt; selectByExampleWithDept(EmployeeExample example);//查询员工信息并带上部门信息Employee selectByPrimaryKeyWithDept(Integer empId); 然后修改EmployeeMapper.xml配置文件，新增两个联表查询语句 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!--自定义新的映射，并添加部门自动--&gt;&lt;resultMap id=&quot;WithDeptResultMap&quot; type=&quot;com.ssmcrud.bean.Employee&quot;&gt; &lt;id column=&quot;emp_id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;empId&quot; /&gt; &lt;result column=&quot;emp_name&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;empName&quot; /&gt; &lt;result column=&quot;gender&quot; jdbcType=&quot;CHAR&quot; property=&quot;gender&quot; /&gt; &lt;result column=&quot;email&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;email&quot; /&gt; &lt;result column=&quot;d_id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;dId&quot; /&gt; &lt;!--指定联合查询出的部门字段的封装--&gt; &lt;association property=&quot;department&quot; javaType=&quot;com.ssmcrud.bean.Department&quot;&gt; &lt;id column=&quot;dept_id&quot; property=&quot;deptId&quot;/&gt; &lt;result column=&quot;dept_name&quot; property=&quot;deptName&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;!--自定义新的SQL重用语句--&gt;&lt;!--包含员工信息和部门信息--&gt;&lt;sql id=&quot;WithDept_Column_List&quot;&gt; e.emp_id, e.emp_name, e.gender, e.email, d.d_id , d.dept_id , d.dept_name&lt;/sql&gt;&lt;!--查询员工同时带部门信息--&gt;&lt;select id=&quot;selectByExampleWithDept&quot; resultMap=&quot;WithDeptResultMap&quot;&gt; select &lt;if test=&quot;distinct&quot;&gt; distinct &lt;/if&gt; &lt;include refid=&quot;WithDept_Column_List&quot; /&gt; FROM tbl_emp e left join tbl_dept d on e.`d_id`=d.`dept_id` &lt;if test=&quot;_parameter != null&quot;&gt; &lt;include refid=&quot;Example_Where_Clause&quot; /&gt; &lt;/if&gt; &lt;if test=&quot;orderByClause != null&quot;&gt; order by $&#123;orderByClause&#125; &lt;/if&gt;&lt;/select&gt;&lt;!--查询单个员工同时带部门信息--&gt;&lt;select id=&quot;selectByPrimaryKeyWithDept&quot; parameterType=&quot;java.lang.Integer&quot; resultMap=&quot;WithDeptResultMap&quot;&gt; select &lt;include refid=&quot;WithDept_Column_List&quot; /&gt; FROM tbl_emp e left join tbl_dept d on e.`d_id`=d.`dept_id` where emp_id = #&#123;empId,jdbcType=INTEGER&#125;&lt;/select&gt; Spring测试 环境搭建完后往表里面添加数据并测试Spring环境是否搭建成功 Spring单元测试 使用Spring的单元测试，需要导入相关依赖，注意JUnit版本要在4.12及以上 1234567&lt;!--Spring-test --&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-test --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.3.7.RELEASE&lt;/version&gt;&lt;/dependency&gt; 原生测试方法 1234//1,创建springIOC容器ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);//2,从容器中获取mapperDepartmentMapper ben = ioc.getBean(DepartmentMapper.class); 使用Spring单元测试方法 @ContextConfiguration注解参数为配置文件路径 使用@RunWith配置使用的单元测试 直接@Autowired要使用的组件即可 由于mybatis逆向工程生成的实体类可能没有构造方法，需要先手动加上无参和有参构造方法才能使用 先在applicationContext.xml中配置个可以执行批量的sqlSession 12345&lt;!-- 配置一个可以执行批量的sqlSession --&gt; &lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;constructor-arg name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;executorType&quot; value=&quot;BATCH&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 123456789101112131415161718192021222324252627282930313233343536373839@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations=&#123;&quot;classpath:applicationContext.xml&quot;&#125;)public class MapperTest &#123; @Autowired DepartmentMapper departmentMapper; @Autowired EmployeeMapper employeeMapper; @Autowired SqlSession sqlSession; /*测试departmentmapper*/ @Test public void testCRUD()&#123; //测试是否拿到了IOC容器里的Bean System.out.println(departmentMapper); //1,插入几个部门 departmentMapper.insertSelective(new Department(null,&quot;开发部&quot;)); departmentMapper.insertSelective(new Department(null,&quot;测试部&quot;)); //2,生成员工数据，测试员工插入 employeeMapper.insertSelective(new Employee(null,&quot;jerry&quot;,&quot;M&quot;,&quot;jerry@pl.com&quot;,1)); //3，批量插入多个员工，使用可以执行批量操作的sqlsession EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class); for(int i=0;i&lt;200;i++)&#123; //对较长的UUID进行字符串截取 String uid = UUID.randomUUID().toString().substring(0,5)+i; mapper.insertSelective(new Employee(null,uid,&quot;M&quot;,uid+&quot;@pl.com&quot;,1)); &#125; System.out.println(&quot;批量添加员工成功&quot;); &#125;&#125; 生成数据为 UUID UUID（Universally Unique Identifier）：通用唯一识别码，是一种软件建构的标准\\ UUID 目的是让分布式系统中的所有元素，都能有唯一的辨识信息，而不需要通过中央控制端来做辨识信息的指定。 UUID是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的 UUID由以下几部分组合： 当前日期和时间，UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同。 时钟序列 全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得 UUID的唯一缺陷在于生成的结果串会比较长 标准的UUID格式为：xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx (8-4-4-4-12) 123456789import java.util.UUID;public class UUIDTest &#123; public static void main(String[] args) &#123; String uId = UUID.randomUUID().toString(); System.out.println(uId); //生成xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx形式字符串 System.out.println(uId.replace(&quot;-&quot;, &quot;&quot;)); //去掉-符号 &#125;&#125;","path":"page/ssmcrud01.html","date":"05-08","excerpt":"","tags":[{"name":"SSM","slug":"SSM","permalink":"http://xiaoliblog.cn/tags/SSM/"}]},{"title":"ECMAScript 6🌞面向对象编程","text":"面向对象 面向对象的思维特点 抽取（抽象）对象共用的属性和行为组织（封装）成一个类（模板） 对类进行实例化，获取类的对象 面向对象编程我们考虑的是有哪些对象，按照面向对象的思维特点不断的创建对象使用对象指挥对象做事情 类和对象 在JavaScript中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等 在ES6中新增加了类的概念，可以使用class关键字声明一个类，之后以这个类来实例化对象 类抽象了对象的公共部分，它泛指某一大类 对象特指某一个，通过类实例化一个具体的对象 1234567891011121314151617181920 //创建类class People &#123; //constructor构造函数会返回一个实例对象 constructor(name,age)&#123; //属性 this.name = name; this.age = age; &#125; //注意：方法与方法之不是逗号,这是类，不是对象！ sing(song)&#123; //方法 console.log(this.name + song); &#125;&#125;//创建实例对象，会自动调用constructor构造函数var lisi = new People(&#x27;李四&#x27;,21);var wangwu = new People(&quot;王五&quot;,22);console.log(lisi);console.log(wangwu);lisi.sing(&quot;-告白气球&quot;);wangwu.sing(&quot;-青花瓷&quot;) 继承 父类中的this指向的是父类构造函数创建的实例对象，子类若想在调用的父类的方法中使用自身的变量，则需要通过super调用父类构造函数将其值传入父类中 当在访问this或在子构造函数return之前， 必须在子构造函数中先调用super构造函数 在子类访问this或在子类的构造函数返回实例对象前，必须调用super父类构造函数 123456789101112131415161718class Father &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; sum() &#123; console.log(this.x + this.y); &#125;&#125;//extends关键字继承，用super调用父类构造函数class Son extends Father &#123; constructor(x, y) &#123; // 通过super调用父类的构造函数 super(x, y); &#125;&#125;var son = new Son(1, 2);son.sum(); //3 super关键字用于访问和调用对象父类上的函数。可以调用父类的构造函数，也可以调用父类的普通函数 1234567891011121314151617181920class Father &#123; constructor() &#123; &#125; say() &#123; return &#x27;this is father&#x27; &#125;&#125;class Son extends Father &#123; constructor() &#123; super() //调用父类构造函数 &#125; say() &#123; console.log(super.say() + &#x27; this is son&#x27;); //结果：this is father this is son &#125;&#125;var son = new Son()son.say()// 若父类和子类含有相同的函数，则会应用就近原则，优先调用子类的函数 在onsole码中打印某函数的结果时，应该采用eturn方式返回数据，而不应该在原函数中打印，这是错误的编程方式 Tab实例 12345678910111213141516171819202122232425&lt;main&gt; &lt;h4&gt; Js 面向对象 动态添加标签页 &lt;h4&gt; &lt;div class=&quot;tabsbox&quot; id=&quot;tab&quot;&gt; &lt;!-- tab 标签 --&gt; &lt;nav class=&quot;fisrstnav&quot;&gt; &lt;ul&gt; &lt;li class=&quot;liactive&quot;&gt;&lt;span&gt;测试1&lt;/span&gt;&lt;span class=&quot;iconfont icon-guanbi&quot;&gt;&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;测试2&lt;/span&gt;&lt;span class=&quot;iconfont icon-guanbi&quot;&gt;&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;测试3&lt;/span&gt;&lt;span class=&quot;iconfont icon-guanbi&quot;&gt;&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;tabadd&quot;&gt; &lt;span&gt;+&lt;/span&gt; &lt;/div&gt; &lt;/nav&gt; &lt;!-- tab 内容 --&gt; &lt;div class=&quot;tabscon&quot;&gt; &lt;section class=&quot;conactive&quot;&gt;测试1&lt;/section&gt; &lt;section&gt;测试2&lt;/section&gt; &lt;section&gt;测试3&lt;/section&gt; &lt;/div&gt; &lt;/div&gt;&lt;/main&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146// 要点1：点击标签栏可以切换相应样式// 要点2：双击标签栏显示输入框，可修改其中的数据// 要点3：点击添加按钮可添加标签栏// 要点4：点击X可以删除标签栏var that;class Tab &#123; constructor(id) &#123; that = this; this.main = document.querySelector(id); // 获取添加按钮的元素 this.add = this.main.querySelector(&quot;.tabadd&quot;); // 获取li的父元素 this.ul = this.main.querySelector(&quot;.fisrstnav ul:first-child&quot;); // 获取section的父元素 this.fsection = this.main.querySelector(&quot;.tabscon&quot;); this.init(); &#125;; // 初始化操作，让相关的元素绑定事件 init() &#123; this.updateNode(); // 为+绑定添加事件 this.add.onclick = this.addTab; // 为li绑定切换事件 for (var i = 0; i &lt; this.lis.length; i++) &#123; this.lis[i].index = i; this.lis[i].onclick = this.toggleTab; this.guanbis[i].index = i; this.guanbis[i].onclick = this.deleteTab; // 绑定双击事件 this.spans[i].ondblclick = this.editTab; this.sections[i].ondblclick = this.editTab; &#125; &#125;; // 重新获取lis和sections updateNode() &#123; this.lis = this.main.querySelectorAll(&quot;li&quot;); this.sections = this.main.querySelectorAll(&quot;section&quot;); this.guanbis = this.main.querySelectorAll(&quot;.icon-guanbi&quot;); this.spans = this.main.querySelectorAll(&quot;.fisrstnav li span:first-child&quot;); &#125;; // 切换功能 toggleTab() &#123; //clearClass函数是类的公共函数，所有只能通过that调用 that.clearClass(); // 该函数的调用者为li,所以函数内部的this指向的都是li元素，所有可以通过this.index获取到值 console.log(&quot;tab&quot; + this.index); this.className = &quot;liactive&quot;; that.sections[this.index].className = &quot;conactive&quot;; &#125;; //清除所有样式 clearClass() &#123; for (var i = 0; i &lt; this.lis.length; i++) &#123; this.lis[i].className = &quot;&quot;; this.sections[i].className = &quot;&quot;; &#125; &#125;; // 添加功能 addTab() &#123; that.clearClass(); // 添加tab和section var random = Math.random(); var newTab = &#x27;&lt;li class=&quot;liactive&quot;&gt;&lt;span&gt;测试1&lt;/span&gt;&lt;span class=&quot;iconfont icon-guanbi&quot;&gt;&lt;/span&gt;&lt;/li&gt;&#x27;; var newSection = `&lt;section class=&quot;conactive&quot;&gt;测试$&#123;random&#125;&lt;/section&gt;`; // 在ul内部的最后一个元素的后面添加标签 that.ul.insertAdjacentHTML(&quot;beforeend&quot;, newTab); that.fsection.insertAdjacentHTML(&quot;beforeend&quot;, newSection); // 重新获取lis和sections元素，并绑定事件 that.init(); &#125;; // 删除功能 deleteTab(e) &#123; // ❤由于父元素绑定了点击切换事件，所有应该阻止点击时冒泡 e.stopPropagation(); console.log(&quot;delete&quot; + this.index); var index = this.index; // ❤删除对应的li和section和guanbi that.lis[index].remove(); that.sections[index].remove(); that.guanbis[index].remove(); // 若删除的是当前元素，则conactive样式已经不存在，if判断为空，然后继续后面的操作，即自动切换至上一个元素 // 若删除的不是当前元素，即conactive样式还是存在的，if判断为真，此时不会切换至上一个元素 if (document.querySelector(&quot;.conactive&quot;)) &#123; that.init(); return; &#125; // ❤若删除的是第一个元素，则会切换至第二个元素，且只有第二个元素存在时，才进行此操作 // ❤若删除的不是第一个元素，则会选择上一个元素 index === 0 ? that.lis[1] &amp;&amp; that.lis[1].click() : that.lis[--index].click(); // ❤删除后重新初始化 that.init(); &#125;; // 编辑功能 editTab() &#123; var _that = this; // 双击时禁止选中文字 window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty(); // 为span的内容换成表单 var str = this.innerHTML; this.innerHTML = `&lt;input type=&#x27;text&#x27; value=$&#123;str&#125; /&gt;`; // 获取input的元素 var input = this.children[0]; // 选中input中的文字,增强用户体验 input.select(); // 离开输出框 input.onblur = function() &#123; // 方式一： // _that.innerHTML = input.value; // 方式二： this.parentNode.innerHTML = input.value; &#125;; // ❤按回车键实现输入框失去焦点同样的效果 input.onkeyup = function(e) &#123; if (e.keyCode == 13) &#123; // 手动调用输入框失去焦点事件 this.blur(); &#125; &#125;; &#125;&#125;var tab = new Tab(&quot;#tab&quot;);// dom相关：// 获取单个dom元素：document.querySelector(&#x27;.fisrstnav ul:first-child&#x27;)// 获取所有满足条件的dom元素：.querySelectorAll(&quot;li&quot;);// 绑定单击事件：.onclick=function()&#123;&#125;// 绑定双击事件： .ondblclick// 在ul的最后一个元素的后面添加标签：ul.insertAdjacentHTML(&quot;beforeend&quot;, newTab); 其他取值：beforstart,afterstart,afterend// 阻止冒泡：e.stopPropagation()// 删除自身元素: .remove()// 双击禁止选中文字：window.getSelection ?window.getSelection().removeAllRanges() :document.selection.empty();// 选中输入框的文字：input.select()// 绑定失焦事件：input.onblur=function()&#123;&#125;// 添加回车键事件：input.onkeyup=function(e)&#123;if(e.keyCode===13)&#123;.......&#125;&#125; 原型对象创建对象 在ES6之前，对象不是基于类创建的，而是用一种称为构建函数的特殊函数来定义对象 创建对象可以通过以下三种方式 对象字面量 new Object() 自定义构造函数 构造函数中的属性和方法称为成员，成员可以添加 实例成员就是构造函数内部通过this添加的成员，实例成员只能通过实例对象访问 静态成员是指在构造函数本身添加的成员。，静态成员只能通过构造函数访问 123456789101112131415161718192021222324// 方式一：通过new Object()创建对象var obj = new Object();// 方式二：通过对象字面量创建对象var obj2 = &#123;&#125;;// 方式三：通过构造函数创建对象// 构造函数的首字母要大写function Star(name, age) &#123; // 实例成员是指通过this添加的成员 this.name = name; this.age = age; this.sing = function() &#123; console.log(this.name + &#x27;sing a song&#x27;); &#125;&#125;var adele = new Star(&#x27;阿黛尔&#x27;, 20)adele.sing(); //实例成员只能通过实例对象访问// 静态成员是指在构造函数本身添加的成员Star.sex = &#x27;女&#x27;console.dir(Star);console.log(Star.sex); //静态成员只能通过构造函数访问console.log(adele.sex); 原型对象 构造函数存在浪费内存的问题，比如下图所示，若函数定义在构造函数内部，则每一个创建出来的对象都会为其单独开辟一个内存地址空间。这样会存在浪费地址空间的问题 如果希望所有的对象使用同一个函数，这样就比较节省内存，这就引出了原型对象 构造函数通过原型分配的函数是所有对象所共享的。JavaScript规定，每一个构造函数都有一个prototype属性，指向另一个对象。注意这个prototype就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有 我们可以把那些不变的方法，直接定义在prototype对象上，这样所有对象的实例就可以共享这些方法 一般情况下，公共属性定义在构造函数中，而公共方法定义在原型对象上 1234567891011121314151617181920212223function Star(name, age) &#123; this.name = name; this.age = age; //1.若函数定义在构造函数内部，则每一个创建出来的对象都会为其单独开辟一个内存地址空间。这样会存在浪费地址空间的问题 // this.sing = function() &#123; // console.log(this.name + &#x27;sing a song&#x27;); // &#125;&#125;// 2.每一个构造函数都有一个原型对象，在原型对象上定义方法可以实现所有对象共享该方法，即共享同一块地址空间。Star.prototype.sing = function () &#123; console.log(this.name + &quot;sing a song&quot;);&#125;;Star.prototype.gender = &quot;female&quot;;var adele = new Star(&quot;阿黛尔&quot;);var wf = new Star(&quot;王菲&quot;);adele.sing();wf.sing();console.log(adele.sing === wf.sing); //true// console.dir(Star);console.log(adele.name);console.log(adele.gender);// 3.❤一般情况下，公共属性定义在构造函数中，而公共方法定义在原型对象上 对象原型 对象都会有一个属性__proto__指向构造函数的prototype原型对象，之所以我们对象可以使用构造函数prototype原型对象的属性和方法，就是因为对象有__proto__原型的存在 1234var obj=&#123; x:1, y:2&#125; 通过实例对象调用方法时的查找规则： 先去对象本身查看是否存在该函数 如果不存在则去__proto__属性上查找，即指向的构造函数的原型对象prototype身上 __proto__对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可用使用这个属性，它只是内部指向原型对象prototype 对象原型与原型对象 原型对象是指构造函数的原型对象Star.prototype 对象原型是指 创建出来的每一个对象身上，都有一个__proto__属性，该属性被称为对象原型 __proto__对象原型和原型对象prototype是等价的 12345678910111213141516function Star(name, age) &#123; this.name = name; this.age = age; &#125; Star.prototype.sing = function () &#123; console.log(this.name + &quot;sing a song&quot;); &#125;; var ldh = new Star(&#x27;刘德华&#x27;,21) var zxy = new Star(&#x27;张学友&#x27;,22) ldh.sing() console.log(ldh) //对象身上系统自动添加一个__proto__指向我们构造函数的原型对象 //__proto__对象原型和原型对象prototype是等价的 console.log(ldh.__proto__ === Star.prototype) //true //方法查找规则： //1.首先其ldh对象身上查找是否有sing方法 //2. 如果没有，由于__proto__的存在，就去指向的构造函数原型对象prototype身上查找 构造函数 对象原型__proto__和构造函数prototype原型对象里面都有一个constructor属性，constructor称为构造函数，因为它指回构造函数本身 constructor主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数 若为构造函数的原型对象赋值为一个新的对象，则会覆盖掉原来的constructor属性 如果修改了原来的原型对象，给原型对象赋值的是一个对象，则必须手动为原型对象添加constructor属性 1234567891011121314151617181920function Star(name, age) &#123; this.name = name; this.age = age;&#125;Star.prototype = &#123; //如果不手动指向则会覆盖掉原来的constructor属性 constructor: Star, sing: function () &#123; //方法1 console.log(this.name + &quot;sing a song&quot;); &#125;, movie : function () &#123; //方法1 console.log(this.name + &quot;play a movie&quot;); &#125;&#125;;var ldh = new Star(&#x27;刘德华&#x27;, 21)var zxy = new Star(&#x27;张学友&#x27;, 22)console.log(Star.prototype.constructor);console.log(ldh.__proto__.constructor);&#125; 三角关系 构造函数、原型对象、实例之间的三角关系 构造函数通过prototype属性指向原型对象 原型对象上的constructor属性又指回了构造函数 实例对象通过__proto__属性指向了原型对象，还可以通过__prototype.constructor指向构造函数 原型链 通过原型链的延续我们可以实现Js中的继承，原型链的顶端是Object.prototype.__proto__，而Object.prototype是一切对象的原型，所以这个对象上所有的属性都能被我们使用，它不能有任何对象为原型，所以递归访问_proto_的终点Object.prototype.__proto__等于null 12345678910function Star(name, age) &#123; this.name = name; this.age = age;&#125;var ldh = new Star(&#x27;刘德华&#x27;, 21);//1. 只要是对象就有__proto__原型,指向原型对象console.log(Star.prototype)//2. 我们Star原型对象里面的__proto__原型指向的是 Object.prototypeconsole.log(Star.prototype.__proto__ === Object.prototype); //trueconsole.log(Object.prototype.__proto__); //null 通过原型链可以明确成员查找规则 当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性 如果没有就查找它的原型（也就是__proto__指向的prototype原型对象) 如果还没有就查找原型对象的原型( Object的原型对象) 依此类推一直找到Object为止 (null ) 123456789101112131415function Star(name, age) &#123; this.name = name; this.age = age;&#125;var ldh = new Star(&#x27;刘德华&#x27;, 21);//要想输出sex为男//第一种，对象本身就有ldh.sex=&#x27;男&#x27;;//第二种，往上找到对象的原型Star.prototype.sex=&#x27;男&#x27;//第三种，再往上找到Object的原型Object.prototype.sex=&#x27;男&#x27;console.log(ldh.sex)//如果出现冲突，根据就近原则，即选取对象本身具有的 扩展内置对象 可以通过原型对象对原来的内置对象进行扩展自定义的方法。比如给数组增加自定义求偶数和的功能 123456789101112131415console.log(Array.prototype);// 在内置对象构造函数的原型对象上扩展自己想要的方法//比如添加数组求和方法Array.prototype.sum = function() &#123; var sum = 0; for (var i = 0; i &lt; this.length; i++) &#123; sum += this[i] &#125; return sum;&#125;var arr = [1, 2, 3, 4, 5]var arr2 = new Array(1, 2, 3, 4, 5, 6)console.log(arr.sum()); //15console.log(arr2.sum()); //21console.log(Array.prototype); 注意：数组和字符串内置对象不能给原型对象覆盖操作Array.prototype= &#123;&#125; , 只能是Array.prototype.xx = function()&#123;&#125;的方式 123456789//以下这种方法会覆盖原来具有的方法，是不可取的，会报错Array.prototype = &#123; sum: function () &#123; for (var i = 0; i &lt; this.length; i++) &#123; sum += this[i] &#125; return sum; &#125;&#125; 继承 ES6之前并没有给我们提供extends继承。我们可以通过构造函数+原型对象模拟实现继承,被称为组合继承 call()方法 call()方法可以调用函数并且修改函数运行时的this指向 123fn.call(thisArg,arg1,arg2...)//thisArg: 当前调用函数this的指向对象//arg1,arg2:传递的其他参数 123456789101112131415//call()方法function fn(x,y)&#123; console.log(&#x27;我想喝咖啡&#x27;) console.log(this) //默认指向Window console.log(x+y)&#125;var obj = &#123; name: &#x27;andy&#x27;&#125;//1. call()可以调用函数fn.call();//2. 改变函数的this指向，使其指向objfn.call(obj);//3. 改变this指向并且传入参数fn.call(obj,1,2); 利用父构造函数继承属性123456789101112131415 //借用父构造函数继承属性//1.父构造函数function Father(name,age)&#123; //this指向父构造函数的对象实例 this.name = name; this.age = age;&#125;//2. 子构造函数function Son(name,age)&#123; //this指向子构造函数对象实例 //把父构造函数的this修改为子构造的this，子构造函数就可以使用name和age属性了 Father.call(this,name,age)&#125;var son = new Son(&quot;刘德华&quot;,21)console.log(son) 利用原型对象继承方法1234567891011121314151617181920212223242526272829 //借用父构造函数继承属性//1.父构造函数function Father(name,age)&#123; //this指向父构造函数的对象实例 this.name = name; this.age = age;&#125;Father.prototype.money = function ()&#123; console.log(&quot;挣钱&quot;)&#125;//2. 子构造函数function Son(name,age)&#123; //this指向子构造函数对象实例 //把父构造函数的this修改为子构造的this，子构造函数就可以使用name和age属性了 Father.call(this,name,age)&#125;//Son.prototype = Father.prototype; 这样直接赋值会有问题，如果修改了子原型对象，父原型对象也会被修改//new Father()实例化对象Son.prototype = new Father();//如果利用对象的形式修改了原型对象，别忘了利用constructor指回原来的原型对象Son.prototype.constructor = Son;//这个是子构造函数专门的方法Son.prototype.exam = function ()&#123; console.log(&#x27;孩子要考试&#x27;)&#125;var son = new Son(&quot;刘德华&quot;,21)console.log(son)console.log(Father.prototype)console.log(Son.prototype.constructor)","path":"page/ECMAScript03.html","date":"05-07","excerpt":"","tags":[{"name":"ECMAScript 6","slug":"ECMAScript-6","permalink":"http://xiaoliblog.cn/tags/ECMAScript-6/"}]},{"title":"jQuery实现QQ音乐播放器🥳页面设计","text":"布局结构 下载源码 在线Demo 12345678910111213141516&lt;div class=&quot;header&quot;&gt; &lt;h1 class=&quot;logo&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/h1&gt; &lt;ul class=&quot;register&quot;&gt; &lt;li&gt;登录&lt;/li&gt; &lt;li&gt;设置&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;content_in&quot;&gt; &lt;div class=&quot;content_left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;content_right&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;footer&quot;&gt; &lt;div class=&quot;footer_in&quot;&gt;&lt;/div&gt;&lt;/div&gt; 顶部布局 1234567&lt;div class=&quot;header&quot;&gt; &lt;h1 class=&quot;logo&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;&lt;/h1&gt; &lt;ul class=&quot;register&quot;&gt; &lt;li&gt;登录&lt;/li&gt; &lt;li&gt;设置&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243*&#123; margin: 0; padding: 0;&#125;html,body&#123; width: 100%; height: 100%; font-size: 14px;&#125;.header&#123; width: 100%; height: 45px;&#125;.header .logo&#123; float: left; margin-left: 20px; opacity: 0.5; /*透明度降低*/&#125;.header .logo:hover&#123; opacity: 1; /*鼠标经过透明度升高，有明亮效果*/&#125;.header .logo a&#123; display: inline-block; width: 78px; height: 21px; /*logo*/ background: url(&quot;../images/player_logo.png&quot;) no-repeat 0 0;&#125;.header .register&#123; float: right; line-height: 45px;&#125;.header .register li&#123; list-style: none; float: left; margin-right: 20px; color: #fff; opacity: 0.5;&#125;.header .register li:hover&#123; opacity: 1;&#125; 内容结构 123456&lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;content_in&quot;&gt; &lt;div class=&quot;content_left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;content_right&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 工具条布局 123456789&lt;div class=&quot;content_left&quot;&gt; &lt;div class=&quot;content_toolbar&quot;&gt; &lt;span&gt;&lt;i&gt;&lt;/i&gt;收藏&lt;/span&gt; &lt;span&gt;&lt;i&gt;&lt;/i&gt;添加到&lt;/span&gt; &lt;span&gt;&lt;i&gt;&lt;/i&gt;下载&lt;/span&gt; &lt;span&gt;&lt;i&gt;&lt;/i&gt;删除&lt;/span&gt; &lt;span&gt;&lt;i&gt;&lt;/i&gt;清空列表&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859.content&#123; width: 100%; height: 460px;&#125;.content .content_in&#123; width: 1200px; height: 100%; margin: 0 auto;&#125;.content_in .content_left&#123; float: left; width: 800px; height: 100%;&#125;.content_left .content_toolbar&#123; width: 100%; height: 40px;&#125;.content_toolbar span&#123; display: inline-block; width: 122px; height: 100%; line-height: 40px; text-align: center; border: 1px solid #fff; box-sizing: border-box; border-radius: 5px; color: #fff; opacity: 0.5;&#125;.content_toolbar span:hover&#123; opacity: 1; /*明亮特效*/&#125;.content_toolbar span i&#123; display: inline-block; width: 18px; height: 18px; /*精灵图*/ background: url(&quot;../images/icon_sprite.png&quot;) no-repeat 0 0; margin-right: 10px; vertical-align: -5px;&#125;/*单独设置每个图片的位置(用PS测试)*/.content_toolbar span:nth-child(1) i&#123; background-position: -60px -20px;&#125;.content_toolbar span:nth-child(2) i&#123; background-position: -20px -20px;&#125;.content_toolbar span:nth-child(3) i&#123; background-position: -40px -240px;&#125;.content_toolbar span:nth-child(4) i&#123; background-position: -100px -20px;&#125;.content_toolbar span:nth-child(5) i&#123; background-position: -40px -300px;&#125;/***********顶部END************/ 播放列表布局 歌曲列表可以视作逐行的列表，第一行为标题，下边为歌曲 123456789101112131415161718192021&lt;div class=&quot;content_left&quot;&gt; &lt;div class=&quot;content_list&quot;&gt; &lt;ul&gt; &lt;li class=&quot;list_title&quot;&gt; &lt;div class=&quot;list_check&quot;&gt;&lt;i&gt;&lt;/i&gt;&lt;/div&gt; &lt;div class=&quot;list_number&quot;&gt;&lt;/div&gt; &lt;div class=&quot;list_name&quot;&gt;歌曲&lt;/div&gt; &lt;div class=&quot;list_singer&quot;&gt;歌手&lt;/div&gt; &lt;div class=&quot;list_time&quot;&gt;时长&lt;/div&gt; &lt;/li&gt; &lt;li class=&quot;list_music&quot;&gt; &lt;div class=&quot;list_check&quot;&gt;&lt;i&gt;&lt;/i&gt;&lt;/div&gt; &lt;div class=&quot;list_number&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;list_name&quot;&gt;告白气球&lt;/div&gt; &lt;div class=&quot;list_singer&quot;&gt;周杰伦&lt;/div&gt; &lt;div class=&quot;list_time&quot;&gt;03:35&lt;/div&gt; &lt;/li&gt; &lt;!--其下的歌曲列表通过JS动态获取--&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647.content_left .content_list&#123; width: 100%; height: 420px; overflow: auto;&#125;.content_list li&#123; list-style: none; width: 100%; height: 50px; border-bottom: 1px solid rgba(255,255,255,0.5); box-sizing: border-box; user-select: none; /*禁用用户复制*/&#125;.content_list li div&#123; float: left; color: rgba(255,255,255,0.5); line-height: 50px; /*opacity: 0.5;*/&#125;.content_list .list_check&#123; width: 50px; height: 100%; text-align: center;&#125;/*勾选框*/.content_list .list_check i&#123; display: inline-block; width: 14px; height: 14px; border: 1px solid #fff; opacity: 0.5;&#125;.content_list .list_number&#123; width: 20px; height: 100%;&#125;.content_list .list_name &#123; width: 50%; height: 100%; background: #ccc;&#125;.content_list .list_singer &#123; width: 20%; height: 100%; background: pink;&#125; user-select: none; 可以禁用用户复制功能 完善播放列表 选择框是一个伪选择框，当被点击时，通过添加类名list_checked切换图片即可 鼠标悬停的图标采用精灵图，使用 a 标签加背景图，然后使用 jQuery 监听鼠标的移入移出事件 1234567891011121314151617&lt;li class=&quot;list_music&quot;&gt; &lt;div class=&quot;list_check&quot;&gt;&lt;i&gt;&lt;/i&gt;&lt;/div&gt; &lt;div class=&quot;list_number&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;list_name&quot;&gt;告白气球 &lt;div class=&quot;list_menu&quot;&gt; &lt;a href=&quot;javascript:;&quot; title=&quot;播放&quot;&gt;&lt;/a&gt; &lt;a href=&quot;javascript:;&quot; title=&quot;添加&quot;&gt;&lt;/a&gt; &lt;a href=&quot;javascript:;&quot; title=&quot;下载&quot;&gt;&lt;/a&gt; &lt;a href=&quot;javascript:;&quot; title=&quot;分享&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;list_singer&quot;&gt;周杰伦&lt;/div&gt; &lt;div class=&quot;list_time&quot;&gt; &lt;span&gt;03:35&lt;/span&gt; &lt;a href=&quot;javascript:;&quot; title=&quot;删除&quot;&gt;&lt;/a&gt; &lt;/div&gt;&lt;/li&gt; 123456789101112131415161718192021222324252627282930313233343536.list_name .list_menu &#123; margin-top: 5px; float: right; margin-right: 20px; display: none;&#125;/*用a标签设置图标*/.list_name .list_menu a &#123; display: inline-block; width: 36px; height: 36px; /*精灵图*/ background: url(&quot;../images/icon_list_menu.png&quot;) no-repeat 0 0;&#125;/*精灵图位置*/.list_name .list_menu a:nth-child(1) &#123; background-position: -120px 0;&#125;.list_name .list_menu a:nth-child(2) &#123; background-position: -120px -80px;&#125;.list_name .list_menu a:nth-child(3) &#123; background-position: -120px -120px;&#125;.list_name .list_menu a:nth-child(4) &#123; background-position: -120px -40px;&#125;.content_list .list_time a &#123; display: inline-block; width: 36px; height: 36px; background: url(&quot;../images/icon_list_menu.png&quot;) no-repeat -120px -160px; float: left; margin-top: 5px; display: none;&#125; 1234567891011121314151617181920212223$(function () &#123; // 1. 监听歌曲的移入移出事件 $(&quot;.list_music&quot;).hover( function () &#123; //移入 // 显示子菜单 在使用JQuery动画时最好先调用stop(),以下使用了淡入淡出 $(this).find(&quot;.list_menu&quot;).stop().fadeIn(100); $(this).find(&quot;.list_time a&quot;).stop().fadeIn(100); // 隐藏时长 $(this).find(&quot;.list_time span&quot;).stop().fadeOut(100); &#125;, function () &#123; //移出 // 隐藏子菜单 $(this).find(&quot;.list_menu&quot;).stop().fadeOut(100); $(this).find(&quot;.list_time a&quot;).stop().fadeOut(100); // 显示时长 $(this).find(&quot;.list_time span&quot;).stop().fadeIn(100); &#125; ); // 2. 监听复选框的点击事件 $(&quot;.list_check&quot;).click(function () &#123; $(this).toggleClass(&quot;list_checked&quot;); &#125;);&#125;); 自定义滚动条 首先设置父盒子超出隐藏，防止歌曲过多导致布局出问题 123.centent_left .content_list&#123; overflow:auto;&#125; 自定义滚动条使用了一个 jQuery 插件jQuery custom content scroller，利用这个插件可以轻松设置滚动条样式 下载后本地导入CSS和JS，注意其是依赖jQuery的插件，需要先引入jQuery 12345678&lt;link rel=&quot;stylesheet&quot; href=&quot;jquery.mCustomScrollbar.css&quot; /&gt;&lt;!--注意引入的顺序问题，先引入插件和框架后引入自己的样式--&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot;&gt;&lt;!--先导入jQuery-&gt;框架插件-&gt;自己的JS--&gt;&lt;script src=&quot;js/jquery-1.12.4.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;jquery.mCustomScrollbar.concat.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/index.js&quot;&gt;&lt;/script&gt; 利用JS初始化插件，为需要添加的元素调用 mCustomScrollbar() 方法 1234$(function () &#123;// 0.自定义滚动条,给需要修改样式的父盒子添加 $(&quot;.content_list&quot;).mCustomScrollbar();&#125;) 在HTML中为该元素添加自定义属性 data-mcs-theme=&quot;dark&quot;，样式设置可以在Scrollbar themes查找 1&lt;div class=&quot;content_list&quot; data-mcs-theme=&#x27;minimal-dark&#x27;&gt;&lt;/div&gt; 对滚动条进行微调，比如宽度 123._mCS_1 .mCSB_scrollTools .mCSB_dragger_bar &#123; width: 8px;&#125; 音乐歌曲信息 12345678910111213141516171819202122&lt;div class=&quot;content_right&quot;&gt; &lt;div class=&quot;song_info&quot;&gt; &lt;!--a标签为背景--&gt; &lt;a href=&quot;javascript;;&quot; class=&quot;song_info_pic&quot;&gt; &lt;!--img为前景即歌曲图片--&gt; &lt;img src=&quot;images/lnj.jpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;div class=&quot;song_info_name&quot;&gt;歌曲名称: &lt;a href=&quot;javascript:;&quot;&gt;告白气球&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;song_info_singer&quot;&gt;歌手名: &lt;a href=&quot;javascript:;&quot;&gt;周杰伦&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;song_info_ablum&quot;&gt;专辑名: &lt;a href=&quot;javascript:;&quot;&gt;周杰伦的床边故事&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;ul class=&quot;song_lyric&quot;&gt; &lt;li class=&quot;cur&quot;&gt;第一条歌词&lt;/li&gt; &lt;li&gt;第二条歌词&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142.content_right .song_info &#123; text-align: center; color: rgba(255, 255, 255, 0.5); line-height: 30px;&#125;.song_info .song_info_pic &#123; display: inline-block; /*背景图片*/ background: url(&quot;../images/album_cover_player.png&quot;) no-repeat 0 0; width: 201px; height: 180px; text-align: left;&#125;/*歌曲图片宽高*/.song_info_pic img &#123; width: 180px; height: 180px;&#125;.song_info div a &#123; text-decoration: none; color: #fff; opacity: 0.5;&#125;.song_info div a:hover &#123; opacity: 1;&#125;.content_right .song_lyric &#123; background: gray; text-align: center; margin-top: 30px;&#125;/*歌词*/.content_right .song_lyric li &#123; list-style: none; line-height: 30px; color: rgba(255, 255, 255, 0.5); font-weight: bold;&#125;.content_right .song_lyric .cur &#123; color: #31c27c;&#125; 底部结构 基本结构 进度条可大致分为四部分 图标 使用 a 标签加背景图即可 歌曲进度条（因为此区域需包含进度条及歌曲名称、时间等信息。因此使用 div 作为布局） 音量部分（此部分包含图标及一个拖动条，因此也使用 div 作为盒子进行布局） 123456789101112&lt;div class=&quot;footer_in&quot;&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;music_pre&quot;&gt;&lt;/a&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;music_play&quot;&gt;&lt;/a&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;music_next&quot;&gt;&lt;/a&gt; &lt;div class=&quot;music_progress_info&quot;&gt;&lt;/div&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;music_mode&quot;&gt;&lt;/a&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;music_fav&quot;&gt;&lt;/a&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;music_down&quot;&gt;&lt;/a&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;music_comment&quot;&gt;&lt;/a&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;music_only&quot;&gt;&lt;/a&gt; &lt;div class=&quot;music_voice_info&quot;&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970.footer_in a &#123; display: inline-block; text-decoration: none; color: #fff; /*精灵图*/ background: url(&quot;../images/player.png&quot;) no-repeat 0 0; margin-right: 20px;&#125;/*上一首*/.footer_in .music_pre &#123; width: 19px; height: 20px; background-position: 0 -30px;&#125;/*播放*/.footer_in .music_play &#123; width: 21px; height: 29px; background-position: 0 0;&#125;/*下一首*/.footer_in .music_next &#123; width: 19px; height: 20px; background-position: 0 -52px;&#125;/*进度条*/.footer_in .music_progress_info &#123; display: inline-block; width: 670px; height: 40px; background-color: red;&#125;/*循环*/.footer_in .music_mode &#123; width: 26px; height: 25px; background-position: 0px -205px;&#125;/*喜欢*/.footer_in .music_fav &#123; width: 24px; height: 21px; background-position: 0px -96px;&#125;/*下载*/.footer_in .music_down &#123; width: 22px; height: 21px; background-position: 0px -120px;&#125;/*评论*/.footer_in .music_comment &#123; width: 24px; height: 24px; background-position: 0px -400px;&#125;/*纯净*/.footer_in .music_only &#123; width: 74px; height: 27px; background-position: 0px -281px;&#125;/*音量*/.footer_in .music_voice_info &#123; display: inline-block; width: 100px; background: green; height: 40px;&#125; 进度条 歌曲部分进度条分歌曲信息和进度条，两个 span 元素即可 进度条使用一种通用的结构。三层结构分别表示背景、前景、圆。 1234567891011&lt;div class=&quot;music_progress_info&quot;&gt; &lt;div class=&quot;music_progress_top&quot;&gt; &lt;span class=&quot;music_progress_name&quot;&gt;告白气球/周杰伦&lt;/span&gt; &lt;span class=&quot;music_progress_time&quot;&gt;00:00 / 03:35&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;music_progress_bar&quot;&gt; &lt;div class=&quot;music_progress_line&quot;&gt; &lt;div class=&quot;music_progress_dot&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 音量部分与歌曲信息的进度条同理，图标同样使用 a 标签与图片结合 12345678&lt;div class=&quot;music_voice_info&quot;&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;music_voice_icon&quot;&gt;&lt;/a&gt; &lt;div class=&quot;music_voice_bar&quot;&gt; &lt;div class=&quot;music_voice_line&quot;&gt; &lt;div class=&quot;music_voice_dot&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/* 歌曲进度条 */.footer_in .music_progress_info &#123; display: inline-block; width: 670px; height: 40px; background-color: red;&#125;.music_progress_info .music_progress_top &#123; width: 100%; height: 30px; line-height: 30px; background: #000000; color: #fff;&#125;.music_progress_top .music_progress_name &#123; float: left; opacity: 0.5;&#125;.music_progress_top .music_progress_name:hover &#123; opacity: 1;&#125;.music_progress_top .music_progress_time &#123; float: right; opacity: 0.5;&#125;.music_progress_info .music_progress_bar &#123; width: 100%; height: 4px; background: rgba(255, 255, 255, 0.5); margin-top: 5px;&#125;.music_progress_bar .music_progress_line &#123; width: 100%; height: 100%; background: #ffffff;&#125;.music_progress_bar .music_progress_dot &#123; width: 14px; height: 14px; border-radius: 50%; background: #fff; position: relative; top: -5px; left: 100px; cursor: pointer;&#125;/* 音量控制 */.footer_in .music_voice_info &#123; display: inline-block; width: 100px; background: green; height: 40px; position: relative;&#125;.music_voice_info .music_voice_icon &#123; width: 26px; height: 21px; background-position: 0 -144px; position: absolute; left: 0; top: 10px;&#125;.music_voice_info .music_voice_bar &#123; width: 70px; height: 4px; background: rgba(255, 255, 255, 0.5); position: absolute; right: 0; top: 18px;&#125;.music_voice_bar .music_voice_line &#123; width: 50px; height: 100%; background: #ffffff;&#125;.music_voice_bar .music_voice_dot &#123; width: 14px; height: 14px; border-radius: 50%; background: #ffffff; position: absolute; top: -5px; left: 50px;&#125; 底部微调完善12345678910111213141516171819202122232425262728293031323334353637383940.footer &#123; height: 80px;&#125;.footer_in .music_play &#123; vertical-align: -5px;&#125;.footer_in .music_progress_info &#123; top: 10px;&#125;.footer_in .music_voice_info &#123; top: 10px;&#125;/* 播放按钮点击 */.footer_in .music_play2 &#123; background-position: -30px 0;&#125;/* 循环模式样式切换 */.footer_in .music_mode2 &#123; width: 23px; height: 20px; background-position: 0px -260px;&#125;.footer_in .music_mode3 &#123; width: 25px; height: 19px; background-position: 0px -74px;&#125;.footer_in .music_mode4 &#123; width: 26px; height: 25px; background-position: 0px -232px;&#125;/* 喜欢按钮 */.footer_in .music_fav2 &#123; background-position: -30px -96px;&#125;/* 纯净模式 */.footer_in .music_only2 &#123; background-position: 0px -310px;&#125; 高斯模糊背景 通过切换不同音乐会根据音乐图片切换不同的模糊背景 模糊背景通过使用一张音乐图片加一个淡灰色的蒙版即可 12&lt;div class=&quot;mask_bg&quot;&gt;&lt;/div&gt;&lt;div class=&quot;mask&quot;&gt;&lt;/div&gt; 12345678910111213141516171819202122232425/* 背景设置 */.mask_bg &#123; position: absolute; left: 0; top: 0; width: 100%; height: 100%; /*音乐图片*/ background: url(&quot;../images/lnj.jpg&quot;) no-repeat 0 0; /*铺满整个屏幕*/ background-size: cover; z-index: -2; /*模糊效果*/ filter: blur(100px);&#125;/*遮罩*/.mask &#123; position: absolute; left: 0; top: 0; width: 100%; height: 100%; z-index: -1; background: rgba(0, 0, 0, 0.35);&#125; 加载歌曲读取JSON文件 加载歌曲使用了 jQuery 得 Ajax 方法。通过一个json 文件获取歌曲的相关信息 在source文件夹下存放了歌曲MP3、图片、歌词等信息，并创建了一个musiclist.json文件存放路径和其他信息 1234567891011121314151617181920212223242526272829[ &#123; &quot;name&quot;:&quot;告白气球&quot;, &quot;singer&quot;: &quot;周杰伦&quot;, &quot;album&quot;: &quot;周杰伦的床边故事&quot;, &quot;time&quot;: &quot;03:35&quot;, &quot;link_url&quot;:&quot;./source/告白气球.mp3&quot;, &quot;cover&quot;:&quot;./source/告白气球.jpg&quot;, &quot;link_lrc&quot;:&quot;./source/告白气球.txt&quot; &#125;, &#123; &quot;name&quot;:&quot;As long AS Love Me&quot;, &quot;singer&quot;: &quot;Justin Bieber&quot;, &quot;album&quot;: &quot;NOW That&#x27;s What I Call Music! 44&quot;, &quot;time&quot;: &quot;03:49&quot;, &quot;link_url&quot;:&quot;./source/AslongASLoveMe.mp3&quot;, &quot;cover&quot;: &quot;./source/AslongASLoveMe.jpg&quot;, &quot;link_lrc&quot;: &quot;./source/AslongASLoveMe.txt&quot; &#125;, &#123; &quot;name&quot;:&quot;Something Just Like This&quot;, &quot;singer&quot;: &quot;Chainsmokers&quot;, &quot;album&quot;: &quot;Something Just Like This&quot;, &quot;time&quot;: &quot;04:07&quot;, &quot;link_url&quot;:&quot;./source/SomethingJustLikeThis.mp3&quot;, &quot;cover&quot;:&quot;./source/SomethingJustLikeThis.jpg&quot;, &quot;link_lrc&quot;:&quot;./source/SomethingJustLikeThis.txt&quot; &#125;] 12345678910111213141516171819202122232425262728293031323334353637// 3. 加载歌曲列表function getPlayerList() &#123; $.ajax(&#123; url: &quot;./source/musiclist.json&quot;, dataType: &quot;json&quot;, success: function (data) &#123; // 3.1 遍历获取到的数据创建每一条音乐 var $musicList = $(&quot;.content_list ul&quot;); $.each(data, function (index, ele) &#123; //定义一个方法 var $item = createMusicItem(index, ele); //动态生成的歌曲追加到ul后 $musicList.append($item); &#125;); &#125;, error: function (e) &#123; console.log(e); &#125;, &#125;);&#125;//调用函数getPlayerList();// 创建一条音乐的方法，可以把前面静态的HTML删掉，通过以下动态生成function createMusicItem(index, music) &#123; var $item = $( &#x27;&lt;li class=&quot;list_music&quot;&gt;&lt;div class=&quot;list_check &quot;&gt;&lt;i&gt;&lt;/i&gt;&lt;/div&gt;&lt;div class=&quot;list_number&quot;&gt;&#x27; + (index + 1) + &#x27;&lt;/div&gt;&lt;div class=&quot;list_name&quot;&gt;&#x27; + music.name + &#x27;&lt;div class=&quot;list_menu&quot;&gt;&lt;a href=&quot;javascript:;&quot; title=&quot;播放&quot;&gt;&lt;/a&gt;&lt;a href=&quot;javascript:;&quot; title=&quot;添加&quot;&gt;&lt;/a&gt;&lt;a href=&quot;javascript:;&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;&lt;a href=&quot;javascript:;&quot; title=&quot;分享&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;list_singer&quot;&gt;&#x27; + music.singer + &#x27;&lt;/div&gt;&lt;div class=&quot;list_time&quot;&gt;&lt;span&gt;&#x27; + music.time + &#x27;&lt;/span&gt;&lt;a href=&quot;javascript:;&quot; title=&quot;删除&quot;&gt;&lt;/a&gt;&lt;/div&gt;&lt;/li&gt;&#x27; ); return $item;&#125; 完善事件 由于音乐列表改成了 js 动态创建，那么就会导致曾经绑定的事件失效，因此需要修改为事件委托方式 1234567891011121314151617181920// 1. 监听歌曲的移入移出事件$(&quot;.content_list&quot;).delegate(&quot;.list_music&quot;, &quot;mouseenter&quot;, function () &#123; // 显示子菜单 $(this).find(&quot;.list_menu&quot;).stop().fadeIn(100); $(this).find(&quot;.list_time a&quot;).stop().fadeIn(100); // 隐藏时长 $(this).find(&quot;.list_time span&quot;).stop().fadeOut(100);&#125;);$(&quot;.content_list&quot;).delegate(&quot;.list_music&quot;, &quot;mouseleave&quot;, function () &#123; // 隐藏子菜单 $(this).find(&quot;.list_menu&quot;).stop().fadeOut(100); $(this).find(&quot;.list_time a&quot;).stop().fadeOut(100); // 显示时长 $(this).find(&quot;.list_time span&quot;).stop().fadeIn(100);&#125;);// 2. 监听复选框的点击事件$(&quot;.content_list&quot;).delegate(&quot;.list_check&quot;, &quot;click&quot;, function () &#123; $(this).toggleClass(&quot;list_checked&quot;);&#125;); 播放图标切换 当播放一首歌曲时，另一首歌单的播放图标要发生改变 为此按钮添加事件同样需要以事件委托的方式。当点击后会发生两件事： 将其他播放按钮改为暂停状态 将底部播放按钮修改 12345678910111213141516171819// 3. 添加子菜单播放按钮的监听var $musicPlay = $(&quot;.music_play&quot;);$(&quot;.content_list&quot;).delegate(&quot;.list_menu_play&quot;, &quot;click&quot;, function () &#123; // 3.1 切换播放的图标 $(this).toggleClass(&quot;list_menu_play2&quot;); // 3.2 复原其他的播放图标 $(this) .parents(&quot;.list_music&quot;) .siblings() .find(&quot;.list_menu_play&quot;) .removeClass(&quot;list_menu_play2&quot;); // 3.3 同步底部播放按钮 if ($(this).attr(&quot;class&quot;).indexOf(&quot;list_menu_play2&quot;) != -1) &#123; // 当前是播放状态 $musicPlay.addClass(&quot;music_play2&quot;); &#125; else &#123; $musicPlay.removeClass(&quot;music_play2&quot;); &#125;&#125;); 播放状态切换 要想控制单个，必须设置时对单个设置，而不是全部，因此 css 部分需要微调 123456789101112131415161718192021.content_list li div &#123; color: rgba(255, 255, 255, 0.5);&#125;.content_list .list_check i &#123; opacity: 0.5;&#125;.content_list .list_checked i &#123; opacity: 1;&#125;.list_name .list_menu a &#123; opacity: 0.5;&#125;.list_name .list_menu a:hover &#123; opacity: 1;&#125;.content_list .list_time a &#123; opacity: 0.5;&#125;.content_list .list_time a:hover &#123; opacity: 1;&#125; 将 css 修改完成后，接下来就是在 JavaScript 绑定的事件中进行修改了 1234567891011121314// 3.3 同步底部播放按钮if ($(this).attr(&quot;class&quot;).indexOf(&quot;list_menu_play2&quot;) != -1) &#123; // 当前是播放状态 $musicPlay.addClass(&quot;music_play2&quot;); // 让文字高亮 $(this).parents(&quot;.list_music&quot;).find(&quot;div&quot;).css(&quot;color&quot;, &quot;#fff&quot;);&#125; else &#123; $musicPlay.removeClass(&quot;music_play2&quot;); // 让文字不高亮 $(this) .parents(&quot;.list_music&quot;) .find(&quot;div&quot;) .css(&quot;color&quot;, &quot;rgba(255,255,255,0.5)&quot;);&#125; 序号动画 当点击播放一首曲目时，会隐藏序号显示播放动态图片。并做一些排他设置 12345.content_list .list_number2 &#123; color: transparent !important; /*添加播放动态图*/ background: url(&quot;../images/wave.gif&quot;) no-repeat 0 0;&#125; 1234567891011121314151617181920212223242526$(&quot;.content_list&quot;).delegate(&quot;.list_menu_play&quot;, &quot;click&quot;, function () &#123; var $item = $(this).parents(&quot;.list_music&quot;); // 3.1 切换播放的图标 $(this).toggleClass(&quot;list_menu_play2&quot;); // 3.2 复原其他的播放图标 $(this) .parents(&quot;.list_music&quot;) .siblings() .find(&quot;.list_menu_play&quot;) .removeClass(&quot;list_menu_play2&quot;); // 3.3 同步底部播放按钮 if ($(this).attr(&quot;class&quot;).indexOf(&quot;list_menu_play2&quot;) != -1) &#123; // 当前是播放状态 $musicPlay.addClass(&quot;music_play2&quot;); // 让文字高亮 $item.find(&quot;div&quot;).css(&quot;color&quot;, &quot;#fff&quot;); $item.siblings().find(&quot;div&quot;).css(&quot;color&quot;, &quot;rgba(255,255,255,0.5)&quot;); &#125; else &#123; $musicPlay.removeClass(&quot;music_play2&quot;); // 让文字不高亮 $item.find(&quot;div&quot;).css(&quot;color&quot;, &quot;rgba(255,255,255,0.5)&quot;); &#125; // 3.4 切换序号的状态 $item.find(&quot;.list_number&quot;).toggleClass(&quot;list_number2&quot;); $item.siblings().find(&quot;.list_number&quot;).removeClass(&quot;list_number2&quot;);&#125;);","path":"page/project06.html","date":"05-05","excerpt":"","tags":[{"name":"项目案例","slug":"项目案例","permalink":"http://xiaoliblog.cn/tags/%E9%A1%B9%E7%9B%AE%E6%A1%88%E4%BE%8B/"}]},{"title":"jQuery🌞jQuery动画操作","text":"内置动画 jQuery提供了两种增加动画特效的方法 内置的动画方法 提供animate()方法自定义动画 显示隐藏动画 方法 说明 show([speed,[easing],[fn]]) 显示匹配元素 hide([speed,[easing],[fn]]) 隐藏匹配元素 toggle([speed],[easing],[ fn]) 元素显示与隐藏切换 speed ：动画的速度（持续时长），如1000（毫秒），或者预定的3种速度(slow、fast、normal) easing：切换效果，默认为swing，另有linear fn ：动画完成时执行的函数 linear方法提供了一个稳定的动画，以使得动画的每个步骤都是相同的(例如，如果要让一个元素以逐渐变化的方式穿过屏幕，每一步的距离和前一步都是相同的)。 swing要更加动态一些，随着动画的开始变得更加快一些，然后再慢下来。swing是一个常用设置，因此，如果没有指定任何缓动，jQuery会使用swing方法。 1234&lt;button&gt;显示&lt;/button&gt;&lt;button&gt;隐藏&lt;/button&gt;&lt;button&gt;切换&lt;/button&gt;&lt;div&gt;&lt;/div&gt; 12345678910111213141516171819202122$(function () &#123; // 编写jQuery相关代码 $(&quot;button&quot;).eq(0).click(function () &#123; // $(&quot;div&quot;).css(&quot;display&quot;, &quot;block&quot;); // 注意: 这里的时间是毫秒 $(&quot;div&quot;).show(1000, function () &#123; // 作用: 动画执行完毕之后调用 alert(&quot;显示动画执行完毕&quot;); &#125;); &#125;); $(&quot;button&quot;).eq(1).click(function () &#123; // $(&quot;div&quot;).css(&quot;display&quot;, &quot;none&quot;); $(&quot;div&quot;).hide(1000, function () &#123; alert(&quot;隐藏动画执行完毕&quot;); &#125;); &#125;); $(&quot;button&quot;).eq(2).click(function () &#123; $(&quot;div&quot;).toggle(1000, function () &#123; alert(&quot;切换动画执行完毕&quot;); &#125;); &#125;);&#125;); 滑入滑出动画 方法 说明 slideDown([speed],[easing],[ fn]) 使用滑动效果，显示隐藏的被选元素（向下） slideUp([speed,[easing],[ fn]]) 使用滑动效果，显示隐藏的被选元素（向上） slideToggle([speed],[easing],[ fn]) 使用滑动效果，显示隐藏的被选元素（向下) 1234567891011div.panel,p.flip&#123; margin:0px; padding:5px; text-align:center; background:#e5eecc; border:solid 1px #c3c3c3;&#125;div.panel&#123; height:120px; display:none; /*如果此元素不隐藏，则不能滑动--视觉效果滑动的是flip，其实滑动的是。panel*/&#125; 12345&lt;div class=&quot;panel&quot;&gt; &lt;p&gt;W3School - 领先的 Web 技术教程站点&lt;/p&gt; &lt;p&gt;在 W3School，你可以找到你所需要的所有网站建设教程。&lt;/p&gt;&lt;/div&gt;&lt;p class=&quot;flip&quot;&gt;请点击这里&lt;/p&gt; 12345$(function () &#123; $(&quot;.flip&quot;).click(function()&#123; $(&quot;.panel&quot;).slideDown(&quot;slow&quot;); &#125;);&#125;); 淡入淡出动画 方法 说明 fadeIn() 淡入显示匹配元素 fadeOut() 淡出隐藏匹配元素 fadeToggle() 在fadeIn()和fadeOut()两种效果间的切换 12345678&lt;p&gt;演示带有不同参数的 fadeIn() 方法。&lt;/p&gt;&lt;button&gt;点击这里，使三个矩形淡入&lt;/button&gt;&lt;br&gt;&lt;br&gt;&lt;div id=&quot;div1&quot; style=&quot;width:80px;height:80px;display:none;background-color:red;&quot;&gt;&lt;/div&gt;&lt;br&gt;&lt;div id=&quot;div2&quot; style=&quot;width:80px;height:80px;display:none;background-color:green;&quot;&gt;&lt;/div&gt;&lt;br&gt;&lt;div id=&quot;div3&quot; style=&quot;width:80px;height:80px;display:none;background-color:blue;&quot;&gt;&lt;/div&gt; 1234567$(function () &#123; $(&quot;button&quot;).click(function()&#123; $(&quot;#div1&quot;).fadeIn(); $(&quot;#div2&quot;).fadeIn(&quot;slow&quot;); $(&quot;#div3&quot;).fadeIn(3000); &#125;);&#125;); 自定义动画 除了内置动画，用户还可以根据开发需求自定义动画效果 animate1$(&#x27;div&#x27;).animate(obj,time,style,fn); 12345678910111213//接收四个参数$(&#x27;div&#x27;).animate( //1. 接收一个对象, 可以在对象中修改属性 &#123;width:&#x27;100px&#x27;,height:&#x27;100px&#x27;&#125;, //2. 指定动画时长 3000, //3. 指定动画节奏, 默认就是swing &#x27;swing&#x27;, //4. 动画执行完毕之后的回调函数 function()&#123; alert(&quot;动画执行完毕&quot;); &#125;); 样式属性名称采用驼峰形式，如maginLeft 无法识别颜色属性，如color、bordercolor、backgroundcolor，可以通过动画序列解决 鼓励通过$.speed()设置动画效果（时长和缓动） 123var params=&#123;width:&#x27;100px&#x27;,height:&#x27;100px&#x27;&#125;;var settings=$.speed(3000,&#x27;swing&#x27;);$(&#x27;div&#x27;).animate(params,setting);``` 动画队列1234567891011function runQue() &#123; div.show(&#x27;slow&#x27;) .animate(&#123;left: &#x27;+=200&#x27;&#125;, 2000) .queue(function() &#123; //弥补jquery不能识别颜色属性的缺陷 $(this).css(&#x27;background&#x27;, &#x27;green&#x27;).dequeue(); &#125;) .animate(&#123;left: &#x27;-=200&#x27;&#125;, 1500) //构成一个永不停止的动画的 .slideUp(&#x27;normal&#x27;, runQue);&#125; 方自定义动画相关方法 说明 animate(params[,speed][,easing][,fn]) 用于创建自定义动画的函数 $.speed([speed][,settings]) 创建一个包含一组属性的对象用来定义自定义动画 queue([queueName]) 显示被选元素上要执行的函数队列（入队） delay(speed[,queueName]) 设置一个延时来推迟执行队列中之后的项目 clearQueue([queueName]) 从尚未运行的队列中移除所有项目 dequeue([queueName]) 从队列移除下一个函数，然后执行函数（出队） finish([queueName]) 停止当前正在运行的动画，删除所有排队的动画，并完成匹配元素所有的动画 top([clearQueue][,jumpToEnd]) 停止所有在指定元素上正在运行的动画 params：表示一组包含动画最终属性值的集合 settings：是easing与fn组成的一个对象集合 queueName：表示队列名称，默认值为fx(标准效果队列) clearQueue：布尔类型，默认为false，用于规定是否停止被选元素所有加入队列的动画 jumpToEnd：布尔类型，默认为false，用于规定是否立即完成当前的动画 动画案例对联广告12345678910111213141516171819*&#123; margin: 0; padding: 0;&#125;.left&#123; float: left; position: fixed; left: 0; top: 200px;&#125;.right&#123; float: right; position: fixed; right: 0; top: 200px;&#125;img&#123; display: none;&#125; 123456789&lt;img src=&quot;images/left_ad.png&quot; class=&quot;left&quot;&gt;&lt;img src=&quot;images/right_ad.png&quot; class=&quot;right&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;... 123456789101112131415$(function () &#123; // 1.监听网页的滚动 $(window).scroll(function () &#123; // 1.1获取网页滚动的偏移位 var offset = $(&quot;html,body&quot;).scrollTop(); // 1.2判断网页是否滚动到了指定的位置 if(offset &gt;= 500)&#123; // 1.3显示广告 $(&quot;img&quot;).show(1000); &#125;else&#123; // 1.4隐藏广告 $(&quot;img&quot;).hide(1000); &#125; &#125;);&#125;); 折叠菜单1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950*&#123; margin: 0; padding: 0;&#125;.nav&#123; list-style: none; width: 300px; margin: 100px auto; /*border: 1px solid #000;*/&#125;.nav&gt;li&#123; border: 1px solid #000; line-height: 35px; border-bottom: none; text-indent: 2em; position: relative;&#125;.nav&gt;li:last-child&#123; border-bottom: 1px solid #000; border-bottom-right-radius: 10px; border-bottom-left-radius: 10px;&#125;.nav&gt;li:first-child&#123; border-top-right-radius: 10px; border-top-left-radius: 10px;&#125;.nav&gt;li&gt;span&#123; /*箭头*/ background: url(&quot;images/arrow_right.png&quot;) no-repeat center center; display: inline-block; width: 32px; height: 32px; position: absolute; right: 10px; top: 5px;&#125;.sub&#123; display: none;&#125;.sub&gt;li&#123; list-style: none; background: skyblue; border-bottom: 1px solid white;&#125;.sub&gt;li:hover&#123; background:seagreen;&#125;.nav&gt;.current&gt;span&#123; transform: rotate(90deg);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;ul class=&quot;nav&quot;&gt; &lt;li&gt;一级菜单&lt;span&gt;&lt;/span&gt; &lt;ul class=&quot;sub&quot;&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;一级菜单&lt;span&gt;&lt;/span&gt; &lt;ul class=&quot;sub&quot;&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;一级菜单&lt;span&gt;&lt;/span&gt; &lt;ul class=&quot;sub&quot;&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;一级菜单&lt;span&gt;&lt;/span&gt; &lt;ul class=&quot;sub&quot;&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;一级菜单&lt;span&gt;&lt;/span&gt; &lt;ul class=&quot;sub&quot;&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;一级菜单&lt;span&gt;&lt;/span&gt; &lt;ul class=&quot;sub&quot;&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;一级菜单&lt;span&gt;&lt;/span&gt; &lt;ul class=&quot;sub&quot;&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;一级菜单&lt;span&gt;&lt;/span&gt; &lt;ul class=&quot;sub&quot;&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;/ul&gt; 1234567891011121314151617 $(function () &#123; // 1.监听一级菜单的点击事件 $(&quot;.nav&gt;li&quot;).click(function () &#123; // 1.1拿到二级菜单 var $sub = $(this).children(&quot;.sub&quot;); // 1.2让二级菜单展开 $sub.slideDown(1000); // 1.3拿到所有非当前的二级菜单 var otherSub = $(this).siblings().children(&quot;.sub&quot;); // 1.4让所有非当前的二级菜单收起 otherSub.slideUp(1000); // 1.5让被点击的一级菜单箭头旋转 $(this).addClass(&quot;current&quot;); // 1.6让所有非被点击的一级菜单箭头还原 $(this).siblings().removeClass(&quot;current&quot;); &#125;);&#125;); 下拉菜单 在jQuery中如果需要执行动画，建议在执行动画之前先调用stop方法，然后再执行动画 1234567891011121314151617181920212223*&#123; margin: 0; padding: 0;&#125;.nav&#123; list-style: none; width: 300px; height: 50px; background: skyblue; margin: 100px auto;&#125;.nav&gt;li&#123; width: 100px; height: 50px; line-height: 50px; text-align: center; float: left;&#125;.sub&#123; list-style: none; background: yellowgreen; display: none;&#125; 1234567891011121314151617181920212223&lt;ul class=&quot;nav&quot;&gt; &lt;li&gt;一级菜单 &lt;ul class=&quot;sub&quot;&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;一级菜单 &lt;ul class=&quot;sub&quot;&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;一级菜单 &lt;ul class=&quot;sub&quot;&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;/ul&gt; 1234567891011121314151617181920212223$(function () &#123; /* 在jQuery中如果需要执行动画, 建议在执行动画之前先调用stop方法,然后再执行动画 */ // 1.监听一级菜单的移入事件 $(&quot;.nav&gt;li&quot;).mouseenter(function () &#123; // 1.1拿到二级菜单 var $sub = $(this).children(&quot;.sub&quot;); // 停止当前正在运行的动画： $sub.stop(); // 1.2让二级菜单展开 $sub.slideDown(1000); &#125;); // 2.监听一级菜单的移出事件 $(&quot;.nav&gt;li&quot;).mouseleave(function () &#123; // 1.1拿到二级菜单 var $sub = $(this).children(&quot;.sub&quot;); // 停止当前正在运行的动画： $sub.stop(); // 1.2让二级菜单收起 $sub.slideUp(1000); &#125;);&#125;); 弹窗广告123456789101112131415161718*&#123; margin: 0; padding: 0;&#125;.ad&#123; position: fixed; right: 0; bottom: 0; display: none;&#125;.ad&gt;span&#123; display: inline-block; width: 30px; height: 30px; position: absolute; top: 0; right: 0;&#125; 1234&lt;div class=&quot;ad&quot;&gt; &lt;img src=&quot;images/ad-pic.png&quot; alt=&quot;&quot;&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt; 12345678910111213141516$(function () &#123; // 1.监听span的点击事件 $(&quot;span&quot;).click(function () &#123; $(&quot;.ad&quot;).remove(); &#125;); // 2.执行广告动画 /* $(&quot;.ad&quot;).slideDown(1000, function () &#123; $(&quot;.ad&quot;).fadeOut(1000, function () &#123; $(&quot;.ad&quot;).fadeIn(1000); &#125;); &#125;); */ $(&quot;.ad&quot;).stop().slideDown(1000).fadeOut(1000).fadeIn(1000); &#125;); 无缝轮播12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667.banner&#123; position:relative; overflow:hidden; margin:100px auto; width:958px; height:400px;&#125;.banner ul&#123; margin:0; padding:0; list-style:none;&#125;.hot&#123; position:absolute; top:0; left:0;&#125;.hot li&#123; float:left;&#125;.dot&#123; position:absolute; bottom:10px; width:100%; text-align:center; font-size:0;&#125;.dot li&#123; display:inline-block; margin:0 5px; width:15px; height:15px; border-radius:100%; background:rgba(145,144,144,.5); cursor:pointer;&#125;.dot .on&#123; background-color:#fff;&#125;/* 左右翻页箭头样式 */.arrow&#123; display:none;&#125;.arrow span&#123; display:block; width:50px; height:100px; background:rgba(0,0,0,.6); color:#fff; text-align:center; font-size:40px; line-height:100px; cursor:pointer;&#125;.arrow .prev&#123; position:absolute; top:50%; left:0; margin-top:-50px;&#125;.arrow .next&#123; position:absolute; top:50%; right:0; margin-top:-50px;&#125; 1234567891011121314151617&lt;div class=&quot;banner&quot;&gt; &lt;!--轮播图片--&gt; &lt;ul class=&quot;hot&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/1.jpg&quot; &gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/2.jpg&quot; &gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/3.jpg&quot; &gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/4.jpg&quot; &gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;images/5.jpg&quot; &gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;!--小圆点--&gt; &lt;ul class=&quot;dot&quot;&gt;&lt;li class=&quot;on&quot;&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt; &lt;!-- 左右翻页箭头--&gt; &lt;div class=&quot;arrow&quot;&gt; &lt;span class=&quot;prev&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;next&quot;&gt;&amp;gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//1.初始工作var i = 0; // 当前显示的图片索引var timer = null; // 定时器var delay = 1000; // 图片自动切换的间隔时间var width = 958; // 每张图片的宽度var speed = 400; // 动画时间// 复制列表中的第一个图片，追加到列表最后，设置ul的宽度为图片张数 * 图片宽度 var firstimg = $(&#x27;.hot li&#x27;).first().clone();$(&#x27;.hot&#x27;).append(firstimg).width($(&#x27;.hot li&#x27;).length * width);// 设置周期计时器，实现图片自动切换timer = setInterval(imgChange, delay);//2. 自动切换图片function imgChange() &#123; ++i; isCrack(); //实现无缝轮播 dotChange(); //自动切换对应的圆点样式&#125;function isCrack() &#123; if (i == $(&#x27;.hot li&#x27;).length) &#123; i = 1; $(&#x27;.hot&#x27;).css(&#123;left: 0&#125;); &#125; $(&#x27;.hot&#x27;).stop().animate(&#123;left: -i * width&#125;, speed);&#125;// 3.自动切换对应的圆点function dotChange() &#123; if (i == $(&#x27;.hot li&#x27;).length - 1) &#123; $(&#x27;.dot li&#x27;).eq(0).addClass(&#x27;on&#x27;). siblings().removeClass(&#x27;on&#x27;); &#125; else &#123; $(&#x27;.dot li&#x27;).eq(i).addClass(&#x27;on&#x27;). siblings().removeClass(&#x27;on&#x27;); &#125;&#125;// 4. 设置左右切换的箭头显示和隐藏$(&#x27;.banner&#x27;).hover( function() &#123; $(&#x27;.arrow&#x27;).show(); &#125;, function () &#123; $(&#x27;.arrow&#x27;).hide();&#125;); // 鼠标移入，暂停自动播放，移出，开始自动播放$(&#x27;.banner&#x27;).hover(function() &#123; clearInterval(timer);&#125;, function() &#123; timer = setInterval(imgChange, delay);&#125;);//5.设置右箭头的事件$(&#x27;.next&#x27;).click(function() &#123; imgChange()&#125;);//6.设置左箭头的事件$(&#x27;.prev&#x27;).click(function() &#123; --i; if (i == -1) &#123; i = $(&#x27;.hot li&#x27;).length - 2; $(&#x27;.hot&#x27;).css(&#123;left: -($(&#x27;.hot li&#x27;).length - 1) * width&#125;); &#125; $(&#x27;.hot&#x27;).stop().animate(&#123;left: -i * width&#125;, speed); dotChange();&#125;);","path":"page/jQuery06.html","date":"05-05","excerpt":"","tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://xiaoliblog.cn/tags/jQuery/"}]},{"title":"jQuery🌞jQuery事件操作","text":"事件操作 标签中通过属性设置事件，每个属性都由一个on和事件名组成。例如，点击事件对应的属性为onclick。 在jQuery中则可直接使用其提供的与事件类型同名的方法。例如，点击事件对应的方法为click()。 这些事件方法允许重复绑定处理程序，按照绑定顺序依次执行。 事件绑定 jQuery中有两种绑定事件方式 eventName(fn);：编码效率高，部分事件jQuery没有实现，所以不能添加 on(eventName,fn);：编码效率较低，所以JS事件都可以添加 12345678910$(function()&#123; //第一种方法，推荐使用 $(&#x27;button&#x27;).click(function()&#123; alert(&quot;test1&quot;); &#125;) //第二种方法 $(&#x27;button&#x27;).on(&#x27;click&#x27;,function()&#123; alert(&quot;test2&quot;); &#125;)&#125;) 注册多个相同事件或者不同类型的事件不会覆盖 事件解绑1234// 解绑匹配元素的所有事件$(selector).off();// 解绑匹配元素的所有click事件,参数为事件类型$(selector).off(&quot;click&quot;); 1234567891011121314$(function()&#123; function test1()&#123; alert(&quot;click&quot;) &#125; function test2()&#123; alert(&quot;mouseenter&quot;) &#125; $(&#x27;button&#x27;).click(test1); $(&#x27;button&#x27;).mouseenter(test2); // 解绑匹配元素的所有事件 $(&#x27;button&#x27;).off(); // 解绑匹配元素的所有click事件 $(&#x27;button&#x27;).off(&quot;click&quot;);&#125;) 事件冒泡 事件冒泡就是事件从下级往上级传递的过程，比如如下HTML结构，给父盒子和子盒子都注册点击事件，单独点击子盒子也会触发父盒子的点击事件 123&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt; 阻止事件冒泡有如下两种方法，注意是在下级即子盒子设置 1234567$(&quot;.son&quot;).click(function (event) &#123; alert(&quot;son&quot;); //阻止事件冒泡方式1 //return false; //阻止事件冒泡方式2 event.stopPropagation();&#125;); 默认行为 当你点击一个超链接或者提交按钮时，没有进行任何事件监听其默认会进行跳转，这就是默认行为 12345&lt;a href=&quot;http://www.baidu.com&quot;&gt;注册&lt;/a&gt;&lt;form action=&quot;http://www.taobao.com&quot;&gt; &lt;input type=&quot;text&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 在有些情况下不使用默认行为，比如对a标签设置不使用默认行为，而是只弹一注册框不进行跳转 1234567$(&quot;a&quot;).click(function (event) &#123; alert(&quot;弹出注册框&quot;); //第一种方式 // return false; //第二种方式 event.preventDefault();&#125;); 自动触发 trigger： 如果利用trigger自动触发事件，会触发事件冒泡，不会阻止事件冒泡 triggerHandler： 如果利用triggerHandler自动触发事件，不会触发事件冒泡，会阻止事件冒泡 123&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt; 12345$(&quot;.son&quot;).click(function (event) &#123; alert(&quot;son&quot;);&#125;);$(&quot;.son&quot;).trigger(&quot;click&quot;); //不会阻止事件冒泡$(&quot;.sonr&quot;).triggerHandler(&quot;click&quot;); //会阻止事件冒泡 自定义事件 想要自定义事件, 必须满足两个条件 事件必须是通过on绑定的 事件必须通过trigger或者triggerHandler来触发 123&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt; 1234$(&quot;.son&quot;).on(&quot;myClick&quot;, function () &#123; alert(&quot;son&quot;);&#125;);$(&quot;.son&quot;).triggerHandler(&quot;myClick&quot;); 事件命名空间 项目都是多人协作，当多个人操作同一个DOM元素时，给同一个元素添加同一个事件时，就需要通过命名空间来区分是谁添加的事件 想要事件的命名空间有效，必须满足两个条件 事件必须是通过on绑定的 事件必须通过trigger或者triggerHandler来触发 123&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt; 123456789101112//通过eventName.命名空间 来标识//张三绑定的事件$(&quot;.son&quot;).on(&quot;click.zs&quot;, function () &#123; alert(&quot;click1&quot;);&#125;);//李四绑定的事件$(&quot;.son&quot;).on(&quot;click.ls&quot;, function () &#123; alert(&quot;click2&quot;);&#125;);// $(&quot;.son&quot;).trigger(&quot;click.zs&quot;);$(&quot;.son&quot;).trigger(&quot;click.ls&quot;); 事件命名空间面试题 利用trigger触发子元素带命名空间的事件， 那么父元素带相同命名空间的事件也会被触发， 而父元素没有命名空间的事件不会被触发 利用trigger触发子元素不带命名空间的事件，那么子元素所有相同类型的事件和父元素所有相同类型的事件都会被触发 1234567891011121314$(function () &#123; $(&quot;.father&quot;).on(&quot;click.ls&quot;, function () &#123; alert(&quot;father click1&quot;); &#125;); $(&quot;.father&quot;).on(&quot;click&quot;, function () &#123; alert(&quot;father click2&quot;); &#125;); $(&quot;.son&quot;).on(&quot;click.ls&quot;, function () &#123; alert(&quot;son click1&quot;); &#125;); // $(&quot;.son&quot;).trigger(&quot;click.ls&quot;); $(&quot;.son&quot;).trigger(&quot;click&quot;);&#125;); 事件委托 事件委托就是请别人帮忙做事情， 然后将做完的结果反馈给我们 123456&lt;ul&gt; &lt;li&gt;我是第1个li&lt;/li&gt; &lt;li&gt;我是第2个li&lt;/li&gt; &lt;li&gt;我是第3个li&lt;/li&gt;&lt;/ul&gt;&lt;button&gt;新增一个li&lt;/button&gt; 12345678910111213$(function () &#123; $(&quot;button&quot;).click(function () &#123; $(&quot;ul&quot;).append(&quot;&lt;li&gt;我是新增的li&lt;/li&gt;&quot;); &#125;) /* 在jQuery中,如果通过核心函数找到的元素不止一个, 那么在添加事件的时候,jQuery会遍历所有找到的元素,给所有找到的元素添加事件 */ //此时会找到三个li $(&quot;ul&gt;li&quot;).click(function () &#123; console.log($(this).html()); &#125;);&#125; 以上代码，当我们点击li标签时，会在控制台打印出内容，但却不能打印出通过jQuery入口函数创建的li标签内容 这是因为jQuery入口函数是在所以DOM元素加载完毕才执行，加载完毕后只有原生的三个li标签，所以只给三个li标签添加了点击事件，新增的标签并没有添加点击事件。那如何使新添加的也绑定事件呢？这就需要用到事件委托机制 我们可以让ul帮li监听click事件。之所以能够监听，是因为入口函数执行的时候ul就已经存在了，所以能够添加事件。之所以this是li，是因为我们点击的是li，而li没有click事件，所以事件冒泡传递给了ul，ul响应了事件， 既然事件是从li传递过来的，所以ul必然指定this是谁 1234//li的点击事件委托给ul监听$(&quot;ul&quot;).delegate(&quot;li&quot;, &quot;click&quot;, function () &#123; console.log($(this).html());&#125;); 事件类型表单事件 方法 说明 blur() 当元素失去焦点时触发 focus() 当元素获得焦点时触发 change() 当元素的值发生改变时触发 select() 当文本框（包括&lt;input&gt;和&lt;textarea&gt;）中的文本被选中时触发 submit() 表单提交时触发 123&lt;p&gt;用户名称：&lt;input type=&quot;text&quot; name=&quot;uname&quot;&gt;&lt;/p&gt;&lt;p&gt;电子邮箱：&lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;&lt;/p&gt;&lt;p&gt;手机号码：&lt;input type=&quot;text&quot; name=&quot;tel&quot;&gt;&lt;/p&gt; 12345678$(&#x27;input[type=text]&#x27;).focus(function() &#123; var tips = $(&#x27;&lt;span&gt;&lt;/span&gt;&#x27;); tips.html(&#x27;请按要求输入&#x27;); $(&#x27;input:focus&#x27;).after(tips);&#125;);$(&#x27;input[type=text]&#x27;).blur(function()&#123; $(this).next().remove();&#125;); 键盘事件 方法 说明 keydown() 键盘按键被按下时触发 keyup() 键盘按键弹起时触发 keypress() 键盘按键（Shift等非字符键除外）被按下时触发 12345.boxes&#123; width:10px; height:10px; background-color:red;&#125; 1&lt;div class=&#x27;boxes&#x27;&gt;&lt;/div&gt; 123456789101112131415$(document).keydown(function(event) &#123; //获取按键码(37、38、39、40) var opt = event.which; var item = $(&#x27;.boxes&#x27;); //获取元素距离文档的位置 var left = item.offset().left; var top = item.offset().top;; console.log(opt); switch(opt)&#123; case 37:item.offset(&#123;left:left-1,top:top&#125;);break; case 38:item.offset(&#123;left:left,top:top-1&#125;);break; case 39:item.offset(&#123;left:left+1,top:top&#125;);break; case 40:item.offset(&#123;left:left,top:top+1&#125;);break; &#125;&#125;); 鼠标事件 方法 说明 mouseover() 当鼠标移入对象时触发 mouseout() 鼠标从元素上离开时触发 mouseenter() 当鼠标移入对象时触发 mouseleave() 鼠标从元素上离开时触发 hover() 监听移入移出 click() 当单击元素时触发 dbclick() 当双击元素时触发 mousedown() 当鼠标指针移动到元素上方，并按下鼠标按键时触发 mouseup() 当在元素上放松鼠标按钮时，会被触发 123456789101112//鼠标移入时，为本文添加背景颜色；$(&#x27;div&#x27;).mouseover(function(event) &#123; $(this).css(&#x27;background-color&#x27;,&#x27;green&#x27;);&#125;);//鼠标移出时，为文本移除背景颜色。$(&#x27;div&#x27;).mouseout(function(event) &#123; $(this).css(&#x27;background-color&#x27;,&#x27;&#x27;);&#125;);//鼠标单击时，打印单击位置。$(&#x27;div&#x27;).click(function(event) &#123; console.log(event.pageY);&#125;); mouseover/mouseout事件, 子元素被移入移出也会触发父元素的事件 mouseenter/mouseleave事件, 子元素被移入移出不会触发父元素的事件，推荐使用 hover()可以同时监听移入和移出事件 12345$(&quot;div&quot;).hover(function () &#123; console.log(&quot;father被移入了&quot;);&#125;,function () &#123; console.log(&quot;father被移出了&quot;);&#125;); 页面加载事件 类比选项 window.onload $(document).ready() 执行时机 必须等待网页中的所有内容加载完成后(包括外部元素，如图片)才能执行 网页中的所有DOM结构绘制完成后就执行（可能关联内容并未加载完成） 编写个数 不能同时编写多个 能够同时编写多个 简化写法 无 $() jQuery中的页面加载事件方法有3种语法形式，具体如下。 123$(document).ready(function() &#123; &#125;); // 语法方式1$().ready(function() &#123; &#125;); // 语法方式2$(function() &#123; &#125;); // 语法方式3 123$(document).ready(function()&#123; alert(&quot;欢迎光临&quot;);&#125;) 事件绑定与切换 方法 说明 on(events,function) 在匹配元素上绑定一个或多个事件处理函数 off(events) 在匹配元素上移除一个或多个事件处理函数 one(events,function) 为每个匹配元素的事件绑定一次性的处理函数 hover([over,]out) 元素鼠标移入与移出事件切换 1&lt;div&gt;文本&lt;/div&gt; 123456789101112$(&#x27;div&#x27;).on(&#x27;click&#x27;,function()&#123; console.log(&#x27;触发点击事件&#x27;); $(&#x27;div&#x27;).off(&#x27;click&#x27;);&#125;)$(&#x27;div&#x27;).on(&#123; mouseover:function()&#123; console.log(&#x27;鼠标移入&#x27;); &#125;, mouseout:function()&#123; console.log(&#x27;鼠标移出&#x27;); &#125;&#125;) 事件案例事件委托案例 点击登录链接，动态产生一个登录界面（一张图片），给其添加事件取消登录界面 123456789101112131415161718192021222324252627282930313233*&#123; margin: 0; padding: 0;&#125;html,body&#123; width: 100%; height: 100%;&#125;/*黑色蒙版*/.mask&#123; width: 100v%; height: 100%; background: rgba(0,0,0,0.5); position: fixed; top: 0; left: 0;&#125;/*登录盒子*/.login&#123; width: 522px; height: 290px; margin: 100px auto; position: relative;&#125;/*定位到关闭x*/.login&gt;span&#123; width: 50px; height: 50px; /*background: red;*/ position: absolute; top: 0; right: 0;&#125; 1&lt;a href=&quot;http://www.baidu.com&quot;&gt;点击登录&lt;/a&gt; 123456789101112131415161718192021$(function () &#123; // 编写jQuery相关代码 $(&quot;a&quot;).click(function () &#123; //登录盒子HTML结构 var $mask = $(&quot;&lt;div class=\\&quot;mask\\&quot;&gt;\\n&quot; + &quot; &lt;div class=\\&quot;login\\&quot;&gt;\\n&quot; + &quot; &lt;img src=\\&quot;login.png\\&quot; alt=\\&quot;\\&quot;&gt;\\n&quot; + &quot; &lt;span&gt;&lt;/span&gt;\\n&quot; + &quot; &lt;/div&gt;\\n&quot; + &quot;&lt;/div&gt;&quot;); // 添加蒙版 $(&quot;body&quot;).append($mask); // 由于登录界面是动态产生的无法绑定事件，所以需要用事件委托，找一个本来就存在的委托给它 $(&quot;body&quot;).delegate(&quot;.login&gt;span&quot;, &quot;click&quot;, function () &#123; // 移除蒙版 $mask.remove(); &#125;); //取消默认行为 return false; &#125;);&#125;); 电影排行榜123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354*&#123; margin: 0; padding: 0;&#125;.box&#123; width: 300px; height: 450px; margin: 50px auto; border: 1px solid #000;&#125;.box&gt;h1&#123; font-size: 20px; line-height: 35px; color: deeppink; padding-left: 10px; border-bottom: 1px dashed #ccc;&#125;ul&gt;li&#123; list-style: none; padding: 5px 10px; border: 1px dashed #ccc;&#125;ul&gt;li:nth-child(-n+3) span&#123; background: deeppink;&#125;ul&gt;li&gt;span&#123; display: inline-block; width: 20px; height: 20px; background: #ccc; text-align: center; line-height: 20px; margin-right: 10px;&#125;.content&#123; overflow: hidden; margin-top: 5px; display: none;&#125;.content&gt;img&#123; width: 80px; height: 120px; float: left;&#125;.content&gt;p&#123; width: 180px; height: 120px; float: right; font-size: 12px; line-height: 20px;&#125;.current .content&#123; display: block;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041div class=&quot;box&quot;&gt; &lt;h1&gt;电影排行榜&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;&lt;span&gt;1&lt;/span&gt;电影名称 &lt;div class=&quot;content&quot;&gt; &lt;img src=&quot;images/zl.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;简介：故事发生在非洲附近的大海上，主人公冷锋（吴京 饰）遭遇人生滑铁卢，被“开除军籍”，本想漂泊一生的他，正当他打算这么做的时候，一场突如其来的意外打破了他的计划，突然被卷入了一场&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt;&lt;span&gt;2&lt;/span&gt;电影名称 &lt;div class=&quot;content&quot;&gt; &lt;img src=&quot;images/zl.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;简介：故事发生在非洲附近的大海上，主人公冷锋（吴京 饰）遭遇人生滑铁卢，被“开除军籍”，本想漂泊一生的他，正当他打算这么做的时候，一场突如其来的意外打破了他的计划，突然被卷入了一场&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt;&lt;span&gt;3&lt;/span&gt;电影名称 &lt;div class=&quot;content&quot;&gt; &lt;img src=&quot;images/zl.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;简介：故事发生在非洲附近的大海上，主人公冷锋（吴京 饰）遭遇人生滑铁卢，被“开除军籍”，本想漂泊一生的他，正当他打算这么做的时候，一场突如其来的意外打破了他的计划，突然被卷入了一场&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt;&lt;span&gt;4&lt;/span&gt;电影名称 &lt;div class=&quot;content&quot;&gt; &lt;img src=&quot;images/zl.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;简介：故事发生在非洲附近的大海上，主人公冷锋（吴京 饰）遭遇人生滑铁卢，被“开除军籍”，本想漂泊一生的他，正当他打算这么做的时候，一场突如其来的意外打破了他的计划，突然被卷入了一场&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt;&lt;span&gt;5&lt;/span&gt;电影名称 &lt;div class=&quot;content&quot;&gt; &lt;img src=&quot;images/zl.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;简介：故事发生在非洲附近的大海上，主人公冷锋（吴京 饰）遭遇人生滑铁卢，被“开除军籍”，本想漂泊一生的他，正当他打算这么做的时候，一场突如其来的意外打破了他的计划，突然被卷入了一场&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt;&lt;span&gt;6&lt;/span&gt;电影名称 &lt;div class=&quot;content&quot;&gt; &lt;img src=&quot;images/zl.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;简介：故事发生在非洲附近的大海上，主人公冷锋（吴京 饰）遭遇人生滑铁卢，被“开除军籍”，本想漂泊一生的他，正当他打算这么做的时候，一场突如其来的意外打破了他的计划，突然被卷入了一场&lt;/p&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 123456789101112131415161718$(function () &#123; // 编写jQuery相关代码 /* // 1.监听li的移入事件 $(&quot;li&quot;).mouseenter(function () &#123; $(this).addClass(&quot;current&quot;); &#125;); // 2.监听li的移出事件 $(&quot;li&quot;).mouseleave(function () &#123; $(this).removeClass(&quot;current&quot;); &#125;); */ $(&quot;li&quot;).hover(function () &#123; $(this).addClass(&quot;current&quot;); &#125;, function () &#123; $(this).removeClass(&quot;current&quot;); &#125;);&#125;); Tab选项卡1234567891011121314151617181920212223242526272829*&#123; margin: 0; padding: 0;&#125;.box&#123; width: 440px; height: 198px; border: 1px solid #000; margin: 50px auto;&#125;.nav&gt;li&#123; list-style: none; width: 110px; height: 50px; background: orange; text-align: center; line-height: 50px; float: left;&#125;.nav&gt;.current&#123; background: #ccc;&#125;.content&gt;li&#123; list-style: none; display: none;&#125;.content&gt;.show&#123; display: block;&#125; 利用index()索引 1234567891011121314151617$(function () &#123; // 1.监听选项卡的移入事件 $(&quot;.nav&gt;li&quot;).mouseenter(function () &#123; // 1.1修改被移入选项卡的背景颜色 $(this).addClass(&quot;current&quot;); // 1.2还原其它兄弟选项卡的背景颜色 $(this).siblings().removeClass(&quot;current&quot;); // 1.3获取当前移出选项卡的索引 var index = $(this).index(); // 1.4根据索引找到对应的图片 var $li = $(&quot;.content&gt;li&quot;).eq(index); // 1.5隐藏非当前的其它图片 $li.siblings().removeClass(&quot;show&quot;); // 1.6显示对应的图片 $li.addClass(&quot;show&quot;); &#125;);&#125;); 手风琴效果 页面组成 5张图片 动态效果： 鼠标移入图片时，该图片完整显示；鼠标移出时，该图片回复默认大小。overflow:hidden多余隐藏。 图片素材 1.jpg2.jpg3.jpg4.jpg5.jpg 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;手风琴效果&lt;/title&gt; &lt;style&gt; ul&#123;list-style:none;margin:0;padding:0&#125; div&#123;width:1200px;height:400px;margin:50px auto;overflow:hidden&#125; div li&#123;width:240px;height:400px;float:left&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;jquery-3.4.1.js&quot;&gt;&lt;/script&gt; &lt;div id=&quot;box&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=&quot;images/1.jpg&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/2.jpg&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/3.jpg&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/4.jpg&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/5.jpg&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; $(&#x27;div&gt;ul&gt;li&#x27;).on(&#123; mouseover:function()&#123; $(this).siblings(&#x27;li&#x27;).css(&#x27;width&#x27;,&#x27;60.5px&#x27;); $(this).css(&#x27;width&#x27;,&#x27;958px&#x27;); &#125;, mouseout:function(event) &#123; $(&#x27;#box&gt;ul&gt;li&#x27;).css(&#x27;width&#x27;,&#x27;240px&#x27;); &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","path":"page/jQuery05.html","date":"05-04","excerpt":"","tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://xiaoliblog.cn/tags/jQuery/"}]},{"title":"jQuery🌞DOM节点操作","text":"DOM节点操作节点追加 content是一段字符串形式的HTML代码 父子节点添加是在匹配到的元素内部进行，兄弟节点是在匹配的元素外部进行。 1234567891011121314//父子节点&lt;p&gt;hello&gt;&lt;/p&gt;$(&#x27;p&#x27;).append(&#x27;&lt;b&gt;append&lt;/b&gt;&#x27;);//添加在结束标签之前&lt;p&gt;hello&lt;b&gt;append&lt;/b&gt;&lt;/p&gt;$(&#x27;p&#x27;).prepend(&#x27;&lt;b&gt;append&lt;/b&gt;&#x27;);//添加在开始标签之后&lt;p&gt;&lt;b&gt;&lt;append&gt;&lt;/b&gt;hello&lt;/p&gt;//弟节点$(&#x27;p&#x27;).after(&#x27;&lt;b&gt;didi&lt;/b&gt;&#x27;);&lt;p&gt;hello&lt;/p&gt;&lt;b&gt;didi&lt;/p&gt;$(&#x27;p&#x27;).before(&#x27;&lt;b&gt;didi&lt;/b&gt;&#x27;);&lt;b&gt;didi&lt;/b&gt;&lt;p&gt;hello&gt;&lt;/p&gt; 节点替换 语法 说明 replaceWith(content) 将所有匹配的元素替换成指定的HTML或DOM元素 replaceAll(selector) 用匹配的元素替换掉所有selector匹配到的元素 123456789&lt;p&gt;hello&lt;/p&gt;&lt;p&gt;world&lt;/p&gt;&lt;script&gt; // $(&#x27;p:first&#x27;).replaceWith(&#x27;&lt;p&gt;你好&lt;/p&gt;&#x27;); // $(&#x27;p:eq(1)&#x27;).replaceWith(&#x27;&lt;p&gt;世界&lt;/p&gt;&#x27;); $(&#x27;&lt;p&gt;你好&lt;/p&gt;&#x27;).replaceAll($(&#x27;p:first&#x27;)); $(&#x27;&lt;p&gt;世界&lt;/p&gt;&#x27;).replaceAll($(&#x27;p:eq(1)&#x27;));&lt;/script&gt; 节点删除 语法 说明 empty() 清空元素的内容，但不删除元素本身 remove() 清空元素的内容，并删除元素本身 12345678910111213&lt;ul&gt; &lt;li&gt;1111&lt;/li&gt; &lt;li&gt;2222&lt;/li&gt; &lt;li&gt;3333&lt;/li&gt; &lt;li&gt;4444&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; //移除第一个节点的内容 $(&#x27;li:first&#x27;).empty(); //移除第二个元素的内容及元素本身 $(&#x27;li:eq(1)&#x27;).remove();&lt;/script&gt; 节点复制 语法 说明 clone([false]) 复制匹配的元素，默认参数为false clone(true) 参数设置为true时，复制元素的所有事件处理 12345678910&lt;ul&gt; &lt;li&gt;1111&lt;/li&gt; &lt;li&gt;2222&lt;/li&gt; &lt;li&gt;3333&lt;/li&gt; &lt;li&gt;4444&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; $(&#x27;ul&#x27;).clone().appendTo($(&#x27;body&#x27;));&lt;/script&gt; 左移与右移12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;左移与右移&lt;/title&gt; &lt;style&gt; select&#123;width:100px;height:150px&#125; input[type=button]&#123;width:50px&#125; #opt&#123;margin:90px 10px 0&#125; .box&#123;width:80%;margin:0 auto;background-color:#999999&#125; .box div&#123;float:left&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div id=&quot;left&quot;&gt; &lt;p&gt;可选项&lt;/p&gt; &lt;select multiple&gt; &lt;option&gt;添加&lt;/option&gt; &lt;option&gt;移动&lt;/option&gt; &lt;option&gt;修改&lt;/option&gt; &lt;option&gt;查询&lt;/option&gt; &lt;option&gt;打印&lt;/option&gt; &lt;option&gt;删除&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div id=&quot;opt&quot;&gt; &lt;input id=&quot;toRight&quot; type=&quot;button&quot; value=&quot;&gt;&quot;&gt;&lt;br&gt; &lt;input id=&quot;toLeft&quot; type=&quot;button&quot; value=&quot;&lt;&quot;&gt;&lt;br&gt; &lt;input id=&quot;toAllRight&quot; type=&quot;button&quot; value=&quot;&gt;&gt;&quot;&gt;&lt;br&gt; &lt;input id=&quot;toAllLeft&quot; type=&quot;button&quot; value=&quot;&lt;&lt;&quot;&gt;&lt;br&gt; &lt;/div&gt; &lt;div id=&quot;right&quot;&gt; &lt;p&gt;已选项&lt;/p&gt; &lt;select multiple=&quot;multiple&quot;&gt;&lt;/select&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 获取按钮添加单击事件，获取第一个下拉框中被选中的option添加到第二个下拉框 $(&#x27;#toRight&#x27;).click(function() &#123; // 右移 $(&#x27;#right&gt;select&#x27;).append($(&#x27;#left&gt;select&gt;option:selected&#x27;)); &#125;); $(&#x27;#toLeft&#x27;).click(function() &#123; // 左移 $(&#x27;#left&gt;select&#x27;).append($(&#x27;#right&gt;select&gt;option:selected&#x27;)); &#125;); $(&#x27;#toAllRight&#x27;).click(function() &#123; // 全部右移 $(&#x27;#right&gt;select&#x27;).append($(&#x27;#left&gt;select&gt;option&#x27;)); &#125;); $(&#x27;#toAllLeft&#x27;).click(function() &#123; // 全部左移 $(&#x27;#left&gt;select&#x27;).append($(&#x27;#right&gt;select&gt;option&#x27;)); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","path":"page/jQuery04.html","date":"05-04","excerpt":"","tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://xiaoliblog.cn/tags/jQuery/"}]},{"title":"jQuery🌞jQuery元素操作","text":"元素操作元素遍历 each()方法可以对元素进行遍历 12345678910111213141516171819202122&lt;ul&gt; &lt;li&gt;PHP&lt;/li&gt; &lt;li&gt;IOS&lt;/li&gt; &lt;li&gt;JAVA&lt;/li&gt; &lt;li&gt;JS&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;//each参数：回调函数 $(&#x27;li&#x27;).each(function(index,element)&#123; console.og(&quot;第&quot;+(index+1)+&#x27;个:&#x27;+$(element).text()); &#125;);//each：遍历选择器匹配到的所有&lt;li&gt;元素//index：当前元素的索引位置//element：当前元素//text():函数，元素的文本&lt;/script&gt;/*第1个:PHP第2个:IOS第3个:JAVA第4个:JS*/ 元素内容 语法 说明 html() 获取第一个匹配元素的HTML内容 html(content) 设置第一个匹配元素的HTML内容 text() 获取所有匹配元素包含的文本内容组合起来的文本 text(content) 设置所有匹配元素的文本内容 val() 获取表单元素的value值 val(value) 设置表单元素的value值 123456789101112//设置div的HTML内容$(&quot;div&quot;).html(&quot;&lt;p&gt;我是段落&lt;span&gt;我是span&lt;/span&gt;&lt;/p&gt;&quot;);//获取div的HTML内容console.log($(&quot;div&quot;).html());//设置div的文本内容$(&quot;div&quot;).text(&quot;&lt;p&gt;我是段落&lt;span&gt;我是span&lt;/span&gt;&lt;/p&gt;&quot;);//获取div的文本内容console.log($(&quot;div&quot;).text());//设置表单的value值$(&quot;input&quot;).val(&quot;请输入内容&quot;);//获取表单的value值console.log($(&quot;input&quot;).val());; 元素样式123456789101112var ele=$(&#x27;div&#x27;);//设置元素多个样式ele.css(&#123; border:&#x27;2px solid black&#x27;, backgroundColor:&#x27;#ccc&#x27;&#125;); //获得元素样式var w=ele.css(&#x27;width&#x27;);var h=ele.css(&#x27;height&#x27;);//设置元素样式ele.css(&#x27;width&#x27;,&#x27;200px&#x27;);ele.css(&#x27;height&#x27;,&#x27;200px&#x27;); 语法 说明 css(name) name:样式名称，获得样式的值 css(properties) properties：键值对形式的对象，设置样式值 css(name,value) 设置样式的值 width()/width(value) 获取/设置第一个匹配元素的当前宽度值 height()/height(value) 获取/设置第一个匹配元素的当前高度值 offset() 获取元素的位置，返回的是一个对象，包含left和top属性 offset(properties) 利用对象设置元素的位置，必须包含left和top属性 元素类操作 语法 作用 说明 addClass(class) 添加一个类 如果要添加多个, 多个类名之间用空格隔开即可 removeClass(class) 删除一个类 如果想删除多个, 多个类名之间用空格隔开即可 toggleClass(class) 切换类 判断指定类是否存在，存在则删除，不存在则添加 hasClass(class) 判断类 判断元素是否具有class样式 1234&lt;button&gt;添加类&lt;/button&gt;&lt;button&gt;删除类&lt;/button&gt;&lt;button&gt;切换类&lt;/button&gt;&lt;div&gt;&lt;/div&gt; 123456789.class1 &#123; margin-top: 30px; width: 100px; height: 100px; background: skyblue;&#125;.class2 &#123; border: 1px solid #000;&#125; 1234567891011121314$(function () &#123; var btns = document.getElementsByTagName(&quot;button&quot;); btns[0].onclick = function () &#123; // $(&quot;div&quot;).addClass(&quot;class1&quot;); $(&quot;div&quot;).addClass(&quot;class1 class2&quot;); &#125; btns[1].onclick = function () &#123; // $(&quot;div&quot;).removeClass(&quot;class2&quot;); $(&quot;div&quot;).removeClass(&quot;class2 class1&quot;); &#125; btns[2].onclick = function () &#123; $(&quot;div&quot;).toggleClass(&quot;class2 class1&quot;); &#125;&#125;); 元素属性属性和属性结点 对象身上保存的变量就是属性 操作属性的方法 对象.属性名称 = 值 对象[&quot;属性名称&quot;] = 值 属性节点 在编写的HTML代码时，在HTML标签中添加的属性就是属性节点 在attributes属性中保存的所有内容都是属性节点 操作属性节点的方法 DOM元素.setAttribute(&quot;属性名称&quot;,&quot;值&quot;); DOM元素.getAttribute(&quot;属性名称&quot;) ; 任何对象都有属性，但是只有DOM对象才有属性节点 attr()方法 语法 说明 attr(name) 取得第一个匹配元素的属性值，否则返回undefined attr(name,value) 为所有匹配的元素设置一个属性值 removeAtrr(name) 从每一个匹配的元素中删除一个属性 12345678//获得属性节点的值,无论找到多少元素都只会返回第一个元素指定的属性节点$(&#x27;div&#x27;).attr(&#x27;class&#x27;);//设置元素的class属性值为false,如果设置的属性节点不存在，系统会自动生成$(&#x27;div&#x27;).attr(&#x27;class&#x27;,&#x27;box1&#x27;);//删除class属性$(&#x27;div&#x27;).removeAttr(&#x27;class&#x27;);//删除多个用空格隔开$(&#x27;div&#x27;).removeAttr(&#x27;class name id&#x27;); prop()方法123456//获得属性节点的值$(&#x27;input&#x27;).prop(&#x27;checked&#x27;);//设置元素的checked属性值为false$(&#x27;input&#x27;).prop(&#x27;checked&#x27;,false);//删除checked属性节点$(&#x27;input&#x27;).removeProp(&#x27;checked&#x27;); 语法 说明 prop(name) 取得第一个匹配元素的属性值，否则返回undefined prop(name,value) 为所有匹配的元素设置一个属性值 removeProp(name) 从每一个匹配的元素中删除一个属性 具有true/false操作状态时使用prop，如checked、selected、disabled；其它用attr 元素特殊属性宽高属性 设置或者获取高度 1234//带参数表示设置高度$(&#x27;img&#x27;).height(200);//不带参数获取高度$(&#x27;img&#x27;).height(); 获取网页的可视区宽高 1234//获取可视区宽度$(window).width();//获取可视区高度$(window).height(); 位置属性 offset方法获取元素距离document的位置，position方法获取的是元素距离有定位的父元素的位置 1234//获取元素距离document的位置,返回值为对象：&#123;left:100, top:100&#125;$(selector).offset();//获取相对于其最近的有定位的父元素的位置。$(selector).position(); 垂直滚动条位置 设置或者获取垂直滚动条的位置 1234//获取页面被卷曲的高度$(window).scrollTop();//获取页面被卷曲的宽度$(window).scrollLeft(); 获取和设置元素的滚动偏移量 1&lt;div class=&quot;scroll&quot;&gt;我是div......&lt;/div&gt; 1234// 获取滚动的偏移位console.log($(&quot;.scroll&quot;).scrollTop());// 设置滚动的偏移位$(&quot;.scroll&quot;).scrollTop(300); 设置网页的滚动偏移量 123456//获取网页滚动的偏移位// 注意点: 为了保证浏览器的兼容, 获取网页滚动的偏移位需要按照如下写法console.log($(&quot;body&quot;).scrollTop()+$(&quot;html&quot;).scrollTop());// 设置网页滚动偏移位// 注意点: 为了保证浏览器的兼容, 设置网页滚动偏移位的时候必须按照如下写法$(&quot;html,body&quot;).scrollTop(300); 折叠菜单12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;jquery-3.4.1.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;&quot;&gt; &lt;style&gt; ul&#123;list-style:none;padding:0;margin:0&#125; div&#123;width:150px;border:1px solid #515E7B;margin:10px;&#125; div li&#123;background:#515E7B;border-bottom:1px solid #fff;&#125; div li a&#123;text-decoration:none;color:#fff;font-size:16px;height:40px;line-height:40px;padding-left:10px;&#125; div li a:hover&#123;text-decoration:underline;&#125; .wrap &#123;width:150px;display:none;&#125; .wrap li&#123;background: #fff;margin: 0;&#125; .wrap li a&#123;color:#3B475F;font-size:12px;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;fold&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;信息管理&lt;/a&gt; &lt;ul class=&quot;wrap&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;未读信息&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;已读信息&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;信息列表&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;商品管理&lt;/a&gt; &lt;ul class=&quot;wrap&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;商品添加&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;商品列表&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;商品分类&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;用户管理&lt;/a&gt; &lt;ul class=&quot;wrap&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;权限设置&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;用户列表&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;重置密码&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; // 默认第一个显示：css--display:block $(&quot;.wrap:first&quot;).css(&#x27;display&#x27;,&#x27;block&#x27;); //添加点击事件，当前显示,其它隐藏 $(&quot;#fold&gt;ul&gt;li&quot;).click(function()&#123; //无需遍历，直接添加事件 $(this).siblings(&#x27;li&#x27;).find(&#x27;.wrap&#x27;).css(&#123;display:&#x27;none&#x27;&#125;); $(this).find(&#x27;.wrap&#x27;).css(&#123;display:&#x27;block&#x27;&#125;); &#125; ); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","path":"page/jQuery03.html","date":"05-04","excerpt":"","tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://xiaoliblog.cn/tags/jQuery/"}]},{"title":"jQuery🌞jQuery选择器","text":"基本选择器 基本选择器常用的有标签选择器、类选择器和ID选择器 CSS选择器 功能描述 示例 li&#123;color:red&#125; 根据指定元素名匹配所有元素 ${“li”} .bar&#123;color:red&#125; 根据指定类名匹配所有元素 ${“.bar”} #btn&#123;color:red&#125; 根据指定id匹配一个元素 ${“#bar}” li,.bar,#btn&#123;color:red&#125; 同时获取多个元素 ${“li,p,div”} 层级选择器 选择器 示例 功能描述 selector selector1 $(&quot;div .test&quot;) 选取&lt;div&gt;下所有class名为test的元素（多级） parent &gt; child $(&quot;.box &gt; .con&quot;) 选取class名为box下的所有class名为con的子元素（一级） prev + next $(&quot;div + .title&quot;) 获取紧邻&lt;div&gt;的下一个class名为title的兄弟节点 prev ~ siblings $(&quot;.bar ~ li&quot;) 获取class名为bar的元素后的所有同级元素节点&lt;li&gt; 基本过滤选择器 选择器 示例 功能描述 :first $(&quot;li : first&quot;) 获取第1个&lt;li&gt;元素 :last $(&quot;li : last&quot;) 获取最后1个&lt;li&gt;元素 :even $(&quot;li :even&quot;) 获取所有li元素中，索引为偶数的奇数行数据,从0开始 :odd $(&quot;li :odd&quot;) 获取所有li元素中，索引为奇数数的偶数行数据，从0开始 :eq(index) $(&quot;li:eq(3)&quot;) 获取索引为3的li元素 :gt(index) $(&quot;li :eq(3)&quot;) 获取索引大于3的li元素 :It(index) $(&quot;li :It(3)&quot;) 获取索引小于3的li元素 :not(seletor) $(&quot;li :not(li:qe(3))&quot;) 获取除指定选择器外的其他元素，获取除索引为3的li元素 :focus $(&quot;inputs:focus&quot;) 匹配当前获取焦点的input元素 :animated $(&quot;div:not(:animated)&quot;) 匹配当前没有执行动画的div元素 内容选择器 选择器 功能描述 示例 :contains(text) 获取内容包含1text文本的元素 &amp;(&quot;li:contains(&#39;js&#39;)&quot;)获取内容中含’js’的li元素 :empty 获取内容为空的元素 $(&quot;li:empty&quot;)获取内容为空的li元素 :has(selector) 获取内容包含指定选择器元素 $(&quot;li:has(&#39;a&#39;)&quot;)获取内容中含a元素的所有li元素 :parent 获取内容不为空的元素(特殊) $(&quot;li:parent&quot;)获取内容不为空的li元素 可见性选择器 选择器 功能描述 示例 :hidden 获取所有隐藏元素 $(&quot;li:hidden&quot;)获取所有隐藏的li元素 :visible 获取所有可见元素 $(&quot;li:visible&quot;)获取所有可见的li元素 属性选择器 选择器 功能描述 示例 [attr] 获取具体指定属性的元素 $(&quot;div[class]&quot;)获取含有class属性的所有div元素 [attr=value] 获取属性值等于value的元素 $(&quot;div[class=current]&quot;)获取class等于current的所有div元素 [attr！=value] 获取属性值不等于value的元素 $(&quot;div[class！=current]&quot;)获取class不等于current的所有div元素 [attr^=value] 获取属性值以value开始的元素 $(&quot;div[class^box]&quot;)获取class以box开始的所有div元素 [attr$=value] 获取属性值以value结尾的元素 $(&quot;div[class$box]&quot;)获取class以box结尾的所有div元素 [attr*=value] 获取属性值包含value的元素 $(&quot;div[class\\*=&#39;-&#39;]&quot;)获取class含有’-‘的所有div元素 [attr~=value] 获取元素的属性值包含一个value，以空格隔开 $(&quot;div[class~=&#39;box&#39;]&quot;)获取class属性值等于’box’或通过空格分隔并含有box的div元素，如”t box” [attr1][attr2]...[attrN] 获取同时拥有多个属性的元素 $(&quot;input[id][name$=&#39;usr&#39;]&quot;)获取同时含有id属性和属性值以usr结尾的name属性的input元素 子元素选择器 选择器 功能描述 :nth-child(index/even/odd/公式) 索引index默认从1开始，匹配指定index索引、偶数、奇书、或符合指定公式(如2n,n默认从0开始)的子元素 :first-child 获取第一个子元素 :last-child 获取最后一个子元素 :only-child 如果当前元素时唯一的子元素，则匹配 :nth-last-child(index/even/odd/公式) 选择所有它们父元素的第n个子元素，计数从最后一个元素开始到第一个 :nth-of-type(index/even/odd/公式) 选择同一个父元素之下，并且标签名相同的子元素中的第n个子元素 :first-of-type 选择所有相同的元素名称的第一个子元素 :last-of-type 选择所有相同的元素名称的最后一个子元素 :only-of-type 选择所有没有兄弟元素，且具有相同的元素名称的元素 :nth-last-of-type(index/even/odd/公式) 选择所有它们的父级元素的第n个子元素，计数从最后一个元素开始到第一个 表单选择器 选择器 功能描述 :input 获取页面中的所有表单元素，包含select元素和textarea元素 :text 选取页面中的所有文本框 :password 选取所有的密码框 :radio 选取所有的单选按钮 :checkbox 选取所有的复选框 :submit 获取submit提交按钮 :reset 获取reset重置按钮 :image 获取type=”image”的图像域 :button 获取button按钮，包括button标签和type=”button” :file 获取type=”file”的文件域 :hidden 获取隐藏表单项 :enabled 获取所有可用表单元素 :disabled 获取所有不可用表单元素 :checked 获取所有选中的表单元素，主要针对radio和checkbox :selected 获取所有可用表单元素，主要针对select 元素筛选函数 语法 说明 $(&quot;ul&quot;).find(&quot;span&quot;) 返回&lt;ul&gt; 后代中所有的&lt;span&gt; 元素 $(&quot;ul&quot;).siblings(&quot;span&quot;)) 返回与&lt;ul&gt; 同级的所有的 &lt;span&gt; 元素 $(&quot;ul&quot;).next(&quot;span&quot;)) 匹配&lt;ul&gt;紧邻的同级的下一个&lt;span&gt;元素 $(&quot;ul&quot;). prev(&quot;span&quot;)) 匹配&lt;ul&gt;紧邻的同级的上一个&lt;span&gt;元素 获取第三层的第一个li 1$(&#x27;#fold&gt;ul&gt;li:first&#x27;) 通过上面的li，获得其下class为wrap的元素 1$(&#x27;#fold&gt;ul&gt;li:first&#x27;).find(&#x27;.wrap&#x27;);","path":"page/jQuery02.html","date":"05-04","excerpt":"","tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://xiaoliblog.cn/tags/jQuery/"}]},{"title":"jQuery🌞jQuery基础及静态方法","text":"jQuery 基本概念 jQuery：一款优秀的JavaScript框架库，封装了很多的JavaScript函数 作用：简化了HTML与JavaScript之间的操作，使得DOM对象、事件处理、动画效果、Ajax等操作的实现语法更加简洁，提高了程序的开发效率，消除很多跨浏览器的兼容问题 下载jQuery 官方网址：http://jquery.com jQuery下载加速地址：https://www.jq22.com/jquery-info122 学习源码：https://gitee.com/ruokeqx/weblearn 引入jQuery 下载：minified（压缩版：去掉注释和空白行，体积较小），引入本地下载的jQuery 1&lt;script src=&quot;jquery-1.12.4.min.js&quot;&gt;&lt;/scirpt&gt; 或者使用CDN：内容分发网络，通过CDN的优势可以加快jQuery文件的访问速度 1&lt;script src=&quot;https://code.jquery.com/jquery-3.4.1.min.js&quot; &gt;&lt;/script&gt; 使用jQuery 在HTML页面中给三个div设置背景颜色 123&lt;div&gt;&lt;/div&gt;&lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;div id=&quot;box2&quot;&gt;&lt;/div&gt; 123456789//原生JSwindow.onload = function (ev) &#123; var div1 = document.getElementsByTagName(&#x27;div&#x27;)[0]; var div2 = document.getElementsByClassName(&#x27;box1&#x27;)[0]; var div3 = document.getElementById(&#x27;box2&#x27;); div1.style.backgroundColor = &quot;red&quot;; div2.style.backgroundColor = &quot;green&quot;; div3.style.backgroundColor = &quot;yellow&quot;;&#125; 1234567891011121314151617//jQuery$(function () &#123; var $div1 = $(&#x27;div&#x27;); var $div2 = $(&#x27;.box1&#x27;); var $div3 = $(&#x27;#box2&#x27;); $div1.css(&#123; background: &quot;red&quot;, width: &quot;200px&quot;, height: &quot;200px&quot; &#125;), $div2.css(&#123; background: &quot;blue&quot;, &#125;), $div3.css(&#123; background: &quot;green&quot;, &#125;)&#125;) 入口函数 jQuery和原生JS的入口函数 12345678910111213//原生JS的固定写法window.onload = function(ev)&#123;&#125;//jQuery固定写法//第一种写法$(document).ready(function() &#123; &#125;);//第二种写法$(function() &#123; &#125;); jQuery和原生JS的入口函数加载模式不同 JavaScript的入口函数要等到页面中所有资源（包括图片、文件）加载完成才开始执行 jQuery的入口函数只会等待文档树加载完成就开始执行，并不会等待图片、文件的加载 1234567891011121314151617181920212223242526&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xiaoliblog/MyCDNRepo/img/headerimg.png&quot;/&gt;&lt;script&gt;//原生JS window.onload = function(ev)&#123; //1.通过原生JS入口函数可以拿到DOM元素 var img = document.getElementsByTagName(&#x27;img&#x27;)[0]; console.log(img); // 2.通过原生的JS入口函数可以拿到DOM元素的宽高 var width = window.getComputedStyle(img).width; console.log(&quot;onload:&quot;,width); &#125; /* * 1.原生JS和jQuery入口函数的加载模式不同 * 原生JS会等到DOM元素加载完毕,并且图片也加载完毕才会执行 * jQuery会等到DOM元素加载完毕,但不会等到图片也加载完毕就会执行 * *///jQuery $(document).ready(function()&#123; // 1.通过jQuery入口函数可以拿到DOM元素 var $img = $(&#x27;img&#x27;); console.log($img); // 2.通过jQuery入口函数不可以拿到DOM元素的宽高 var $width = $img.width(); console.log(&quot;ready:&quot;,$width); &#125;)&lt;/script&gt; 当出现多个入口函数时有所不同 原生的JavaScript如果编写了多个入口函数，后面编写的会覆盖前面编写的 jQuery中编写多个入口函数，后面的不会覆盖前面的 123456789101112$(document).ready(function () &#123; alert(&quot;hello lnj1&quot;);&#125;);$(document).ready(function () &#123; alert(&quot;hello lnj2&quot;);&#125;);// window.onload = function (ev) &#123;// alert(&quot;hello lnj1&quot;);// &#125;// window.onload = function (ev) &#123;// alert(&quot;hello lnj2&quot;);// &#125; 冲突问题 当你使用的其他框架也含有$符号时，会根据引入顺序进行覆盖，后引入的覆盖先前引入的。这就使得程序员只能丢弃其中一种框架，从而解决冲突。但是我们可以通过释放jQuery中$的使用权来进行冲突解决 注意点 释放操作必须在编写其它jQuery代码之前编写 释放之后就不能再使用$，改为使用自定义的符号（默认为jQuery） 12345678//1. 释放$的使用权//jQuery.noConflict();// 2.自定义一个访问符号var nj = jQuery.noConflict();nj(function()&#123; alert(&quot;test&quot;)&#125;) 核心函数 $()就代表调用jQuery的核心参数，它可以接收函数、字符串、字符串选择器、代码片段、DOM元素 123&lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;div id=&quot;box2&quot;&gt;&lt;/div&gt;&lt;span&gt;我是span&lt;/span&gt; 12345678910111213141516171819202122//1.接收一个函数$(function () &#123; alert(&quot;hello lnj&quot;); // 2.接收一个字符串 // 2.1接收一个字符串选择器 // 返回一个jQuery对象, 对象中保存了找到的DOM元素 var $box1 = $(&quot;.box1&quot;); var $box2 = $(&quot;#box2&quot;); console.log($box1); console.log($box2); // 2.2接收一个字符串代码片段 // 返回一个jQuery对象, 对象中保存了创建的DOM元素 var $p = $(&quot;&lt;p&gt;我是段落&lt;/p&gt;&quot;); console.log($p); $box1.append($p); // 3.接收一个DOM元素 // 会被包装成一个jQuery对象返回给我们 var span = document.getElementsByTagName(&quot;span&quot;)[0]; console.log(span); var $span = $(span); console.log($span);&#125;); jQuery对象 DOM对象：使用JavaScript中的方法获取页面中的元素返回的对象就是dom对象。 jQuery对象：jquery对象就是使用jquery的方法获取页面中的元素返回的对象就是jQuery对象。 jQuery对象其实就是DOM对象的包装集包装了DOM对象的集合（伪数组） DOM对象与jQuery对象的方法不能混用 123&lt;div&gt;div1&lt;/div&gt;&lt;div&gt;div2&lt;/div&gt;&lt;div&gt;div3&lt;/div&gt; 12345678910$(function () &#123;//jQuery对象是一个伪数组//伪数组:有0到length-1的属性, 并且有length属性 var $div = $(&quot;div&quot;); console.log($div);//与数组对比一下 var arr = [1, 3, 5]; console.log(arr);&#125;); 静态方法 静态方法通过类名调用 实例方法通过实例调用 1234567891011121314151617181920// 1.定义一个类function AClass() &#123;&#125;// 2.给这个类添加一个静态方法// 直接添加给类的就是静态方法AClass.staticMethod = function () &#123; alert(&quot;staticMethod&quot;);&#125;// 静态方法通过类名调用AClass.staticMethod();s// 3.给这个类添加一个实例方法AClass.prototype.instanceMethod = function () &#123; alert(&quot;instanceMethod&quot;);&#125;// 实例方法通过类的实例调用// 创建一个实例(创建一个对象)var a = new AClass();// 通过实例调用实例方法a.instanceMethod(); each()方法 原生的forEach方法只能遍历数组, 不能遍历伪数组 12345678910111213var arr = [1, 3, 5, 7, 9];var obj = &#123;0:1, 1:3, 2:5, 3:7, 4:9, length:5&#125;;/*第一个参数: 遍历到的元素第二个参数: 当前遍历到的索引*/arr.forEach(function(value,index)&#123; console.log(index,value);&#125;)//以下会报错obj.forEach(function(value,index)&#123; console.log(index,value);&#125;) 利用jQuery的each静态方法遍历数组，可以遍历伪数组 123$.each(obj, function (index, value) &#123; console.log(index, value);&#125;); map()方法 .利用原生JS的map方法遍历，和原生的forEach一样,不能遍历的伪数组 1234567891011121314var arr = [1, 3, 5, 7, 9];var obj = &#123; 0: 1, 1: 3, 2: 5, 3: 7, 4: 9, length: 5 &#125;;/*第一个参数: 当前遍历到的元素第二个参数: 当前遍历到的索引第三个参数: 当前被遍历的数组*/arr.map(function (value, index, array) &#123; console.log(index, value, array);&#125;);//同样会报错obj.map(function (value, index, array) &#123; console.log(index, value, array);\\&#125;); jQuery的map()方法 123456789101112131415161718/*第一个参数: 要遍历的数组第二个参数: 每遍历一个元素之后执行的回调函数回调函数的参数: 第一个参数: 遍历到的元素 第二个参数: 遍历到的索引*/var res = $.map(obj, function (value, index) &#123; console.log(index, value); return value + index;&#125;);var res2 = $.each(obj, function (index, value) &#123; console.log(index, value); return value + index;&#125;);console.log(res);console.log(res2); jQuery中的each静态方法和map静态方法的区别: each静态方法默认的返回值就是, 遍历谁就返回谁 map静态方法默认的返回值是一个空数组 each静态方法不支持在回调函数中对遍历的数组进行处理 map静态方法可以在回调函数中通过return对遍历的数组进行处理, 然后生成一个新的数组返回 holdReady()方法 由于jQuery是在DOM加载完后入口函数调用，但有时候想要其他资源中jQuery调用之前就执行 所以$.holdReady(true)作用就是暂停ready入口函数执行 恢复改为$.holdReady(false)即可 1&lt;button&gt;恢复ready事件&lt;/button&gt; 123456789// $.holdReady(true); 作用: 暂停ready执行$.holdReady(true);$(document).ready(function () &#123; alert(&quot;ready&quot;);&#125;);var btn = document.getElementsByTagName(&quot;button&quot;)[0];btn.onclick = function () &#123; $.holdReady(false); //恢复ready事件，弹窗&#125; 其他静态方法 trim() 作用：去除字符串空格 参数：参数伪去除空格的字符串 返回值：去除空格之后的字符串 123var str = &quot; China &quot;;var newStr = $.trim(str);console.log(&quot;---&quot;+newStr+&quot;---&quot;) 判断方法 123isArray(obj)isFunction(obj)isWindow(obj)","path":"page/jQuery01.html","date":"05-04","excerpt":"","tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://xiaoliblog.cn/tags/jQuery/"}]},{"title":"Ajax🌞Ajax进阶操作","text":"nodemon nodemon是一种工具，可以自动检测到目录中的文件更改时通过重新启动应用程序来调试基于node.js的应用程序 nodemon官方地址：https://www.npmjs.com/package/nodemon 使用nodemon工具后当修改了服务器代码就不需要手动重启服务器了 安装nodemon 输入一下命令安装 1npm install -g nodemon 使用nodemon 不再使用node运行服务器脚本，而是使用如下命令 1nodemon xxx.js Ajax进阶IE缓存问题 IE浏览器会对Ajax请求的结果进行缓存，因此下一次访问时访问到的是本地缓存的数据，而不是页面更新的数据 修改服务器端 1234567//针对IE缓存app.get(&#x27;/server-ie&#x27;, (request, response) =&gt;&#123; //设置响应头,设置允许跨域，解决跨域问题 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;*&#x27;); //设置响应体 response.send(&#x27;Hello IE - 1&#x27;)&#125;); 前端方式Ajax请求 12//2. 初始化，设置请求方法和URLxhr.open(&quot;GET&quot;, &quot;http://localhost:8000/server-ie&quot;); 此时IE浏览器结果为第一次Ajax的结果 修改服务器端响应体，再访问IE发现结果还是第一次Ajax的结果，这就是IE缓存问题 1response.send(&#x27;Hello IE - 1&#x27;) 那如何解决呢？只需要在前端Ajax请求URL加一个时间戳参数，让浏览器认为是两次不同的请求 12//获取当前时间戳，时间戳不一样浏览器就会认为是两次不不同的请求xhr.open(&quot;GET&quot;, &quot;http://localhost:8000/server-ie?t=&quot;+Date.now()); 此时刷新IE浏览器 请求超时处理 当出现由于网络等其他问题出现请求超时时，Ajax需要对这种请求进行处理 服务器延迟设置 12345678//延时响应app.get(&#x27;/server-delay&#x27;, (request, response) =&gt;&#123; //设置响应头,设置允许跨域，解决跨域问题 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;*&#x27;); setTimeout(()=&gt;&#123; response.send(&#x27;延时响应&#x27;) &#125;,3000)&#125;); 前端发送Ajax时，对请求超时和网络异常的处理 1234567891011121314//1. 创建对象const xhr = new XMLHttpRequest();//超时设置xhr.timeout = 2000; //2s之内没有收到结果就把请求取消，认为超时//超时回调xhr.ontimeout = function()&#123; alert(&quot;网络异常，请稍后重新！&quot;)&#125;//网络异常回调xhr.onerror = function()&#123; alert(&quot;你的网络出现了问题！&quot;)&#125;xhr.open(&quot;GET&quot;, &quot;http://localhost:8000/server-delay&quot;);//... 取消请求 调用abort()方法即可 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Ajax 取消请求&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;点击发送&lt;/button&gt; &lt;button&gt;点击取消&lt;/button&gt;&lt;/button&gt; &lt;script&gt; //获取button元素 const btns = document.querySelectorAll(&#x27;button&#x27;); let xhr =null; btns[0].onclick = function()&#123; xhr = new XMLHttpRequest(); xhr.open(&quot;GET&quot;, &quot;http://localhost:8000/server-delay&quot;); xhr.send(); &#125; btns[1].onclick = function()&#123; //取消请求 xhr.abort(); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 请求重复发送 每点击一次发送按钮就发送一次Ajax请求，如果服务器响应慢，用户频繁发同一个请求就会加大服务器的压力 可以判断是否为同一次请求，如果是就取消掉 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Ajax 取消请求&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;点击发送&lt;/button&gt; &lt;script&gt; //获取button元素 const btns = document.querySelectorAll(&#x27;button&#x27;); let xhr =null; //标识变量 let isSending = false; //是否正在发送Ajax请求 btns[0].onclick = function()&#123; //判断标识变量 if(isSending)&#123; //如果正在发送，则取消该请求，创建一个新的请求 xhr.abort(); &#125; xhr = new XMLHttpRequest(); //修改标识变量的值 isSending = true; xhr.open(&quot;GET&quot;, &quot;http://localhost:8000/server-delay&quot;); xhr.send(); //请求完成后 xhr.onreadystatechange = function()&#123; //4表示请求完成，不论成功还是失败 if(xhr.readyState === 4)&#123; //修改标识变量 isSending = false; &#125; &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; jQuery发送Ajax发送单个请求 服务器端设置 12345678app.all(&#x27;/server-jQuery&#x27;, (request, response) =&gt;&#123; //设置响应头,设置允许跨域，解决跨域问题 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;*&#x27;); const data = &#123; name:&quot;李白&quot; &#125; response.send(JSON.stringify(data)) &#125;); 通过jQuery发送Ajax请求，注意它的四个参数 123456789101112131415161718//获取第一个按钮绑定点击事件 $(&#x27;button&#x27;).eq(0).click(function () &#123; //(URL,参数,回调函数，响应的类型) $.get(&#x27;http://localhost:8000/server-jQuery&#x27;, &#123; a: 100, b: 200 &#125;, function (data) &#123; console.log(data) //打印服务器返回的结果 &#125;,&#x27;json&#x27;)&#125;)//获取第二个按钮绑定点击事件 $(&#x27;button&#x27;).eq(1).click(function () &#123; //(URL,参数,回调函数，响应的类型) $.post(&#x27;http://localhost:8000/server-jQuery&#x27;, &#123; a: 100, b: 200 &#125;, function (data) &#123; console.log(data) &#125;,&#x27;json&#x27;)&#125;) 发送通用型请求 推荐使用通用型，参数为一个对象，由属性来控制 12345678910111213141516171819202122232425262728293031//获取第三个按钮绑定点击事件$(&#x27;button&#x27;).eq(2).click(function () &#123; //参数为一个对象，由属性来设置 $.ajax(&#123; //请求类型 type:&#x27;GET&#x27;, //url请求地址 url:&#x27;http://localhost:8000/server-jQuery&#x27;, //参数 data:&#123;a:100,b:200&#125;, //响应体结果 dataType: &#x27;json&#x27;, //成功的回调函数 success:function(data)&#123; console.log(data) &#125;, //超时时间，超过2s就调用error失败回调函数 timeout: 2000, //失败的回调 error:function()&#123; consloe.log(&#x27;出错啦!&#x27;) &#125;, //头信息 header:&#123; name:&#x27;李白&#x27;, age: 21 &#125; //自定义的头信息，服务器端需要添加以下头 // response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&#x27;*&#x27;); &#125;)&#125;) Axios发送Ajax Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中 Axios中文文档：http://www.axios-js.com/zh-cn/docs/ 引入在线CDN 1&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/axios/0.21.1/axios.min.js&quot;&gt;&lt;/script&gt; 发送单个请求12345678910111213141516171819202122232425262728293031323334353637383940414243 const btns = document.querySelectorAll(&#x27;button&#x27;); //配置baseURLaxios.defaults.baseURL = &#x27;http://localhost:8000&#x27;;//GET请求btns[0].onclick = function()&#123; //GET请求 配置了baseURL，就不需要写IP:端口，以下等价于http://localhost:8000/server-axios axios.get(&#x27;/server-axios&#x27;,&#123; //url参数 params:&#123; id:1, age:21 &#125;, //请求头信息 headers:&#123; name:123 &#125; &#125;).then(value =&gt;&#123; console.log(value); &#125;)&#125;//POST请求btns[1].onclick = function()&#123; //(url,请求体,其他配置) axios.post(&#x27;/server-axios&#x27;,&#123; username:&#x27;admin&#x27;, password:&#x27;admin&#x27; &#125;,&#123; //url参数 params:&#123; id:2, age:22 &#125;, //请求头信息 headers:&#123; height:100, wight:200 &#125; &#125;).then(value =&gt;&#123; console.log(value); &#125;)&#125; 发送通用型请求123456789101112131415161718192021222324252627282930313233btns[2].onclick = function () &#123; axios(&#123; //请求方法 method: &#x27;POST&#x27;, //url url: &#x27;server-axios&#x27;, //url参数 params: &#123; id: 3, age: 23 &#125;, //头信息 headers: &#123; a: 100, b: 100 &#125;, //请求体参数 data: &#123; username: &#x27;admin&#x27;, password: &#x27;admin&#x27; &#125; &#125;).then(response =&gt; &#123; console.log(response); //响应状态码 console.log(response.status); //响应状态字符串 console.log(response.statusText); //响应头信息 console.log(response.headers); //响应体 console.log(response.data); &#125;)&#125; fetch函数发送Ajax fetch()具体查看MDN Web Docs文档 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;Ajax请求&lt;/button&gt; &lt;script&gt; const btn = document.querySelector(&#x27;button&#x27;); btn.onclick = function () &#123; fetch(&#x27;http:localhost:8000/server-fetch&#x27;, &#123; //请求方法 method: &#x27;POST&#x27;, //请求头 headers: &#123; name: &#x27;xiaoliblog&#x27; &#125;, //请求体 body: &#x27;username=admin&amp;password=admin&#x27; &#125;).then(response =&gt; &#123; return response.text(); //return response.json; &#125;).then(response =&gt; &#123; console.log(response) &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","path":"page/Ajax02.html","date":"05-04","excerpt":"","tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://xiaoliblog.cn/tags/Ajax/"}]},{"title":"Ajax🌞Ajax基本操作","text":"Ajax Ajax：Asynchronous JavaScript And XML，即异步JavaScript和XML技术。 描述：不是一门新的语言或技术，是由JavaScript、XML、DOM、CSS等多种已有技术组合而成的一种浏览器端技术。 功能：用于实现与服务器进行异步交互的功能。 传统Web工作流程每当用户触发一个页面HTTP请求，就需要服务器返回一个新的页面 Ajax工作流程页面通过Ajax对象与服务器进行通信，然后通过DOM操作将返回的结果更新到页面中，整个过程都是在同一个页面中进行的Ajax技术的创新之处在于，改善了传统的“请求-等待-响应-刷新-返回数据”模式，在信息返回之前，用户可以继续自己的操作，当前页面不会因为请求而刷新。这样大大的提高了交互性。 相较于传统页面，Ajax技术的优势具体有以下几个方面： 无需刷新页面与服务器端进行交互 允许根据用户事件来更新部分页面的内容 Ajax缺点 没有浏览历史，不能回退 存在跨域问题（同源） SEO（Search Engine Optimization搜索引擎优化）不友好，网页爬虫爬不到数据 服务端搭建安装Express 安装好Node.js后，使用Express服务器框架进行搭建 Express官网地址：https://www.expressjs.com.cn/ 首先创建一个文件夹，然后输入以下命令进行初始化，会生成package.json 1npm init --yes 然后安装Express 1npm i express 服务器搭建 创建一个JS文件，比如express_demo.js 123456789101112131415161718//1. 引入Expressconst express = require(&#x27;express&#x27;);//2. 创建应用对象const app = express();//3. 创建路由规则//request是对请求报文的封装//response是对响应报文的封装app.get(&#x27;/&#x27;, (request, response) =&gt;&#123; //设置响应 response.send(&quot;Hello Express&quot;);&#125;);//4. 监听端口启动服务app.listen(8000,()=&gt;&#123; console.log(&quot;服务已经启动,8000 端口监听中...&quot;)&#125;) 在终端中打开，使用node运行脚本 1node express_demo.js Ajax发送GET请求服务端设置 修改URL为http://localhost:8000/server即可· 1234567891011121314151617181920//1. 引入Expressconst express = require(&#x27;express&#x27;);//2. 创建应用对象const app = express();//3. 创建路由规则//request是对请求报文的封装//response是对响应报文的封装app.get(&#x27;/server&#x27;, (request, response) =&gt;&#123; //设置响应头,设置允许跨域，解决跨域问题 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;*&#x27;); //设置响应体 response.send(&#x27;Hello Ajax&#x27;)&#125;);//4. 监听端口启动服务app.listen(8000,()=&gt;&#123; console.log(&quot;服务已经启动,8000 端口监听中...&quot;)&#125;) Ajax基本操作 页面无刷新获取服务器返回结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Ajax GET请求&lt;/title&gt; &lt;style&gt; #result &#123; width: 200px; height: 100px; border: solid 1px skyblue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;点击发送请求&lt;/button&gt; &lt;div id=&quot;result&quot;&gt;&lt;/div&gt; &lt;script&gt; //获取button元素 const btn = document.getElementsByTagName(&quot;button&quot;)[0]; const result = document.getElementById(&quot;result&quot;); //绑定事件,发送Ajax btn.onclick = function () &#123; //1. 创建对象 const xhr = new XMLHttpRequest(); //2. 初始化，设置请求方法和URL xhr.open(&quot;GET&quot;, &quot;http://localhost:8000/server&quot;); //3. 发送 xhr.send(); //4. 事件绑定，处理服务端返回的结果 xhr.onreadystatechange = function () &#123; //readyState是对象的属性，表示状态 0 1 2 3 4 //判断(4表示服务端返回了所有的结果) if (xhr.readyState === 4) &#123; //判断响应状态码 200 404 500 // 2xx 都表示成功 if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123; //处理结果 //1. 响应行 console.log(xhr.status); //响应状态码 console.log(xhr.statusText); //状态字符串 console.log(xhr.getAllResponseHeaders()); //所以响应头 console.log(xhr.response); //响应体 //设置result的文本 result.innerHTML = xhr.response; &#125; else &#123; &#125; &#125; &#125;; &#125;; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 设置请求参数 在请求URL中添加即可 1xhr.open(&quot;GET&quot;, &quot;http://localhost:8000/server?a=100&amp;b=100&quot;); Ajax发送POST请求服务器设置 增加post路由规则 123456app.post(&#x27;/server&#x27;, (request, response) =&gt;&#123; //设置响应头,设置允许跨域，解决跨域问题 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;*&#x27;); //设置响应体 response.send(&#x27;Hello Ajax POST&#x27;)&#125;); 每次修改JS都需要重新启动一下服务器 发送请求123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Ajax Post请求&lt;/title&gt; &lt;style&gt; #result &#123; width: 200px; height: 100px; border: solid 1px skyblue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;result&quot;&gt;&lt;/div&gt; &lt;script&gt; //获取元素对象 const result = document.getElementById(&quot;result&quot;); //绑定事件,发送Ajax 鼠标移入div就发送Ajax result.addEventListener(&quot;mouseover&quot;, function () &#123; //1. 创建对象 const xhr = new XMLHttpRequest(); //2. 设置请求类型和URL xhr.open(&quot;POST&quot;, &quot;http://localhost:8000/server&quot;); //3. 发送 xhr.send(); //4. 事件绑定 xhr.onreadystatechange = function () &#123; //判断 if (xhr.readyState === 4) &#123; if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123; //处理服务器端返回的结果 result.innerHTML = xhr.response; &#125; &#125; &#125;; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 设置请求参数 POST设置请求参数如下 123xhr.send(&#x27;a=100&amp;b=100&#x27;);//也可以用以下方法书写xhr.send(&#x27;a:100&amp;b:100&#x27;); POST请求参数在地址栏是看不到，需要到响应体中查看 设置请求头 在第二和第三步之间设置请求头 12345//2. 设置请求类型和URLxhr.open(&quot;POST&quot;, &quot;http://localhost:8000/server&quot;);xhr.setRequestHeader(&#x27;Content-type&#x27;,&#x27;application/x-www-form-urlencoded&#x27;);//3. 发送xhr.send(&#x27;a=100&amp;b=100&#x27;); 可以自定义请求头，但需要服务器进行设置 12345678//在服务器设置如下app.all(&#x27;/server&#x27;, (request, response) =&gt;&#123; //设置响应头,设置允许跨域，解决跨域问题 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;*&#x27;); response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&#x27;*&#x27;); //设置响应体 response.send(&#x27;Hello Ajax POST&#x27;)&#125;); 1xhr.setRequestHeader(&#x27;name&#x27;,&#x27;lzy&#x27;) JSON数据 JSON是一种轻量级的数据交换格式，它采用完全独立于语言的文本格式 服务端设置 服务端设置返回一个对象 123456789101112app.get(&#x27;/server&#x27;, (request, response) =&gt;&#123; //设置响应头,设置允许跨域，解决跨域问题 response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;*&#x27;); //响应一个对象 const data = &#123; name: &#x27;李白&#x27; &#125;; //对对象进行字符串转换 let str = JSON.stringify(data); //设置响应体，响应体内只能村妇字符串和buffer response.send(str)&#125;); 手动转换 前端接收的是JSON对象，可以通过手动转换的方式 123456789 xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4)&#123; if(xhr.status &gt;=200 &amp;&amp; xhr.status &lt; 300)&#123; //手动对数据进行转换 let data = JSON.parse(xhr.response); result.innerHTML = data.name; //结果为：李白 &#125; &#125;&#125; 自动转换 自动转换需要设置响应体类型为JSON格式，其会自动转化为JSON格式 123456789101112//设置响应体数据类型xhr.responseType = &#x27;json&#x27;;xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4)&#123; if(xhr.status &gt;=200 &amp;&amp; xhr.status &lt; 300)&#123; //2. 自动转换 console.log(xhr.response) result.innerHTML = xhr.response.name; //结果为李白 &#125; &#125;&#125;","path":"page/Ajax01.html","date":"05-04","excerpt":"","tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://xiaoliblog.cn/tags/Ajax/"}]},{"title":"前端实例🥳响应式网站首页","text":"项目准备JS库 本项目采用了animejs库：https://www.animejs.cn/，用于JS控制HTML动画 轮播组件使用glidejs库：https://glidejs.com/ 用于排列和筛选使用Isotope库`：https://isotope.metafizzy.co/ 当页面滑动到一定程度时使用动画展现效果，使用ScrollReveal：https://scrollrevealjs.org/ 当点击导航链接后流畅滑动到对应目标处使用smooth-scroll：https://github.com/cferdinandi/smooth-scroll 所需组件的JS库 项目结构 创建项目工程，采用样式结构分离 创建index.html，style.css，index.js，lib存放JS库，images存放图片，videos存放视频 HTML结构 遵循语义化原则 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;script src=&quot;libs/scrollReveal/scrollreveal.min.js&quot;&gt;&lt;/script&gt; &lt;!-- font-awesome --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.bootcss.com/font-awesome/5.11.2/css/all.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;libs/glide/glide.core.min.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;libs/glide/glide.theme.min.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; /&gt; &lt;title&gt;峰华科技 - 创新型网络技术企业&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 头部 --&gt; &lt;header&gt;&lt;/header&gt; &lt;!--主体内容--&gt; &lt;section&gt;&lt;/section&gt; &lt;!-- 底部信息 --&gt; &lt;footer&gt;&lt;/footer&gt; &lt;!-- 轮播插件 --&gt; &lt;script src=&quot;libs/glide/glide.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 案例筛选组件 --&gt; &lt;script src=&quot;libs/isotope/isotope.pkgd.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 动画组件 --&gt; &lt;script src=&quot;libs/anime/anime.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 流畅滑动组件 --&gt; &lt;script src=&quot;libs/smooth-scroll/smooth-scroll.polyfills.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 自定义JS文件 --&gt; &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 全局样式1234567891011121314151617181920212223242526* &#123; margin: 0; padding: 0; box-sizing: border-box; font-family: Helvetica, &quot;PingFang SC&quot;, &quot;Microsoft Yahei&quot;, sans-serif; font-size: 14px;&#125;/* 图片默认宽度100% */img &#123; width: 100%;&#125;/* 定义变量 定义所需要的颜色变量*/:root &#123; --primary-color: #ff434f; --secondary-color: #e3e3e3; --text-color-lightest: #e7e9ec; --text-color-darker: #2e2e2e; --text-color-dark: #494949; --text-color-gray: #8b8b8b; --text-color-dark-gray: #727272; --text-color-light-gray: #c6c6c6; --backdrop-color: rgba(42, 42, 42, 0.69);&#125;/*使用方法：color: var(--text-color-lightest);*/ 正式开发导航栏 1234567891011121314151617181920&lt;!-- 头部 --&gt;&lt;header class=&quot;open&quot;&gt; &lt;div class=&quot;logo&quot;&gt;峰华科技&lt;/div&gt; &lt;!-- 导航 --&gt; &lt;nav&gt; &lt;a href=&quot;#home&quot;&gt;首页&lt;/a&gt; &lt;a href=&quot;#about-us&quot;&gt;关于我们&lt;/a&gt; &lt;a href=&quot;#showcases&quot;&gt;成功案例&lt;/a&gt; &lt;a href=&quot;#service&quot;&gt;服务流程&lt;/a&gt; &lt;a href=&quot;#team-intro&quot;&gt;团队介绍&lt;/a&gt; &lt;a href=&quot;#company-activities&quot;&gt;公司动态&lt;/a&gt; &lt;i class=&quot;fas fa-search&quot;&gt;&lt;/i&gt; &lt;/nav&gt; &lt;!-- 折叠导航按钮(三根横线) --&gt; &lt;div class=&quot;burger&quot;&gt; &lt;div class=&quot;burger-line1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;burger-line2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;burger-line3&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/header&gt; CSS样式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/* ============= 头部================== *//* 头部 */header &#123; width: 100vw; height: 80px; /* 栅格布局 */ display: grid; padding: 0 40px; /* 两列，一列占三分之一，一列占三分之二 */ grid-template-columns: 1fr 2fr; /* 垂直居中 */ align-items: center; /* 用于定位导航菜单 */ position: relative; z-index: 200;&#125;/* logo */.logo &#123; font-size: 24px; font-weight: 600; color: var(--text-color-lightest); /*使用变量*/&#125;/* 导航 */header nav &#123; /* 水平靠右对齐 */ justify-self: end;&#125;/* 导航链接 */header nav a &#123; color: var(--text-color-lightest); text-decoration: none; margin: 0 24px;&#125;/* 搜索图标 */header nav i &#123; color: var(--text-color-lightest);&#125;/* 折叠菜单 */header .burger &#123; display: none;&#125;/* 页面下滑时固定导航，背景设置为白色 */header.sticky &#123; position: fixed; background-color: white; box-shadow: 0 0 18px rgba(0, 0, 0, 0.2); animation: dropDown 0.5s ease-in-out forwards;&#125;/* 固定导航文字颜色为黑色 */header.sticky .logo,header.sticky nav a,header.sticky nav i &#123; color: var(--text-color-darker);&#125;/* 固定导航下滑动画 */@keyframes dropDown &#123; from &#123; transform: translateY(-100px); &#125; to &#123; transform: translateY(0); &#125;&#125; 轮播图 轮播图采用了glidejs组件库，具体使用可以查看Github：https://github.com/glidejs/glide 引入glide相关css和js 1234&lt;link rel=&quot;stylesheet&quot; href=&quot;libs/glide/glide.core.min.css&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;libs/glide/glide.theme.min.css&quot; /&gt; &lt;!-- 引入JS轮播插件 --&gt;&lt;script src=&quot;libs/glide/glide.min.js&quot;&gt;&lt;/script&gt; 项目源码，注意为双横线__ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!-- 首页图片轮播，使用glide JS插件 --&gt;&lt;div class=&quot;glide&quot; id=&quot;home&quot;&gt; &lt;!-- 轮播轨道 --&gt; &lt;div class=&quot;glide__track&quot; data-glide-el=&quot;track&quot;&gt; &lt;!-- 所有轮播容器 --&gt; &lt;div class=&quot;glide__slides&quot;&gt; &lt;!-- 单个轮播组件 --&gt; &lt;div class=&quot;glide__slide&quot;&gt; &lt;!-- 轮播标题 --&gt; &lt;div class=&quot;slide-caption&quot;&gt; &lt;h1&gt;用创新点缀人生，让科技融入理想。&lt;/h1&gt; &lt;h3&gt; 科技创新大平台，智慧生活新引擎。依靠科技进步推进经济跨越式发展。用创新点缀人生，让科技融入理想。 &lt;/h3&gt; &lt;!-- 探索按钮 --&gt; &lt;button class=&quot;explore-btn&quot;&gt;探索更多&lt;/button&gt; &lt;/div&gt; &lt;!-- 背景遮罩 --&gt; &lt;div class=&quot;backdrop&quot;&gt;&lt;/div&gt; &lt;!-- 轮播图片 --&gt; &lt;img src=&quot;images/people-in-couch-1024248.jpg&quot; alt=&quot;&quot; /&gt; &lt;/div&gt; &lt;!-- 第二张轮播 --&gt; &lt;div class=&quot;glide__slide&quot;&gt; &lt;div class=&quot;slide-caption left&quot;&gt; &lt;h1&gt;科技改变世界&lt;/h1&gt; &lt;h3&gt; 立足科学发展，着力自主创新。加速科技进步，为全市经济社会发展提供有力支撑。凝聚科技创意，成就创新梦想。 &lt;/h3&gt; &lt;button class=&quot;explore-btn&quot;&gt;探索更多&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;backdrop&quot;&gt;&lt;/div&gt; &lt;!-- 轮播视频 --&gt; &lt;video src=&quot;videos/working-man.mp4&quot; muted autoplay loop&gt;&lt;/video&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- glide 控制按钮 --&gt; &lt;div class=&quot;glide__arrows&quot; data-glide-el=&quot;controls&quot;&gt; &lt;button class=&quot;glide__arrow glide__arrow--left&quot; data-glide-dir=&quot;&lt;&quot;&gt; &lt; &lt;/button&gt; &lt;button class=&quot;glide__arrow glide__arrow--right&quot; data-glide-dir=&quot;&gt;&quot;&gt; &gt; &lt;/button&gt; &lt;/div&gt; &lt;!-- glide 控制圆点 --&gt; &lt;div class=&quot;glide__bullets&quot; data-glide-el=&quot;controls[nav]&quot;&gt; &lt;button class=&quot;glide__bullet&quot; data-glide-dir=&quot;=0&quot;&gt;&lt;/button&gt; &lt;button class=&quot;glide__bullet&quot; data-glide-dir=&quot;=1&quot;&gt;&lt;/button&gt; &lt;/div&gt;&lt;/div&gt; 轮播样式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/* ============= 轮播 ================== */.glide &#123; /* 定位标题和图片 */ position: relative; /* 抵消导航高度 */ top: -80px; /* 放置在最下层 */ z-index: 50;&#125;/* 轮播的图片和视频的大小 */.glide__slide img,.glide__slide video &#123; object-fit: cover; /*自动等比例缩放*/ width: 100vw; height: 100vh;&#125;/* 轮播的布局 */.glide__slide &#123; display: flex; align-items: center; justify-content: center;&#125;/* 轮播标题容器 */.slide-caption &#123; position: absolute; /* 放置在遮罩上层 */ z-index: 70; color: var(--text-color-lightest); text-align: center; max-width: 60vw;&#125;/* 轮播标题默认不显示，在JS中用动画移入 */.slide-caption &gt; * &#123; opacity: 0;&#125;/* 轮播标题中的主标语 */.slide-caption h1 &#123; font-size: 54px; font-weight: 600;&#125;/* 轮播标题中的副标语 */.slide-caption h3 &#123; font-size: 24px; margin: 48px 0;&#125;/* 第二页轮播标题布局方式 */.slide-caption.left &#123; max-width: 80vw; text-align: left;&#125;/* 轮播遮罩层 */.backdrop &#123; background: var(--backdrop-color); opacity: 0.5; position: absolute; left: 0; width: 100%; height: 100%; /* 放置在幻灯片上层 */ z-index: 60;&#125;.glide__arrows,.glide__bullets &#123; z-index: 70;&#125;/* 探索更多按钮 */.explore-btn &#123; padding: 14px 32px; background-color: var(--primary-color); border: 0; border-radius: 4px; color: var(--text-color-lightest); font-size: 18px; cursor: pointer; outline: none; /*去掉浏览器默认的按钮蓝色边框*/&#125; 在index.js中初始化加载glide和实现轮播标题依次出现动画，其中使用到理anime库，所以需要引入组件，动画相关可以查看中文文档 12&lt;!-- 动画组件 --&gt;&lt;script src=&quot;libs/anime/anime.min.js&quot;&gt;&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233// 初始轮播const glide = new Glide(&quot;.glide&quot;);// 获取轮播标题实例const captionsEl = document.querySelectorAll(&quot;.slide-caption&quot;);// 当轮播加载完成后，每个轮播完成时，加载标题动画glide.on([&quot;mount.after&quot;, &quot;run.after&quot;], () =&gt; &#123; // 获取当前展示的轮播index const caption = captionsEl[glide.index]; //使用anime库 anime(&#123; // 对每个子元素进行动画 targets: caption.children, // 透明度 opacity: [0, 1], // 持续时间 duration: 400, easing: &quot;linear&quot;, // 每个子元素相继延迟400毫秒，第一个延迟300毫秒 delay: anime.stagger(400, &#123; start: 300 &#125;), // 从下向上移动，每行从40到10递减，最后移动到0 translateY: [anime.stagger([40, 10]), 0] &#125;);&#125;);// 轮播进行前，把标题透明度设置为0，还原glide.on(&quot;run.before&quot;, () =&gt; &#123; // *表示通配符 所有元素 document.querySelectorAll(&quot;.slide-caption &gt; *&quot;).forEach(el =&gt; &#123; el.style.opacity = 0; &#125;);&#125;);// 加载轮播，必须在添加事件处理函数之后glide.mount(); 内容区域 内容区域通用样式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* ============= 内容区域 ================== *//* 通用样式 */.content-wrapper &#123; display: flex; flex-direction: column; align-items: center;&#125;/* 所有section都按grid布局 */section &#123; display: grid; /* 单元格都居中对齐 */ justify-items: center; max-width: 1180px; padding: 0 80px;&#125;/* 区域大标题 */.title1 &#123; /* justify-self: center; */ /* position: relative; */ font-size: 34px; color: var(--text-color-darker);&#125;/* 大标题下方红线 */.title1::after &#123; content: &quot;&quot;; display: block; width: 80%; height: 4px; transform: translateX(10%); margin-top: 14px; background-color: var(--primary-color);&#125;/* 大d标题下方简介 */.intro &#123; margin: 28px 0 60px 0; font-size: 18px; color: var(--text-color-dark-gray);&#125;/* 区域背景色，因为区域有最大宽度限制，用before来设置占满浏览器宽度 */.section-bg &#123; position: relative;&#125;.section-bg::before &#123; content: &quot;&quot;; display: block; position: absolute; background-color: #f9fbfb; width: 100vw; height: 100%; z-index: -1;&#125; 以下主题内容部分使用一个大div包裹起来 123456789&lt;!-- 内容容器 --&gt;&lt;div class=&quot;content-wrapper&quot;&gt; &lt;section&gt;关于我们&lt;/section&gt; &lt;section&gt;成功案例&lt;/section&gt; &lt;section&gt;服务流程&lt;/section&gt; &lt;section&gt;团队介绍&lt;/section&gt; &lt;section&gt;数据部分&lt;/section&gt; &lt;section&gt;公司动态&lt;/section&gt;&lt;/div&gt; 关于我们 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 &lt;!-- 关于我们， id用来导航菜单跳转 --&gt;&lt;section id=&quot;about-us&quot; class=&quot;about-us&quot;&gt; &lt;!-- 标题 --&gt; &lt;h2 class=&quot;title1&quot;&gt;关于我们&lt;/h2&gt; &lt;!-- 补充说明区域 --&gt; &lt;p class=&quot;intro&quot;&gt; 网络公司不仅仅是提供域名注册、空间租用、网站开发、网站建设与网络营销活动策划相关的企业组织。 &lt;/p&gt; &lt;!-- 公司业务容器，栅格布局 --&gt; &lt;div class=&quot;features&quot;&gt; &lt;!-- 公司业务 --&gt; &lt;div class=&quot;feature&quot;&gt; &lt;!-- 左侧业务图标 --&gt; &lt;i class=&quot;fas fa-lightbulb&quot;&gt;&lt;/i&gt; &lt;!-- 右侧业务标题 --&gt; &lt;h4 class=&quot;feature-title&quot;&gt;品牌创意&lt;/h4&gt; &lt;!-- 右侧业务内容 --&gt; &lt;p class=&quot;feature-content&quot;&gt; 为企业设计独特的并能完美呈现企业价值观的视觉 &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;feature&quot;&gt; &lt;i class=&quot;fas fa-chart-line&quot;&gt;&lt;/i&gt; &lt;h4 class=&quot;feature-title&quot;&gt;整合营销&lt;/h4&gt; &lt;p class=&quot;feature-content&quot;&gt; 通过市场进入分析、制定网络营销战略、网络营销实施 &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;feature&quot;&gt; &lt;i class=&quot;fas fa-shopping-cart&quot;&gt;&lt;/i&gt; &lt;h4 class=&quot;feature-title&quot;&gt;电子商务&lt;/h4&gt; &lt;p class=&quot;feature-content&quot;&gt; 根据企业需求，开设不同的销售渠道，通过网上直销 &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;feature&quot;&gt; &lt;i class=&quot;fas fa-desktop&quot;&gt;&lt;/i&gt; &lt;h4 class=&quot;feature-title&quot;&gt;网页设计&lt;/h4&gt; &lt;p class=&quot;feature-content&quot;&gt; 通过网站建设、智能建站、域名主机、企业邮箱 &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;feature&quot;&gt; &lt;i class=&quot;fas fa-tachometer-alt&quot;&gt;&lt;/i&gt; &lt;h4 class=&quot;feature-title&quot;&gt;网站优化&lt;/h4&gt; &lt;p class=&quot;feature-content&quot;&gt; 网站推广是指将网站推广到国内各大知名网站和搜索引擎 &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;feature&quot;&gt; &lt;i class=&quot;fas fa-server&quot;&gt;&lt;/i&gt; &lt;h4 class=&quot;feature-title&quot;&gt;网站架设&lt;/h4&gt; &lt;p class=&quot;feature-content&quot;&gt; 通过绑定域名和服务器，把网站展现给全世界 &lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt; CSS样式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* ============= 关于我们 ================== *//* 关于我们 */.about-us &#123; padding-bottom: 32px;&#125;/* 公司业务布局 */.features &#123; display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: 126px 126px; column-gap: 5vw; align-items: center;&#125;/* 业务 */.feature &#123; display: grid; /* 规划栅格，图标占两行，标题和内容各占一行 */ grid-template-areas: &quot;icon title&quot; &quot;icon content&quot;; /* 每列的宽度，第一列60象素，第二列占满剩余空间 */ grid-template-columns: 60px 1fr; /* 三行 */ grid-template-rows: 1fr 3fr;&#125;/* 图标 */.feature i.fas &#123; grid-area: icon; font-size: 34px; color: var(--primary-color);&#125;/* 标题 */.feature-title &#123; grid-area: title; font-size: 18px; color: var(--text-color-darker);&#125;/* 内容 */.feature-content &#123; grid-area: content; color: var(--text-color-gray); margin-top: 8px;&#125; 成功案例 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!-- 成功案例 --&gt;&lt;!-- section-bg 区域灰色背景 --&gt;&lt;section id=&quot;showcases&quot; class=&quot;showcases section-bg&quot;&gt; &lt;h2 class=&quot;title1&quot;&gt;成功案例&lt;/h2&gt; &lt;!-- 筛选按钮 --&gt; &lt;div class=&quot;filter-btns&quot;&gt; &lt;button class=&quot;filter-btn active&quot; data-filter=&quot;*&quot;&gt;全部&lt;/button&gt; &lt;!-- 指定要过滤的class selector，包括. --&gt; &lt;button class=&quot;filter-btn&quot; data-filter=&quot;.web&quot;&gt;WEB&lt;/button&gt; &lt;button class=&quot;filter-btn&quot; data-filter=&quot;.mobile&quot;&gt;移动&lt;/button&gt; &lt;button class=&quot;filter-btn&quot; data-filter=&quot;.science&quot;&gt;科研&lt;/button&gt; &lt;/div&gt; &lt;!-- 案例 --&gt; &lt;div class=&quot;cases&quot;&gt; &lt;!-- case-item样式类，web science为类别类 --&gt; &lt;div class=&quot;case-item web science&quot;&gt; &lt;!-- 图片 --&gt; &lt;img src=&quot;images/gray-laptop-computer-showing-html-codes-in-shallow-focus-160107.jpg&quot; alt=&quot;&quot;/&gt; &lt;/div&gt; &lt;div class=&quot;case-item web science&quot;&gt; &lt;img src=&quot;images/photo-of-imac-near-macbook-1029757.jpg&quot; alt=&quot;&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;case-item web&quot;&gt; &lt;img src=&quot;images/apple-laptop-notebook-office-39284.jpg&quot; alt=&quot;&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;case-item web&quot;&gt; &lt;img src=&quot;images/apple-apple-device-design-desk-285814.jpg&quot; alt=&quot;&quot;/&gt; &lt;/div&gt; &lt;div class=&quot;case-item mobile&quot;&gt; &lt;img src=&quot;images/person-using-black-and-white-smartphone-and-holding-blue-230544.jpg&quot; alt=&quot;&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;case-item science&quot;&gt; &lt;img src=&quot;images/person-holding-a-smartphone-892757.jpg&quot; alt=&quot;&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;case-item mobile web science&quot;&gt; &lt;img src=&quot;images/blur-close-up-code-computer-546819.jpg&quot; alt=&quot;&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;case-item mobile&quot;&gt; &lt;img src=&quot;images/bokeh-photography-of-person-holding-turned-on-iphone-1440727.jpg&quot; alt=&quot;&quot;/&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt; CSS样式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* ============= 成功案例 ================== *//* 成功案例 */.showcases &#123; max-width: unset; padding: 0; padding-top: 72px;&#125;/* 案例筛选按钮容器 */.filter-btns &#123; margin-top: 54px; margin-bottom: 38px;&#125;/* 筛选按钮 */.filter-btn &#123; margin: 0 7px; background-color: var(--secondary-color); border: 0; color: var(--text-color-dark-gray); padding: 8px 18px; border-radius: 4px; cursor: pointer; transition: 0.4s;&#125;/* 按钮选中时 */.filter-btn:focus,.filter-btn:active &#123; /* 去掉边框 */ outline: none;&#125;.filter-btn.active,.filter-btn:hover &#123; background-color: var(--primary-color); color: white;&#125;.showcases .cases &#123; width: 100vw;&#125;.showcases .case-item &#123; /* 保持图片长宽比 */ width: 25vw; /* 这里没有写错，图片比例为25：20，也就是5：4 */ height: 20vw; overflow: hidden;&#125;/* 案例图片 */.case-item img &#123; height: 100%; object-fit: cover;&#125; 成功案例JS，初始化Isotope，先引入Isotope 12&lt;!-- 案例筛选组件 --&gt;&lt;script src=&quot;libs/isotope/isotope.pkgd.min.js&quot;&gt;&lt;/script&gt; 1234567891011121314151617181920212223242526/============= 成功案例 =============// 初始化isotopeconst isotope = new Isotope(&quot;.cases&quot;, &#123; // 适应行布局，每行宽度一样 layoutMode: &quot;fitRows&quot;, // 每个案例的class选择器 itemSelector: &quot;.case-item&quot; // percentPosition: true&#125;);// 成功案例筛选const filterBtns = document.querySelector(&quot;.filter-btns&quot;);// 当点击筛选按钮时filterBtns.addEventListener(&quot;click&quot;, e =&gt; &#123; let &#123; target = &#123;&#125; &#125; = e; const filterOption = target.getAttribute(&quot;data-filter&quot;); if (filterOption) &#123; // 取消其他按钮active状态 document .querySelectorAll(&quot;.filter-btn.active&quot;) .forEach(btn =&gt; btn.classList.remove(&quot;active&quot;)); target.classList.add(&quot;active&quot;); // 筛选 isotope.arrange(&#123; filter: filterOption &#125;); &#125;&#125;); 服务流程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 &lt;!-- 服务流程 --&gt;&lt;section id=&quot;service&quot; class=&quot;service&quot;&gt; &lt;h2 class=&quot;title1&quot;&gt;服务流程&lt;/h2&gt; &lt;p class=&quot;intro&quot;&gt; 网络综合公司，提供包括网络基础服务（如域名、主机、邮箱）和网络增值服务（如网站建设和推广，网站优化）等业务 &lt;/p&gt; &lt;!-- 同关于我们 --&gt; &lt;div class=&quot;services&quot;&gt; &lt;div class=&quot;service-item&quot;&gt; &lt;i class=&quot;fas fa-comments&quot;&gt;&lt;/i&gt; &lt;h2 class=&quot;service-title&quot;&gt;需求沟通&lt;/h2&gt; &lt;p class=&quot;service-content&quot;&gt; 客户提出网站建设的基本需求，包括设计要求及功能要求 &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;service-item&quot;&gt; &lt;i class=&quot;fas fa-gavel&quot;&gt;&lt;/i&gt; &lt;h2 class=&quot;service-title&quot;&gt;项目评估&lt;/h2&gt; &lt;p class=&quot;service-content&quot;&gt; 根据客户提出的需求进行评估，估算出相应的时间与费用 &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;service-item&quot;&gt; &lt;i class=&quot;fas fa-file-signature&quot;&gt;&lt;/i&gt; &lt;h2 class=&quot;service-title&quot;&gt;签订合同&lt;/h2&gt; &lt;p class=&quot;service-content&quot;&gt; 合作双方确认费用、工期、合作要求的基础上，双方共同签订合同 &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;service-item&quot;&gt; &lt;i class=&quot;fas fa-user&quot;&gt;&lt;/i&gt; &lt;h2 class=&quot;service-title&quot;&gt;提案阶段&lt;/h2&gt; &lt;p class=&quot;service-content&quot;&gt; 完成网站初稿DEMO设计，包括首页风格，内页风格页面 &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;service-item&quot;&gt; &lt;i class=&quot;fas fa-chalkboard-teacher&quot;&gt;&lt;/i&gt; &lt;h2 class=&quot;service-title&quot;&gt;制作阶段&lt;/h2&gt; &lt;p class=&quot;service-content&quot;&gt; 完成所有页面的设计，进行程序开发以及前后后台的页面整合 &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;service-item&quot;&gt; &lt;i class=&quot;fas fa-user-check&quot;&gt;&lt;/i&gt; &lt;h2 class=&quot;service-title&quot;&gt;网站验收&lt;/h2&gt; &lt;p class=&quot;service-content&quot;&gt; 根据合同条款进行网站验收，并签署网站验收确认单 &lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt; CSS样式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* ============= 服务流程 ================== *//* 区域 */.service &#123; padding-top: 131px;&#125;/* 所有服务 */.services &#123; display: grid; /* 同关于我们 */ grid-template-columns: repeat(3, 1fr); grid-template-rows: 1fr 1fr; column-gap: 38px; row-gap: 34px;&#125;/* 服务 */.service-item &#123; /* 同关于我们 */ display: grid; grid-template-areas: &quot;icon title&quot; &quot;icon content&quot;; grid-template-columns: 70px 1fr; grid-template-rows: 1fr 3fr; /* 内边距 */ padding: 24px; box-shadow: 0px 0px 18px rgba(0, 0, 0, 0.06);&#125;/* 服务图标 */.service-item i.fas &#123; grid-area: icon; font-size: 42px; color: var(--primary-color); padding-top: 6px;&#125;/* 服务标题 */.service-item .service-title &#123; grid-area: title; color: var(--text-color-darker); font-size: 24px;&#125;/* 服务内容 */.service-item .service-content &#123; grid-area: content; color: var(--text-color-gray); line-height: 30px; font-size: 16px; /* align-self: st; */ margin-top: 8px;&#125; 团队介绍 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;!-- 团队介绍 --&gt;&lt;section id=&quot;team-intro&quot; class=&quot;team-intro section-bg&quot;&gt; &lt;h2 class=&quot;title1&quot;&gt;团队介绍&lt;/h2&gt; &lt;!-- 团队成员容器 --&gt; &lt;div class=&quot;team-members&quot;&gt; &lt;!-- 团队成员 --&gt; &lt;div class=&quot;team-member&quot;&gt; &lt;!-- 成员照片 --&gt; &lt;div class=&quot;profile-image&quot;&gt; &lt;img src=&quot;images/man-wearing-black-suit-2955376.jpg&quot; alt=&quot;&quot; /&gt; &lt;/div&gt; &lt;!-- 成员姓名 --&gt; &lt;h4 class=&quot;name&quot;&gt;张紫齐&lt;/h4&gt; &lt;!-- 成员职位 --&gt; &lt;p class=&quot;position&quot;&gt;前端工程师&lt;/p&gt; &lt;!-- 成员社交账号 --&gt; &lt;ul class=&quot;social-links&quot;&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;fab fa-weixin&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;fab fa-weibo&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;fab fa-github&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;fab fa-linkedin&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;team-member&quot;&gt; &lt;div class=&quot;profile-image&quot;&gt; &lt;img src=&quot;images/smiling-woman-wearing-black-sweater-1587009.jpg&quot; alt=&quot;&quot;/&gt; &lt;/div&gt; &lt;h4 class=&quot;name&quot;&gt;米诗艺&lt;/h4&gt; &lt;p class=&quot;position&quot;&gt;UI设计师&lt;/p&gt; &lt;ul class=&quot;social-links&quot;&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;fab fa-weixin&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;fab fa-weibo&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;fab fa-github&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;fab fa-linkedin&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;team-member&quot;&gt; &lt;div class=&quot;profile-image&quot;&gt; &lt;img src=&quot;images/selective-focus-photograph-of-man-wearing-gray-suit-jacket-1138903.jpg&quot; alt=&quot;&quot;/&gt; &lt;/div&gt; &lt;h4 class=&quot;name&quot;&gt;纪乐泉&lt;/h4&gt; &lt;p class=&quot;position&quot;&gt;后端工程师&lt;/p&gt; &lt;ul class=&quot;social-links&quot;&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;fab fa-weixin&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;fab fa-weibo&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;fab fa-github&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;fab fa-linkedin&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;team-member&quot;&gt; &lt;div class=&quot;profile-image&quot;&gt; &lt;img src=&quot;images/business-woman-2697954_1920.jpg&quot; alt=&quot;&quot; /&gt; &lt;/div&gt; &lt;h4 class=&quot;name&quot;&gt;云秋贻&lt;/h4&gt; &lt;p class=&quot;position&quot;&gt;市场专员&lt;/p&gt; &lt;ul class=&quot;social-links&quot;&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;fab fa-weixin&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;fab fa-weibo&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;fab fa-github&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;fab fa-linkedin&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;/section&gt; CSS样式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/* ============= 团队介绍 ================== *//* 团队介绍 */.team-intro &#123; margin-top: 48px; padding-top: 62px; padding-bottom: 52px;&#125;/* 团队成员容器 */.team-members &#123; display: grid; /* 4列 */ grid-template-columns: repeat(4, 1fr); column-gap: 24px; margin-top: 86px;&#125;/* 团队成员 */.team-member &#123; background-color: white; box-shadow: 0px 0px 24px rgba(0, 0, 0, 0.2); text-align: center; padding-bottom: 28px; /* 鼠标移过会放大并上移 */ transition: 0.4s; display: grid; justify-items: center;&#125;/* 成员照片遮罩 */.profile-image &#123; overflow: hidden;&#125;/* 成员照片 */.profile-image img &#123; width: 100%; height: 264px; object-fit: cover; object-position: top center;&#125;/* 团队姓名 */.team-member .name &#123; margin-top: 18px; font-size: 18px; font-weight: 500; color: var(--text-color-dark);&#125;/* 团队职位 */.team-member .position &#123; color: var(--text-color-dark-gray); margin-top: 12px; margin-bottom: 18px;&#125;/* 社交账号 */.social-links &#123; width: 100%; max-width: 200px; display: flex; justify-content: space-between; padding: 0 42px;&#125;/* 社交账号 */.social-links li &#123; list-style: none;&#125;/* 社交账号图标 */.social-links li a &#123; color: var(--text-color-dark); text-decoration: none;&#125;/* 鼠标移过加动画 */.team-member:hover &#123; transform: translateY(-20px) scale(1.05); box-shadow: 0px 0px 36px rgba(0, 0, 0, 0.1);&#125; 数据部分 数字有增加的效果，而且背景移动时有视差的效果 123456789101112131415161718192021222324252627&lt;!-- 数据展示 --&gt;&lt;section id=&quot;data-section&quot; class=&quot;data-section&quot;&gt; &lt;!-- 单个数据 --&gt; &lt;div class=&quot;data-piece&quot;&gt; &lt;!-- 图标 --&gt; &lt;i class=&quot;fas fa-code&quot;&gt;&lt;/i&gt; &lt;!-- 数据 --&gt; &lt;div class=&quot;num&quot;&gt;156&lt;/div&gt; &lt;!-- 单位 --&gt; &lt;div class=&quot;data-desc&quot;&gt;行代码&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;data-piece&quot;&gt; &lt;i class=&quot;fas fa-award&quot;&gt;&lt;/i&gt; &lt;div class=&quot;num&quot;&gt;288&lt;/div&gt; &lt;div class=&quot;data-desc&quot;&gt;个奖项&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;data-piece&quot;&gt; &lt;i class=&quot;fas fa-laugh-wink&quot;&gt;&lt;/i&gt; &lt;div class=&quot;num&quot;&gt;1588&lt;/div&gt; &lt;div class=&quot;data-desc&quot;&gt;位客户&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;data-piece&quot;&gt; &lt;i class=&quot;fas fa-folder&quot;&gt;&lt;/i&gt; &lt;div class=&quot;num&quot;&gt;200&lt;/div&gt; &lt;div class=&quot;data-desc&quot;&gt;个项目&lt;/div&gt; &lt;/div&gt;&lt;/section&gt; CSS样式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/* ============= 数据区域 ================== *//* 数据 */.data-section &#123; max-width: unset; width: 100vw; height: 255px; /* 背景，自动拉伸，取中间部分 */ background-image: url(images/adult-business-computer-contemporary-380769.jpg); background-size: cover; background-position: center; /*取图片中间位置*/ /* 4列布局 */ display: grid; grid-template-columns: repeat(4, minmax(auto, 220px)); justify-content: center; align-items: center; position: relative; z-index: 20;&#125;/* 背景遮罩 */.data-section::before &#123; content: &quot;&quot;; display: block; position: absolute; background-color: var(--backdrop-color); width: 100%; height: 100%; z-index: 1;&#125;/* 每个数据项的样式 */.data-piece &#123; width: 250px; display: grid; grid-template-rows: repeat(3, 1fr); justify-items: center; color: white; position: relative; z-index: 40;&#125;/* 数据图标 */.data-piece i.fas &#123; font-size: 44px;&#125;/* 数据数字 */.data-piece .num &#123; margin-top: 7px; font-size: 41px; font-weight: 600;&#125;/* 数字单位 */.data-piece .data-desc &#123; font-size: 18px; font-weight: 500;&#125; 后续JS部分实现数据增长和视差滚动特效 公司动态 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!-- 公司动态 --&gt;&lt;section id=&quot;company-activities&quot; class=&quot;company-activities&quot;&gt; &lt;h2 class=&quot;title1&quot;&gt;公司动态&lt;/h2&gt; &lt;p class=&quot;intro&quot;&gt;关注公司动态，第一时间获取一手消息&lt;/p&gt; &lt;!-- 动态容器 --&gt; &lt;div class=&quot;activities&quot;&gt; &lt;!-- 动态1 --&gt; &lt;div class=&quot;activity&quot;&gt; &lt;!-- 动态图片 --&gt; &lt;div class=&quot;act-image-wrapper&quot;&gt; &lt;img src=&quot;images/activity01-image.jpg&quot; alt=&quot;&quot; /&gt; &lt;/div&gt; &lt;!-- 动态元数据，包括发表日期和评论数量 --&gt; &lt;div class=&quot;meta&quot;&gt; &lt;!-- 发布日期 --&gt; &lt;p class=&quot;date-published&quot;&gt; &lt;i class=&quot;far fa-calendar&quot;&gt;&lt;/i&gt; 2019年12月1日 &lt;/p&gt; &lt;p class=&quot;comments&quot;&gt;&lt;i class=&quot;far fa-comments&quot;&gt;&lt;/i&gt; 33条评论&lt;/p&gt; &lt;/div&gt; &lt;!-- 动态标题 --&gt; &lt;h2 class=&quot;act-title&quot;&gt;提供互联网接入的ISP公司&lt;/h2&gt; &lt;!-- 动态内容摘要 --&gt; &lt;article&gt; 网络公司原本指的是提供网络服务的互联网内容提供商ICP公司，提供互联网接入的ISP公司，提供内容托管的IDC提供商，还有无线接入、网络游戏、网络视频、网络培训、网络销售。 &lt;/article&gt; &lt;!-- 阅读更多按钮 --&gt; &lt;button class=&quot;readmore-btn&quot;&gt;阅读更多&lt;/button&gt; &lt;/div&gt; &lt;!-- 动态2 --&gt; &lt;div class=&quot;activity&quot;&gt; &lt;!-- 动态图片 --&gt; &lt;div class=&quot;act-image-wrapper&quot;&gt; &lt;img src=&quot;images/watercrafts-on-river-3464632.jpg&quot; alt=&quot;&quot; /&gt; &lt;/div&gt; &lt;!-- 动态元数据，包括发表日期和评论数量 --&gt; &lt;div class=&quot;meta&quot;&gt; &lt;!-- 发布日期 --&gt; &lt;p class=&quot;date-published&quot;&gt; &lt;i class=&quot;far fa-calendar&quot;&gt;&lt;/i&gt; 2019年12月1日 &lt;/p&gt; &lt;p class=&quot;comments&quot;&gt;&lt;i class=&quot;far fa-comments&quot;&gt;&lt;/i&gt; 33条评论&lt;/p&gt; &lt;/div&gt; &lt;!-- 动态标题 --&gt; &lt;h2 class=&quot;act-title&quot;&gt;提供互联网接入的ISP公司&lt;/h2&gt; &lt;!-- 动态内容摘要 --&gt; &lt;article&gt; 网络公司原本指的是提供网络服务的互联网内容提供商ICP公司，提供互联网接入的ISP公司，提供内容托管的IDC提供商，还有无线接入、网络游戏、网络视频、网络培训、网络销售。 &lt;/article&gt; &lt;!-- 阅读更多按钮 --&gt; &lt;button class=&quot;readmore-btn&quot;&gt;阅读更多&lt;/button&gt; &lt;/div&gt; &lt;!-- 动态3 --&gt; &lt;div class=&quot;activity&quot;&gt; &lt;!-- 动态图片 --&gt; &lt;div class=&quot;act-image-wrapper&quot;&gt; &lt;img src=&quot;images/red-suspension-bridge-3493772.jpg&quot; alt=&quot;&quot; /&gt; &lt;/div&gt; &lt;!-- 动态元数据，包括发表日期和评论数量 --&gt; &lt;div class=&quot;meta&quot;&gt; &lt;!-- 发布日期 --&gt; &lt;p class=&quot;date-published&quot;&gt; &lt;i class=&quot;far fa-calendar&quot;&gt;&lt;/i&gt; 2019年12月1日 &lt;/p&gt; &lt;p class=&quot;comments&quot;&gt;&lt;i class=&quot;far fa-comments&quot;&gt;&lt;/i&gt; 33条评论&lt;/p&gt; &lt;/div&gt; &lt;!-- 动态标题 --&gt; &lt;h2 class=&quot;act-title&quot;&gt;提供互联网接入的ISP公司&lt;/h2&gt; &lt;!-- 动态内容摘要 --&gt; &lt;article&gt; 网络公司原本指的是提供网络服务的互联网内容提供商ICP公司，提供互联网接入的ISP公司，提供内容托管的IDC提供商，还有无线接入、网络游戏、网络视频、网络培训、网络销售。 &lt;/article&gt; &lt;!-- 阅读更多按钮 --&gt; &lt;button class=&quot;readmore-btn&quot;&gt;阅读更多&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt; CSS样式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/* ============= 公司动态 ================== *//* 公司动态 */.company-activities &#123; margin-top: 88px;&#125;/* 动态栅格布局 */.activities &#123; display: grid; grid-template-columns: repeat(3, 1fr); column-gap: 24px;&#125;/* 动态 */.activity &#123; box-shadow: 0px 0px 24px rgba(0, 0, 0, 0.1); padding: 24px; transition: 0.4s;&#125;/* 动态图片容器 */.act-image-wrapper &#123; height: 255px; overflow: hidden; /* 抵消activity的padding */ margin: -24px; margin-bottom: 0;&#125;/* 动态图片 */.act-image-wrapper img &#123; min-height: 300px; object-fit: cover;&#125;/* 动态元数据 */.activity .meta &#123; margin-top: 20px; margin-bottom: 12px; color: var(--text-color-light-gray); font-size: 12px; display: flex;&#125;/* 评论 */.activity .meta &gt; p:last-child &#123; margin-left: 36px;&#125;/* 动态标题 */.act-title &#123; color: var(--text-color-dark); font-size: 18px; margin-bottom: 16px;&#125;/* 动态摘要 */.activity article &#123; color: var(--text-color-gray); letter-spacing: 0.54px; line-height: 24px;&#125;/* 阅读更多按钮 */.readmore-btn &#123; border: 0; color: white; background-color: var(--primary-color); border-radius: 4px; padding: 6px 14px; margin-top: 24px;&#125;/* 动态鼠标移上时 */.activity:hover &#123; transform: translateY(-20px) scale(1.05); box-shadow: 0px 0px 36px rgba(0, 0, 0, 0.1);&#125; 底部信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!-- 底部信息 --&gt;&lt;footer&gt; &lt;!-- 底部菜单 --&gt; &lt;div class=&quot;footer-menus&quot;&gt; &lt;!-- 联系信息 --&gt; &lt;div class=&quot;contact-us&quot;&gt; &lt;p class=&quot;menu-title&quot;&gt;联系我们&lt;/p&gt; &lt;p&gt;地址：中国XX省XX市XX路XX商务中心10号楼&lt;/p&gt; &lt;p&gt;电话：+18618618611861&lt;/p&gt; &lt;p&gt;传真：+18618618611861&lt;/p&gt; &lt;p&gt;电子邮箱：admin@abc.com&lt;/p&gt; &lt;/div&gt; &lt;!-- 导航菜单 --&gt; &lt;div class=&quot;service-menu footer-menu&quot;&gt; &lt;p class=&quot;menu-title&quot;&gt;服务概览&lt;/p&gt; &lt;ul class=&quot;menu-items&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;网站建设&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;域名购买&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;网页设计&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;移动应用&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;showcase-menu footer-menu&quot;&gt; &lt;p class=&quot;menu-title&quot;&gt;成功案例&lt;/p&gt; &lt;ul class=&quot;menu-items&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;桌面网站&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;移动网站&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;科研项目&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;软件应用&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;activity-menu footer-menu&quot;&gt; &lt;p class=&quot;menu-title&quot;&gt;公司动态&lt;/p&gt; &lt;ul class=&quot;menu-items&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;信息公开&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;最近新闻&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;最新博客&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;help-menu footer-menu&quot;&gt; &lt;p class=&quot;menu-title&quot;&gt;帮助与支持&lt;/p&gt; &lt;ul class=&quot;menu-items&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;帮助中心&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;联系客服&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;文档资源&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- 备案信息 --&gt; &lt;p class=&quot;icp-info&quot;&gt;京ICP备 12345678901-1 号&lt;/p&gt; &lt;!-- 版权信息 --&gt; &lt;p class=&quot;rights&quot;&gt;&amp;copy; 2020 峰华科技 - 响应式网络公司官网 版权所有&lt;/p&gt; &lt;!-- 返回顶部按钮 --&gt; &lt;div class=&quot;scrollToTop&quot;&gt; &lt;a href=&quot;#home&quot;&gt;&lt;i class=&quot;fas fa-chevron-up&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/footer&gt; CSS样式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/* ============= 底部区域 ================== *//* 底部 */footer &#123; margin-top: 124px; background-color: #181818; display: grid; justify-items: center; padding-top: 72px; padding-bottom: 24px;&#125;/* 底部菜单 */.footer-menus &#123; width: 100%; max-width: 1180px; display: grid; /* 5列布局 */ grid-template-columns: 2fr repeat(4, 1fr); padding: 0 80px; position: relative;&#125;/* 导航菜单，靠右对齐 */.footer-menu &#123; justify-self: end;&#125;/* 一级菜单 */.menu-title &#123; font-size: 16px; color: white; font-weight: 500; margin-bottom: 20px;&#125;/* 联系我们，靠左对齐 */.contact-us &#123; justify-self: start; color: var(--text-color-lightest);&#125;/* 联系我们，文字 */.contact-us p:not(:first-child) &#123; padding-bottom: 16px;&#125;/* 菜单项 */.menu-items li &#123; list-style: none; padding-bottom: 8px;&#125;/* 菜单链接 */.menu-items li a &#123; text-decoration: none; font-weight: 300; color: var(--text-color-lightest);&#125;/* 备案信息 */.icp-info &#123; margin-top: 24px; margin-bottom: 16px;&#125;/* 备案信息，版权信息 */.icp-info,.rights &#123; /* 占满整行，-1代表最后一个编号 */ grid-column: 1 / -1; /* 居中对齐 */ justify-self: center; color: white;&#125;/* 返回顶部按钮，默认不显示 */.scrollToTop &#123; display: none; position: relative; z-index: 300;&#125;/* 返回顶部按钮 */.scrollToTop a &#123; width: 32px; height: 32px; border-radius: 4px; display: flex; align-items: center; justify-content: center; background-color: var(--primary-color); color: white; text-decoration: none; position: fixed; bottom: 60px; right: 30px;&#125; 在接下来用JS控制滑动到何处出现返回顶部按钮 固定导航栏 导航栏当网页滑动到一定位置时会从顶部显示并固定 12&lt;!--增加一个sticky类名--&gt;&lt;header class=&quot;sticky&quot;&gt; &lt;/header&gt; 123456789101112131415161718192021222324/* 页面下滑时固定导航，背景设置为白色 */header.sticky &#123; position: fixed; background-color: white; box-shadow: 0 0 18px rgba(0, 0, 0, 0.2); animation: dropDown 0.5s ease-in-out forwards;&#125;/* 固定导航文字颜色为黑色 */header.sticky .logo,header.sticky nav a,header.sticky nav i &#123; color: var(--text-color-darker);&#125;/* 固定导航下滑动画 */@keyframes dropDown &#123; from &#123; transform: translateY(-100px); &#125; to &#123; transform: translateY(0); &#125;&#125; 在JS中控制滑动到何处出现固定导航栏和何处出现返回顶部按钮 12345678910111213141516171819202122232425// 导航实例const headerEl = document.querySelector(&quot;header&quot;);// 返回顶部实例const scrollToTop = document.querySelector(&quot;.scrollToTop&quot;);// 窗口滚动处理window.addEventListener(&quot;scroll&quot;, () =&gt; &#123; // 固定导航 let height = headerEl.getBoundingClientRect().height; if (window.pageYOffset - height &gt; 800) &#123; if (!headerEl.classList.contains(&quot;sticky&quot;)) &#123; headerEl.classList.add(&quot;sticky&quot;); &#125; &#125; else &#123; headerEl.classList.remove(&quot;sticky&quot;); &#125; // 显示返回顶部 if (window.pageYOffset &gt; 2000) &#123; scrollToTop.style.display = &quot;block&quot;; &#125; else &#123; scrollToTop.style.display = &quot;none&quot;; &#125;&#125;); 滚动展示和数据部分动画 当滚动到一定地方时会出现动画效果，这使用到了scrollreveal库 12&lt;!--推荐在head标签内顶部引入--&gt;&lt;script src=&quot;libs/scrollReveal/scrollreveal.min.js&quot;&gt;&lt;/script&gt; JS中初始化控制 1234567891011121314151617181920212223242526272829303132333435363738394041// 滚动展示插件// 通用动画配置，从底部50象素滑出来const staggeringOption = &#123; delay: 300, distance: &quot;50px&quot;, duration: 500, easing: &quot;ease-in-out&quot;, origin: &quot;bottom&quot;&#125;;// 滚动到业务流程时的展示动画，interval需要单独设置，每个feature元素相继350毫秒，下同ScrollReveal().reveal(&quot;.feature&quot;, &#123; ...staggeringOption, interval: 350 &#125;);ScrollReveal().reveal(&quot;.service-item&quot;, &#123; ...staggeringOption, interval: 350 &#125;);// 数据部分const dataSectionEl = document.querySelector(&quot;.data-section&quot;);ScrollReveal().reveal(&quot;.data-section&quot;, &#123; beforeReveal: () =&gt; &#123; // 在展示之前，加载anime动画，使数据从0增长到定义好的数值 anime(&#123; targets: &quot;.data-piece .num&quot;, innerHTML: el =&gt; &#123; return [0, el.innerHTML]; &#125;, duration: 2000, round: 1, easing: &quot;easeInExpo&quot; &#125;); dataSectionEl.style.backgroundPosition = `center calc(50% - $&#123;dataSectionEl.getBoundingClientRect() .bottom / 5&#125;px)`; &#125;&#125;);// 数据，背景视差滚动window.addEventListener(&quot;scroll&quot;, () =&gt; &#123; const bottom = dataSectionEl.getBoundingClientRect().bottom; const top = dataSectionEl.getBoundingClientRect().top; // 如果在可见区域内 if (bottom &gt;= 0 &amp;&amp; top &lt;= window.innerHeight) &#123; dataSectionEl.style.backgroundPosition = `center calc(50% - $&#123;bottom / 5&#125;px)`; &#125;&#125;); 流畅滚动效果 首先给每一个锚链接添加对应的ID属性 123456789101112&lt;!--首页--&gt;&lt;div id=&quot;home&quot;&gt;&lt;/div&gt; &lt;!-- 关于我们， id用来导航菜单跳转 --&gt;&lt;section id=&quot;about-us&quot;&gt;&lt;/section&gt; &lt;!-- 成功案例 --&gt;&lt;section id=&quot;showcases&quot;&gt;&lt;/section&gt;&lt;!-- 服务流程 --&gt;&lt;section id=&quot;service&quot;&gt;&lt;/section&gt;&lt;!-- 团队介绍 --&gt;&lt;section id=&quot;team-intro&quot;&gt;&lt;/section&gt;&lt;!-- 公司动态 --&gt;&lt;section id=&quot;company-activities&quot;&gt;&lt;/section&gt; 然后给导航栏设置跳转链接 12345678910&lt;!-- 导航 --&gt;&lt;nav&gt; &lt;a href=&quot;#home&quot;&gt;首页&lt;/a&gt; &lt;a href=&quot;#about-us&quot;&gt;关于我们&lt;/a&gt; &lt;a href=&quot;#showcases&quot;&gt;成功案例&lt;/a&gt; &lt;a href=&quot;#service&quot;&gt;服务流程&lt;/a&gt; &lt;a href=&quot;#team-intro&quot;&gt;团队介绍&lt;/a&gt; &lt;a href=&quot;#company-activities&quot;&gt;公司动态&lt;/a&gt; &lt;i class=&quot;fas fa-search&quot;&gt;&lt;/i&gt;&lt;/nav&gt; 需要用到smooth-scroll组件 12&lt;!-- 流畅滑动组件 --&gt;&lt;script src=&quot;libs/smooth-scroll/smooth-scroll.polyfills.min.js&quot;&gt;&lt;/script&gt; 在JS中初始化组件 12345678910111213// 流畅滚动 参数为跳转的选择器 把href属性中以#开头的选择出来，一个是导航栏，一个是返回顶部按钮const scroll = new SmoothScroll(&#x27;nav a[href*=&quot;#&quot;], .scrollToTop a[href*=&quot;#&quot;]&#x27;, &#123; // 自动计算固定导航的高度 header: &quot;header&quot;, // 往下多偏移80象素 offset: 80&#125;);// 探索更多按钮的处理函数const exploreBtnEl = document.querySelector(&quot;.explore-btn&quot;);exploreBtnEl.addEventListener(&quot;click&quot;, () =&gt; &#123; scroll.animateScroll(document.querySelector(&quot;#about-us&quot;));&#125;); 实现响应式 CSS样式中使用媒体查询 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276/* 自适应，小于1100象素时 */@media (max-width: 1100px) &#123; /* 导航设置为不可见，点击折叠按钮显示全屏导航 */ header nav &#123; display: none; &#125; /* 头部平分两列布局 */ header &#123; grid-template-columns: repeat(2, 1fr); &#125; /* 折叠菜单样式，显示出来 */ header .burger &#123; display: block; justify-self: end; cursor: pointer; position: relative; width: 20px; height: 6px; &#125; /* 折叠按钮线条样式 */ .burger-line1, .burger-line2, .burger-line3 &#123; width: 20px; height: 2px; background-color: var(--text-color-lightest); /* position: relative; */ &#125; /* 上移第一条线 */ .burger-line1 &#123; position: absolute; top: -6px; &#125; /* 下移第三条线 */ .burger-line3 &#123; position: absolute; top: 6px; &#125; /* 全屏导航展开时，折叠按钮设置为深色 */ header.open .burger-line1, header.open .burger-line2, header.open .burger-line3, header.sticky .burger-line1, header.sticky .burger-line2, header.sticky .burger-line3 &#123; background-color: var(--text-color-darker); transition: 0.4s ease; &#125; /* 全屏导航显示时，折叠按钮第一条线样式 */ header.open .burger-line1 &#123; transform: rotate(45deg) translate(3px, 5px); &#125; /* 全屏导航显示时，折叠按钮第二条线样式 */ header.open .burger-line2 &#123; transform: translateX(5px); opacity: 0; &#125; /* 全屏导航显示时，折叠按钮第三条线样式 */ header.open .burger-line3 &#123; transform: rotate(-45deg) translate(3px, -5px); &#125; /* 全屏导航显示时，logo样式 */ header.open .logo &#123; color: var(--text-color-darker); z-index: 40; &#125; /* 全屏导航显示时，导航菜单样式 */ header.open nav &#123; display: grid; /* 每行高度为内容的高度，不设置会平分全屏高度 */ grid-auto-rows: max-content; /* 菜单项靠右对齐 */ justify-items: end; position: absolute; top: 0; left: 0; background: white; width: 100vw; height: 100vh; padding: 0 40px; opacity: 0; /* 下滑效果 */ animation: slideDown 0.6s ease-out forwards; &#125; /* 全屏导航显示时，导航菜单项样式和动画 */ header.open nav &gt; * &#123; margin: 4px 0; font-size: 18px; color: var(--text-color-darker); opacity: 0; animation: showMenu 0.5s linear forwards 0.4s; &#125; /* 搜索按钮 */ header.open nav &gt; i.fas &#123; margin-top: 10px; &#125; /* 导航下滑动画 */ @keyframes slideDown &#123; from &#123; height: 0; opacity: 0; &#125; to &#123; height: 100vh; padding-top: 80px; opacity: 1; &#125; &#125; /* 菜单项动画 */ @keyframes showMenu &#123; from &#123; opacity: 0; transform: translateY(-1vh); &#125; to &#123; opacity: 1; &#125; &#125; /* 缩小业务流程标题字体 */ .service-item .service-title &#123; font-size: 20px; &#125; /* 缩小业务流程内容字体和行距 */ .service-item .service-content &#123; font-size: 14px; line-height: 24px; &#125; /* 团队成员改为两列 */ .team-members &#123; grid-template-columns: repeat(2, 1fr); column-gap: 6vw; row-gap: 36px; &#125; /* 公司动态改为两列 */ .activities &#123; grid-template-columns: repeat(2, 1fr); row-gap: 36px; &#125;&#125;/* 小于992象素时 */@media (max-width: 992px) &#123; /* 轮播标题字号缩小 */ .slide-caption h1 &#123; font-size: 48px; &#125; .slide-caption h3 &#123; font-size: 18px; &#125; /* 关于我们和业务流程设置为两列布局 */ .features, .services &#123; grid-template-columns: repeat(2, 1fr); /* 取消两行布局 */ grid-template-rows: unset; &#125; /* 数据部分设置为两列布局 */ .data-section &#123; /* 每列最小宽度为200象素，最大为自动 */ grid-template-columns: repeat(2, minmax(200px, auto)); row-gap: 24px; height: auto; padding: 24px 0; background-size: 200%; &#125; /* 成功案例图片设置为3列 */ .showcases .case-item &#123; width: calc(100vw / 3); &#125;&#125;/* 小于768象素时 */@media (max-width: 768px) &#123; /* 区域的左右内边距设置为40象素 */ section, .footer-menus &#123; padding: 0 40px; &#125; /* 关于我们和业务流程设置为1列 */ .features, .services &#123; grid-template-columns: 1fr; &#125; /* 团队成员设置为1列 */ .team-members &#123; grid-template-columns: minmax(200px, 400px); /* column-gap: 6vw; row-gap: 36px; */ &#125; /* 数据部分设置为1列 */ .data-section &#123; grid-template-columns: 1fr; /* 增加背景尺寸 */ background-size: 320%; &#125; /* 公司动态设置为1列 */ .activities &#123; grid-template-columns: 1fr; row-gap: 36px; &#125; /* 成功案例图片显示为两列 */ .showcases .case-item &#123; width: calc(100vw / 2); height: 30vw; &#125; /* 底部菜单设置为3列 */ .footer-menus &#123; grid-template-columns: 2fr repeat(2, 1fr); row-gap: 24px; &#125; /* 联系我们占前两列 */ .contact-us &#123; grid-row: 1 / 3; &#125; /* 菜单文字靠右对齐 */ .footer-menu &#123; text-align: right; &#125;&#125;/* 小于576象素 */@media (max-width: 576px) &#123; /* 缩小轮播标题文字，探索更多按钮文字 */ .slide-caption h1 &#123; font-size: 28px; &#125; .slide-caption h3 &#123; font-size: 14px; &#125; .explore-btn &#123; padding: 8px 18px; font-size: 14px; &#125; /* 成功案例显示为1列 */ .showcases .case-item &#123; width: 100vw; height: 60vw; &#125; /* 底部菜单显示为1列 */ .footer-menus &#123; grid-template-columns: 1fr; /* row-gap: 24px; */ &#125; /* 底部菜单左对齐 */ .footer-menu &#123; justify-self: start; text-align: left; &#125;&#125; 在JS中控制切换 123456// 折叠按钮const burgerEl = document.querySelector(&quot;.burger&quot;);const nav = document.querySelector(&quot;header nav&quot;);burgerEl.addEventListener(&quot;click&quot;, () =&gt; &#123; headerEl.classList.toggle(&quot;open&quot;);&#125;); 关闭全屏导航 按了折叠按钮后跳转到锚链接，就关闭顶部的全屏导航 123456// 折叠菜单打开时，如果点击了链接，则自动关闭全屏导航document.addEventListener(&quot;scrollStart&quot;, () =&gt; &#123; if (headerEl.classList.contains(&quot;open&quot;)) &#123; headerEl.classList.remove(&quot;open&quot;); &#125;&#125;);","path":"page/project01.html","date":"04-30","excerpt":"","tags":[{"name":"项目案例","slug":"项目案例","permalink":"http://xiaoliblog.cn/tags/%E9%A1%B9%E7%9B%AE%E6%A1%88%E4%BE%8B/"}]},{"title":"Vue.js前端框架🎯Pagination+PageHelper实现分页","text":"分页分页的原理 任何分页都有五个部分组成 记录的总条数 每页显示的记录条数 总页数 当前是第几页 当前页的所有记录 真假分页的区别 真分页：每一页都去后端发送请求，请求当前页的数据。适用于大数据量，能缓解后端接口的压力 假分页：一开始就从获取所有数据，前端通过组件的方式对数据进行分页，在点击分页按钮时，数据已经都在浏览器缓存中了，不需要再请求后端接口。不适合大数据量 Pagination为真分页 PageHelper PageHelper是第三方组件，用于提供后端的分页数据 MyBatis 分页插件 PageHelper官方文档：https://pagehelper.github.io/ PageHelper使用 官方介绍👉使用方法 在pom.xml中导入依赖 123456&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.10&lt;/version&gt;&lt;/dependency&gt; 配置拦截器插件 在mybatis-config.xml中添加插件，该插件中的键值对的含义请参考官方文档 12345678&lt;plugins&gt; &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;!-- 使用下面的方式配置参数，后面会有所有的参数介绍 --&gt; &lt;property name=&quot;helperDialect&quot; value=&quot;mysql&quot;/&gt; &lt;property name=&quot;reasonable&quot; value=&quot;true&quot;/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 另一种方法是在 Spring 配置文件中配置拦截器插件，在sqlSessionFactory配置里面加入 1234567891011121314151617&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!-- 注意其他配置 --&gt; &lt;property name=&quot;plugins&quot;&gt; &lt;array&gt; &lt;bean class=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;property name=&quot;properties&quot;&gt; &lt;!--使用下面的方式配置参数，一行配置一个 --&gt; &lt;value&gt; &lt;property name=&quot;helperDialect&quot; value=&quot;mysql&quot;/&gt; &lt;property name=&quot;reasonable&quot; value=&quot;true&quot;/&gt; &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 两种方法选一种即可 编写接口 在controller包下ProductController类中编写方法 12345678910111213141516171819202122232425import com.github.pagehelper.PageHelper;import com.github.pagehelper.PageInfo;/*** 获得分页对象，里面封装了分页需要用到的所有信息* @param pageNum 当前是第几页* @param pageSize 当前页一共显示多少条记录* @return*/@RequestMapping(value=&quot;pageInfo&quot;,method = RequestMethod.GET)@ResponseBodypublic PageInfo&lt;TProduct&gt; getPageInfo(int pageNum, int pageSize)&#123; //1.通过调用PageHelper的静态方法开始获取分页数据 //指定当前是第几页， 以及每页显示的记录条数 PageHelper.startPage(pageNum,pageSize); //2.获得所有的商品记录 List&lt;TProduct&gt; list = productService.getList(); //3.获得当前分页对象 PageInfo&lt;TProduct&gt; pageInfo = new PageInfo&lt;TProduct&gt;(list); return pageInfo;&#125; 通过PageHelper得到一个PageInfo对象，该对象中封装了分页所必须的数据 然后通过PostMan进行后端接口测试 1http:&#x2F;&#x2F;localhost:8080&#x2F;pageInfo?pageNum&#x3D;1&amp;pageSize&#x3D;10 测试结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&#123; &quot;pageNum&quot;: 1, &quot;pageSize&quot;: 5, &quot;size&quot;: 5, &quot;startRow&quot;: 1, &quot;endRow&quot;: 5, &quot;pages&quot;: 3, &quot;prePage&quot;: 0, &quot;nextPage&quot;: 2, &quot;isFirstPage&quot;: true, &quot;isLastPage&quot;: false, &quot;hasPreviousPage&quot;: false, &quot;hasNextPage&quot;: true, &quot;navigatePages&quot;: 8, &quot;navigatepageNums&quot;: [ 1, 2, 3 ], &quot;navigateFirstPage&quot;: 1, &quot;navigateLastPage&quot;: 3, &quot;total&quot;: 14, &quot;list&quot;: [ &#123; &quot;id&quot;: 8, &quot;name&quot;: &quot;M10&quot;, &quot;images&quot;: &quot;aaaa&quot;, &quot;price&quot;: 2199, &quot;salePrice&quot;: 222, &quot;salePoint&quot;: &quot;sdf&quot;, &quot;typeId&quot;: 1, &quot;typeName&quot;: &quot;sss&quot;, &quot;flag&quot;: true, &quot;createTime&quot;: &quot;Jun 5, 2019 12:10:29 AM&quot;, &quot;updateTime&quot;: &quot;Jun 21, 2019 12:10:34 AM&quot;, &quot;createUser&quot;: 1, &quot;updateUser&quot;: 1 &#125;, &#123; &quot;id&quot;: 9, &quot;name&quot;: &quot;M11&quot;, &quot;images&quot;: &quot;aaaa&quot;, &quot;price&quot;: 1333, &quot;salePrice&quot;: 222, &quot;salePoint&quot;: &quot;sdf&quot;, &quot;typeId&quot;: 1, &quot;typeName&quot;: &quot;sss&quot;, &quot;flag&quot;: true, &quot;createTime&quot;: &quot;Jun 5, 2019 12:10:29 AM&quot;, &quot;updateTime&quot;: &quot;Jun 21, 2019 12:10:34 AM&quot;, &quot;createUser&quot;: 1, &quot;updateUser&quot;: 1 &#125;, &#123; &quot;id&quot;: 11, &quot;name&quot;: &quot;M13&quot;, &quot;images&quot;: &quot;aaaa&quot;, &quot;price&quot;: 3333, &quot;salePrice&quot;: 222, &quot;salePoint&quot;: &quot;sdf&quot;, &quot;typeId&quot;: 1, &quot;typeName&quot;: &quot;sss&quot;, &quot;flag&quot;: true, &quot;createTime&quot;: &quot;Jun 5, 2019 12:10:29 AM&quot;, &quot;updateTime&quot;: &quot;Jun 21, 2019 12:10:34 AM&quot;, &quot;createUser&quot;: 1, &quot;updateUser&quot;: 1 &#125;, &#123; &quot;id&quot;: 12, &quot;name&quot;: &quot;M14&quot;, &quot;images&quot;: &quot;aaaa&quot;, &quot;price&quot;: 4333, &quot;salePrice&quot;: 222, &quot;salePoint&quot;: &quot;sdf&quot;, &quot;typeId&quot;: 1, &quot;typeName&quot;: &quot;sss&quot;, &quot;flag&quot;: true, &quot;createTime&quot;: &quot;Jun 5, 2019 12:10:29 AM&quot;, &quot;updateTime&quot;: &quot;Jun 21, 2019 12:10:34 AM&quot;, &quot;createUser&quot;: 1, &quot;updateUser&quot;: 1 &#125;, &#123; &quot;id&quot;: 15, &quot;name&quot;: &quot;M15&quot;, &quot;images&quot;: &quot;aaaa&quot;, &quot;price&quot;: 555, &quot;salePrice&quot;: 222, &quot;salePoint&quot;: &quot;sdf&quot;, &quot;typeId&quot;: 1, &quot;typeName&quot;: &quot;sss&quot;, &quot;flag&quot;: true, &quot;createTime&quot;: &quot;Jun 5, 2019 12:10:29 AM&quot;, &quot;updateTime&quot;: &quot;Jun 21, 2019 12:10:34 AM&quot;, &quot;createUser&quot;: 1, &quot;updateUser&quot;: 1 &#125; ]&#125; pageHelper可以配合Pagination使用，进行前后端分离 Pagination 分页可以通过Element UI的内置组件Pagination实现 在线演示地址 在线源码 Pagination原理 通过分析综合模板，找到src\\views\\table\\complex-table.vue 12&lt;!--父组件--&gt;&lt;pagination v-show=&quot;total&gt;0&quot; :total=&quot;total&quot; :page.sync=&quot;listQuery.page&quot; :limit.sync=&quot;listQuery.limit&quot; @pagination=&quot;getList&quot; /&gt; 找到src\\components\\Pageination\\index.vue源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;!--子组件--&gt;&lt;template&gt; &lt;div :class=&quot;&#123;&#x27;hidden&#x27;:hidden&#125;&quot; class=&quot;pagination-container&quot;&gt; &lt;el-pagination :background=&quot;background&quot; :current-page.sync=&quot;currentPage&quot; :page-size.sync=&quot;pageSize&quot; :layout=&quot;layout&quot; :page-sizes=&quot;pageSizes&quot; :total=&quot;total&quot; v-bind=&quot;$attrs&quot; @size-change=&quot;handleSizeChange&quot; @current-change=&quot;handleCurrentChange&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; scrollTo &#125; from &#x27;@/utils/scroll-to&#x27;export default &#123; name: &#x27;Pagination&#x27;, props: &#123; total: &#123; required: true, type: Number &#125;, page: &#123; type: Number, default: 1 &#125;, limit: &#123; type: Number, default: 20 &#125;, pageSizes: &#123; type: Array, default() &#123; return [10, 20, 30, 50] &#125; &#125;, layout: &#123; type: String, default: &#x27;total, sizes, prev, pager, next, jumper&#x27; &#125;, background: &#123; type: Boolean, default: true &#125;, autoScroll: &#123; type: Boolean, default: true &#125;, hidden: &#123; type: Boolean, default: false &#125; &#125;, computed: &#123; currentPage: &#123; get() &#123; return this.page &#125;, set(val) &#123; this.$emit(&#x27;update:page&#x27;, val) &#125; &#125;, pageSize: &#123; get() &#123; return this.limit &#125;, set(val) &#123; this.$emit(&#x27;update:limit&#x27;, val) &#125; &#125; &#125;, methods: &#123; handleSizeChange(val) &#123; this.$emit(&#x27;pagination&#x27;, &#123; page: this.currentPage, limit: val &#125;) if (this.autoScroll) &#123; scrollTo(0, 800) &#125; &#125;, handleCurrentChange(val) &#123; this.$emit(&#x27;pagination&#x27;, &#123; page: val, limit: this.pageSize &#125;) if (this.autoScroll) &#123; scrollTo(0, 800) &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.pagination-container &#123; background: #fff; padding: 32px 16px;&#125;.pagination-container.hidden &#123; display: none;&#125;&lt;/style&gt; Pagination实际上是一个组件，组件里设置了分页常用到的参数。通过父组件使用Pagination组件，向该组件中传递参数，让Pagination组件得到分页常用到的参数值，这就能够实现分页，那么这样的组件之间的参数传递（父传子） Pagination使用 首先在对应文件夹下导入Pagination内容，以下内容可以在综合模块里找 components/Pagination utils/scroll-to.js 页面中使用Pagination 参数 说明 total 记录的总条数 listQuery.page 当前是第几页 listQuery.limit 每页显示的数量 getList() 当前页的所有记录（数据） 总页数？发现不用我们设置 步骤一： 使用Pagination组件，在需要分页的组件中加入Pagination 123&lt;template&gt; &lt;pagination v-show=&quot;total&gt;0&quot; :total=&quot;total&quot; :page.sync=&quot;listQuery.page&quot; :limit.sync=&quot;listQuery.limit&quot; @pagination=&quot;getList&quot; /&gt;&lt;/template&gt; 步骤二：在script里注册Pagination，并声明相应的参数 1234567891011121314151617181920212223&lt;script&gt;//本地注册import Pagination from &#x27;@/components/Pagination&#x27;export default &#123; //使用组件 components: &#123; Pagination &#125;, data() &#123; return &#123; total: 0, listQuery: &#123; page: 1, limit: 10 &#125; &#125; &#125;, methods: &#123; getList() &#123; // 获取数据 &#125; &#125;&#125;&lt;/script&gt; 步骤三：声明getList函数，该函数用于获取后端提供的PageInfo对象，该对象里封装了分页所需要的所有的数据 1234567891011121314151617created() &#123; // this.fetchData() this.getList() //注意。此时使用分页的方法 &#125;, methods: &#123; getList()&#123; var vm = this; this.axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://localhost:8080//pageInfo?pageNum=&#x27;+vm.listQuery.page+&#x27;&amp;pageSize=&#x27;+vm.listQuery.limit &#125;).then(function(response)&#123; //得到一个PageInfo对象 vm.total = response.data.total;// 将PageInfo中的total赋给vm的total vm.list = response.data.list;//当前页显示的所有数据 &#125;); &#125;,","path":"page/Vuejs11.html","date":"04-26","excerpt":"","tags":[{"name":"分页","slug":"分页","permalink":"http://xiaoliblog.cn/tags/%E5%88%86%E9%A1%B5/"}]},{"title":"Vue.js前端框架🎯Vue-Element-admin模版","text":"Vue-Element-admin admin-element-vue是一个后台前端解决方案，它基于 Webpack 、Vue和 element-ui实现。它使用了最新的前端技术栈，动态路由，权限验证，它可以帮助你快速搭建企业级中后台产品原型。 中文文档地址：https://panjiachen.gitee.io/vue-element-admin-site/zh/guide/ Github：https://github.com/PanJiaChen/vue-element-admin 集成模板在线预览地址：https://github.com/PanJiaChen/vue-element-admin 基础模板在线预览地址：https://panjiachen.github.io/vue-admin-template/#/dashboard 克隆模板到本地 你需要在本地安装 node 和 git。本项目技术栈基于 ES2015+、vue、vuex、vue-router 、vue-cli 、axios 和 element-ui，所有的请求数据都使用Mock.js进行模拟 克隆 vue-element-admin 完整模板到本地，主要作用是方便我们直接拿组件到项目中使用 1git clone https://github.com/PanJiaChen/vue-element-admin.git 克隆 vue-admin-template 基础模板到本地，主要作用是创建一个最简单的项目后台，再根据需求慢慢完善功能 1git clone https://github.com/PanJiaChen/vue-admin-template.git 克隆后项目后，进入项目目录，安装依赖 1234567891011# 进入项目目录cd vue-element-admin# 安装依赖npm install# 建议不要用 cnpm 安装 可以通过如下操作解决 npm 下载速度慢的问题npm install --registry=https://registry.npm.taobao.org# 本地开发 启动项目npm run dev IDEA在使用vue-element-admin 模板时会默认开启ESLint代码质量管理工具。为了开发方便，关闭ESLint 项目结构1234567891011121314151617181920212223242526272829303132├── build # 构建相关├── mock # 项目mock 模拟数据├── plop-templates # 基本模板├── public # 静态资源│ │── favicon.ico # favicon图标│ └── index.html # html模板├── src # 源代码│ ├── api # 所有请求│ ├── assets # 主题 字体等静态资源│ ├── components # 全局公用组件│ ├── directive # 全局指令│ ├── filters # 全局 filter│ ├── icons # 项目所有 svg icons│ ├── lang # 国际化 language│ ├── layout # 全局 layout│ ├── router # 路由│ ├── store # 全局 store管理│ ├── styles # 全局样式│ ├── utils # 全局公用方法│ ├── vendor # 公用vendor│ ├── views # views 所有页面│ ├── App.vue # 入口页面│ ├── main.js # 入口文件 加载组件 初始化等│ └── permission.js # 权限管理├── tests # 测试├── .env.xxx # 环境变量配置├── .eslintrc.js # eslint 配置项├── .babelrc # babel-loader 配置├── .travis.yml # 自动化CI配置├── vue.config.js # vue-cli 配置├── postcss.config.js # postcss 配置└── package.json # package.json 修改侧边栏参考官方文档路由||侧边栏 本项目侧边栏和路由是绑定在一起的，所以你只有在 @/router/index.js 下面配置对应的路由，侧边栏就能动态的生成了 其中的@就是src目录，你可以在vue.config.js中看到 一般侧边栏有两种形式即：submenu 和 直接 el-menu-item。 一个是嵌套子菜单，另一个则是直接一个链接。如下图： 在 Sidebar 中已经帮你做了判断，当你一个路由下面的 children 声明的路由大于&gt;1 个时，自动会变成嵌套的模式。 如果子路由正好等于一个就会默认将子路由作为根路由显示在侧边栏中，若不想这样，可以通过设置在根路由中设置alwaysShow: true来取消这一特性 在路由中修改如下，图标可以去官方文档查找 实现商品列表展示安装axios模块 下载axios模块 1npm install --save vue-axios 首先在main.js中引入axios模块 12345import Vue from &#x27;vue&#x27;import axios from &#x27;axios&#x27;import VueAxios from &#x27;vue-axios&#x27;Vue.use(VueAxios, axios) mock数据 使用mock模拟后端传来的数据，fastmock官网：https://www.fastmock.site/#/ 1234567891011121314151617181920212223242526&#123; &quot;product&quot;:[ &#123; &quot;id&quot;:01, &quot;name&quot;:&quot;手机&quot;, &quot;images&quot;:&quot;img01&quot;, &quot;price&quot;:999, &quot;salePrice&quot;:100, &quot;salePoint&quot;:200, &#125;,&#123; &quot;id&quot;:02, &quot;name&quot;:&quot;相机&quot;, &quot;images&quot;:&quot;img02&quot;, &quot;price&quot;:1999, &quot;salePrice&quot;:100, &quot;salePoint&quot;:200, &#125;,&#123; &quot;id&quot;:03, &quot;name&quot;:&quot;电脑&quot;, &quot;images&quot;:&quot;img03&quot;, &quot;price&quot;:10099, &quot;salePrice&quot;:100, &quot;salePoint&quot;:200, &#125; ]&#125; 属性名中不能带有特殊符号，例如sale_Point是无法取到值的 复制接口然后前端调用 修改路由 修改src/router/index.js路由 1234567891011121314151617//商品管理 &#123; path: &#x27;/example&#x27;, component: Layout, alwaysShow:true, //取消子路由作为根路由显示在侧边栏中 redirect: &#x27;/example/table&#x27;, name: &#x27;Example&#x27;, meta: &#123; title: &#x27;商品管理&#x27;, icon: &#x27;el-icon-s-help&#x27; &#125;, children: [ &#123; path: &#x27;products&#x27;, name: &#x27;products&#x27;, //路由的路径 component: () =&gt; import(&#x27;@/views/products/index&#x27;), meta: &#123; title: &#x27;商品列表&#x27;, icon: &#x27;table&#x27; &#125; &#125; &#125;, 在views下创建products/index.vue，直接复制原table文件夹里的index.vue路由，然后修改即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;el-table :data=&quot;list&quot; border fit highlight-current-row&gt; &lt;!--第一列--&gt; &lt;el-table-column align=&quot;center&quot; label=&quot;序号&quot; width=&quot;95&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &#123;&#123; scope.$index+1 &#125;&#125; &lt;!--索引,会根据数据自动加1,默认为0--&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;!--第二列--&gt; &lt;el-table-column label=&quot;商品ID&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &#123;&#123; scope.row.id &#125;&#125; &lt;!--id对应json或者数据库表中的字段--&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;!--第三列--&gt; &lt;el-table-column label=&quot;商品名称&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &#123;&#123; scope.row.name &#125;&#125; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; list: &#123;&#125; &#125;; &#125;, created() &#123; this.fetchData(); &#125;, methods: &#123; fetchData() &#123; var vm = this; //axios请求 this.axios(&#123; method:&#x27;get&#x27;, url:&#x27;https://www.fastmock.site/mock/00daa94229c45f62263030ffe4b715db/myVuedemo/getProductList&#x27;, &#125;).then(function(resp)&#123; vm.list=resp.data.product &#125;) &#125; &#125;&#125;;&lt;/script&gt; 使用npm run dev查看运行结果 实现编辑商品路由跳转 在商品列表中提供编辑按钮，可以取复杂模板获取 在views/editproduct下创建一个商品编辑页（index.vue） 在router/index.js路由表中注册商品编辑页 12345678910111213&#123; path: &quot;/editproduct&quot;, hidden: true, //不在侧边栏出现 component: Layout, children: [ &#123; path: &quot;index/:id&quot;, //注意带了一个参数 name: &quot;editproduct&quot;, component: () =&gt; import(&quot;@/views/editproduct/index&quot;), meta: &#123; title: &quot;编辑商品&quot;, icon: &quot;form&quot; &#125; &#125; ] &#125;, 通过商品列表的编辑按钮跳转到商品编辑页，但是如何标识唯一商品呢，我们可以通过获取商品ID做为路由参数传递 在商品列表product/index.vue中给按钮添加事件 12345678910111213141516171819202122&lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-button type=&quot;primary&quot; size=&quot;mini&quot; @click=&quot;editproduct(scope.row.id)&quot;&gt; 编辑 &lt;/el-button&gt;&lt;/template&gt; &lt;script&gt;export default &#123; data() &#123; return &#123; list: &#123;&#125; &#125;; &#125;, methods: &#123; //点击编辑按钮 editproduct(id)&#123; //跳转路由 this.$router.push(&quot;/editproduct/index/&quot;+id); &#125; &#125;&#125;;&lt;/script&gt; 然后在editproduct/index.vue页面取值 1&#123;&#123; this.$route.params.id &#125;&#125; 或者创建SSM项目，java代码如下 12345@RequestMapping(&quot;list&quot;)public List&lt;TProduct&gt; getList()&#123; return productService.getList(); //编写查询全部&#125; 根据ID获取后端数据 通过id，发送请求，让后端提供该id的商品对象，并展示在页面中 修改editproduct/index.vue页面，通过v-model双向绑定数据 123456789101112131415&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;el-form ref=&quot;form&quot; :model=&quot;product&quot; label-width=&quot;120px&quot;&gt; &lt;el-form-item label=&quot;商品名称&quot;&gt; &lt;el-input v-model=&quot;product.name&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品价格&quot;&gt; &lt;el-input v-model=&quot;product.price&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;onsubmit()&quot;&gt;编辑&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt; 创建生命周期钩子函数，用于发送axios请求给后端，实时获取数据 123456789101112131415161718192021222324252627282930313233&lt;script&gt;export default &#123; data() &#123; return &#123; product: &#123; id: 1, name: &quot;手机&quot;, images: &quot;img01&quot;, price: 999, salePrice: 100, salePoint: 200 &#125; &#125;; &#125;, created() &#123; this.fetchDataById(); &#125;, methods: &#123; fetchDataById() &#123; var id = this.$route.params.id; var vm = this; this.axios(&#123; method: &quot;GET&quot;, url: &quot;https://localhost:8080/getProductList?id=&quot; +id &#125;).then(function(resp) &#123; vm.product = resp.data; &#125;); &#125;, onsubmit() &#123;&#125; &#125;&#125;;&lt;/script&gt; Java代码 123456@RequestMapping(&quot;getProductById&quot;)@ResponseBodypublic TProduct getProductById(Long id)&#123; return productService.getProductById(id); //编写通过id查询&#125; 编辑内容发送给后端 点编辑按钮时，获得所有编辑的数据，传送给后端接口，实现修改数据的效果 请求方式是用POST， 编辑完后，要跳转到商品列表 1234567891011121314151617181920212223242526272829303132&lt;el-form-item&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;onsubmit()&quot;&gt;编辑&lt;/el-button&gt;&lt;/el-form-item&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; product: &#123; id: 1, name: &quot;手机&quot;, images: &quot;img01&quot;, price: 999, salePrice: 100, salePoint: 200 &#125; &#125;; &#125;, methods: &#123; onsubmit() &#123; var vm = this; this.axios(&#123; method:&quot;post&quot;, url: &quot;http://localhost:8080/product/editproduct&quot;, data: vm.product //发送的数据类型为一个JSON对象 &#125;).then(function(resp)&#123; vm.$router.push(&quot;/products&quot;) //跳转到显示页面 &#125;) &#125; &#125;&#125;;&lt;/script&gt; 注意：前端传来的是JSON数据对象，后端参数要加@RequestBody注解 1234567@RequestMapping(value=&quot;editproduct&quot;,method = RequestMethod.POST)@ResponseBodypublic String editProductById(@RequestBody TProduct tProduct)&#123; productService.editProductById(tProductp); //接到这个对象更新到数据库里面 return &quot;success&quot;;&#125; 删除商品 前端 1234567891011121314151617//点击删除商品 delproduct(id)&#123; var vm = this; //axios请求 this.axios(&#123; method: &quot;get&quot;, url: &quot;https://localhost:8080/delproduct?id=&quot;+id &#125;).then(function(resp) &#123; if(resp.data == &quot;success&quot;)&#123; alert(&quot;成功!&quot;) &#125; vm.fetchData(); //更新商品列表 &#125;).catch(function(error) &#123; alert(&quot;失败!&quot;) &#125;) &#125; 后端代码 123456@RequestMapping(value=&quot;delproduct&quot;,method = RequestMethod.GET)@ResponseBodypublic String delProductById(int id)&#123; productService.delProductById(id); //根据id删除 return &quot;success&quot;;&#125; 添加商品创建路由 在product/inde.vue商品列表增加添加商品的按钮 12345&lt;div align=&quot;right&quot;&gt; &lt;el-button type=&quot;success&quot; @click=&quot;addproduct()&quot;&gt; 添加 &lt;/el-button&gt;&lt;/div 在views/addproduct下创建index.vue路由 1234567891011121314151617&lt;template&gt; &lt;div class=&quot;app-container&quot;&gt; &lt;el-form ref=&quot;form&quot; :model=&quot;product&quot; label-width=&quot;120px&quot;&gt; &lt;el-form-item label=&quot;商品名称&quot;&gt; &lt;el-input v-model=&quot;product.name&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;商品价格&quot;&gt; &lt;el-input v-model=&quot;product.price&quot; /&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;addproduct()&quot;&gt;添加&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt; 在router/index.js中配置路由 12345678910111213&#123; path: &quot;/addproduct&quot;, hidden: true, //不再侧边栏出现 component: Layout, children: [ &#123; path: &quot;index&quot;, name: &quot;addproduct&quot;, component: () =&gt; import(&quot;@/views/addproduct/index&quot;), meta: &#123; title: &quot;添加商品&quot;, icon: &quot;form&quot; &#125; &#125; ] &#125;, post请求如何传递数据qs插件 qs是一个流行的查询参数序列化和解析库。可以将一个普通的object序列化成一个查询字符串，或者反过来将一个查询字符串解析成一个object,帮助我们查询字符串解析和序列化字符串 需要使用qs内置库，首先安装qs 1npm install qs 然后在main.js中引入qs内置库 1import qs from &#x27;qs&#x27; 在main.js中配置全局属性 1Vue.prototype.$qs = qs 方法 qs.parse()是将URL解析成对象的形式 12const str = &quot;username=&#x27;admin&#x27;&amp;password=&#x27;admin&#x27;&quot; console.log(qs.parse(str)) // Object &#123; username: &quot;admin&quot;, password: &quot;admin&quot; &#125; qs.stringify()是将对象 序列化成URL的形式，以&amp;进行拼接 12qs.stringify(&#123;username:&#x27;admin&#x27;, password:&#x27;admin&#x27;&#125;)//username=admin&amp;password=admin 解决Vue中POST请求无法携带数据的问题 12345678910111213onSubmit()&#123; var vm = this; this.axios(&#123; method: &#x27;POST&#x27;, url: &#x27;&#x27;, //=========解决POST请求无法携带数据的问题=========== transformRequest: [function (data) &#123; return Qs.stringify(data) &#125;], //=============================== data:vm.product &#125;).then();&#125; 跳转并发送请求 在product/inde.vue商品列表中点击添加商品的按钮就跳转到addproduct下的路由 123addproduct()&#123; this.$router.push(&quot;/addproduct/index&quot;) &#125; 在views/addproduct/index.vue路由中发送axios请求 1234567891011121314151617181920methods: &#123; addproduct() &#123; var vm = this; this.axios(&#123; method: &quot;post&quot;, url: &quot;http://localhost:8080/product/addproduct&quot;, //=========解决POST请求无法携带数据的问题=========== transformRequest: [ function(data) &#123; return Qs.stringify(data); &#125; ], //=============================== data: vm.product //发送的数据类型为一个JSON对象 &#125;).then(function(resp) &#123; //添加成功后，前往商品列表页面 vm.$router.push(&quot;/products&quot;); &#125;); &#125; &#125; 后端 123456@RequestMapping(value=&quot;addproduct&quot;,method = RequestMethod.POST)public String addProduct(TProduct tProduct)&#123; ProductService.addProduct(tProduct); //添加数据 return &quot;success&quot;&#125;","path":"page/Vuejs10.html","date":"04-20","excerpt":"","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://xiaoliblog.cn/tags/Vue-js/"}]},{"title":"Vue.js前端框架🎯Webpack-Vue模块","text":"Webpack-Vue创建工程 创建一个名为 Webpack-vue-demo 的工程，根据需求选择 12# 使用 webpack 打包工具初始化一个名为 Webpack-vue-demo 的工程vue init webpack Webpack-vue-demo 安装依赖 我们需要安装 vue-router、element-ui、sass-loader 和 node-sass 四个插件 12345678# 进入工程目录cd Webpack-vue-demo# 安装 vue-routernpm install vue-router --save-dev# 安装 element-uinpm i element-ui -S# 安装 SASS 加载器npm install sass-loader node-sass --save-dev 安装依赖 12# 安装依赖npm install 启动工程 1npm run dev 附：NPM相关命令说明 1234npm install moduleName #安装模块到项目目录下npm install -g moduleName #-g的意思是将模块安装到全局，具体安装到磁盘哪个位置，要看 npm config prefix 的位置npm install -save moduleName #--save 的意思是将模块安装到项目目录下，并在 package 文件的 dependencies 节点写入依赖，`-S` 为该命令的缩写npm install -save-dev moduleName #--save-dev 的意思是将模块安装到项目目录下，并在 package 文件的 devDependencies 节点写入依赖，`-D` 为该命令的缩写 Element UI搭建登录页 Element UI官方文档：https://element.eleme.cn/#/ 在源码src目录下创建如下结构，有则忽略 views文件夹：用于存放Vue视图组件 router文件夹：用于存放vue-router配置 components文件夹：用于存放Vue功能组件 assets文件夹：用于存放资源文件 创建视图 在 views 目录下创建一个名为 Main.vue 的视图组件；用于登录后展示登录成功的跳转效果； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;template&gt; &lt;div&gt; &lt;el-container style=&quot;height: 500px; border: 1px solid #eee&quot;&gt; &lt;el-aside width=&quot;200px&quot; style=&quot;background-color: rgb(238, 241, 246)&quot;&gt; &lt;!--默认打开1--&gt; &lt;el-menu :default-openeds=&quot;[&#x27;1&#x27;]&quot;&gt; &lt;el-submenu index=&quot;1&quot;&gt; &lt;template slot=&quot;title&quot; &gt;&lt;i class=&quot;el-icon-message&quot;&gt;&lt;/i&gt;商品管理&lt;/template &gt; &lt;el-menu-item-group&gt; &lt;el-menu-item index=&quot;1-1&quot;&gt;商品列表&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;1-2&quot;&gt;商品信息&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt; &lt;/el-aside&gt; &lt;el-container&gt; &lt;el-header style=&quot;text-align: right; font-size: 12px&quot;&gt; &lt;el-dropdown&gt; &lt;i class=&quot;el-icon-setting&quot; style=&quot;margin-right: 15px&quot;&gt;&lt;/i&gt; &lt;el-dropdown-menu slot=&quot;dropdown&quot;&gt; &lt;el-dropdown-item&gt;查看&lt;/el-dropdown-item&gt; &lt;el-dropdown-item&gt;新增&lt;/el-dropdown-item&gt; &lt;el-dropdown-item&gt;删除&lt;/el-dropdown-item&gt; &lt;/el-dropdown-menu&gt; &lt;/el-dropdown&gt; &lt;span&gt;王小虎&lt;/span&gt; &lt;/el-header&gt; &lt;el-main&gt; &lt;el-table :data=&quot;tableData&quot;&gt; &lt;el-table-column prop=&quot;date&quot; label=&quot;日期&quot; width=&quot;140&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;name&quot; label=&quot;姓名&quot; width=&quot;120&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;address&quot; label=&quot;地址&quot;&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/el-main&gt; &lt;/el-container&gt; &lt;/el-container&gt; &lt;/div&gt; &lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;Main&quot;&#125;;&lt;/script&gt;&lt;style&gt; .el-header &#123; background-color: #B3C0D1; color: #333; line-height: 60px; &#125; .el-aside &#123; color: #333; &#125;&lt;/style&gt; 在 views 目录下创建一个名为 Login.vue 的视图组件，其中 el-* 的元素为 ElementUI 组件； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;template&gt; &lt;div&gt; &lt;el-form ref=&quot;loginForm&quot; :model=&quot;form&quot; :rules=&quot;rules&quot; label-width=&quot;80px&quot; class=&quot;login-box&quot;&gt; &lt;h3 class=&quot;login-title&quot;&gt;欢迎登录&lt;/h3&gt; &lt;el-form-item label=&quot;账号&quot; prop=&quot;username&quot;&gt; &lt;el-input type=&quot;text&quot; placeholder=&quot;请输入账号&quot; v-model=&quot;form.username&quot;/&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;密码&quot; prop=&quot;password&quot;&gt; &lt;el-input type=&quot;password&quot; placeholder=&quot;请输入密码&quot; v-model=&quot;form.password&quot;/&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type=&quot;primary&quot; v-on:click=&quot;onSubmit(&#x27;loginForm&#x27;)&quot;&gt;登录&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;el-dialog title=&quot;温馨提示&quot; :visible.sync=&quot;dialogVisible&quot; width=&quot;30%&quot; :before-close=&quot;handleClose&quot;&gt; &lt;span&gt;请输入账号和密码&lt;/span&gt; &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;dialogVisible = false&quot;&gt;确 定&lt;/el-button&gt; &lt;/span&gt; &lt;/el-dialog&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;Login&quot;, data() &#123; return &#123; form: &#123; username: &#x27;&#x27;, password: &#x27;&#x27; &#125;, // 表单验证，需要在 el-form-item 元素中增加 prop 属性 rules: &#123; username: [ &#123;required: true, message: &#x27;账号不可为空&#x27;, trigger: &#x27;blur&#x27;&#125; ], password: [ &#123;required: true, message: &#x27;密码不可为空&#x27;, trigger: &#x27;blur&#x27;&#125; ] &#125;, // 对话框显示和隐藏 dialogVisible: false &#125; &#125;, methods: &#123; onSubmit(formName) &#123; // 为表单绑定验证功能 this.$refs[formName].validate((valid) =&gt; &#123; if (valid) &#123; // 使用 vue-router 路由到指定页面，该方式称之为编程式导航 this.$router.push(&quot;/main&quot;); &#125; else &#123; this.dialogVisible = true; return false; &#125; &#125;); &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .login-box &#123; border: 1px solid #DCDFE6; width: 350px; margin: 180px auto; padding: 35px 35px 15px 35px; border-radius: 5px; -webkit-border-radius: 5px; -moz-border-radius: 5px; box-shadow: 0 0 25px #909399; &#125; .login-title &#123; text-align: center; margin: 0 auto 40px auto; color: #303133; &#125;&lt;/style&gt; 创建路由 在 router 目录下创建一个名为 index.js 的 vue-router 路由配置文件，这就是一个路由表 123456789101112131415161718192021import Vue from &quot;vue&quot;;import Router from &quot;vue-router&quot;;import Login from &quot;../views/Login&quot;;import Main from &quot;../views/main&quot;;//安装路由Vue.use(Router);export default new Router(&#123; routes: [ &#123; path: &quot;/Login&quot;, //到时候地址栏会显示的路径 name: &quot;Login&quot;, component: Login // Login是组件的名字，这个路由对应跳转到的组件 &#125;, &#123; path: &quot;/main&quot;, name: &quot;main&quot;, component: Main &#125; ]&#125;); 配置路由 修改 main.js 入口代码，导入路由模块和ElementUI 1234567891011121314151617181920212223242526import Vue from &#x27;vue&#x27;import App from &#x27;./App&#x27;//导入路由配置目录import router from &#x27;./router&#x27;import VueRouter from &#x27;vue-router&#x27; //全局使用路由模块// 导入 ElementUIimport ElementUI from &#x27;element-ui&#x27;;import &#x27;element-ui/lib/theme-chalk/index.css&#x27;;//引入Axiosimport axios from &#x27;axios&#x27;import VueAxios from &quot;vue-axios&quot;; Vue.use(VueAxios, axios)//使用路由和ElementUIVue.use(VueRouter)Vue.use(ElementUI);new Vue(&#123; el: &#x27;#app&#x27;, //配置路由 router, render: h =&gt; h(App)&#125;) 在App.vue中使用 12345678910&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;App&#x27;&#125;&lt;/script&gt; Mock数据 每次前端测试的时候，都需要搭建一个后端环境，很麻烦，这时候可以使用Mock假数据，即提供假数据，可以让前端不需要等待后端的接口，而直接进行下一步的开发。一个常用的工具：Easy-Mock或者fastmock Gitee地址：https://gitee.com/mirrors/Easy-Mock 由于Esay-Mock最近好像崩了，推荐另一款在线工具fastmock：https://www.fastmock.site/#/ fastmock使用文档：https://marvengong.gitee.io/fastmock/#/default fastmock可以让你在没有后端程序的情况下能真实地在线模拟ajax请求，你可以用fatmock实现项目初期纯前端的效果演示，也可以用fastmock实现开发中的数据模拟从而实现前后端分离 注册登录 进入注册页面进行注册 用户名备忘：li1234 创建接口 点击【创建项目】，自定义名称和接口 项目如下所示，点击【新增接口】 填写接口相关信息，创建一个users的JSON数组 复制好完整接口地址，用于前端发送Ajax 测试接口 通过main.vue测试接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;template&gt; &lt;div&gt; &lt;el-container style=&quot;height: 500px; border: 1px solid #eee&quot;&gt; &lt;el-aside width=&quot;200px&quot; style=&quot;background-color: rgb(238, 241, 246)&quot;&gt; &lt;!--默认打开1--&gt; &lt;el-menu :default-openeds=&quot;[&#x27;1&#x27;]&quot;&gt; &lt;el-submenu index=&quot;1&quot;&gt; &lt;template slot=&quot;title&quot; &gt;&lt;i class=&quot;el-icon-message&quot;&gt;&lt;/i&gt;商品管理&lt;/template &gt; &lt;el-menu-item-group&gt; &lt;el-menu-item index=&quot;1-1&quot;&gt;商品列表&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;1-2&quot;&gt;商品信息&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;/el-submenu&gt; &lt;/el-menu&gt; &lt;/el-aside&gt; &lt;el-container&gt; &lt;el-header style=&quot;text-align: right; font-size: 12px&quot;&gt; &lt;el-dropdown&gt; &lt;i class=&quot;el-icon-setting&quot; style=&quot;margin-right: 15px&quot;&gt;&lt;/i&gt; &lt;el-dropdown-menu slot=&quot;dropdown&quot;&gt; &lt;el-dropdown-item&gt;查看&lt;/el-dropdown-item&gt; &lt;el-dropdown-item&gt;新增&lt;/el-dropdown-item&gt; &lt;el-dropdown-item&gt;删除&lt;/el-dropdown-item&gt; &lt;/el-dropdown-menu&gt; &lt;/el-dropdown&gt; &lt;span&gt;王小虎&lt;/span&gt; &lt;/el-header&gt; &lt;!--数据显示，从后端拿取,:data为创建一个属性对应值为users--&gt; &lt;el-main&gt; &lt;el-table :data=&quot;users&quot;&gt; &lt;el-table-column prop=&quot;uid&quot; label=&quot;用户ID&quot; width=&quot;140&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;name&quot; label=&quot;姓名&quot; width=&quot;120&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;age&quot; label=&quot;年龄&quot;&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/el-main&gt; &lt;/el-container&gt; &lt;/el-container&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;Main&quot;, data()&#123; return &#123; //users对应:data,是一个JSON数组，对应Mock接口里的数据 users:[ ] &#125; &#125;, //调用生命周期钩子函数，页面加载完就调用 created()&#123; //axios内部的then是调用不到this //因为this是当前axios对象，而不是当前Vue对象，因此把当前Vue对象用vm来指明，这样this不会冲突 var vm = this; this.axios(&#123; method:&quot;get&quot;, //mock接口地址 url:&quot;https://www.fastmock.site/mock/00daa94229c45f62263030ffe4b715db/myVuedemo/getUserList&quot;, &#125;).then(function(resp)&#123; //请求成功后的回调函数 vm.users = resp.data.users //后端的值赋给Vue实例对象的users &#125;); &#125;&#125;;&lt;/script&gt;&lt;style&gt; .el-header &#123; background-color: #B3C0D1; color: #333; line-height: 60px; &#125; .el-aside &#123; color: #333; &#125;&lt;/style&gt; 可以看到拿到了mock的假数据 重点：在发送axios请求时，如何调用到当前vue对象中的内容 因为axios内部的then内的this是当前axios对象，而不是当前vue对象，因此把当前vue对象用vm来指明。这样this不会冲突 12345678910111213141516171819&lt;script&gt;export default &#123; name: &quot;Main&quot;, //调用生命周期钩子函数，页面加载完就调用 created()&#123; //axios内部的then是调用不到this //因为this是当前axios对象，而不是当前Vue对象，因此把当前Vue对象用vm来指明，这样this不会冲突 var vm = this; this.axios(&#123; method:&quot;get&quot;, //mock接口地址 url:&quot;https://www.fastmock.site/mock/00daa94229c45f62263030ffe4b715db/myVuedemo/getUserList&quot;, &#125;).then(function(resp)&#123; //请求成功后的回调函数 vm.users = resp.data.users //后端的值赋给Vue实例对象的users console.log = (resp.data.users) &#125;); &#125;&#125;;&lt;/script&gt; 嵌套路由 在路由显示的组件内部，又嵌套着路由，称为嵌套路由也叫子路由。在实际应用中，通常由多层嵌套的组件组合而成。同样地，URL 中各段动态路径也按某种结构对应嵌套的各层组件，例如： 12345678&#x2F;user&#x2F;foo&#x2F;profile &#x2F;user&#x2F;foo&#x2F;posts+------------------+ +-----------------+| User | | User || +--------------+ | | +-------------+ || | Profile | | +------------&gt; | | Posts | || | | | | | | || +--------------+ | | +-------------+ |+------------------+ +-----------------+ 配置路由表 环境场景是main.vue下有两个子路由ProductInfo.vue和ProductList.vue 首先配置子路由ProductInfo.vue 12345678910111213&lt;template&gt; &lt;div&gt; 商品信息... &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default (&#123; name:&quot;ProductInfo&quot;&#125;)&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 配置子路由ProductList.vue 12345678910111213&lt;template&gt; &lt;div&gt; 商品列表... &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default (&#123; name:&quot;ProductList&quot;&#125;)&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 在route/index.js中引入，在父路由下配置路由表 123456789101112131415161718192021222324252627282930313233343536import Vue from &quot;vue&quot;;import Router from &quot;vue-router&quot;;import Login from &quot;../views/Login&quot;;import Main from &quot;../views/main&quot;;import ProductInfo from &quot;../views/ProductInfo&quot;;import ProductList from &quot;../views/ProductList&quot;;//安装路由Vue.use(Router);export default new Router(&#123; routes: [ &#123; path: &quot;/Login&quot;, //到时候地址栏会显示的路径 name: &quot;Login&quot;, component: Login // Login是组件的名字，这个路由对应跳转到的组件 &#125;, &#123; path: &quot;/main&quot;, //到时候地址栏会显示的路径 name: &quot;main&quot;, component: Main, // Login是组件的名字，这个路由对应跳转到的组件 // main主页面下有两个子路由 children:[ &#123; path:&quot;/ProductList&quot;, //注意,使用路由时的地址:/productlist name:&quot;ProductList&quot;, component: ProductList, //显示在main的&lt;routerview&gt;&lt;/routerview&gt;标签里面 &#125;, &#123; path:&quot;/ProductInfo&quot;, name:&quot;ProductLInfo&quot;, component: ProductInfo, &#125; ] &#125; ]&#125;); 使用嵌套路由 在父路由main.vue中使用 通过&lt;router-link to=&quot;/ProductInfo&quot;&gt;商品信息&lt;/router-link&gt;跳转 通过&lt;router-view&gt;&lt;/router-view&gt;显示 12345678910111213141516171819202122232425262728293031&lt;template&gt;&lt;div&gt; &lt;el-menu-item-group&gt; &lt;!--跳转有两种实现方法：1.to=&quot;/路径&quot; 2. 通过@click点击事件--&gt; &lt;!--跳转到ProductList,不需要带/main/--&gt; &lt;el-menu-item index=&quot;1-1&quot;&gt;&lt;router-link to=&quot;/ProductList&quot;&gt;商品列表&lt;/router-link&gt;&lt;/el-menu-item&gt; &lt;el-menu-item index=&quot;1-2&quot;&gt;&lt;router-link to=&quot;/ProductInfo&quot;&gt;商品信息&lt;/router-link&gt;&lt;/el-menu-item&gt; &lt;/el-menu-item-group&gt; &lt;!--数据显示，从后端拿取,:data为创建一个属性对应值为users--&gt; &lt;el-main&gt; &lt;!--显示商品列表--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/el-main&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;Main&quot;, methods:&#123; //方法跳转 toProductInfo:function()&#123; this.$router.push(&quot;/ProductInfo&quot;) &#125; &#125;,&#125;;&lt;/script&gt; 测试结果，可以看到在父路由页面不改变的情况下，切换页面 组件重定向 Vue 中的重定向是作用在路径不同但组件相同的情况下 配置重定向 直接调用另一个已配置好的路由对象即可 比如实现一个退出功能，访问/logout就跳转到/Login登录页面 跳转就需要用到路由，去router/index.js中配置路由，使用redirect设置跳转路径 123456789101112export default new Router(&#123; routes: [ &#123; path: &quot;/Login&quot;, //到时候地址栏会显示的路径 name: &quot;Login&quot;, component: Login // Login是组件的名字，这个路由对应跳转到的组件 &#125;, &#123; path:&quot;/logout&quot;, redirect:&quot;/Login&quot; //重定向到登录页面 &#125;,&#125;); 在main.vue中使用 1&lt;router-link to=&quot;/logout&quot;&gt;退出&lt;/router-link&gt; 参数传递 我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。此时我们就需要传递参数了； 使用路径匹配方式 此方法有局限性，/ProductInfo/1后面一定要接一个参数才能访问，而且只能接一个参数 配置路由 修改ProductInfo路由配置 12345 &#123; path:&quot;/ProductInfo/:id&quot;, name:&quot;ProductLInfo&quot;, component: ProductInfo,&#125; 说明：主要是在 path 属性中增加了 :id 这样的占位符 传递参数 在main.vue中配置router-link 1&lt;router-link to=&quot;/ProductInfo/1&quot;&gt;商品信息&lt;/router-link&gt; 取得参数 在ProductInfo.vue中通过插值表达式取值 12345&lt;template&gt; &lt;div&gt; 商品信息...参数为：&#123;&#123;this.$route.params.id&#125;&#125; &lt;/div&gt;&lt;/template&gt; 运行结果取得参数1 运行原理 使用 props的方式 第二种方法参用对象方式的传递，只在传参部分不同 配置路由 修改ProductInfo路由，配置和第一种方法相同 12345 &#123; path:&quot;/ProductInfo/:id&quot;, name:&quot;ProductInfo&quot;, //注意这个name参数，后面传参要用到 component: ProductInfo,&#125; 传递参数 router-link 12&lt;!--params指定参数,可以指定多个参数,以键值对形式存在--&gt;&lt;router-link :to=&quot;&#123;name:&#x27;ProductInfo&#x27;,params:&#123;id:1001&#125;&#125;&quot;&gt;商品信息&lt;/router-link&gt; 说明：此时我们将 to 改为了 :to，是为了将这一属性当成对象使用，注意 router-link 中的 name 属性名称 一定要和 路由中的 name 属性名称 匹配，因为这样 Vue 才能找到对应的路由路径； 接收参数 在目标组件中使用以下来接收参数，接参不变 12345&lt;template&gt; &lt;div&gt; 商品信息...参数为：&#123;&#123;this.$route.params.id&#125;&#125; &lt;/div&gt;&lt;/template&gt; 运行结果取得参数1001 运行原理 路由钩子与异步请求路由中的钩子函数 beforeRouteEnter：在进入路由前执行 beforeRouteLeave：在离开路由前执行 123456789101112export default &#123; props: [&#x27;id&#x27;], name: &quot;UserProfile&quot;, beforeRouteEnter: (to, from, next) =&gt; &#123; console.log(&quot;准备进入个人信息页&quot;); next(); &#125;, beforeRouteLeave: (to, from, next) =&gt; &#123; console.log(&quot;准备离开个人信息页&quot;); next(); &#125;&#125; 参数说明： to：路由将要跳转的路径信息 from：路径跳转前的路径信息 next：路由的控制参数 next() 跳入下一个页面 next(&#39;/path&#39;) 改变路由的跳转方向，使其跳到另一个路由 next(false) 返回原来的页面 next((vm)=&gt;&#123;&#125;) 仅在 beforeRouteEnter 中可用，vm 是组件实例 在钩子函数中使用异步请求 安装 Axios 1npm install axios -s 引用 Axios 12import axios from &#x27;axios&#x27;Vue.prototype.axios = axios; 在 beforeRouteEnter 中进行异步请求，案例代码如下： 123456789101112131415161718192021222324252627export default &#123; props: [&#x27;id&#x27;], name: &quot;UserProfile&quot;, beforeRouteEnter: (to, from, next) =&gt; &#123; console.log(&quot;准备进入个人信息页&quot;); // 注意，一定要在 next 中请求，因为该方法调用时 Vue 实例还没有创建，此时无法获取到 this 对象，在这里使用官方提供的回调函数拿到当前实例 next(vm =&gt; &#123; vm.getData(); &#125;); &#125;, beforeRouteLeave: (to, from, next) =&gt; &#123; console.log(&quot;准备离开个人信息页&quot;); next(); &#125;, methods: &#123; getData: function () &#123; this.axios(&#123; method: &#x27;get&#x27;, url: &#x27;http://localhost:8080/data.json&#x27; &#125;).then(function (repos) &#123; console.log(repos); &#125;).catch(function (error) &#123; console.log(error); &#125;); &#125; &#125; &#125;","path":"page/Vuejs09.html","date":"04-19","excerpt":"","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://xiaoliblog.cn/tags/Vue-js/"}]},{"title":"Vue.js前端框架🎯路由模块","text":"路由模块 官方文档：https://router.vuejs.org/zh/ 路由器的功能：在数据通信时 帮你选择通信的路线 在vue中的路由，能够帮助我们在一个vue组件中实现其他组件的相互切换。也就是说，可以通过路由模块，再创建路由表，将制定的组件显示在路由视图中 安装路由模块1npm install vue-router -s 设计路由界面 创建components文件夹，文件夹内分别创建Products、Home组件 Products.vue 123&lt;template&gt; &lt;div&gt;商品列表&lt;/div&gt;&lt;/template&gt; Home.vue 123&lt;template&gt; &lt;div&gt;首页&lt;/div&gt;&lt;/template&gt; 创建静态路由表 在src下创建routes.js（原webpack-simple模版） 12345678import Home from &#x27;./component/Home.vue&#x27;import Products from &#x27;./component/Products.vue&#x27;//创建路由表,path值即为路由链接的to值,component用于标识一个组件export const routes = [ &#123;path:&#x27;/Home&#x27;,component:Home&#125;, &#123;path:&#x27;/Products&#x27;,component:Products&#125;] 引入路由模块并使用 在main.js中引入路由模块并使用，如果在一个模块化工程中使用它，必须要通过 Vue.use() 明确地安装路由功能： 1234567891011121314151617import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import VueRouter from &#x27;vue-router&#x27; //1.引入路由模块import &#123;routes&#125; from &#x27;./route.js&#x27; //2.引入静态路由表Vue.use(VueRouter)//3.使用路由模块//4.创建一个VueRouter模块的实例const router = new VueRouter(&#123; routes:routes&#125;);new Vue(&#123; el: &#x27;#app&#x27;, router,//5.把router实例放入到vue实例中 render: h =&gt; h(App)&#125;) 路由初体验 修改App.vue 12345678910&lt;template&gt; &lt;div class=&quot;app&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:&quot;app&quot;&#125;;&lt;/script&gt; 改变url，发现&lt;router-view&gt;&lt;/router-view&gt;中的内容发生改变 http://localhost:8080/#/Home 显示home首页 http://localhost:8080/#/Products 显示produtcs商品列表 在项目模板下使用启动项目命令：npm run dev 链接路由的实现 修改App.vue 1234567891011121314&lt;template&gt; &lt;div class=&quot;app&quot;&gt; &lt;!--to的参数就是route.js路由表里的path--&gt; &lt;span&gt;&lt;router-link to=&quot;./Home&quot;&gt;首页&lt;/router-link&gt;&lt;/span&gt; &lt;span&gt;&lt;router-link to=&quot;./Products&quot;&gt;商品列表&lt;/router-link&gt;&lt;/span&gt; &lt;!--显示组件的内容--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:&quot;app&quot;&#125;;&lt;/script&gt; 可以发现像两个a标签，&lt;router-view&gt;&lt;/router-view&gt;就是页面的内容 路由过程分析： 路由之间的参数传递设参 通过route.js路由表，设置路由参数 12345//创建路由表,添加:midexport const routes = [ &#123;path:&#x27;/Home&#x27;,component:Home&#125;, &#123;path:&#x27;/Products/:mid&#x27;,component:Products&#125;] 传参 通过router-link的to访问路径时携带参数 1&lt;router-link to=&quot;/Products/1&quot; tag=&quot;li&quot; active-class=&quot;active&quot;&gt;&lt;a&gt;手机&lt;/a&gt;&lt;/router-link&gt; 接参 在目标Products.vue中，通过vue中的$route.params.mid 123456789101112131415&lt;template&gt; &lt;div&gt; &#123;&#123;id&#125;&#125;商品列表，此时这个页面要得到一个商品分类的ID，然后根据商品分离的ID，去数据库查询所有是该分离的商品，再显示在这个页面上 &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:&quot;Product&quot;, data()&#123; return&#123; id:this.$route.params.mid &#125; &#125;&#125;&lt;/script&gt; 实际改变的还是同一个页面，这种机制只能每一个参数对应一个Vue组件 路由跳转的两种方式 通过HTML中的路由&lt;router-link to=&quot;路由地址&quot;&gt;链接进行跳转 1&lt;span&gt;&lt;router-link to=&quot;./Home&quot;&gt;首页&lt;/router-link&gt;&lt;/span&gt; 通过js实现路由的跳转 1234567891011&lt;button type=&quot;button&quot; @click=&quot;btnfn&quot;&gt;点我&lt;/button&gt;&lt;script&gt;export default &#123; name: &quot;app&quot;, methods: &#123; btnfn:function()&#123; this.$router.push(&quot;/Products&quot;); &#125; &#125;,&#125;;&lt;/script&gt;","path":"page/Vuejs08.html","date":"04-18","excerpt":"","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://xiaoliblog.cn/tags/Vue-js/"}]},{"title":"Vue.js前端框架🎯Axios发送Ajax","text":"Axios发送Ajax Axios 是一个开源的可以用在浏览器端和 NodeJS 的异步通信框架，她的主要作用就是实现 AJAX 异步通信，其功能特点如下： 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF（跨站请求伪造） GitHub：https://github.com/axios/axios 由于 Vue.js 是一个 视图层框架 并且作者（尤雨溪）严格准守 SoC （关注度分离原则），所以 Vue.js 并不包含 AJAX 的通信功能，为了解决通信问题，作者单独开发了一个名为 vue-resource 的插件，不过在进入 2.0 版本以后停止了对该插件的维护并推荐了 Axios 框架 引入Boostrap 引入Boostrap等外部文件的CDN都在index.html中引入，因为vue组件最后都有经过index页面 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;vue-cli-demo&lt;/title&gt; &lt;/head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css&quot;/&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;/dist/build.js&quot;&gt;&lt;/script&gt; &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 修改App.vue，创建表单，并通过v-model绑定data中的属性，此表单用于提交测试 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;div style=&quot;width:50%&quot; class=&quot;container&quot;&gt; &lt;div&gt; &lt;h3&gt;Regist&lt;/h3&gt; &lt;h5&gt;Email&lt;/h5&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; v-model.trim=&quot;mail&quot; /&gt;&lt;br /&gt; &#123;&#123;mail&#125;&#125; &lt;h5&gt;Password&lt;/h5&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; v-model.lazy=&quot;password&quot; /&gt;&lt;br /&gt; &#123;&#123;password&#125;&#125; &lt;h5&gt;Gender&lt;/h5&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; v-model=&quot;gender&quot; value=&quot;female&quot; /&gt;男 &lt;input type=&quot;radio&quot; name=&quot;gender&quot; v-model=&quot;gender&quot; value=&quot;male&quot; /&gt;女&lt;br /&gt; &lt;h5&gt;Hobby&lt;/h5&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; v-model=&quot;hobby&quot; value=&quot;music&quot;&gt;音乐 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; v-model=&quot;hobby&quot; value=&quot;movie&quot;&gt;电影 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; v-model=&quot;hobby&quot; value=&quot;sport&quot;&gt;运动 &#123;&#123;hobby&#125;&#125; &lt;br&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-success&quot; @click=&quot;registbtn&quot;&gt; 注册 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data()&#123; return &#123; mail:&quot;xxx@126.com&quot;, password:&quot;&quot;, gender:&quot;&quot;, hobby:[] &#125; &#125;, methods:&#123; changeName:function(name)&#123; this.name = name &#125;,//点击注册就发送Ajax请求 //方法可以改成created()，即在创建的时候发送Ajax请求 registbtn: function() &#123; this.axios(&#123; method: &quot;get&quot;, //url为SSM框架的controller接口 url:&#x27;http://bit.ly/2mTM3nY&#x27;, data: &#123;&#125; &#125;).then(function(response) &#123; console.log(response.data); &#125;); &#125; &#125;&#125;&lt;/script&gt; 使用v-model绑定表单控件，v-model修饰符 lazy：失去焦点时才会绑定内容 trim： 绑定的内容自动去除开头和结尾的所有的空格，字符串内部的空格不去除 Axios的使用 安装vue axios 1npm install --save axios vue-axios 在main.js中引入，在项目中使用axios模块 12345import Vue from &#x27;vue&#x27;import axios from &#x27;axios&#x27;import VueAxios from &#x27;vue-axios&#x27;Vue.use(VueAxios, axios) 发送Ajax请求 123456789this.axios(&#123; method:&#x27;get&#x27;, //url应为SSM框架的controller接口 url:&#x27;http://bit.ly/2mTM3nY&#x27;, data:&#123;&#125;&#125;) .then(function (response) &#123; console.log(response.data) &#125;); 后端接口 简单搭建一个SpringMVC项目 1234567891011121314package com.lzy.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class UserController &#123; @RequestMapping(value=&quot;regist&quot;,method=RequestMethod.GET) public String regist(String mail,String password)&#123; System.out.println(mail); System.out.println(password); return &quot;regist success&quot;; &#125;&#125; 并提供postman进行接口测试 服务端解决跨域问题，在spring-mvc.xml中加入上述这一段。其中，allowed-origins指的是允许的访问源的域名，”*“表示任何人都可以访问，也可以指明具体的域名 1234567&lt;mvc:cors&gt; &lt;mvc:mapping path=&quot;/**&quot; allowed-origins=&quot;*&quot; allowed-methods=&quot;POST, GET, OPTIONS, DELETE, PUT,PATCH&quot; allowed-headers=&quot;Content-Type, Access-Control-Allow-Headers, Authorization, X-Requested-With&quot; allow-credentials=&quot;true&quot; /&gt;&lt;/mvc:cors&gt; 在App.vue中修改后端接口，提供注册按钮发送Ajax的 get请求 12345678910111213141516171819202122232425262728&lt;script&gt;export default &#123; data() &#123; return &#123; mail: &quot;xxx@126.com&quot;, password: &quot;&quot;, gender: &quot;&quot;, hobby: [] &#125;; &#125;, methods: &#123; changeName: function(name) &#123; this.name = name; &#125;, //点击注册就发送Ajax请求 registbtn: function() &#123; this.axios(&#123; method: &quot;get&quot;, //url为SSM框架的controller接口 url: &#x27;http://localhost:8080/regist?mail=&#x27;+this.mail+&#x27;&amp;password=&#x27;+this.password, //注意 get请求的参数一定是在url之后 data: &#123;&#125; &#125;).then(function(response) &#123; console.log(response.data); //返回的结果在response里 &#125;); &#125; &#125;&#125;;&lt;/script&gt; 发送Post请求 1234567891011this.axios(&#123; method:&#x27;post&#x27;, url:&#x27;http://localhost:8090/regist,data:&#123; mail:this.mail, password:this.password&#125;&#125;).then(function (response) &#123; console.log(response.data) &#125;); 解决axios无法传递data中的参数问题 原因：默认情况下发送axios时请求头中的内容类型为： 1Content-Type:application/json;charset=UTF-8 而实际服务端需要的是： 1Content-Type:application/x-www-form-urlencoded 因此，使用axios的qs内置库中的方法进行内容类型的转换。 123456789101112131415import Qs from &#x27;qs&#x27;this.axios(&#123; method:&#x27;post&#x27;, url:&#x27;http://localhost:8081/regist&#x27;, transformRequest: [function (data) &#123; return Qs.stringify(data) &#125;], data:&#123; email:this.email &#125;&#125;).then(function (response) &#123; alert(response.data.message)&#125;);","path":"page/Vuejs07.html","date":"04-17","excerpt":"","tags":[{"name":"Axios","slug":"Axios","permalink":"http://xiaoliblog.cn/tags/Axios/"}]},{"title":"Vue.js前端框架🎯跨域问题","text":"跨域问题 在浏览器端进行 Ajax 请求时会出现跨域问题，那么什么是跨域，如何解决跨域呢？先看浏览器端出现跨域问题的现象，如下图所示 跨域与同源 跨域，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript施加的安全限制。 跨域问题是浏览器对js的一种安全限制，也就是说浏览器的页面内去访问其他服务器上的资源的时候，就会出现跨域。同源策略明确了什么情况是属于跨域。所谓的同源策略，指的是协议、域名、端口完全相同，才是安全的 所谓同源是指，域名,协议，端口均相同 http://www.qf.com/ -&gt; http://admin.qf.com/ 跨域 http://www.qf.com/ -&gt; http://www.qf.com/ 非跨域 http://www.qf.com/ -&gt; http://www.qf.com:8080/ 跨域 http://www.qf.com/ -&gt; https://www.qf.com/ 跨域 跨域有以下解决方法 使用CORS（跨资源共享）解决跨域问题 使用JSONP解决跨域问题 使用Nginx反向代理解决跨域问题 CORS请求原理 CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制 CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE 浏览器不能低于IE10。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信（在header中设置: &quot;Access-Control-Allow-0rigin&quot;,&quot;*&quot;)，比如在spring-mvc.xml中配置 这个跨域访问的解决方案的安全基础是基JavaScript无法控制该HTTP头，它需要通过目标域返回的HTTP头来授权是否允许跨域访问。 12response.addHeader(‘Access-Control-Allow-Origin:*’);//允许所有来源访问 response.addHeader(‘Access-Control-Allow-Method:POST,GET’);//允许访问的方式 关于CORS，强烈推荐阅读👉跨域资源共享 CORS 详解(阮一峰) JSONP方法 JSONP （JSON with Padding）是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题 在同源策略下，在某个服务器下的页面是无法获取到该服务器以外的数据的，即一般的ajax是不能进行跨域请求的。但 img、iframe 、script等标签是个例外，这些标签可以通过src属性请求到其他服务器上的数据 利用&lt;script&gt;标签的开放策略，我们可以实现跨域请求数据，当然这需要服务器端的配合。 Jquery中ajax的核心是通过 XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加&lt;script&gt;标签来调用服务器提供的 js脚本 当我们正常地请求一个JSON数据的时候，服务端返回的是一串JSON类型的数据，而我们使用 JSONP模式来请求数据的时候服务端返回的是一段可执行的JavaScript代码。因为jsonp跨域的原理就是用的动态加载&lt;script&gt;的src ，所以我们只能把参数通过url的方式传递，所以jsonp的 type类型只能是get ！ JSONP之所以能够用来解决跨域方案,主要是因为 &lt;script&gt; 脚本拥有跨域能力，而JSONP正是利用这一点来实现。具体原理如图 1234567891011121314//前端$.ajax(&#123; type : &quot;GET&quot;, async : false, url : &quot;http://a.a.com/a/FromServlet?userName=644064&quot;, dataType : &quot;jsonp&quot;,//数据类型为jsonp jsonp : &quot;jsonpCallback&quot;,//服务端用于接收callback调用的function名的参数 success : function(data) &#123; alert(data[&quot;userName&quot;]); &#125;, error : function() &#123; alert(&#x27;fail&#x27;); &#125;&#125;); 1234//后端 String jsonpCallback = request.getParameter(&quot;jsonpCallback&quot;); //构造回调函数格式jsonpCallback(数据) resp.getWriter().println(jsonpCallback+&quot;(&quot;+jsonObject.toJSONString()+&quot;)&quot;); 推荐使用CORS解决跨域问题，其他解决方法请参考：https://blog.csdn.net/itcats_cn/article/details/82318092 Nginx反向代理 以上跨域问题解决方案都需要服务器支持，当服务器无法设置header或提供callback 时我们就可以采用Nginx反向代理的方式解决跨域问题。 Nginx配置跨域案例，在nginx.conf的location 中增加如下配置: 123add_ header Access -Control -Allow-Origin *或域名;add_ header Access-Control -Allow-Headers X- Requested-With;add_ header Access-Control -Allow-Methods GET, POST, OPTIONS; 比如 12345678910111213141516171819202122232425262728user nginx;worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application&#x2F;octet-stream; sendfile on; keepalive_timeout 65; server &#123; listen 80; server_name 192.168.75.128; location &#x2F; &#123; add_header Access-Control-Allow-Origin *; add_header Access-Control-Allow-Headers X-Requested-With; add_header Access-Control-Allow-Methods GET,POST,OPTIONS; root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;wwwroot&#x2F;cdn; index index.jsp index.html index.htm; &#125; &#125;&#125; SpringMVC 配置 CORS1234567&lt;mvc:cors&gt; &lt;mvc:mapping path=&quot;/**&quot; allowed-origins=&quot;*&quot; allowed-methods=&quot;POST, GET, OPTIONS, DELETE, PUT,PATCH&quot; allowed-headers=&quot;Content-Type, Access-Control-Allow-Headers, Authorization, X-Requested-With&quot; allow-credentials=&quot;true&quot; /&gt;&lt;/mvc:cors&gt; 在spring-mvc.xml中加入上述这一段。其中，allowed-origins指的是允许的访问源的域名，”*“表示任何人都可以访问，也可以指明具体的域名，比如下图： 拦截器的方式配置解决跨域1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import lombok.extern.slf4j.Slf4j;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@Slf4jpublic class CorsInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object o) throws Exception &#123; System.out.println(&quot;CorsInterceptor.preHandle&quot;); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object o, ModelAndView modelAndView) throws Exception &#123; // Access-Control-Allow-Origin String origin = request.getHeader(&quot;Origin&quot;); System.out.println(&quot;origin..........&quot;+origin); response.setHeader(&quot;Access-Control-Allow-Origin&quot;, origin); response.setHeader(&quot;Vary&quot;, &quot;Origin&quot;); // Access-Control-Max-Age response.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;); // Access-Control-Allow-Credentials response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); // Access-Control-Allow-Methods response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, DELETE&quot;); // Access-Control-Allow-Headers response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With, Content-Type,Accept,X-Custom-Header,Set-Cookie&quot;); &#125; @Override public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123; System.out.println(&quot;CorsInterceptor.afterCompletion&quot;); &#125;&#125; Spring Boot 配置 CORS使用 Java 配置的方式1234567891011121314/** * 跨域配置 * &lt;p&gt;Title: CorsConfiguration&lt;/p&gt; * &lt;p&gt;Description: &lt;/p&gt; */@Configurationpublic class CORSConfiguration extends WebMvcConfigurerAdapter &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/**&quot;).allowedOrigins(&quot;*&quot;) .allowedMethods(&quot;GET&quot;, &quot;HEAD&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;) .allowCredentials(false).maxAge(3600); &#125;&#125; 使用注解的方式1@CrossOrigin(origins = &quot;*&quot;, maxAge = 3600) 解决跨域后的效果图","path":"page/Vuejs06.html","date":"04-16","excerpt":"","tags":[{"name":"跨域问题","slug":"跨域问题","permalink":"http://xiaoliblog.cn/tags/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"}]},{"title":"Vue.js前端框架🎯Axios网络应用","text":"Axios网络应用axios基础 axios是功能强大的网络前求库 导入JS库 1&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; 基本语法 12axios.get(地址?key=value&amp;key2=values).then(function(response)&#123;&#125;,function(err)&#123;&#125;)axios.post(地址,&#123;key:value,key2:value2&#125;).then(function(response)&#123;&#125;,function(err)&#123;&#125;) axios必须先导入才可以使用 使用get或post方法即可发送对应的请求 then方法中的回调函数会在请求成功或失败时触发 通过回调函数的形参可以获取响应内容，或错误信息 文档传送门：https://github.com/axios/axios 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;title&gt;axios基本使用&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;get请求&quot; class=&quot;get&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;post请求&quot; class=&quot;post&quot;&gt; &lt;!-- 官网提供的 axios 在线地址 --&gt; &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; /* 接口1:随机笑话 请求地址:https://autumnfish.cn/api/joke/list 请求方法:get 请求参数:num(笑话条数,数字) 响应内容:随机笑话 */ document.querySelector(&quot;.get&quot;).onclick = function () &#123; axios.get(&quot;https://autumnfish.cn/api/joke/list?num=6&quot;) //获取6条笑话 .then(function (response) &#123; console.log(response); &#125;,function(err)&#123; console.log(err); &#125;) &#125; /* 接口2:用户注册 请求地址:https://autumnfish.cn/api/user/reg 请求方法:post 请求参数:username(用户名,字符串) 响应内容:注册成功或失败 */ document.querySelector(&quot;.post&quot;).onclick = function () &#123; axios.post(&quot;https://autumnfish.cn/api/user/reg&quot;,&#123;username:&quot;小李博客&quot;&#125;) .then(function(response)&#123; console.log(response); console.log(this.skill); &#125;,function (err) &#123; console.log(err); &#125;) &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; axios+vue 语法 1234567891011121314var app = new Vue(&#123; el: &quot;#app&quot;, data: &#123; joke: &quot;搞笑的笑话&quot; &#125;, methods: &#123; getJokes: function() &#123; // this.joke axios.get(&quot;地址&quot;).then(function(response) &#123; // this.joke ? &#125;, function(err) &#123;&#125;); &#125; &#125;&#125;) axios回调函数中的this已经改变，无法访问到data中数据 把this保存起来，回调函数中直接使用保存的this即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;axios+vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;获取笑话&quot; @click=&quot;getJoke&quot;&gt; &lt;p&gt; &#123;&#123; joke &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;!-- 官网提供的 axios 在线地址 --&gt; &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; /* 接口:随机获取一条笑话 请求地址:https://autumnfish.cn/api/joke 请求方法:get 请求参数:无 响应内容:随机笑话 */ var app = new Vue(&#123; el:&quot;#app&quot;, data:&#123; joke:&quot;很好笑的笑话&quot; &#125;, methods: &#123; getJoke:function()&#123; // console.log(this.joke); var that = this; axios.get(&quot;https://autumnfish.cn/api/joke&quot;).then(function(response)&#123; // console.log(response) console.log(response.data); // console.log(this.joke); that.joke = response.data; &#125;,function (err) &#123; &#125;) &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 天知道案例 按下回车(v-on .enter) 查询数据(axios 接口 v-model ) 渲染数据(v-for 数组 that) 应用的逻辑代码建议和页面分离，使用单独的js文件编写 axios回调函数中this指向改变了，需要额外的保存一份 服务器返回的数据比较复杂时，获取的时候需要注意层级结构 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;title&gt;天知道&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/reset.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot; /&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;wrap&quot; id=&quot;app&quot;&gt; &lt;div class=&quot;search_form&quot;&gt; &lt;div class=&quot;form_group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;input_txt&quot; placeholder=&quot;请输入查询的天气&quot; v-model=&quot;city&quot; @keyup.enter=&quot;queryWeather&quot; /&gt; &lt;button class=&quot;input_sub&quot; @click=&quot;queryWeather&quot;&gt; 搜 索 &lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;hotkey&quot;&gt; &lt;a href=&quot;javascript:;&quot; v-for=&quot;city in hotCitys&quot; @click=&quot;clickSearch(city)&quot;&gt;&#123;&#123; city &#125;&#125;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;ul class=&quot;weather_list&quot;&gt; &lt;li v-for=&quot;(item,index) in forecastList&quot; :key=&quot;item.date&quot; :style=&quot;&#123;transitionDelay:index*100+&#x27;ms&#x27;&#125;&quot;&gt; &lt;div class=&quot;info_type&quot;&gt; &lt;span class=&quot;iconfont&quot;&gt;&#123;&#123; item.type &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;info_temp&quot;&gt; &lt;b&gt;&#123;&#123; item.low&#125;&#125;&lt;/b&gt; ~ &lt;b&gt;&#123;&#123; item.high&#125;&#125;&lt;/b&gt; &lt;/div&gt; &lt;div class=&quot;info_date&quot;&gt; &lt;span&gt;&#123;&#123; item.date &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;!-- 官网提供的 axios 在线地址 --&gt; &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; /* 请求地址:http://wthrcdn.etouch.cn/weather_mini 请求方法:get 请求参数:city(城市名) 响应内容:天气信息 1. 点击回车 2. 查询数据 3. 渲染数据 */ new Vue(&#123; el: &quot;#app&quot;, data: &#123; city: &quot;武汉&quot;, forecastList: [], hotCitys: [&quot;北京&quot;, &quot;上海&quot;, &quot;广州&quot;, &quot;深圳&quot;] &#125;, methods: &#123; queryWeather() &#123; this.forecastList = []; axios .get(`http://wthrcdn.etouch.cn/weather_mini?city=$&#123;this.city&#125;`) .then(res =&gt; &#123; console.log(res); this.forecastList = res.data.data.forecast; &#125;) .catch(err =&gt; &#123; console.log(err); &#125;) .finally(() =&gt; &#123; &#125;); &#125;, clickSearch(city) &#123; this.city = city; this.queryWeather(); &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 综合应用 教程地址 https://www.bilibili.com/video/BV12J411m7MG?p=30 歌曲搜索 按下回车(v-on .enter) 查询数据(axios接口v-model ) 渲染数据(v-for数组that) 接口说明 歌曲搜索接口 请求地址：https://autumnfish.cn/search 请求方法：get 请求参数：keywords(查询关键字) 响应内容：歌曲搜索结果 歌曲url获取接口 请求地址：https://autumnfish.cn/song/url 请求方法：get 请求参数：id(歌曲id) 响应内容：歌曲url地址 歌曲详情获取 请求地址：https://autumnfish.cn/song/detail 请求方法：get 请求参数：ids(歌曲id) 响应内容:歌曲详情(包括封面信息) 热门评论获取 请求地址：https://autumnfish.cn/comment/hot?type=0 请求方法：get 请求参数：id(歌曲id,地址中的type固定为0) 响应内容:歌曲的热门评论 mv地址获取 请求地址：https://autumnfish.cn/mv/url 请求方法：get 请求参数：id(mvid,为0表示没有mv) 响应内容：mv的地址 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 样式 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./css/index.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;play_wrap&quot; id=&quot;player&quot;&gt; &lt;div class=&quot;search_bar&quot;&gt; &lt;img src=&quot;images/player_title.png&quot; alt=&quot;&quot; /&gt; &lt;!-- 搜索歌曲 --&gt; &lt;input type=&quot;text&quot; autocomplete=&quot;off&quot; v-model=&#x27;query&#x27; @keyup.enter=&quot;searchMusic();&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;center_con&quot;&gt; &lt;!-- 搜索歌曲列表 --&gt; &lt;div class=&#x27;song_wrapper&#x27; ref=&#x27;song_wrapper&#x27;&gt; &lt;ul class=&quot;song_list&quot;&gt; &lt;li v-for=&quot;item in musicList&quot;&gt; &lt;!-- 点击放歌 --&gt; &lt;a href=&quot;javascript:;&quot; @click=&#x27;playMusic(item.id)&#x27;&gt;&lt;/a&gt; &lt;b&gt;&#123;&#123;item.name&#125;&#125;&lt;/b&gt; &lt;span&gt; &lt;i @click=&quot;playMv(item.mvid)&quot; v-if=&quot;item.mvid!=0&quot;&gt;&lt;/i&gt; &lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;img src=&quot;images/line.png&quot; class=&quot;switch_btn&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;!-- 歌曲信息容器 --&gt; &lt;div class=&quot;player_con&quot; :class=&quot;&#123;playing:isPlay&#125;&quot;&gt; &lt;img src=&quot;images/player_bar.png&quot; class=&quot;play_bar&quot; /&gt; &lt;!-- 黑胶碟片 --&gt; &lt;img src=&quot;images/disc.png&quot; class=&quot;disc autoRotate&quot; /&gt; &lt;img :src=&quot;coverUrl==&#x27;&#x27;?&#x27;./images/cover.png&#x27;:coverUrl&quot; class=&quot;cover autoRotate&quot; /&gt; &lt;/div&gt; &lt;!-- 评论容器 --&gt; &lt;div class=&quot;comment_wrapper&quot; ref=&#x27;comment_wrapper&#x27;&gt; &lt;h5 class=&#x27;title&#x27;&gt;热门留言&lt;/h5&gt; &lt;div class=&#x27;comment_list&#x27;&gt; &lt;dl v-for=&quot;item in hotComments&quot;&gt; &lt;dt&gt; &lt;img :src=&quot;item.user.avatarUrl&quot; alt=&quot;&quot; /&gt; &lt;/dt&gt; &lt;dd class=&quot;name&quot;&gt;&#123;&#123;item.user.nickname&#125;&#125;&lt;/dd&gt; &lt;dd class=&quot;detail&quot;&gt; &#123;&#123;item.content&#125;&#125; &lt;/dd&gt; &lt;/dl&gt; &lt;/div&gt; &lt;img src=&quot;images/line.png&quot; class=&quot;right_line&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;audio_con&quot;&gt; &lt;audio ref=&#x27;audio&#x27; @play=&quot;play&quot; @pause=&quot;pause&quot; :src=&quot;musicUrl&quot; controls autoplay loop class=&quot;myaudio&quot;&gt;&lt;/audio&gt; &lt;/div&gt; &lt;div class=&quot;video_con&quot; v-show=&quot;showVideo&quot;&gt; &lt;video ref=&#x27;video&#x27; :src=&quot;mvUrl&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt; &lt;div class=&quot;mask&quot; @click=&quot;closeMv&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;!-- 官网提供的 axios 在线地址 --&gt; &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 设置axios的基地址 axios.defaults.baseURL = &#x27;https://autumnfish.cn&#x27;; // axios.defaults.baseURL = &#x27;http://localhost:3000&#x27;; // 实例化vue var app = new Vue(&#123; el: &quot;#player&quot;, data: &#123; // 搜索关键字 query: &#x27;&#x27;, // 歌曲列表 musicList: [], // 歌曲url musicUrl: &#x27;&#x27;, // 是否正在播放 isPlay: false, // 歌曲热门评论 hotComments: [], // 歌曲封面地址 coverUrl: &#x27;&#x27;, // 显示视频播放 showVideo: false, // mv地址 mvUrl: &#x27;&#x27; &#125;, // 方法 methods: &#123; // 搜索歌曲 searchMusic() &#123; if (this.query == 0) &#123; return &#125; axios.get(&#x27;/search?keywords=&#x27; + this.query).then(response =&gt; &#123; // 保存内容 this.musicList = response.data.result.songs; &#125;) // 清空搜索 this.query = &#x27;&#x27; &#125;, // 播放歌曲 playMusic(musicId) &#123; // 获取歌曲url axios.get(&#x27;/song/url?id=&#x27; + musicId).then(response =&gt; &#123; // 保存歌曲url地址 this.musicUrl = response.data.data[0].url &#125;) // 获取歌曲热门评论 axios.get(&#x27;/comment/hot?type=0&amp;id=&#x27; + musicId).then(response =&gt; &#123; // console.log(response) // 保存热门评论 this.hotComments = response.data.hotComments &#125;) // 获取歌曲封面 axios.get(&#x27;/song/detail?ids=&#x27; + musicId).then(response =&gt; &#123; // console.log(response) // 设置封面 this.coverUrl = response.data.songs[0].al.picUrl &#125;) &#125;, // audio的play事件 play() &#123; this.isPlay = true // 清空mv的信息 this.mvUrl = &#x27;&#x27; &#125;, // audio的pause事件 pause() &#123; this.isPlay = false &#125;, // 播放mv playMv(vid) &#123; if (vid) &#123; this.showVideo = true; // 获取mv信息 axios.get(&#x27;/mv/url?id=&#x27; + vid).then(response =&gt; &#123; // console.log(response) // 暂停歌曲播放 this.$refs.audio.pause() // 获取mv地址 this.mvUrl = response.data.data.url &#125;) &#125; &#125;, // 关闭mv界面 closeMv() &#123; this.showVideo = false this.$refs.video.pause() &#125;, // 搜索历史记录中的歌曲 historySearch(history) &#123; this.query = history this.searchMusic() this.showHistory = false; &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","path":"page/Vuejs05.html","date":"04-16","excerpt":"","tags":[{"name":"Axios","slug":"Axios","permalink":"http://xiaoliblog.cn/tags/Axios/"}]},{"title":"Vue.js前端框架🎯Vue开发模式","text":"Vue-cil 我们后端使用maven来创建项目，有两个目的，一是通过maven的依赖机制，能够快速的管理依赖。二是通过maven来确定项目的结构，所谓项目的结构就是项目里有哪些文件和文件夹，文件夹是一个怎样的层级关系 问题来了？ 一个vue项目里的项目结构应该是什么样的？ 我们能不能快速的获得这样的项目结构呢？ 可以通过vue-cli这种脚手架工具来解决这样的问题。 vue-cli里存放了很多常用的项目骨架，直接拿来用就可以搭建出一个拥有比较成熟的项目结构的项目 CLI（command line interfaces ）命令行接口。在进行Vue项目开发时，可以选择不同的Vue模板（骨架）进行项目的搭建，比如simple、webpack-simple、webpack、browserify/browserify-simple等；vue-cli是官方提供的一个脚手架（预先定义好的目录结构及基础代码，咱们在创建 Maven 项目时可以选择创建一个骨架项目，这个骨架项目就是脚手架），用于快速生成一个 vue 的项目模板 安装使用 下载安装node.js：https://nodejs.org/en/download/ 1node -v 建议先下载淘宝镜像 1npm config set registry https://registry.npm.taobao.org 打开cmd，通过以下命令下载vue-cli 1npm install vue-cli -g 创建vue项目文件夹并打开，比如创建vuedemo文件夹 进入新建的文件夹，并使用vue list命令查看当前可用的vue骨架 使用vue命令创建基于vue-webpack-simple骨架的项目，vue-cli-demo是项目名，过程中需要输入一些参数，回车是使用提示的值 1vue init webpack-simple vue-cli-demo 进入生成的vue-cli-demo文件夹，按以下命令下载依赖 1npm install #安装依赖环境 启动项目 1npm run dev #进入开发模式 启动后，会出现index首页，默认端口为8080 通过以下命令打包并发布项目 1npm run build #发布项目 关于资源打包 开发一个vue项目，标准的步骤： 用vue-cli拉取一个项目骨架 安装依赖 使用npm run dev 进入开发者模式 使用npm run build命令来构建资源 此时在开发中模式中，各种修改都能看到实时效果，那么这些内容实际上是由vue-cli进行打包并发布在node.js上的。那么，最后开发完以后，要上生产，这些资源是需要我们手动部署在自己的服务器上的。那么，哪些资源是需要我们手动部署的，因此，通过npm run build命令来构建资源。会产生一个dist文件夹。 里面包含静态资源。 因此，在开发环境下，要想使用静态资源，在src下存放静态文件是访问不到的，首先通过npm run build命令来创建dist文件夹，然后将静态资源放入，再在vue的代码中，去该/dist/文件夹内取资源即可 webpack-simple模板结构 无论前端页面内容有多复杂，index.html都只有11行，其实际的内容已经被打包进了 /dist/build.js 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;vue-cli-demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script src=&quot;/dist/build.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; main.js文件是整个vue项目的入口js App.vue 这种以“.vue”为扩展名的内容（文件），实际上就是一个Vue对象。在这里这种文件，也称为Vue组件，里面是页面的源码 App.vue文件IDEA配置 使用idea开发需要下载一个插件Vue.js 在idea中配置，能够操作.vue文件 修改App.vue App.vue大体结构如下 注意template必须有一个根节点，以下会报错 1234567&lt;template&gt; &lt;div&gt; &#123;&#123;title&#125;&#125; &lt;/div&gt; &lt;span&gt; &lt;/span&gt;&lt;/template&gt; 多个vue组件 在App.vue组件中使用多个vue组件搭建一个页面` 创建component文件夹用于存放vue组件，在其下创建Header.vue 123456789101112131415&lt;template&gt; &lt;div&gt; &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:&quot;Header&quot;, data()&#123; return&#123; title:&quot;宝淘专业的个人用品分享网站&quot; &#125; &#125;&#125;&lt;/script&gt; 在component文件夹创建Content.vue 12345678910&lt;template&gt; &lt;div&gt; 商品列表... &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:&quot;Content&quot;&#125;&lt;/script&gt; 在component文件夹创建Bottom.vue 12345678&lt;template&gt; &lt;div&gt;版权所有&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:&quot;Bottom&quot;&#125;&lt;/script&gt; 全局注册 创建好三个vue组件后，在main.js中进行全局注册。通过import 和 Vue.component配合，来将一个.vue文件注册成为一个标签。该标签就可以在整个项目中使用 1234567891011121314import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import Header from &#x27;./component/Header.vue&#x27;import Content from &#x27;./component/Content.vue&#x27;import Bottom from &#x27;./component/Bottom.vue&#x27;Vue.component(&quot;MyHeader&quot;,Header);Vue.component(&quot;MyContent&quot;,Content);Vue.component(&quot;MyBottom&quot;,Bottom);new Vue(&#123; el: &#x27;#app&#x27;, render: h =&gt; h(App)&#125;) 在App.vue中使用 12345678910111213141516&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;MyHeader&gt;&lt;/MyHeader&gt; &lt;MyContent&gt;&lt;/MyContent&gt; &lt;MyBottom&gt;&lt;/MyBottom&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;app&#x27;,&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 本地注册 在组件的内部去注册另外一个组件，成为一个标签，这个标签，只在该组件的内部使用，而不能在其他组件内使用 1234567891011121314151617181920&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;MHeader&gt;&lt;/MHeader&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import MHeader from &#x27;./component/Header&#x27;export default &#123; name: &#x27;app&#x27;, components:&#123; &quot;MHeader&quot;:MHeader &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 各组件之间的参数传递父传子 父组件为App.vue，子组件为Content.vue，前提Content.vue已经进行全局注册 通过父vue的标签属性传递参数： 通过子组件的props部分，来指明可以接收的参数，父组件通过在标签中写明参数的键值对来传递参数 props是表示一个组件的参数部分，那么props的写法有两种： props:[参数列表] 比如： props:[‘MyProp1’,’MyProp2’,…] props:&#123;参数名1:&#123;type:String,required:true,default:&#39;XX&#39;&#125;,参数名2:&#123;...&#125;&#125; 子传父 是以事件发射的方式来实现子传父的效果。 在子组件中，使用 this.$emit(&quot;键&quot;,&quot;值&quot;) 在父组件中，子组件的标签中 使用 @键=&quot; msg=$event&quot; 其中$event就能得到值，msg是父组件中vue属性 子组件 12345methods:&#123; doClick()&#123; this.$emit(&#x27;newName&#x27;,&#x27;hello js&#x27;) &#125;&#125; 父组件 12345&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;MyContent :MyTitle=&quot;msg&quot; @newName=&quot;msg=$event&quot;&gt;&lt;/MyContent&gt; &lt;/div&gt;&lt;/template&gt;","path":"page/Vuejs04.html","date":"04-15","excerpt":"","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://xiaoliblog.cn/tags/Vue-js/"}]},{"title":"Vue.js前端框架🎯Vue组件","text":"Vue实例 可以有多个Vue对象，即实例 123var v1 = new Vue(&#123;&#125;)var v2 = new Vue(&#123;&#125;)... 实例之间操作 在一个实例中，通过调用另一个实例的属性，来操作其属性 123456&lt;div id=&quot;app1&quot;&gt; &lt;span&gt;&#123;&#123;message&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;div id=&quot;app2&quot;&gt; &lt;input type=&quot;button&quot; @click=&quot;changMsg&quot; value=&quot;改变&quot;/&gt;&lt;/div&gt; 12345678910111213141516&lt;script type=&quot;text/javascript&quot;&gt; var v1 = new Vue(&#123; el: &quot;#app1&quot;, data: &#123; message:&quot;HELLO VUE!&quot; &#125; &#125;); var va2 = new Vue(&#123; el: &quot;#app2&quot;, methods: &#123; changMsg:function()&#123; v1.message=&quot;hello vue!&quot;; &#125; &#125;, &#125;)&lt;/script&gt; 实例外操作 在Vue外面操作Vue实例——操作属性 123setTimeout(function () &#123; v1.message = &quot;st title&quot;;&#125;, 2000); 调用vue实例中的方法——操作方法 123setTimeout(function()&#123; v1.btnclick();&#125;,2000); 实例属性 直接通过对象.的方式调用的属性，是来自与data或computed中的属性，但是Vue对象中的el、data等等这些键也称为属性，这些属性就是vue对象中的实例属性 12v1.$data v1.$el 设置实例属性 1234567891011&lt;div id=&quot;app1&quot;&gt; &lt;span&gt;&#123;&#123;message&#125;&#125;&lt;/span&gt;&lt;/div&gt;var data = &#123; message: &quot;args data&quot;,&#125;;var v1 = new Vue(&#123; el: &quot;#app1&quot;, data: data,&#125;); v1.$data.message 相当于 v1.message Vue组件 组件化是Vue的一大特性，也就是可以将vue对象作为一个组件，被反复使用 要想实现组件化，需要在页面中注册组件:关于注册的方式有两种，分别是全局注册和本地注册 全局注册 注册组件 1Vue.component(&quot;组件名&quot;,&#123;vue 对象&#125;) 使用组件 在被vue绑定了的html元素中才能使用组件 1234&lt;div id=&quot;app&quot;&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;button-counter&gt;&lt;/button-counter&gt;&lt;/div&gt; 1234567891011&lt;script type=&quot;text/javascript&quot;&gt; // 定义一个名为 button-counter 的新组件,可以使用在Vue挂载的实例里 Vue.component(&quot;button-counter&quot;, &#123; //template内容为显示的内容 template:&quot;&lt;h1&gt;Hello Vue!&lt;/h1&gt;&quot;, &#125;); //必须使用在Vue挂载的实例里 new Vue(&#123; el: &quot;#app&quot; &#125;);&lt;/script&gt; 使用插值表达式和方法 1234567891011121314151617181920&lt;script type=&quot;text/javascript&quot;&gt; // 定义一个名为 button-counter 的新组件,可以使用在Vue挂载的实例里 Vue.component(&quot;button-counter&quot;, &#123; template:&quot;&lt;div&gt;&#123;&#123;title&#125;&#125;&lt;button type=&#x27;button&#x27; @click=&#x27;btnFn&#x27;&gt;点我&lt;/button&gt;&lt;/div&gt;&quot;, data()&#123; return &#123; title:&quot;Hello Vue!&quot; &#125; &#125;, methods: &#123; btnFn:function()&#123; alert(&quot;Hello&quot;); &#125; &#125;, &#125;); //必须使用在Vue挂载的实例里 new Vue(&#123; el: &quot;#app&quot; &#125;);&lt;/script&gt; 注意事项 Vue.componet(&quot;组件名&quot;,&#123;vue 对象&#125;)，这个vue对象和之前的vue对象的data实例属性的写法是有区别的 1234567891011121314new Vue(&#123; data:&#123; title:&quot;value&quot; &#125;&#125;)Vue.componet(&quot;mybutton&quot;,&#123; data:function()&#123; return&#123; title:&quot;value&quot; &#125; &#125;&#125;)&lt;!--然后通过&#123;&#123;title&#125;&#125;取值--&gt; template是将内容展现在页面商的一个键。值是一个字符串。一定要注意一点：**template里必须有且只能有一个根元素** 1234&lt;!--错误写法--&gt;template:&quot;&lt;span&gt;&#123;&#123;title&#125;&#125;&lt;/span&gt;&lt;button type=&#x27;button&#x27; @click=&#x27;btnFn&#x27;&gt;点我&lt;/button&gt;&quot;,&lt;!--正确写法--&gt;template:&quot;&lt;div&gt;&#123;&#123;title&#125;&#125;&lt;button type=&#x27;button&#x27; @click=&#x27;btnFn&#x27;&gt;点我&lt;/button&gt;&lt;/div&gt;&quot;, 生命周期函数 一个Vue对象会经历 初始化、创建、绑定、更新、销毁等阶段，不同的阶段，都会有相应的生命周期钩子函数被调用 本地注册 vue的全局注册，也就意味着在页面的任意一个被vue绑定过的div中，都可以使用全局注册了的vue组件。但是，如果是对vue组件进行本地注册，那么在其他被vue绑定的div中，不能使用该组件 12345678&lt;div id=&quot;app&quot;&gt; &lt;model11&gt;&lt;/model11&gt;&lt;/div&gt;&lt;hr/&gt;&lt;div id=&quot;app1&quot;&gt; &lt;model11&gt;&lt;/model11&gt;&lt;/div&gt; 12345678910111213141516171819202122232425&lt;script&gt; // var model1 = new Vue(&#123; el: &quot;#app&quot;, //只有id是app的div才能使用model11组件 components: &#123; model11: &#123; template: &quot;&lt;div&gt;&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;&lt;button type=&#x27;button&#x27; @click=&#x27;btnfn&#x27;&gt;点我&lt;/button&gt;&lt;/div&gt;&quot;, data: function () &#123; return &#123; title: &quot;hello vue&quot;, &#125;; &#125;, methods: &#123; btnfn: function () &#123; alert(&quot;hello !!!&quot;); &#125;, &#125;, &#125;, &#125;, &#125;); new Vue(&#123; el: &quot;#app1&quot;, //这个div不能使用model11组件 &#125;);&lt;/script&gt; 样式表作用范围 如果vue组件中的style标签没有带上scoped属性，那么这个style的样式将会作用在整个页面中，而不是当前组件中，那么因此加上scoped，让样式只作用在当前组件中 12345&lt;style scoped&gt;div&#123; border: 1px solid red;&#125;&lt;/style&gt; 首页实例 使用Vue和Bootstrap搭建首页 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;Bootstrap 101 Template&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;link href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot; class=&quot;container&quot;&gt; &lt;!--导航条--&gt; &lt;div&gt; &lt;ul class=&quot;nav nav-pills&quot;&gt; &lt;!--循环读取数组navigateData的值并创建li,role为Bootstrap属性--&gt; &lt;li v-for=&quot;nav in navigateData&quot; role=&quot;presentation&quot;&gt; &lt;a href=&quot;#&quot;&gt;&#123;&#123;nav&#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!--轮播图--&gt; &lt;div style=&quot;width: 100%; height: 300px&quot; id=&quot;carousel-example-generic&quot; class=&quot;carousel slide&quot; data-ride=&quot;carousel&quot; &gt; &lt;!-- Indicators --&gt; &lt;ol class=&quot;carousel-indicators&quot;&gt; &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;0&quot; class=&quot;active&quot; &gt;&lt;/li&gt; &lt;li data-target=&quot;#carousel-example-generic&quot; data-slide-to=&quot;1&quot;&gt;&lt;/li&gt; &lt;/ol&gt; &lt;!-- Wrapper for slides --&gt; &lt;div class=&quot;carousel-inner&quot; role=&quot;listbox&quot;&gt; &lt;div v-for=&quot;(myimg,i) in banner_imgs&quot; :key=&quot;i&quot; :class=&quot;i==0?&#x27;active&#x27;:&#x27;&#x27;&quot; class=&quot;item&quot; &gt; &lt;img style=&quot;width: 100%; height: 300px&quot; :src=&quot;myimg&quot; alt=&quot;...&quot; /&gt; &lt;div class=&quot;carousel-caption&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- Controls --&gt; &lt;a class=&quot;left carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;prev&quot; &gt; &lt;span class=&quot;glyphicon glyphicon-chevron-left&quot; aria-hidden=&quot;true&quot; &gt;&lt;/span&gt; &lt;span class=&quot;sr-only&quot;&gt;Previous&lt;/span&gt; &lt;/a&gt; &lt;a class=&quot;right carousel-control&quot; href=&quot;#carousel-example-generic&quot; role=&quot;button&quot; data-slide=&quot;next&quot; &gt; &lt;span class=&quot;glyphicon glyphicon-chevron-right&quot; aria-hidden=&quot;true&quot; &gt;&lt;/span&gt; &lt;span class=&quot;sr-only&quot;&gt;Next&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.10/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new Vue(&#123; el: &quot;#app&quot;, data: &#123; navigateData: [&quot;首页&quot;, &quot;最新商品&quot;, &quot;搜索&quot;, &quot;购物车&quot;, &quot;我的订单&quot;], banner_imgs: [&quot;./img/bg1.png&quot;, &quot;./img/bg2.png&quot;], pros: [ &#123; proname: &quot;&quot;, pro_img: &quot;&quot;, pro_price: &quot;&quot;, &#125;, &#123;&#125;, &#123;&#125;, ], &#125;, &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","path":"page/Vuejs03.html","date":"04-14","excerpt":"","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://xiaoliblog.cn/tags/Vue-js/"}]},{"title":"Vue.js前端框架🎯Vue指令","text":"内容绑定/事件绑定v-text指令 语法 1&lt;p v-text=&quot;content&quot;&gt;&lt;/p&gt; v-text指令的作用是：设置标签的内容(textContent) 默认写法会替换全部内容，使用差值表达式&#123;&#125;可以替换指定内容 内部支持写表达式 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h2 v-text=&quot;message+&#x27;!&#x27;&quot;&gt;全部替换&lt;/h2&gt; &lt;h2 v-text=&quot;info+&#x27;!&#x27;&quot;&gt;全部替换&lt;/h2&gt; &lt;h2&gt;&#123;&#123; message+&#x27;!&#x27; &#125;&#125;替换部分&lt;/h2&gt; &lt;/div&gt; &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var app = new Vue(&#123; el: &quot;#app&quot;, data:&#123; message: &quot;小李博客&quot;, info:&quot;Hello Vue！&quot; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; v-html指令 语法 1&lt;p v-html=&quot;content&quot;&gt;&lt;/p&gt; v-html指令的作用是：设置元素的innerHTML 内容中有htm|结构会被解析为标签 v-text指令无论内容是什么,只会解析为文本 解析文本使用v-text，需要解析html结构使用v-html 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--2. html结构--&gt; &lt;div id=&quot;app&quot;&gt; &lt;p v-html=&quot;content&quot;&gt;&lt;/p&gt; &lt;p v-text=&quot;content&quot;&gt;&lt;/p&gt; &lt;!--普通文本和text指令一样--&gt; &lt;/div&gt; &lt;!-- 1. 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;!--3. 创建Vue实例--&gt; &lt;script&gt; var app = new Vue(&#123; el: &quot;#app&quot;, data:&#123; content:&quot;&lt;a href=&#x27;https://xiaoliblog.cn&#x27;&gt;小李博客&lt;/a&gt;&quot; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; v-on指令 语法 12&lt;a v-on:click=&quot;doSomething方法&quot;&gt;...&lt;/a&gt;&lt;a @click=&quot;doSomething方法&quot;&gt;...&lt;/a&gt; v-on指令的作用是：为元素绑定事件 事件名不需要写on 指令可以简写为@ 绑定的方法定义 在methods属性中 方法内部通过this关键字可以访问定义在data中数据 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--2. html结构--&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;v-on指令完整&quot; v-on:click=&quot;doit&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;v-on指令简写&quot; @click=&quot;doit&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;双击&quot; @dblclick=&quot;doit&quot;&gt; &lt;h2 @click=&quot;changeFood&quot;&gt;&#123;&#123; food &#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;!-- 1. 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;!--3. 创建Vue实例--&gt; &lt;script&gt; var app = new Vue(&#123; el: &quot;#app&quot;, data:&#123; food:&quot;西红柿&quot; &#125;, methods: &#123; doit:function()&#123; alert(&quot;做IT&quot;); &#125;, changeFood:function()&#123; this.food+=&quot;好好吃！&quot; &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 如果带参数event，可以利用event.target.value当前事件对象的值 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input text=&quot;text&quot; @keyup.enter=&quot;sayHi&quot;/&gt; &lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &quot; &quot;, &#125;, methods: &#123; sayHi:function(event)&#123; &lt;!--this.message表示当前Vue对象的message属性--&gt; this.message=event.target.value; &#125;, &#125;, &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; this表示当前Vue对象”new Vue()”，可以通过”this.“来调用当前Vue对象的属性和方法” v-once指令 v-once指明此元素的数据只出现一次，数据内容的修改不影响此元素 1&lt;p v-once&gt;&#123;&#123;titile&#125;&#125;&lt;/p&gt; 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p v-once&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt; &lt;input text=&quot;text&quot; v-model=&quot;message&quot;&gt;&lt;/input&gt; &lt;/div&gt; &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &quot;第一次内容就不变了&quot;, &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 计数器 data中定义数据:比如num methods中添加两个方法:比如add(递增),sub(递减) 使用v-text将num设置给span标签 使用v-on将add,sub分别绑定给+,-按钮 累加的逻辑：小于10累加,否则提示 递减的逻辑：大于0递减,否则提示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;title&gt;计数器&lt;/title&gt; &lt;style&gt; body &#123; background-color: #f5f5f5; &#125; #app &#123; width: 480px; height: 80px; margin: 200px auto; &#125; .input-num &#123; margin-top: 20px; height: 100%; display: flex; border-radius: 10px; overflow: hidden; box-shadow: 4px 4px 4px #adadad; border: 1px solid #c7c7c7; background-color: #c7c7c7; &#125; .input-num button &#123; width: 150px; height: 100%; font-size: 40px; color: #ad2a27; cursor: pointer; border: none; outline: none; background-color: rgba(0, 0, 0, 0); &#125; .input-num span &#123; height: 100%; font-size: 40px; flex: 1; text-align: center; line-height: 80px; font-family: auto; background-color: white; &#125; img &#123; float: right; margin-top: 50px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 计数器 --&gt; &lt;div class=&quot;input-num&quot;&gt; &lt;button @click=&quot;sub&quot;&gt; - &lt;/button&gt; &lt;span&gt;&#123;&#123; num &#125;&#125;&lt;/span&gt; &lt;button @click=&quot;add&quot;&gt; + &lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;!-- 编码 --&gt;&lt;script&gt; // 创建Vue实例 var app = new Vue(&#123; el: &quot;#app&quot;, data: &#123; num: 1, min: 0, max: 10 &#125;, methods: &#123; sub:function() &#123; if (this.num &gt; this.min) &#123; this.num--; &#125; else &#123; alert(&quot;别点啦,到底啦&quot;); &#125; &#125;, add:function() &#123; if (this.num &lt; this.max) &#123; this.num++; &#125; else &#123; alert(&quot;别点啦,到头啦&quot;); &#125; &#125; &#125; &#125;);&lt;/script&gt; 显示切换/属性绑定v-show指令 语法 123&lt;img src=&quot;img.jpg&quot; v-show=&quot;true&quot;&gt;&lt;img src=&quot;img.jpg&quot; v-show=&quot;isShow&quot;&gt; &lt;!--布尔变量--&gt;&lt;img src=&quot;img.jpg&quot; v-show=&quot;age&gt;=18&quot;&gt; &lt;!--变量判断--&gt; v-show指令的作用是：根据真假切换元素的显示状态 原理是修改元素的display，实现显示隐藏 指令后面的内容最终都会解析为布尔值 值为true元素显示，值为false元素隐藏 数据改变之后，对应元素的显示状态会同步更新 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;title&gt;vue&lt;/title&gt; &lt;style&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;切换显示状态&quot; @click=&quot;changIsShow&quot;&gt; &lt;img src=&quot;logo.png&quot; v-show=&quot;isShow&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;累加年龄&quot; @click=&quot;addage&quot;&gt; &lt;img src=&quot;logo.png&quot; v-show=&quot;age&gt;=18&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;!-- 编码 --&gt;&lt;script&gt; // 创建Vue实例 var app = new Vue(&#123; el: &quot;#app&quot;, data:&#123; isShow:false, age:17 &#125;, methods: &#123; changIsShow:function()&#123; this.isShow=!this.isShow; &#125;, addage:function()&#123; this.age++ &#125; &#125;, &#125;);&lt;/script&gt; v-if指令 语法 123&lt;p v-if=&quot;true&quot;&gt;&lt;/p&gt;&lt;p v-if=&quot;isShow&quot;&gt;&lt;/p&gt;&lt;p v-if=&quot;表达式&quot;&gt;&lt;/p&gt; v-if指令的作用是：根据表达式的真假切换元素的显示状态 本质是通过操纵dom元素来切换显示状态 表达式的值为true，元素存在于dom树中，为false，从dom树中移除 频繁的切换v-show，反之使用v-if，前者的切换消耗小 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;title&gt;vue&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;切换显示&quot; @click=&quot;changIsShow&quot;&gt; &lt;p v-if=&quot;isShow&quot;&gt;小李博客&lt;/p&gt; &lt;!--直接从DOM中消除--&gt; &lt;p v-show=&quot;isShow&quot;&gt;小李博客 --v-show修饰&lt;/p&gt; &lt;!--只更改display--&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;!-- 编码 --&gt;&lt;script&gt; // 创建Vue实例 var app = new Vue(&#123; el: &quot;#app&quot;, data:&#123; isShow:false, &#125;, methods: &#123; changIsShow:function()&#123; this.isShow=!this.isShow; //取反 &#125;, &#125;, &#125;);&lt;/script&gt; v-bind指令 插值表达式不能用于属性中，可以通过v-bind实现属性值的绑定 语法 123456789&lt;img src=&quot;img.jpg&quot;&gt;&lt;!--v-bind:属性名=表达式--&gt;&lt;img v-bind:src=&quot;imgSrc&quot;&gt; &lt;!--imgSrc=img.jpg--&gt;&lt;img v-bind:title=&quot;imgtitle+‘!！！’&quot;&gt;&lt;img v-bind:class=&quot;isActive?&#x27;active&#x27;:&#x27;&#x27;&quot; &gt;&lt;img v-bind:class=&quot;&#123;active:isActive&#125;&quot;&gt; &lt;img v-bind:href=&quot;link&quot;&gt;baidu&lt;/a&gt;&lt;!--v-bind可以省略--&gt;&lt;img :src=&quot;imgSrc&quot;&gt; v-bind指令的作用是：为元素绑定属性 完整写法是v-bind:属性名 简写的话可以直接省略v- bind,只保留:属性名 需要动态的增删class建议使用对象的方式{active:isActive} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;title&gt;vue&lt;/title&gt; &lt;style&gt; .active&#123; border:1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;img v-bind:src=&quot;imgSrc&quot;&gt; &lt;!--绑定事件和切换类名（三元表达式的方法）--&gt; &lt;img v-bind:src=&quot;imgSrc&quot; :class=&quot;isActive?&#x27;active&#x27;:&#x27;&#x27;&quot; @click=&quot;changeActive&quot;&gt; &lt;br&gt; &lt;img :src=&quot;imgSrc&quot; :title=&quot;imgTitle+&#x27;!&#x27; &quot;&gt; &lt;!--简写--&gt; &lt;!--绑定事件和切换类名（对象的方法）--&gt; &lt;img :src=&quot;imgSrc&quot; :title=&quot;imgTitle+&#x27;!&#x27; &quot; :class=&quot;&#123;active:isActive&#125;&quot; @click=&quot;changeActive&quot;&gt; &lt;!--简写--&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;!-- 编码 --&gt;&lt;script&gt; // 创建Vue实例 var app = new Vue(&#123; el: &quot;#app&quot;, data:&#123; imgSrc:&quot;logo.png&quot;, imgTitle:&quot;小李博客&quot;, isActive:false &#125;, methods: &#123; changeActive:function()&#123; this.isActive=!this.isActive; &#125; &#125;, &#125;);&lt;/script&gt; 图片切换 定义图片数组 添加图片索引 绑定src属性 图片切换用v-show 显示状态切换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; html, body, #mask &#123; width: 100%; height: 100%; &#125; #mask &#123; background-color: #c9c9c9; position: relative; &#125; #mask .center &#123; position: absolute; background-color: #fff; left: 50%; top: 50%; transform: translate(-50%, -50%); padding: 10px; &#125; #mask .center .title &#123; position: absolute; display: flex; align-items: center; height: 56px; top: -61px; left: 0; padding: 5px; padding-left: 10px; padding-bottom: 0; color: rgba(175, 47, 47, 0.8); font-size: 26px; font-weight: normal; background-color: white; padding-right: 50px; z-index: 2; &#125; #mask .center .title img &#123; height: 40px; margin-right: 10px; &#125; #mask .center .title::before &#123; content: &quot;&quot;; position: absolute; width: 0; height: 0; border: 65px solid; border-color: transparent transparent white; top: -65px; right: -65px; z-index: 1; &#125; #mask .center&gt;img &#123; display: block; width: 700px; height: 458px; &#125; #mask .center a &#123; text-decoration: none; width: 45px; height: 100px; position: absolute; top: 179px; vertical-align: middle; opacity: 0.5; &#125; #mask .center a :hover &#123; opacity: 0.8; &#125; #mask .center .left &#123; left: 15px; text-align: left; padding-right: 10px; border-top-right-radius: 10px; border-bottom-right-radius: 10px; &#125; #mask .center .right &#123; right: 15px; text-align: right; padding-left: 10px; border-top-left-radius: 10px; border-bottom-left-radius: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;mask&quot;&gt; &lt;div class=&quot;center&quot;&gt; &lt;h2 class=&quot;title&quot;&gt; &lt;img src=&quot;./images/logo.png&quot; alt=&quot;&quot;&gt; 深圳创维校区环境 &lt;/h2&gt; &lt;!--图片--&gt; &lt;img :src=&quot;imgList[index]&quot; alt=&quot;&quot; /&gt; &lt;!--左箭头--&gt; &lt;a href=&quot;javascript:void(0)&quot; @click=&quot;prev&quot; class=&quot;left&quot; v-show=&quot;index&gt;0&quot;&gt; &lt;img src=&quot;./images/prev.png&quot; alt=&quot;&quot; /&gt; &lt;/a&gt; &lt;!--右箭头--&gt; &lt;a href=&quot;javascript:void(0)&quot; @click=&quot;next&quot; class=&quot;right&quot; v-show=&quot;index&lt;imgList.length-1&quot;&gt; &lt;img src=&quot;./images/next.png&quot; alt=&quot;&quot; /&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const app = new Vue(&#123; el: &quot;#mask&quot;, data: &#123; imgList: [ &quot;./images/00.jpg&quot;, &quot;./images/01.jpg&quot;, &quot;./images/02.jpg&quot;, &quot;./images/03.jpg&quot;, &quot;./images/04.jpg&quot;, &quot;./images/05.jpg&quot;, &quot;./images/06.jpg&quot;, &quot;./images/07.jpg&quot;, &quot;./images/08.jpg&quot;, &quot;./images/09.jpg&quot;, &quot;./images/10.jpg&quot;, ], index: 0 &#125;, methods: &#123; // 上一张 prev: function () &#123; this.index--; &#125;, // 下一张 next: function () &#123; this.index++; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 列表循环/表单元素绑定v-for指令 语法 1234&lt;ul&gt; &lt;li v-for=&quot;item in arr&quot;&gt;&lt;/li&gt; &lt;li v-for=&quot;(it,index) in arr&quot;&gt;&lt;/li&gt;&lt;/ul&gt; v-for指令的作用是：根据数据生成列表结构 数组经常和v-for结合使用 语法是( item,index) in数据 item和index可以结合其他指令一起使用 数组长度的更新会同步到页面上，是响应式的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;v-for指令&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;添加数据&quot; @click=&quot;add&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;移除数据&quot; @click=&quot;remove&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(it,index) in arr&quot;&gt; &#123;&#123; index+1 &#125;&#125;校区:&#123;&#123; it &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;h2 v-for=&quot;item in vegetables&quot; v-bind:title=&quot;item.name&quot;&gt; &#123;&#123; item.name &#125;&#125; &lt;/h2&gt; &lt;/div&gt; &lt;!-- 1.开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var app = new Vue(&#123; el:&quot;#app&quot;, data:&#123; arr:[&quot;北京&quot;,&quot;上海&quot;,&quot;广州&quot;,&quot;深圳&quot;], vegetables:[ &#123;name:&quot;西兰花炒蛋&quot;&#125;, &#123;name:&quot;蛋炒西蓝花&quot;&#125; ] &#125;, methods: &#123; add:function()&#123; this.vegetables.push(&#123; name:&quot;花菜炒蛋&quot; &#125;); &#125;, remove:function()&#123; this.vegetables.shift(); &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; v-on补充 语法 相关修饰符查看官方文档 1&lt;input type=&quot;text&quot; @keyup.enter=&quot;sayHi&quot;&gt; &lt;!--按下回车键才触发--&gt; 事件绑定的方法写成函数调用的形式，可以传入自定义参数 定义方法时需要定义形参来接收传入的实参 事件的后面跟上.修饰符可以对事件进行限制 .enter可以限制触发的按键为回车 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;v-on补充&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;点击&quot; @click=&quot;doIt(666,&#x27;老铁&#x27;)&quot;&gt; &lt;input type=&quot;text&quot; @keyup.enter=&quot;sayHi&quot;&gt; &lt;/div&gt; &lt;!-- 1.开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var app = new Vue(&#123; el:&quot;#app&quot;, methods: &#123; doIt:function(p1,p2)&#123; console.log(&quot;做it&quot;); console.log(p1); console.log(p2); &#125;, sayHi:function()&#123; alert(&quot;吃了没&quot;); &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; v-model指令 语法 1&lt;input type=&quot;text&quot; v-model=&quot;message&quot; /&gt; v-model指令的作用是便捷的设置和获取表单元素的值 绑定的数据会和表单元素值相关联 绑定的数据等价于表单元素的值 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;v-model指令&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;修改message&quot; @click=&quot;setM&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot; @keyup.enter=&quot;getM&quot;&gt; &lt;h2&gt;&#123;&#123; message &#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var app = new Vue(&#123; el:&quot;#app&quot;, data:&#123; message:&quot;小李博客&quot; &#125;, methods: &#123; getM:function()&#123; alert(this.message); &#125;, setM:function()&#123; this.message =&quot;酷丁鱼&quot;; &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 记事本 新增 生成列表结构(v-for数组) 获取用户输入(v-model) 回车，新增数据(v-on .enter 添加数据) 删除 点击删除指定内容(v-on splice索引) 统计 统计信息个数(v-text length)，即数组长度 清空 点击清除所有信息(v-on 清空数组) 隐藏 没有数据时，隐藏元素(v-show v-if 数组非空) 列表结构可以通过v-for指令结合数据生成 v-on结合事件修饰符可以对事件进行限制比如.enter v-on在绑定事件时可以传递自定义参数 通过v-model可以快速的设置和获取表单元素的值 基于数据的开发方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;记事本&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./css/index.css&quot; /&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 主体区域 --&gt; &lt;section id=&quot;todoapp&quot;&gt; &lt;!-- 输入框 --&gt; &lt;header class=&quot;header&quot;&gt; &lt;h1&gt;记事本&lt;/h1&gt; &lt;!--增加--&gt; &lt;input v-model=&quot;inputValue&quot; @keyup.enter=&quot;add&quot; autofocus=&quot;autofocus&quot; autocomplete=&quot;off&quot; placeholder=&quot;请输入任务&quot; class=&quot;new-todo&quot; /&gt; &lt;/header&gt; &lt;!-- 列表区域 --&gt; &lt;section class=&quot;main&quot;&gt; &lt;ul class=&quot;todo-list&quot;&gt; &lt;li class=&quot;todo&quot; v-for=&quot;(item,index) in list&quot;&gt; &lt;div class=&quot;view&quot;&gt; &lt;span class=&quot;index&quot;&gt;&#123;&#123; index+1 &#125;&#125;.&lt;/span&gt; &lt;label&gt;&#123;&#123; item &#125;&#125;&lt;/label&gt; &lt;!--删除--&gt; &lt;button class=&quot;destroy&quot; @click=&quot;remove(index)&quot;&gt;&lt;/button&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/section&gt; &lt;!-- 统计和清空 --&gt; &lt;footer class=&quot;footer&quot; v-show=&quot;list.length!=0&quot;&gt; &lt;!--显示与隐藏--&gt; &lt;span class=&quot;todo-count&quot; v-if=&quot;list.length!=0&quot;&gt; &lt;strong&gt;&#123;&#123; list.length &#125;&#125;&lt;/strong&gt; items left &lt;/span&gt; &lt;button v-show=&quot;list.length!=0&quot; class=&quot;clear-completed&quot; @click=&quot;clear&quot;&gt; Clear &lt;/button&gt; &lt;/footer&gt; &lt;/section&gt; &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var app = new Vue(&#123; el: &quot;#todoapp&quot;, data: &#123; list: [&quot;写代码&quot;, &quot;吃饭饭&quot;, &quot;睡觉觉&quot;], inputValue: &quot;好好学习,天天向上&quot; &#125;, methods: &#123; //添加 add: function () &#123; this.list.push(this.inputValue); //数组追加元素 &#125;, //删除 remove: function (index) &#123; console.log(&quot;删除&quot;); console.log(index); this.list.splice(index, 1); &#125;, //清空 clear: function () &#123; this.list = []; //清空数组 &#125; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 改变样式的方法第一种方法 通过给html元素的class属性绑定vue中的属性值，得到样式的动态绑定 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .mydiv&#123; background-color:black; width: 100px; height: 100px; &#125; .red&#123; background-color: red; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div v-bind:class=&quot;&#123;red:temp&#125;&quot; class=&quot;mydiv&quot;&gt;&lt;/div&gt; &lt;input type=&quot;button&quot; v-on:click=&quot;temp=!temp&quot; value=&quot;改变颜色&quot;/&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var v1 = new Vue(&#123; el: &quot;#app&quot;, data: &#123; temp:true &#125;, &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 第二种方法 通过computed返回一个对象，对象里放着多个键值对 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .mydiv&#123; background-color:black; width: 100px; height: 100px; &#125; .red&#123; background-color: red; &#125; .mywidth&#123; width:450px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--v-bind绑定属性--&gt; &lt;div :class=&quot;myClassStyle&quot; class=&quot;mydiv&quot;&gt;&lt;/div&gt; &lt;hr/&gt; &lt;input type=&quot;button&quot; v-on:click=&quot;temp=!temp&quot; value=&quot;改变颜色&quot;/&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var v1 = new Vue(&#123; el: &quot;#app&quot;, data: &#123; temp:true &#125;, computed:&#123; myClassStyle:function()&#123; return &#123; //返回一个JSON对象 red:this.temp, mywidth:this.temp &#125; &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","path":"page/Vuejs02.html","date":"04-13","excerpt":"","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://xiaoliblog.cn/tags/Vue-js/"}]},{"title":"Vue.js前端框架🎯Vue概述及属性","text":"Vue简介 Vue是一个渐进式的JavaScript框架，只注重视图层，结合了HTML+CSS+JS，非常的易用，并且有很好的生态系统。而且vue体积很小，速度很快，优化很到位 可以用来简化Dom操作和响应式数据驱动 官方文档：https://cn.vuejs.org/v2/guide/ 视频教程强力推荐：VUE+Element UI+Vue Element Admin+SSM+微信支付实现前后端完整电商闭环 MVVM模式 MVVM模式即双向数据绑定模式 Model：模型层，在这里表示JavaScript对象 View：视图层，在这是表示DOM（HTML操作的元素） ViewModel：连接视图和数据的中间件，Vue.js技术MVVM中的ViewModel层的实现者 在MVVM架构中，是不允许数据和视图直接通信的，只能通过ViewModel来通信，而ViewModel就是定义了一个Observer观察者 ViewModel能够观察到数据的变化，并对视图对应的内容进行更新 ViewModel能够监听到视图的变化，并能够通知数据发生改变 Vue.js就是一个MVVM的实现者，他的核心就是实现了DOM监听和数据绑定 123456789101112131415161718&lt;!--这里就是MVVM中的View--&gt;&lt;div id=&quot;app&quot;&gt; &lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt; &lt;input text=&quot;text&quot; v-model=&quot;message&quot;/&gt;&lt;/div&gt;&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;//这里就是MVVM中的View Model var app = new Vue(&#123; el: &#x27;#app&#x27;, //这里就是MVVM中的Model data: &#123; message: &#x27;Hello Vue!&#x27; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; Vue中数据的单向传递就是把数据交给Vue实例对象，实例对象再将数据交给界面 两大核心要素数据驱动 当你把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器。 这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。这里需要注意的问题是浏览器控制台在打印数据对象时 getter/setter 的格式化并不同，所以你可能需要安装 vue-devtools 来获取更加友好的检查接口。 每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新 组件化 页面上每个独立的可交互的区域视为一个组件 每个组件对应一个工程目录，组件所需的各种资源在这个目录下就近维护 页面不过是组件的容器，组件可以嵌套自由组合（复用）形成完整的页面 CDN加速策略 CDN的全称是Content Delivery Network，即内容分发网络。其目的是通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络“边缘”，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。 说白了就是一种加速策略，能够从离自己最近的服务器上快速的获得外部的资源 比如当你需要Vue框架时，其服务器架在国外，光访问就花费不少时间，大大影响了用户体验。而CDN，其已经在全世界各地建立了内容分发服务器，当你引入Vue的CDN链接，就会从周边最近的内容分发服务器访问，大大提高了访问速率 Vue调试工具 Vue Devtools调试工具项目地址：https://github.com/vuejs/vue-devtools/tree/v5.1.1、 可以下载Github项目到本地安装，但推荐快速下载插件的网址收藏猫插件：https://chrome.pictureknow.com 密码:aypg 点击Chrome浏览器右上角&gt;更多工具&gt; 点击扩展程序 在扩展中心打开右上角的【开发者模式】按钮，然后【刷新】页面，把下载好的.crx 文件拖入扩展中心 打开调试工具可以看到多了一个Vue选项 Vue快速开始 导入开发版本的Vue.js 1&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; 创建HTML的DOM元素，用ID选择，且值为app 123&lt;div id=&quot;app&quot;&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt; 创建Vue实例对象，设置el属性用于绑定DOM和data属性设置显示数据 12345678910&lt;script&gt; //创建一个Vue的实例对象 new Vue(&#123; //告诉Vue的实例对象，将来需要控制界面上的哪个区域 el: &#x27;#app&#x27;, data: &#123; //以后，数据就是通过发送ajax请求，来获得的 message: &#x27;Hello Vue!&#x27; &#125; &#125;)//json格式的对象 使用大括号包裹，里面放了键值对，在js中键可以没有引号,多个键值对之间使用‘,’分隔&lt;/script&gt; 除了简单的引入来开发，还可以使用官方的脚手架进行开发 插值表达式 插值表达式也就是模板语法，详情可以参考art-template 差值表达式是用在html中被绑定的元素中的，目的是通过差值表达式来获取vue对象中的属性和方法 语法格式： &#123;&#123;vue的内容&#125;&#125; 12345678new Vue(&#123; data:&#123;&#125; &lt;== 这个data就提供了属性 methods:&#123; &lt;== 这各methods就是提供方法的 sayHi:function()&#123; alert(&quot;hello vue&quot;) &#125; &#125;&#125;) 插值表达式另一种用法 123456&lt;div id=&quot;app&quot;&gt; &#123;&#123;title&#125;&#125; &#123;&#123;[1,2,3,4][2]&#125;&#125; &#123;&#123; &#123;&quot;name&quot;:&quot;xiaoyu&quot;,&quot;age&quot;:20&#125;.age &#125;&#125; &#123;&#123; sayHello()&#125;&#125;&lt;/div&gt; Vue属性el挂载点 el是用来设置Vue实例挂载(管理)的元素 Vue会管理el选项命中的元素及其内部的后代元素 可以使用其他的选择器，但是建议使用ID选择器 可以使用其他的双标签，不能使用HTML和BODY data数据对象 Vue中用到的数据定义在data中 data中可以写复杂类型的数据 渲染复杂类型数据时，遵守js的语法即可 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &#123;&#123; message &#125;&#125; &lt;h2&gt;&#123;&#123; school.name &#125;&#125; &#123;&#123; school.mobile &#125;&#125; &lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&#123;&#123; campus[0] &#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123; campus[1] &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var app = new Vue(&#123; el: &#x27;#app&#x27;, //推荐ID选择器，只支持单标签 data: &#123; message: &#x27;Hello Vue!&#x27;, school: &#123; //对象 name: &quot;xiaoli&quot;, mobile: &quot;123456&quot; &#125;, campus: [&quot;北京&quot;, &quot;上海&quot;] //数组 &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; methods属性 methods用于放置页面中的业务逻辑，js方法一般都放置在methods中 123456789new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &quot;&lt;a href=&#x27;https://xiaoliblog.cn&#x27;&gt;小李博客&lt;/a&gt;&quot; &#125;, methods: &#123; alert(&quot;你好&quot;); &#125;,&#125;) computed属性 computed是计算属性 计算属性的重点突出在 属性 两个字上（属性是名词），首先它是个 属性 其次这个属性有 计算 的能力（计算是动词），这里的 计算 就是个函数；简单点说，它就是一个能够将计算结果缓存起来的属性（将行为转化成了静态的属性），仅此而已； 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;vue&quot;&gt; &lt;p&gt;调用当前时间的方法：&#123;&#123;currentTime1()&#125;&#125;&lt;/p&gt; &lt;p&gt;当前时间的计算属性：&#123;&#123;currentTime2&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue(&#123; el: &#x27;#vue&#x27;, data: &#123; message: &#x27;Hello Vue&#x27; &#125;, methods: &#123; currentTime1: function () &#123; return Date.now(); &#125; &#125;, computed: &#123; currentTime2: function () &#123; this.message; return Date.now(); &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; methods：定义方法，调用方法使用 currentTime1()，需要带括号 computed：定义计算属性，调用属性使用 currentTime2，不需要带括号；this.message 是为了能够让 currentTime2 观察到数据变化而变化 注意：methods 和 computed 里不能重名 调用方法时，每次都需要进行计算，既然有计算过程则必定产生系统开销，那如果这个结果是不经常变化的呢？此时就可以考虑将这个结果缓存起来，采用计算属性可以很方便的做到这一点；计算属性的主要特性就是为了将不经常变化的计算结果进行缓存，以节约我们的系统开销 watch属性 watch用于监控参数的变化，并调用函数，newVal是能获得参数新的值，oldVal是参数老的值 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &#123;&#123;title&#125;&#125; &lt;input type=&quot;text&quot; v-model=&quot;title&quot; /&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var v1 = new Vue(&#123; el: &quot;#app&quot;, data: &#123; title: &quot;hello vue&quot;, &#125;, watch: &#123; title: function (newValue, oldValue) &#123; console.log(newValue + &quot;:&quot; + oldValue); &#125;, &#125;, &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 虚拟DOM和diff算法 vue的高效的核心，就是虚拟的dom和diff算法，vue不通过修改dom树来达到修改的效果，而是直接在页面上改那个元素，此时这个元素就是一个虚拟的dom 那么vue怎么去改呢？ 通过diff算法，计算出虚拟的dom修改后和修改前的区别，然后在虚拟dom的原基础上进行修改，这样的效率就大大提升了","path":"page/Vuejs01.html","date":"04-13","excerpt":"","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://xiaoliblog.cn/tags/Vue-js/"}]},{"title":"Nginx🎯Nginx安装及使用","text":"Windows下安装下载Nginx 访问Nginx官网下载稳定版本：http://nginx.org/en/download.html 以nginx/Windows-1.18.0为例，直接下载压缩包，解压后如下 启动Nginx 第一种方式：直接双击nginx.exe，双击后一个黑色的弹窗一闪而过 第二种方式：打开cmd命令窗口，切换到nginx解压目录下，输入命令nginx.exe，回车即可 小诀窍，在指定目录下按Shift+鼠标右键用Powershell窗口打开，可以输入start cmd打开命令窗口，也可以直接使用 当出现窗口一闪而过时，可以检查Nginx压缩目录下logs\\error.log，出现如下表示默认80端口被占用 12021&#x2F;04&#x2F;11 13:04:48 [emerg] 10728#19784: bind() to 0.0.0.0:80 failed (10013: An attempt was made to access a socket in a way forbidden by its access permissions) 解决方法，修改conf/nginx.conf配置文件，修改成如下 123456789101112server &#123; listen 8100; server_name localhost; #charset koi8-r; #access_log logs&#x2F;host.access.log main; location &#x2F; &#123; root html; index index.html index.htm; &#125; 这时候再点击开启nginx，这时候会出现是否出现安全提示，然后在浏览器中输入127.0.0.1:8100，出现如下页面，表示安装成功 Linux下安装可以通过宝塔可视化界面在软件商店下载，以下介绍命令行下载方法 访问Nginx官网下载稳定版本：http://nginx.org/en/download.html 下载压缩包后，通过Xftp上传到Linux服务器，移动到/usr/local/下 上传后通过命令进行解压 1tar -zxcf nignx-1.18.0.tar.gz 进行Nginx目录进行配置安装 12345678910##进入nginx目录cd nginx-1.9.9# 自动配置./configure# makemakemake install 启动Nginx 1234# 进入cd /usr/local/nginx/sbin# 执行./nginx 端口修改，通过vim修改 123456cd conf/cat nginx.conf# 修改vim nginx.conf# 重新加载./nginx -s reload Nginx常用命令123456cd /usr/local/nginx/sbin/./nginx # 启动./nginx -s stop # 停止./nginx -s quit # 安全退出./nginx -s reload # 重新加载配置文件ps aux|grep nginx # 查看Nginx进程 Nginx实例 假设有一个项目，比如博客网站（https://xiaoliblog.cn)，开了两个服务器，分别是8080和8081端口，但是用户只想通过80端口就可以访问服务，且每个服务器权重不一样，这就需要Nginx进行反向代理和负载均衡了 Nginx配置文件 Nginx的设置都在\\conf\\nginx.conf中进行，其结构大致分为如下 12345678910111213141516171819202122232425262728全局配置模块events &#123; worker_connections 1024;&#125;http &#123; http 配置 upstream xx&#123; &#x2F;&#x2F; 负载均衡配置 &#125; server &#123; listen 80; server_name localhost; &#x2F;&#x2F;服务80端口的代理服务器配置 location &#x2F;&#123; #根目录下的请求发送到128服务器 &#x2F;&#x2F;xxx 128.xxx &#125; location &#x2F;admin&#123; #admin下面的请求发送到47服务器 &#x2F;&#x2F;xxx 47 &#125; &#125; server &#123; listen 443; server_name localhost; &#x2F;&#x2F;代理 &#125;&#125; 配置文件详情请参考https://www.runoob.com/w3cnote/nginx-setup-intro.html 修改conf文件，让80端口服务器代理8081和8080服务 1234567891011121314151617181920events &#123; worker_connections 1024;&#125;http &#123; #用于设置负载均衡,名称自定义 upstream xiaoliblog &#123; #weight设置权重 server 127.0.0.1:8080 wegiht&#x3D;3; server 127.0.0.1:8081 wegiht&#x3D;1; &#125; server &#123; listen 80; server_name localhost; location &#x3D; &#x2F;50x.html &#123; root html; index index.html index.html; proxy_pass http:&#x2F;&#x2F;xiaoliblog; &#125;&#125; 修改后在cmd命令输入重新加载配置文件命令 1nginx -s reload # 重新加载配置文件","path":"page/Nginx02.html","date":"04-11","excerpt":"","tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://xiaoliblog.cn/tags/Nginx/"}]},{"title":"Nginx🎯反向代理及负载均衡","text":"Nginx应用场景 我们公司项目刚刚上线的时候，并发量小，用户使用的少，所以在低并发的情况下，一个jar包启动应用就够了，然后内部tomcat返回内容给用户 但是慢慢的，使用我们平台的用户越来越多，并发量慢慢增大了，这时候一台服务器满足不了我们的需求了 于是我们横向扩展，又增加了服务器。这个时候几个项目启动在不同的服务器上，用户要访问，就需要增加一个代理服务器了，通过代理服务器来帮我们转发和处理请求 架构：没有加一层解决不了的问题 我们希望这个代理服务器可以帮助我们接收用户的请求，然后将用户的请求按照规则帮我们转发到不同的服务器节点之上。这个过程用户是无感知的，用户并不知道是哪个服务器返回的结果，我们还希望他可以按照服务器的性能提供不同的权重选择，保证最佳体验！所以引出了Nginx Nginx简介 Nginx (engine x)是一个高性能的HTTP和反向代理web服务器 ，同时也提供了IMAP/POP3/SMTP服务 Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点(俄文: Pam6nep) 开发的，第一个公开版本0.1.0发布于2004年10月4日。2011年6月1日, nginx 1.0.4发布 其特点是占有内存少，并发能力强，实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、东新浪、网易、腾讯、淘宝等。在全球活跃的网站中有12.18%的使用比率，大约为2220万个网站 Nginx是一个安装非常的简单、 配置文件非常简洁(还能够支持peri语法)、Bug非常少的服务。Nginx 启动特别容易，并且几乎可以做到7 *24不间断运行，即使运行数个月也不需要重新启动。你还能够不间断服务的情况下进行软件版本的升级 Nginx代码完全用C语言从头写成。官方数据测试表明能够支持高达50,000 个并发连接数的响应 Nginx作用正向代理 首先了解一下正向代理，正向代理类似一个跳板机，代理访问外部资源，即代理客户端的 比如我们国内访问谷歌，直接访问访问不到，我们可以通过一个正向代理服务器，比如VPN，请求发到代理服服务器，代理服务器能够访问谷歌，这样由代理去谷歌取到返回数据，再返回给我们，这样我们就能访问谷歌了 正向代理的用途： 访问原来无法访问的资源，如google 可以做缓存，加速访问资源 对客户端访问授权，上网进行认证 代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息 反向代理 反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器 反向代理的作用： 保证内网的安全，阻止web攻击，大型网站，通常将反向代理作为公网访问地址，Web服务器是内网 负载均衡，通过反向代理服务器来优化网站的负载 正向代理即是客户端代理, 代理客户端, 服务端不知道实际发起请求的客户端 反向代理即是服务端代理, 代理服务端, 客户端不知道实际提供服务的服务端 负载均衡 Nginx提供的负载均衡策略有两种 内置策略，比如轮询，加权轮询，Ip hash 扩展策略，就天马行空，只有你想不到的没有他做不到的 轮询 加权轮询 Ip hashi对客户端请求的ip进行hash操作，然后根据hash结果将同一个客户端ip的请求分发给同一台服务器进行处理， 可以解决session不共享的问题 动静分离 动静分离，在我们的软件开发中，有些请求是需要后台处理的，有些请求是不需要经过后台处理的(如: CSS、 html、 jpg、 js等等文件)，这些不需要经过后台处理的文件称为静态文件。让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作。提高资源响应的速度","path":"page/Nginx01.html","date":"04-11","excerpt":"","tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://xiaoliblog.cn/tags/Nginx/"}]},{"title":"ECMAScript 6🌞Babel转码及ES6模块化","text":"Babel ES6的某些高级语法在浏览器环境甚至是Node.js环境中无法执行。而Babel是一个广泛使用的转码器，可以将ES6代码转为ES5代码，从而在现有环境中执行。这意味着你可以用ES6编写程序，而不用担心环境是否支持 Babel官方文档：https://www.babeljs.cn/ 安装 Babel提供babel-cli工具，用于命令行转码，它的安装命令如下 1234npm install -g babel-cli# 查看是否安装成功babel --version Babel的使用 创建babel文件夹，做为工程目录 初始化项目 1npm init -y 在项目目录下创建文件夹src/example.js，以下是ES6代码 123456//转换前//定义变量let input = [1,2,3]//将数组的每个元素+1input = input.map(item =&gt; item+1)console.log(input) 创建一个.babelrc配置文件，存放在项目的根目录下，该文件用来设置转码规则和插件，基本格式如下 1234&#123; &quot;presets&quot;: [&quot;es2015&quot;], &quot;plugins&quot;: []&#125; presets字段设定转码规则，将ES2015规则加入.babelrc 安装转码器，在项目中安装 1npm install --save-dev babel-preset-es2015 转换器其实就是一个映射器，把let=&gt;var，const=&gt;var，=&gt; 转为function() 进行转换 1babel src -d dist 可以看到生成了一个dist\\example.js文件，其内容就是ES2015的语法 12345678910&quot;use strict&quot;;//转换前//定义变量var input = [1, 2, 3];//将数组的每个元素+1input = input.map(function (item) &#123; return item + 1;&#125;);console.log(input); Babel自定义脚本 通过package.json进行包管理，不需要输入命令进行转换，改写package.json 12345678&#123;//... &quot;scripts&quot;: &#123; &quot;dev&quot;:&quot;babel src -d dist&quot; //命令名：命令值 &#125;, //...&#125; 转码的时候，执行下面的命令 1npm run dev ES6模块化 ES6使用expert和import来导入、导出模块 第一种写法 创建model-es6文件夹 创建src/UserAPI.js文件·，导出模块 1234567export function getList()&#123; //在真实业务中，异步获取数据 console.log(&quot;获取数据列表&quot;)&#125;export function save()&#123; console.log(&quot;保存数据&quot;)&#125; 创建src/UserComponent.js文件，导入上面的模块 123456//只取需要的方法即可，多个方法用逗号隔开import &#123;getList,save&#125; from &#x27;./UserAPI.js&#x27;;getList()save()//默认不支持ES6 语法的 import 不支持ES6，使用Babel初始化项目，在项目目录下执行以下命令 1npm npm init -y 在根目录下创建.babelrc的配置文件，注意文件后缀为babelrc，然后添加信息 1234&#123; &quot;presets&quot;: [&quot;es2015&quot;], &quot;plugins&quot;: []&#125; 修改package.json文件，或者直接输入命令 123456&#123; &quot;scripts&quot;: &#123; &quot;build&quot;:&quot;babel src -d dist&quot; &#125;,&#125; 执行添加的命令 1npm run build 运行dist目录下的UserComponent.js 1node UserComponent.js 第二种方式 其余都一样，只是导入导出模块更加简化了 改写UserAPI.js导出模块，可以看到做为一个对象全部导出 123456789export default&#123; getList()&#123; //在真实业务中，异步获取数据 console.log(&quot;获取数据列表&quot;) &#125;, save()&#123; console.log(&quot;保存数据&quot;) &#125;&#125; 改写UserComponent.js导入模块 123456//所有方法赋给一个对象userimport user from &#x27;./UserAPI.js&#x27;;user.getList()user.save()//默认不支持ES6 语法的 import 然后继续使用Babel执行即可","path":"page/ECMAScript02.html","date":"04-11","excerpt":"","tags":[{"name":"ECMAScript 6","slug":"ECMAScript-6","permalink":"http://xiaoliblog.cn/tags/ECMAScript-6/"}]},{"title":"ECMAScript 6🌞ES6基础语法","text":"ECMAScript 6 ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言 参考阮一峰《ECMAScript 6入门》：https://es6.ruanyifeng.com/ ECMAScript的快速发展 let和const命令123456789//传统的定义变量和常量的方式 都使用varvar name1 = &quot;es6&quot;;var PI1 = Math.PI;//ES6定义方式let name2 = &quot;es6&quot;; //定义常量const PI2 = Math.PI; let和const的使用可以为我们解决两大问题 var变量穿透（let) 常量修改（const) 12345for(var i =0;i&lt;5;i++)&#123; console.log(i);&#125;//这里就会造成变量穿透console.log(i); 如下运行结果，5的出现不符合规范 如果var改为let，就会报错，提醒我们出现变量穿透 如下使用var定义常量，常量可以被修改 12345var PI = Math.PI;console.log(PI);//常量被修改PI = 100;console.log(PI); 修改为const定义，修改就会报错 在实际开发中，如果是小程序，uniapp或者一些脚手架中，可以大胆的去使用let和const但是如果是web开发，建议函数使用var，因为一些低版本浏览器并不支持let和const 模板字符串 以前：都是使用单引号&#39;或者双引号&quot; &quot;来进行字符串拼接 现在：使用``反引号进行字符串拼接，通过${value}区别值 123456789101112//字符串会牵涉到动态部分var person = &#123; name : &quot;小李&quot;, address : &quot;长沙&quot;, link : &quot;https://xiaoliblog.cn&quot;&#125;;let address = &quot;我是&quot; + person.name + &quot;,现居&quot; + person.address + &quot;,我的博客网站:&quot; + person.link;console.log(&quot;传统&quot;+address);//ES6的语法模板字符串let address1 = `我是$&#123;person.name&#125;,现居$&#123;person.address&#125;,我的博客网站:$&#123;person.link&#125;`;console.log(&quot;ES6&quot;+address1); 默认参数 函数默认参数：在方法的参数后面加上一个默认值即可 比如以下函数，我只传单个参数或者不传，控制台就会输出NaN 123456//不传参数，默认为undefinedfunction sum(a,b)&#123; return a+b;&#125;var result = sum(100)console.log(&quot;result=&quot;+result) 这个时候可以使用默认参数，可以不用传值，手动传值优先级更高 123456// 函数默认参数function sum(a=100,b=100)&#123; return a+b;&#125;var result = sum(100)console.log(&quot;result=&quot;+result) 箭头函数1234567891011// 传统函数var sum = function (a, b) &#123; return a + b;&#125;;//箭头函数 - 改进1var sum = (a, b) =&gt; &#123; return a + b;&#125;;//箭头函数 - 改进2var sum = (a, b) =&gt; a + b; 可以发现有以下规律 去掉function 在括号后面加箭头 如果逻辑代码仅有return可以直接省去 如果参数只有一个，可以把括号也省去 通过箭头函数可以简化一些复杂的函数 123456789var arr = [1,2,3,4,5,6];var newarr1 = arr.map(function(obj)&#123; return obj+2;&#125;)console.log(newarr1);//箭头函数简化var newarr2 = arr.map((obj)=&gt;obj+2)console.log(newarr2); 对象初始化简写12345678910111213141516171819202122var info = &#123; title:&quot;小李博客&quot;, link:&quot;https://xiaoliblog.cn&quot;, go:function()&#123; console.log(&quot;加油！&quot;) &#125;&#125;;//ES6简写//因为对象是key：value存在//1. 如果key和变量的名字一致，可以只定义一次即可//2. 如果value是一个函数，可以把&quot;:function&quot;去掉，只剩下()即可var title1 = &quot;小李博客&quot;var link1 = &quot;https://xiaoliblog.cn&quot;let info2 = &#123; title1, link1, go()&#123; console.log(&quot;加油！&quot;) &#125;&#125;console.log(info2) 应用场景 123456789101112131415161718192021222324var username = &quot;admin&quot;;var password = &quot;123&quot;;$.ajax(&#123; type:&quot;post&quot;, url:&quot;xxx&quot;, data:&#123; username : username, password : password &#125;, success:function()&#123; &#125;&#125;)//简化var params = &#123;username,password&#125;;$.ajax(&#123; type:&quot;post&quot;, url:&quot;xxx&quot;, data:params, success()&#123; &#125;&#125;) 对象解构 对象解构能快捷获取对象属性和行为方式 123456789101112131415161718192021222324//因为对象是key：value存在，获取的方式有两种//1. 通过.//2. 通过[]var title = &quot;小李博客&quot;;var link = &quot;https://xiaoliblog.cn&quot;;let info = &#123; title, link, go() &#123; console.log(&quot;加油！&quot;); &#125;,&#125;;//通过.和[]方式console.log(info.title)console.log(info[&quot;title&quot;])info[&quot;go&quot;]();//ES6对象结构 --快速获取属性和方法的形式-var &#123;title,link,go&#125; = info;// 还原代码,以上等价于//var title = info.title//var link = info.linkconsole.log(title,link)go() 传播操作符 传播操作符可以把一个对象的属性传播到另外一个对象中 123456789101112131415var person = &#123; name: &quot;小李博客&quot;, address:&quot;长沙&quot;, link:&quot;https://xiaoliblog.cn&quot;, phone:12134, go()&#123; console.log(&quot;加油&quot;) &#125;&#125;//对象解构,person传播给person2//name,address已经解构出来了,剩下的也会传播给person2var &#123;name,address,...person2&#125; = person;console.log(name);console.log(address);console.log(person2); 数组Map12345678910111213141516171819202122232425262728//对arr数组中每个元素*2var arr = [1,2,3,4,5,6,7]//传统方式var newarr = [];for(let i=0;i&lt;arr.length;i++)&#123; newarr.push(arr[i]*2)&#125;console.log(newarr);//map -- 自带的循环功能,并且会把处理的值回填到原来的位置var newarr2 = arr.map(function(ele)&#123; return ele*2&#125;)//var newarr2 = arr.map((ele)=&gt;ele*2)console.log(newarr2)//map --处理对象中的数据//需求:每个年龄+1var users = [ &#123;age:10,name:&quot;小李&quot;&#125;, &#123;age:12,name:&quot;小王&quot;&#125;, &#123;age:14,name:&quot;小刘&quot;&#125;]var newusers = users.map(function(ele)&#123; ele.age = ele.age+1; return ele;&#125;)console.log(newusers) 数组Reduce12345678 var arr = [1,2,3,4,5,6,7,8,9,10]//第一次取值,a=1,b=2,a+b=3,取代[1,2]的位置//第二次,a=3,b=3,a+b=6,去掉[3,3]的位置//依此类推var result = arr.reduce(function(a,b)&#123; return a+b&#125;)console.log(&quot;result = &quot;,result);","path":"page/ECMAScript01.html","date":"04-10","excerpt":"","tags":[{"name":"ECMAScript 6","slug":"ECMAScript-6","permalink":"http://xiaoliblog.cn/tags/ECMAScript-6/"}]},{"title":"Webpack🌞Webpack安装及使用","text":"Webpack Webpack是一个前端资源加载/打包工具。它将根据模块的依赖关系进行静态分享，然后将这些模块按照指定的规则生成对应的静态资源 Webpack官方文档：https://webpack.docschina.org/ 从图中我们可以看出，Webpack可以将多种静态资源js、css、less转换成一个静态文件，减少了页面的请求 Webpack安装 全局安装 1npm install 0g webpack webpack-cli 安装后查看版本号 1webpack -v Webpack合并JS 项目实现步骤 创建一个nodejs项目npm init -y 创建一个src目录 在src存放两个需要合并的util.js和common.js 准备一个入口文件main.js, 其实就是模块集中进行引入 在根目录下定义个webpack.config.js文件配置打包的规则 执行webpack查看效果 初始化项目 创建webpack项目文件夹 1npm init -y 创建src文件夹 src下创建common.js 12345//输出exports.info = function (str) &#123; console.log(str); document.write(str);&#125;; src下创建util.js 12//相加函数exports.add = (a, b) =&gt; a + b; src下创建main.js 12345//导入模块const util = require(&#x27;./util&#x27;);const common = require(&#x27;./common&#x27;);//合并打印common.info(&quot;Hello world,&quot;+util.add(100,100)) 在根目录下创建webpack-config.js文件 123456789101112131415//导入path模块,nodejs内置模块const path = require(&#x27;path&#x27;);//等于JS打包规则module.exports =&#123; //1.入口函数：从哪里开始进行编译打包 entry:&quot;./src/main.js&quot;, //2.编译成功后把内容输出到哪里去 output:&#123; //2-1:定义输出的指定的目录，__dirname:当前项目根目录，生成一个dist文件 path:path.resolve(__dirname,&quot;./dist&quot;), //2-2:合并的js文件存储在dist/bundle.js中 filename:&quot;bundle.js&quot; &#125;&#125; 执行webpack指令·，如果出现以下错误 需要按Shift运行powershell（管理员身份），输入set-ExecutionPolicy RemoteSigned，并选择A 然后执行webpack打包指令 可以看到生成了dist/bundle.js文件，其合并了common.js和util.js的JS文件，未格式化时是一行显示，被压缩了 创建一个test.html，引入bundle.js文件运行 1&lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; 其他命令可以通过webpack -h查看，比如webpack -w有监听作用，当你修改或增加模块时，会动态打包 webpack合并CSS安装Loader插件 Webpack本身只能处理JavaScript模块，如果要处理其他类型的文件，就需要使用loader进行转换 Loader 可以理解为模块和资源的转换器 首先需要安装相关Loader插件 css-loader 是将css装载到javascript style-loader 是让javascript认识css 在webpack工程目录下安装依赖 1npm install --save-dev style-loader css-loader 合并配置 修改webpack.config.js文件 123456789101112131415161718192021//导入path模块,nodejs内置模块const path = require(&#x27;path&#x27;);//等于JS打包规则module.exports =&#123; //1.入口函数：从哪里开始进行编译打包 entry:&quot;./src/main.js&quot;, //2.编译成功后把内容输出到哪里去 output:&#123; //2-1:定义输出的指定的目录，_dirname:当前项目根目录，生成一个dist文件 path:path.resolve(__dirname,&quot;./dist&quot;), //2-2:合并的js文件存储在dist/bundle.js中 filename:&quot;bundle.js&quot; &#125;, module:&#123; rules:[&#123; test:/\\.css$/, //把项目中所有的.css结尾的文件进行打包 use:[&quot;style-loader&quot;,&quot;css-loader&quot;] //使用两个依赖 &#125;] &#125;&#125; 在src文件夹创建style.css 123body&#123; background-color:yellow;&#125; 修改入口函数main.js，引入style.css 12//导入cssrequire(&quot;./style.css&quot;) 执行webpack命令·，或者在package.json中编写脚本 123webpack# 或者npm run 脚本名 依然生成了dist/bundle.js文件·，里面把JS和CSS合并了，运行引入了bundle.js文件的test.html，可以看到已经生效了 此时执行监听命令 1webpack -w 修改style.css 12345body&#123; background-color:yellow; font-size:30px; color:red;&#125; test.html页面也随之改变·","path":"page/Webpack01.html","date":"04-10","excerpt":"","tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://xiaoliblog.cn/tags/Webpack/"}]},{"title":"服务器购买及宝塔部署环境说明","text":"服务器购买 作为一个程序员，必须要发布自己的网站和项目！ 自己的远程仓库、远程数据库、远程tomcat….. 搭建在服务器上 练习，Linux进行任意的环境部署操作！ Window下开发，你不熟悉Linux 轻量级服务器 如果是学生或者24以下的小伙伴，可以购买学生机，100多元一年 学生机链接：https://www.aliyun.com/activity/promotion/campus2018 优惠活动：https://www.aliyun.com/sale-season/2020/procurement-new-members?userCode=0phtycgr 服务器购买流程参考：https://www.kubk.net/800.html 轻量级服务器配置参考：https://blog.csdn.net/weixin_43553694/article/details/104105256 香港服务器可以避免备案，但是尽量不要自己挂VPN，会被封！ 认证好学生后，可以购买轻量级1核2G 系统镜像就是纯净版系统 ，应用镜像就是安装了部分软件的系统。个人建议选择系统镜像，再去安装所需的软件就行，比如宝塔面板一键安装部署 进入轻量应用服务器控制台，可以看到自己的服务器 设置可视化面板 进入服务器，我们使用的可视化面板为宝塔（BT-Panel），使用之前要先确定自己的系统是CentOS 如果之前没有设置，可以在左侧边栏：【服务器运维】-【重制系统】下的【应用镜像】和【系统镜像】设置 应用镜像设置为BT-Panel，系统镜像设置为CentOS 设置之后系统会被重置，确保重置不会影响自己服务器中已部署的程序的运行，如果是新服务器则不需担心此问题 配置宝塔面板 进入侧边栏：【应用管理】-【应用详情】，这里会有如何配置宝塔界面的使用方法 获取面板初始密码 按照顺序，先点击1.复制密码查询指令，会将查询密码的指令复制到剪切板 再点击2，会弹出一个终端，粘贴上剪切板的内容，敲回车 下一行出现的就是你的宝塔面板默认密码，这个密码可以用于忘记账号密码等等 忘记宝塔密码的解决方案 使用超级管理员权限，在远程连接中输入以下命令重置密码 重置密码之后就可以使用面板的初始密码和用户名登陆 1cd /www/server/panel &amp;&amp; python tools.py panel testpasswd 如果提示多次登录失败，暂时禁止登录 请输入以下命令 清除登录限制 1rm -f /www/server/panel/data/*.login 登录面板 在安全-防火墙中将8888端口开放 在浏览器中新开页面，在网址处输入自己服务器的IP:8888，比如自己服务器的IP是127.0.0.1，就输入127.0.0.1:8888，就会进入宝塔的登陆界面（服务器IP可以在配置方法里看到） 默认用户名为admin，密码是刚才我们获取到的 进入宝塔面板的面板设置，修改自己的用户名和密码 可以看到宝塔面板上的【文件】，这就是远程服务器上的文件 接下来介绍另一种远程连接方式，通过Shell和Xftp进行远程服务器访问 XShell远程连接 为什么要远程连接？ 公司服务器不是个人电脑更不是虚拟机，其有独立的机房存放 补充：有的机房 “藏” 在山里，一方面可以防止人为干扰，另一方面气温较低有助于服务器冷却 如何远程连接？用什么软件？ Xshell：实现远程连接、命令行操控服务器 Xftp：帮助服务器实现文件的上传和下载 官网下载地址：https://www.netsarang.com/zh/all-downloads/ 选择右边家庭和学校用户的免费许可证下载 然后会通过邮件发送下载链接给你 XShell 下载好XShell软件后，直接打开，点击【文件】【新建】，填入服务器IP和服务器端口号进行连接，IP和端口号在阿里云控制台可以找到，22端口要在安全组打开 在阿里云控制台设置如下 再次打开软件需要登录，用户名root，密码为在阿里云设置的密码 连接成功如下所示 Ctrl+滚轮可以缩放字体，你可以通过Liunx命令操作服务器了 Xftp 上传文件使用Xftp即可，直接在XShell可以看到，前提是已经下载了Xftp 打开Xftp，可以看到划分为两个窗口，分别代表本地和远程服务器，文件交互拖到就可以 安装宝塔 也可以通过XShell安装宝塔界面 下载安装地址：https://www.bt.cn/bbs/thread-19376-1-1.html 在网址中找一个命令用于下载宝塔 1yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh 下载完毕之后，就可以得到一个地址：宝塔的管理面板！ Tomcat部署Java项目远程连接超级管理员权限 如下图进入远程连接，在远程连接中输入下行命令，获取超级管理员权限 1sudo su root 安装JDK 下载JDK的压缩包，在本机上将jdk解压成文件夹 在宝塔面板中，进入文件，找到根目录/www/server，将jdk安装包上传到这个目录下 配置环境变量，将/etc/profile文件，编辑打开，在最后一行加入如下环境变量 12345&#x2F;&#x2F;下面的路径要根据自己jdk的位置，改成自己服务器上的路径JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk8PATH&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk8&#x2F;bin:$PATHCLASSPATH&#x3D;.:&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk8&#x2F;lib&#x2F;dt.jar:&#x2F;usr&#x2F;java&#x2F;jdk8&#x2F;lib&#x2F;tools.jarexport JAVA_HOME PATH CLASSPATH CATALINA_HOME 在远程连接中输入如下命令，启用文件 1source /etc/profile 之后在远程连接中输入javac来测试是否配置成功 环境安装 进入面板选择软件管理，安装Nginx 、Apache、MySQL、Tomcat（安装合适的版本即可) 默认的安装目录在根目录/www/server下 配置站点 如果已经绑定域名，将域名添加到站点中 如果没有安装Ngnix，是不能添加站点的 这时在浏览器中输入域名就可以看到站点创建成功的提示 放行端口 在安全中，将Tomcat将要使用的8080端口放行 由于数据库使用的是Mysql，默认端口3306，所以我们将3306端口也放行 如果不放行端口，就会出现端口无法访问的情况 只在这里放行是不可以的，还要回到阿里云服务器界面，在阿里云中也放行8080和3306 部署项目 在宝塔页面的文件管理中，进入tomcat的webapp文件夹，将本地打包好的war包上传 只需要上传就可以，tomcat运行时会自动解压出文件夹 如果将war包删除，解压出的文件夹也会自动删除 在宝塔文件管理的上方打开宝塔终端，cd进入tomcat的bin目录，图片中的目录是默认安装目录之后使用./catalina.sh start启动tomcat，刚刚上传的war包就会自动解压 部署成功后，在浏览器输入域名:8080就可以访问tomcat首页，按照自己项目访问路径就可以访问自己的项目","path":"page/server.html","date":"04-05","excerpt":"","tags":[{"name":"企业常用技术","slug":"企业常用技术","permalink":"http://xiaoliblog.cn/tags/%E4%BC%81%E4%B8%9A%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF/"}]},{"title":"SpringMVC🍃前后端数据校验","text":"一般来说，数据校验由前端jQuery校验，服务端JSR303校验和数据库的约束，这三层共同组成 jQuery前端校验 jQuery Validate 插件提供了强大的表单验证功能，能够让客户端表单验证变得更简单，同时它还提供了大量的可定制化选项，以满足应用程序的各种需求。该插件捆绑了一套非常有用的验证方法，包括 URL 和电子邮件验证，同时也提供了API允许用户自定义校验方法。提供的所有捆绑方法默认使用英语作为错误信息，且已翻译成其他 37 种语言 官方网站：https://jqueryvalidation.org/ Github项目地址：https://github.com/jquery-validation/jquery-validation 导入JS库 可以通过下载1.19.0版本到本地进行引入 1234&lt;script src=&quot;jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;jquery.validate.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;additional-methods.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;messages_zh.min.js&quot;&gt;&lt;/script&gt; 在web项目中使用&lt;%=request.getContextPath() %&gt;作为根目录 或者使用使用菜鸟教程提供的CDN引入 123&lt;script src=&quot;http://static.runoob.com/assets/jquery-validation-1.14.0/lib/jquery.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;http://static.runoob.com/assets/jquery-validation-1.14.0/dist/jquery.validate.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;http://static.runoob.com/assets/jquery-validation-1.14.0/dist/localization/messages_zh.js&quot;&gt;&lt;/script&gt; 默认校验规则 规则 描述 required:true 必须输入的字段 remote:&quot;remote-valid.jsp&quot; 使用 ajax 方法调用 remote-valid.jsp 验证输入值 email:true 必须输入正确格式的电子邮件 url:true 必须输入正确格式的网址 date:true 必须输入正确格式的日期。日期校验 ie6 出错，慎用 dateISO:true 必须输入正确格式的日期（ISO），例如：2009-06-23，1998/01/22。只验证格式，不验证有效性 number:true 必须输入合法的数字（负数，小数） digits:true 必须输入整数 creditcard: 必须输入合法的信用卡号 equalTo:&quot;#password&quot; 输入值必须和 password 相同 accept: 输入拥有合法后缀名的字符串（上传文件的后缀） maxlength:5 输入长度最多是 5 的字符串（汉字算一个字符） minlength:10 输入长度最小是 10 的字符串（汉字算一个字符） rangelength:[5,10] 输入长度必须介于 5 和 10 之间的字符串（汉字算一个字符） range:[5,10] 输入值必须介于 5 和 10 之间 max:5 输入值不能大于 5 min:10 输入值不能小于 10 默认提示 jQuery Validate提供了中文信息提示包，位于下载包的下载/dist/localization/messages_zh.min.js中，内容如下 12345678910111213141516171819202122232425262728293031323334/*! jQuery Validation Plugin - v1.19.0 - 11/28/2018 * https://jqueryvalidation.org/ * Copyright (c) 2018 Jörn Zaefferer; Licensed MIT */!(function (a) &#123; &quot;function&quot; == typeof define &amp;&amp; define.amd ? define([&quot;jquery&quot;, &quot;../jquery.validate.min&quot;], a) : &quot;object&quot; == typeof module &amp;&amp; module.exports ? (module.exports = a(require(&quot;jquery&quot;))) : a(jQuery);&#125;)(function (a) &#123; return ( a.extend(a.validator.messages, &#123; required: &quot;这是必填字段&quot;, remote: &quot;请修正此字段&quot;, email: &quot;请输入有效的电子邮件地址&quot;, url: &quot;请输入有效的网址&quot;, date: &quot;请输入有效的日期&quot;, dateISO: &quot;请输入有效的日期 (YYYY-MM-DD)&quot;, number: &quot;请输入有效的数字&quot;, digits: &quot;只能输入数字&quot;, creditcard: &quot;请输入有效的信用卡号码&quot;, equalTo: &quot;你的输入不相同&quot;, extension: &quot;请输入有效的后缀&quot;, maxlength: a.validator.format(&quot;最多可以输入 &#123;0&#125; 个字符&quot;), minlength: a.validator.format(&quot;最少要输入 &#123;0&#125; 个字符&quot;), rangelength: a.validator.format(&quot;请输入长度在 &#123;0&#125; 到 &#123;1&#125; 之间的字符串&quot;), range: a.validator.format(&quot;请输入范围在 &#123;0&#125; 到 &#123;1&#125; 之间的数值&quot;), step: a.validator.format(&quot;请输入 &#123;0&#125; 的整数倍值&quot;), max: a.validator.format(&quot;请输入不大于 &#123;0&#125; 的数值&quot;), min: a.validator.format(&quot;请输入不小于 &#123;0&#125; 的数值&quot;), &#125;), a );&#125;); 可以将该本地化信息文件 dist/localization/messages_zh.js 引入到页面： 1&lt;script src=&quot;http://static.runoob.com/assets/jquery-validation-1.14.0/dist/localization/messages_zh.js&quot;&gt;&lt;/script&gt; 使用方式 参考菜鸟教程：https://www.runoob.com/jquery/jquery-plugin-validate.html 首先给表单一个ID值，在JS中调用validate()方法，参数为键值对对象 1234567&lt;form action=&quot;#&quot; id=&quot;r-form&quot;&gt; &lt;h1&gt;注册&lt;/h1&gt; &lt;p&gt;用户名：&lt;input name=&quot;username&quot; type=&quot;text&quot; placeholder=&quot;昵称&quot;&gt;&lt;/p&gt; &lt;p&gt;电子邮箱：&lt;input name=&quot;email&quot; type=&quot;email&quot; placeholder=&quot;电子邮箱&quot;&gt;&lt;/p&gt; &lt;p&gt;密码：&lt;input name=&quot;password&quot; type=&quot;password&quot; placeholder=&quot;密码&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;/button&gt;&lt;button id=&quot;btn-register&quot;&gt;注册&lt;/button&gt;&lt;/p&gt;&lt;/form&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243 //$().ready(function()&#123;&#125;) 页面加载完成就调用函数$().ready(function()&#123; // 在键盘按下并释放及提交后验证提交表单 $(&quot;#r-form&quot;).validate(&#123; rules: &#123; //指定规则 username: &#123; required: true, minlength: 2, maxlength: 6, usernameCheck: true, //usernameCheck为自己制定校验规则的一个函数 &#125;, email: &#123; required: true, email: true &#125;, password: &#123; required: true, minlength: 5 &#125; &#125;, messages: &#123; //回复信息 username:&#123; required: &quot;请输入用户名&quot;, minlength:&quot;用户名必须有两个字符组成&quot;, maxlength:&quot;用户名最大长度为六个字符&quot; &#125;, email:&#123; required: &quot;请输入邮箱地址&quot;, email:&quot;请输入一个正确的邮箱&quot; &#125;, password: &#123; required: &quot;请输入密码&quot;, minlength: &quot;密码长度不能小于 5 个字符&quot; &#125; &#125; &#125;);&#125;)//自定义验证规则jQuery.validator.addMethod(&quot;usernameCheck&quot;, function (value, element) &#123; var regExpStr = /^[\\u4E00-\\u9FA5A-Za-z0-9]+$/; return regExpStr.test(value);&#125;, &quot;昵称只支持中文、英文、数字&quot;); 发送ajax123456789101112131415161718192021 $().ready(function () &#123; // 在键盘按下并释放及提交后验证提交表单 $(&quot;#r-form&quot;).validate(&#123; submitHandler:function()&#123; $.ajax(&#123; url:&quot;http://localhost:8080/register&quot;, type:&quot;post&quot;, data:&#123; username: $(&quot;#r-username&quot;).val(), email:$(&quot;#r-email&quot;).val(), password:$(&quot;#r-password&quot;).val() &#125;, success:function(result)&#123; &#125; &#125;) //注意当注册的&lt;button&gt;&lt;/button&gt;未指定type时表单会默认提交,所以这里要return false; return false; &#125; &#125;)&#125; JSR303后端校验 JSR是Java Specification Requests的缩写，意思是Java 规范提案。是指向JCP(Java Community Process)提出新增一个标准化技术规范的正式请求。任何人都可以提交JSR，以向Java平台增添新的API和服务。JSR已成为Java界的一个重要标准 导入依赖12345678910111213&lt;!--JSR303数据校验支持；tomcat7及以上的服务器--&gt;&lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-validator --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.4.1.Final&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/javax.validation/validation-api --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.validation&lt;/groupId&gt; &lt;artifactId&gt;validation-api&lt;/artifactId&gt; &lt;version&gt;2.0.1.Final&lt;/version&gt;&lt;/dependency&gt; 校验规则 Bean Validation 中内置的 constraint Constraint 详细信息 @Null 被注释的元素必须为 null @NotNull 被注释的元素必须不为 null @AssertTrue 被注释的元素必须为 true @AssertFalse 被注释的元素必须为 false @Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @Size(max, min) 被注释的元素的大小必须在指定的范围内 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内 @Past 被注释的元素必须是一个过去的日期 @Future 被注释的元素必须是一个将来的日期 @Pattern(value) 被注释的元素必须符合指定的正则表达式 Hibernate Validator 附加的 constraint Constraint 详细信息 @Email 被注释的元素必须是电子邮箱地址 @Length 被注释的字符串的大小必须在指定的范围内 @NotEmpty 被注释的字符串的必须非空 @Range 被注释的元素必须在合适的范围内 实例Demo 在一个实体类上加验证 12345678910111213141516171819202122232425262728293031package com.bytebeats.codelab.bean.validation.model; import org.hibernate.validator.constraints.Email;import org.hibernate.validator.constraints.NotEmpty; import javax.validation.constraints.NotNull;import javax.validation.constraints.Size;import java.util.Date; public class Order &#123; @NotNull(message = &quot;orderId必须不为null&quot;) @Size(min = 10, max = 10) private String orderId; @NotEmpty(message = &quot;customer须不为空&quot;) private String customer; @Email(message = &quot;email必须是一个电子信箱地址&quot;) private String email; @NotEmpty(message = &quot;address必须不为空&quot;) private String address; @NotNull(message = &quot;status必须不为 null&quot;) private String status; @NotNull(message = &quot;createDate必须不为 null&quot;) private Date createDate; //getter and setter&#125; 测试类，调用JSR303验证工具，校验参数 1234567891011121314Validator validator = Validation.buildDefaultValidatorFactory().getValidator(); Order order = new Order();order.setOrderId(&quot;12345&quot;);order.setCustomer(&quot;ricky&quot;);order.setEmail(&quot;ricky&quot;);order.setAddress(&quot;北京市朝阳区&quot;);order.setStatus(&quot;DELV&quot;);order.setCreateDate(new Date()); Set&lt;ConstraintViolation&lt;Order&gt;&gt; violations = validator.validate(order);for(ConstraintViolation&lt;Order&gt; violation: violations) &#123; System.out.println(violation.getPropertyPath()+&quot;\\t&quot;+ violation.getMessage());&#125; 运行结果 12orderId 个数必须在10和10之间email email必须是一个电子信箱地址","path":"page/SpringMVC09.html","date":"04-05","excerpt":"","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://xiaoliblog.cn/tags/SpringMVC/"}]},{"title":"SpringMVC🍃SSM整合案例","text":"环境搭建数据库 创建一个存放书籍的数据库 123456789101112131415161718CREATE DATABASE `ssmbuild`;USE `ssmbuild`;DROP TABLE IF EXISTS `books`;CREATE TABLE `books` ( `bookID` INT(10) NOT NULL AUTO_INCREMENT COMMENT &#x27;书id&#x27;, `bookName` VARCHAR(100) NOT NULL COMMENT &#x27;书名&#x27;, `bookCounts` INT(11) NOT NULL COMMENT &#x27;数量&#x27;, `detail` VARCHAR(200) NOT NULL COMMENT &#x27;描述&#x27;, KEY `bookID` (`bookID`)) ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO `books`(`bookID`,`bookName`,`bookCounts`,`detail`)VALUES (1,&#x27;Java&#x27;,1,&#x27;从入门到放弃&#x27;),(2,&#x27;MySQL&#x27;,10,&#x27;从删库到跑路&#x27;),(3,&#x27;Linux&#x27;,5,&#x27;从进门到进牢&#x27;); 相关依赖 新建一个Maven项目，添加web支持 在父工程导入相关的pom依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;dependencies&gt; &lt;!--Junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;!--数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Servlet - JSP --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--Spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.3.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;org.springframework.beans&lt;/artifactId&gt; &lt;version&gt;3.1.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--aop织入--&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.20&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Maven资源过滤设置 1234567891011121314151617181920&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 开发插件 MybatisCodeHelperPro Mybatis plugin 配置结构框架 com.lzy.pojo 实体类 com.lzy.dao dao接口 com.lzy.service 业务层 om.lzy.controller 控制层 mybatis-config.xml配置文件 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;&lt;/configuration&gt; applicationContext.xml配置文件 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt; MyBatis层数据库连接 数据库配置文件 database.properties 12345# 如果使用的是MySQL8.0+,还需要设置时区 &amp;serverTimezone=Asia/Shanghaijdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ssmbuild?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghaijdbc.username=rootjdbc.password=root IDEA关联数据库 MyBatis配置文件 编写MyBatis核心配置文件 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.lzy.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/lzy/dao/BookMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 写SQL时没有自动提示，解决方法参考：https://blog.csdn.net/qq_37975919/article/details/113763242 Dao层 编写数据库对应的实体类 com.lzy.pojo.Books 使用lombok插件！ 123456789101112131415package com.lzy.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class Books &#123; private int bookID; private String bookName; private int bookCounts; private String detail;&#125; 编写Dao层的Mapper接口 1234567891011121314151617181920212223package com.lzy.dao;import com.lzy.pojo.Books;import org.apache.ibatis.annotations.Param;import java.util.List;public interface BookMapper &#123; //增加一本书 int addBook(Books books); //删除一本书 int deleteBookById(@Param(&quot;bookID&quot;) int id); //更新一本书 int updateBook(Books books); //查询一本书 Books queryBookById(@Param(&quot;bookID&quot;) int id); //查询全部的书 List&lt;Books&gt; queryAllBook();&#125; 编写接口对应的 Mapper.xml 文件。需要导入MyBatis的包； 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.lzy.dao.BookMapper&quot;&gt; &lt;!--增加一个Book--&gt; &lt;insert id=&quot;addBook&quot; parameterType=&quot;Books&quot;&gt; insert into ssmbuild.books(bookName, bookCounts, detail) values (#&#123;bookName&#125;,#&#123;bookCounts&#125;,#&#123;detail&#125;) &lt;/insert&gt; &lt;!--删除一本书--&gt; &lt;delete id=&quot;deleteBookById&quot; parameterType=&quot;int&quot;&gt; delete from ssmbuild.books where bookID = #&#123;bookID&#125; &lt;/delete&gt; &lt;!--更新一本书--&gt; &lt;update id=&quot;updateBook&quot; parameterType=&quot;Books&quot;&gt; update ssmbuild.books set bookName = #&#123;bookName&#125;, bookCounts = #&#123;bookCounts&#125;, detail=#&#123;detail&#125; where bookID = #&#123;bookID&#125; &lt;/update&gt; &lt;!--查询一本书--&gt; &lt;select id=&quot;queryBookById&quot; resultType=&quot;Books&quot;&gt; select * from ssmbuild.books where bookID = #&#123;bookID&#125; &lt;/select&gt; &lt;!--查询全部--&gt; &lt;select id=&quot;queryAllBook&quot; resultType=&quot;Books&quot;&gt; select * from ssmbuild.books &lt;/select&gt;&lt;/mapper&gt; Service层 编写Service层的接口 123456789101112131415161718192021222324package com.lzy.service;import com.lzy.pojo.Books;import java.util.List;public interface BookService &#123; //增加一本书 int addBook(Books books); //删除一本书 int deleteBookById(int id); //更新一本书 int updateBook(Books books); //查询一本书 Books queryBookById(int id); //查询全部的书 List&lt;Books&gt; queryAllBook();&#125; 编写Service层的实现类 1234567891011121314151617181920212223242526272829303132333435363738package com.lzy.service;import com.lzy.dao.BookMapper;import com.lzy.pojo.Books;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;public class BookServiceImpl implements BookService &#123; //service层调Dao层,组合进来,BookMapper就是BookDao private BookMapper bookMapper; @Override public int addBook(Books books) &#123; return this.bookMapper.addBook(books); &#125; @Override public int deleteBookById(int id) &#123; return this.bookMapper.deleteBookById(id); &#125; @Override public int updateBook(Books books) &#123; return this.bookMapper.updateBook(books); &#125; @Override public Books queryBookById(int id) &#123; return this.bookMapper.queryBookById(id); &#125; @Override public List&lt;Books&gt; queryAllBook() &#123; return this.bookMapper.queryAllBook(); &#125;&#125; Spring层配置数据库连接 配置Spring整合MyBatis，我们这里数据源使用c3p0连接池； 去编写Spring整合Mybatis的相关的配置文件；创建 spring-dao.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 1.关联数据库配置文件--&gt; &lt;context:property-placeholder location=&quot;classpath:database.properties&quot;/&gt; &lt;!-- 2.数据库连接池 dbcp：半自动化操作，不能自动连接 cp30：自动化操作（自动化加载配置文件，并且可以自动设置到对象中！） --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;!-- c3p0连接池的私有属性 --&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt; &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;/&gt; &lt;!--关闭连接后不自动commit--&gt; &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt; &lt;!--获取连接超时时间--&gt; &lt;property name=&quot;checkoutTimeout&quot; value=&quot;10000&quot;/&gt; &lt;!--当获取连接失败重试次数--&gt; &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;/&gt; &lt;/bean&gt; &lt;!-- 3. sqlSessionFactory--&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!--绑定mybatis配置文件--&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;/bean&gt; &lt;!--配置dao接口扫描包,动态的实现了dao接口可以注入到Spring容器中--&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!--注入sqlSessionFactory--&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; &lt;!--要扫描的dao包--&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.lzy.dao&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 整合service层 编写spring-Service.xml 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;import resource=&quot;classpath:spring-dao.xml&quot;/&gt; &lt;!--1.扫描service下的包--&gt; &lt;context:component-scan base-package=&quot;com.lzy.service&quot;/&gt; &lt;!--2.将我们的所有业务类注入到Spring中，可以通过配置，或者注解--&gt; &lt;bean id=&quot;BookServiceImpl&quot; class=&quot;com.lzy.service.BookServiceImpl&quot;&gt; &lt;property name=&quot;bookMapper&quot; ref=&quot;bookMapper&quot;/&gt; &lt;/bean&gt; &lt;!--3. 声明式事务配置--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!--注入数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; SpringMVC层配置web.xml123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!--此处放的整合的配置文件--&gt; &lt;param-value&gt;classpath:applicationCotext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--encodingFilter--&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt; org.springframework.web.filter.CharacterEncodingFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--Session过期时间 15分钟--&gt; &lt;session-config&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt; &lt;/session-config&gt;&lt;/web-app&gt; spring-mvc.xml配置 创建spring-mvc.xml配置文件，并在WEB-INF下创建jsp文件夹 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--1.注解驱动--&gt; &lt;mvc:annotation-driven/&gt; &lt;!--2.静态资源过滤--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--扫描包--&gt; &lt;context:component-scan base-package=&quot;com.lzy.controller&quot;/&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 配置整合文件 在applicationContext.xml中导入整合配置文件 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;import resource=&quot;spring-dao.xml&quot;/&gt; &lt;import resource=&quot;spring-Service.xml&quot;/&gt; &lt;import resource=&quot;spring-mvc.xml&quot;/&gt;&lt;/beans&gt; Controller 和视图层查询书籍 BoBookokController 类编写 ， 方法一：查询全部书籍 123456789101112131415@Controller@RequestMapping(&quot;/book&quot;)public class BookController &#123; @Autowired @Qualifier(&quot;BookServiceImpl&quot;) private BookService bookService; @RequestMapping(&quot;/allBook&quot;) public String list(Model model) &#123; List&lt;Books&gt; list = bookService.queryAllBook(); model.addAttribute(&quot;list&quot;, list); return &quot;allBook&quot;; &#125;&#125; 编写首页index.js 1234567891011121314151617181920212223242526272829&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; %&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;首页&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; a &#123; text-decoration: none; color: black; font-size: 18px; &#125; h3 &#123; width: 180px; height: 38px; margin: 100px auto; text-align: center; line-height: 38px; background: deepskyblue; border-radius: 4px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/book/allBook&quot;&gt;点击进入列表页&lt;/a&gt;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 书籍列表页面 allBook.jsp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;书籍列表&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;!-- 引入 Bootstrap --&gt; &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row clearfix&quot;&gt; &lt;div class=&quot;col-md-12 column&quot;&gt; &lt;div class=&quot;page-header&quot;&gt; &lt;h1&gt; &lt;small&gt;书籍列表 —— 显示所有书籍&lt;/small&gt; &lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-4 column&quot;&gt; &lt;a class=&quot;btn btn-primary&quot; href=&quot;$&#123;pageContext.request.contextPath&#125;/book/toAddBook&quot;&gt;新增&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row clearfix&quot;&gt; &lt;div class=&quot;col-md-12 column&quot;&gt; &lt;table class=&quot;table table-hover table-striped&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;书籍编号&lt;/th&gt; &lt;th&gt;书籍名字&lt;/th&gt; &lt;th&gt;书籍数量&lt;/th&gt; &lt;th&gt;书籍详情&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;c:forEach var=&quot;book&quot; items=&quot;$&#123;requestScope.get(&#x27;list&#x27;)&#125;&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;book.getBookID()&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.getBookName()&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.getBookCounts()&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.getDetail()&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/book/toUpdateBook?id=$&#123;book.getBookID()&#125;&quot;&gt;更改&lt;/a&gt; | &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/book/del/$&#123;book.getBookID()&#125;&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 添加书籍 BookController 类编写 ， 方法二：添加书籍 1234567891011@RequestMapping(&quot;/toAddBook&quot;)public String toAddPaper() &#123; return &quot;addBook&quot;;&#125;@RequestMapping(&quot;/addBook&quot;)public String addPaper(Books books) &#123; System.out.println(books); bookService.addBook(books); return &quot;redirect:/book/allBook&quot;;&#125; 添加书籍页面：addBook.jsp 123456789101112131415161718192021222324252627282930&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;新增书籍&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;!-- 引入 Bootstrap --&gt; &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row clearfix&quot;&gt; &lt;div class=&quot;col-md-12 column&quot;&gt; &lt;div class=&quot;page-header&quot;&gt; &lt;h1&gt; &lt;small&gt;新增书籍&lt;/small&gt; &lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/book/addBook&quot; method=&quot;post&quot;&gt; 书籍名称：&lt;input type=&quot;text&quot; name=&quot;bookName&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; 书籍数量：&lt;input type=&quot;text&quot; name=&quot;bookCounts&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; 书籍详情：&lt;input type=&quot;text&quot; name=&quot;detail&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;添加&quot;&gt; &lt;/form&gt;&lt;/div&gt; 修改书籍 BookController 类编写 ， 方法三：修改书籍 12345678910111213141516@RequestMapping(&quot;/toUpdateBook&quot;)public String toUpdateBook(Model model, int id) &#123; Books books = bookService.queryBookById(id); System.out.println(books); model.addAttribute(&quot;book&quot;,books ); return &quot;updateBook&quot;;&#125;@RequestMapping(&quot;/updateBook&quot;)public String updateBook(Model model, Books book) &#123; System.out.println(book); bookService.updateBook(book); Books books = bookService.queryBookById(book.getBookID()); model.addAttribute(&quot;books&quot;, books); return &quot;redirect:/book/allBook&quot;;&#125; 修改书籍页面 updateBook.jsp 12345678910111213141516171819202122232425262728293031&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;修改信息&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;!-- 引入 Bootstrap --&gt; &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row clearfix&quot;&gt; &lt;div class=&quot;col-md-12 column&quot;&gt; &lt;div class=&quot;page-header&quot;&gt; &lt;h1&gt; &lt;small&gt;修改信息&lt;/small&gt; &lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/book/updateBook&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;bookID&quot; value=&quot;$&#123;book.getBookID()&#125;&quot;/&gt; 书籍名称：&lt;input type=&quot;text&quot; name=&quot;bookName&quot; value=&quot;$&#123;book.getBookName()&#125;&quot;/&gt; 书籍数量：&lt;input type=&quot;text&quot; name=&quot;bookCounts&quot; value=&quot;$&#123;book.getBookCounts()&#125;&quot;/&gt; 书籍详情：&lt;input type=&quot;text&quot; name=&quot;detail&quot; value=&quot;$&#123;book.getDetail() &#125;&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt; &lt;/form&gt;&lt;/div&gt; 删除书籍12345@RequestMapping(&quot;/del/&#123;bookId&#125;&quot;)public String deleteBook(@PathVariable(&quot;bookId&quot;) int id) &#123; bookService.deleteBookById(id); return &quot;redirect:/book/allBook&quot;;&#125;","path":"page/SpringMVC10.html","date":"04-04","excerpt":"","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://xiaoliblog.cn/tags/SpringMVC/"}]},{"title":"SpringMVC🍃文件上传下载","text":"准备工作 文件上传是项目开发中最常见的功能之一 ，springMVC 可以很好的支持文件上传，但是SpringMVC上下文中默认没有装配MultipartResolver，因此默认情况下其不能处理文件上传工作。如果想使用Spring的文件上传功能，则需要在上下文中配置MultipartResolver。 前端表单要求：为了能上传文件，必须将表单的method设置为POST，并将enctype设置为multipart/form-data。只有在这样的情况下，浏览器才会把用户选择的文件以二进制数据发送给服务器； 对表单中的 enctype 属性做个详细的说明： application/x-www=form-urlencoded：默认方式，只处理表单域中的 value 属性值，采用这种编码方式的表单会将表单域中的值处理成 URL 编码方式 multipart/form-data：这种编码方式会以二进制流的方式来处理表单数据，这种编码方式会把文件域指定文件的内容也封装到请求参数中，不会对字符编码 text/plain：除了把空格转换为 “+” 号外，其他字符都不做编码处理，这种方式适用直接通过表单发送邮件 1234&lt;form action=&quot;&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 一旦设置了enctype为multipart/form-data，浏览器即会采用二进制流的方式来处理表单数据，而对于文件上传的处理则涉及在服务器端解析原始的HTTP响应。在2003年，Apache Software Foundation发布了开源的Commons FileUpload组件，其很快成为Servlet/JSP程序员上传文件的最佳选择 Servlet3.0规范已经提供方法来处理文件上传，但这种上传需要在Servlet中完成 而Spring MVC则提供了更简单的封装 Spring MVC为文件上传提供了直接的支持，这种支持是用即插即用的MultipartResolver实现的 Spring MVC使用Apache Commons FileUpload技术实现了一个MultipartResolver实现类 CommonsMultipartResolver。因此，SpringMVC的文件上传还需要依赖Apache Commons FileUpload的组件 文件上传导入jar包 导入文件上传的jar包，commons-fileupload ， Maven会自动帮我们导入他的依赖包 commons-io包； 需要导入高版本的Servlet-api 123456789101112&lt;!--文件上传--&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.3&lt;/version&gt;&lt;/dependency&gt;&lt;!--servlet-api导入高版本的--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt;&lt;/dependency&gt; 配置Bean 在springmvc-servlet.xml配置bean：multipartResolver 注意，这个bena的id必须为：multipartResolver ， 否则上传文件会报400的错误！ 12345678&lt;!--文件上传配置--&gt;&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;/&gt; &lt;!-- 上传文件大小上限，单位为字节（10485760=10M） --&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760&quot;/&gt; &lt;property name=&quot;maxInMemorySize&quot; value=&quot;40960&quot;/&gt;&lt;/bean&gt; 编写前端页面 12345678&lt;html&gt;&lt;body&gt;&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/upload&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;upload&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; Controller CommonsMultipartFile的常用方法 说明 String getOriginalFilename() 获取上传文件的原名 InputStream getInputStream() 获取文件流 void transferTo(File dest) 将上传文件保存到一个目录文件中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.lzy.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.multipart.commons.CommonsMultipartFile;import javax.servlet.http.HttpServletRequest;import java.io.*;@RestControllerpublic class FileController &#123; //@RequestParam(&quot;file&quot;) 将name=file控件得到的文件封装成CommonsMultipartFile 对象 //批量上传CommonsMultipartFile则为数组即可 @RequestMapping(&quot;/upload&quot;) public String fileUpload(@RequestParam(&quot;file&quot;) CommonsMultipartFile file , HttpServletRequest request) throws IOException &#123; //获取文件名 : file.getOriginalFilename(); String uploadFileName = file.getOriginalFilename(); //如果文件名为空，直接回到首页！ if (&quot;&quot;.equals(uploadFileName))&#123; return &quot;redirect:/index.jsp&quot;; &#125; System.out.println(&quot;上传文件名 : &quot;+uploadFileName); //上传路径保存设置,导入高版本Servlet依赖 String path = request.getServletContext().getRealPath(&quot;/upload&quot;); //如果路径不存在，创建一个 File realPath = new File(path); if (!realPath.exists())&#123; realPath.mkdir(); &#125; System.out.println(&quot;上传文件保存地址：&quot;+realPath); InputStream is = file.getInputStream(); //文件输入流 OutputStream os = new FileOutputStream(new File(realPath,uploadFileName)); //文件输出流 //读取写出 int len=0; byte[] buffer = new byte[1024]; while ((len=is.read(buffer))!=-1)&#123; os.write(buffer,0,len); os.flush(); &#125; os.close(); is.close(); return &quot;redirect:/index.jsp&quot;; &#125;&#125; 运行结果，可以看到文件上传的路径 运行出错，不一定是代码的问题，也有可能是jar导入不成功 文件下载 文件下载步骤： 设置 Response 响应头 读取文件 – InputStream 写出文件 – OutputStream 执行操作 关闭流 （先开后关） 12345678910111213141516171819202122232425262728293031@RequestMapping(value=&quot;/download&quot;)public String downloads(HttpServletResponse response ,HttpServletRequest request) throws Exception&#123; //要下载的图片地址 String path = request.getServletContext().getRealPath(&quot;/upload&quot;); String fileName = &quot;基础语法.jpg&quot;; //1、设置response 响应头 response.reset(); //设置页面不缓存,清空buffer response.setCharacterEncoding(&quot;UTF-8&quot;); //字符编码 response.setContentType(&quot;multipart/form-data&quot;); //二进制传输数据 //设置响应头 response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;fileName=&quot;+URLEncoder.encode(fileName, &quot;UTF-8&quot;)); File file = new File(path,fileName); //2、 读取文件--输入流 InputStream input=new FileInputStream(file); //3、 写出文件--输出流 OutputStream out = response.getOutputStream(); byte[] buff =new byte[1024]; int index=0; //4、执行 写出操作 while((index= input.read(buff))!= -1)&#123; out.write(buff, 0, index); out.flush(); &#125; out.close(); input.close(); return null;&#125; 前端 1&lt;a href=&quot;/download&quot;&gt;点击下载&lt;/a&gt;","path":"page/SpringMVC08.html","date":"04-04","excerpt":"","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://xiaoliblog.cn/tags/SpringMVC/"}]},{"title":"SpringMVC🍃拦截器实现","text":"拦截器 SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter，用于对处理器进行预处理和后处理。开发者可以自己定义一些拦截器来实现特定的功能。 过滤器与拦截器的区别：拦截器是AOP思想的具体应用 过滤器 Servlet规范中的一部分，任何java web工程都可以使用 在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截 拦截器 拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能使用 拦截器只会拦截访问的控制器方法， 如果访问的是jsp/html/css/image/js是不会进行拦截的 自定义拦截器 想要自定义拦截器，必须实现 HandlerInterceptor 接口 搭建SpringMVC环境 新建一个Moudule ，并 添加web支持 配置web.xml 和 springmvc-servlet.xml 文件 编写一个拦截器 编写一个拦截器MyInterceptor 123456789101112131415161718192021222324252627282930313233package com.lzy.interceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class MyInterceptor implements HandlerInterceptor &#123; //在请求处理的方法之前执行 //如果返回true执行下一个拦截器 //如果返回false就不执行下一个拦截器 @Override public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123; System.out.println(&quot;------------处理前------------&quot;); return true; &#125; //在请求处理方法执行之后执行 @Override public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;------------处理后------------&quot;); &#125; //在dispatcherServlet处理后执行,做清理工作. @Override public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123; System.out.println(&quot;------------清理------------&quot;); &#125;&#125; 在springmvc-servlet.xml的配置文件中配置拦截器 1234567891011&lt;!--关于拦截器的配置--&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--/** 包括路径及其子路径--&gt; &lt;!--/admin/* 拦截的是/admin/add等等这种 , /admin/add/user不会被拦截--&gt; &lt;!--/admin/** 拦截的是/admin/下的所有--&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;!--bean配置的就是拦截器--&gt; &lt;bean class=&quot;com.lzy.interceptor.MyInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 编写一个Controller，接收请求 1234567891011121314package com.lzy.controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;//测试拦截器的控制器@RestControllerpublic class InterceptorController &#123; @GetMapping(&quot;/t1&quot;) public String testFunction() &#123; System.out.println(&quot;InterceptorController控制器中的方法执行了&quot;); return &quot;OK&quot;; &#125;&#125; 前端index.jsp 12345678&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;html&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;body&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/t1&quot;&gt;拦截器测试&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 登录判断验证 有一个登陆页面，需要写一个controller访问页面。 登陆页面有一提交表单的动作。需要在controller中处理。判断用户名密码是否正确。如果正确，向session中写入用户信息。返回登陆成功。 拦截用户请求，判断用户是否登陆。如果用户已经登陆。放行， 如果用户未登陆，跳转到登陆页面 项目结构 前端页面 由于在WEB-INF下的所有页面或者资源不能直接访问，需要通过index.jsp作为入口 1234567891011121314&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;需求:未登录不能进入首页&lt;/h1&gt;&lt;hr&gt;&lt;%--在WEB-INF下的所有页面或者资源不能直接访问,所有通过index.jsp作为入口--%&gt;&lt;%--请求响应给LoginContoller控制器,gologin和main为@RequestMapping值--%&gt;&lt;h1&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/gologin&quot;&gt;登录&lt;/a&gt;&lt;/h1&gt;&lt;h1&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/main&quot;&gt;首页&lt;/a&gt;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 在jsp/下编写一个登陆页面 login.jsp 1234567891011121314151617181920&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;h1&gt;登录页面&lt;/h1&gt;&lt;hr&gt;&lt;body&gt;&lt;%-- 在WEB-INF下的所有页面或者资源,只能通过Controller,或者Servlet进行访问--%&gt;&lt;%--表单请求提交到控制器,logon为@RequestMapping值--%&gt;&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/user/login&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;br&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 在jsp/下编写一个主页面 main.jsp 123456789101112131415&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;首页&lt;/h3&gt;&lt;span&gt;用户名:$&#123;username&#125;&lt;/span&gt;&lt;p&gt; &lt;!--注销请求发送到控制器,且@RequestMapping参数值为goOut进行处理--&gt; &lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;/user/logout&quot;&gt;注销&lt;/a&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 控制器 编写一个Controller处理请求 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.lzy.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.http.HttpSession;@Controller//取一个父路径,即所有请求都在/user@RequestMapping(&quot;/user&quot;)public class LoginController &#123; //处理前端user/main请求转到首页 @RequestMapping(&quot;/main&quot;) public String main()&#123; //访问main.jsp return &quot;main&quot;; &#125; //处理前端user/gologin请求转到登录页面 @RequestMapping(&quot;/gologin&quot;) public String gologin()&#123; //访问login.jsp return &quot;login&quot;; &#125; //处理login.jsp登录的请求 @RequestMapping(&quot;/login&quot;) public String login(HttpSession session, String username, String password, Model model)&#123; //把用户信息存在session中 session.setAttribute(&quot;userloginInfo&quot;,username); //登录的用户名保存 model.addAttribute(&quot;username&quot;,username); //转到main.jsp return &quot;main&quot;; &#125; //注销退出登录 //注册main.jsp发送过来的注销请求 @RequestMapping(&quot;/logout&quot;) public String logout(HttpSession session)&#123; //移除sessionID属性 session.removeAttribute(&quot;userloginInfo&quot;); //转到login.jsp return &quot;login&quot;; &#125;&#125; 拦截器 首先配置web.xml注册控制器 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--1.注册servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动顺序，数字越小，启动越早 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--所有请求都会被springmvc拦截 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 编写用户登录拦截器 123456789101112131415161718192021222324252627282930313233package com.lzy.interceptor;import org.springframework.web.servlet.HandlerInterceptor;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;public class LoginInterceptor implements HandlerInterceptor &#123; //如果返回true执行下一个拦截器放行 //如果返回false就不执行下一个拦截器不放行 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; HttpSession session = request.getSession(); //放行:判断什么情况下没有登录 //路径含有gologin说明是登录页面,也会放行 if(request.getRequestURI().contains(&quot;gologin&quot;))&#123; return true; &#125; //第一次登录没有session,需要对路径包含login放行,说明我在提交登录 if(request.getRequestURI().contains(&quot;login&quot;))&#123; return true; &#125; //第一次登录,也是没有session,如果sessionID不为空,说明是已登录用户,放行 if(session.getAttribute(&quot;userloginInfo&quot;)!=null)&#123; return true; &#125; //其他情况下即未登录用户不放行,让其转发的登录页面 request.getRequestDispatcher(&quot;/WEB-INF/jsp/login.jsp&quot;).forward(request,response); return false; &#125;&#125; 在Springmvc的配置文件中注册拦截器 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt; &lt;context:component-scan base-package=&quot;com.lzy.controller&quot;/&gt; &lt;!--静态资源过滤！！--&gt; &lt;mvc:default-servlet-handler /&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;!-- 后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; &lt;!--关于拦截器的配置--&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!--包括/user请求下面的所有请求,所以最好取一个父路径--&gt; &lt;mvc:mapping path=&quot;/user/**&quot;/&gt; &lt;bean id=&quot;loginInterceptor&quot; class=&quot;com.lzy.interceptor.LoginInterceptor&quot;/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt;&lt;/beans&gt; 运行结果可以发现注销后，再访问main.jsp直接跳到登录页面","path":"page/SpringMVC07.html","date":"04-04","excerpt":"","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://xiaoliblog.cn/tags/SpringMVC/"}]},{"title":"SpringMVC🍃Ajax异步交互","text":"Ajax简介 AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML） AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术 Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术 在 2005 年，Google 通过其 Google Suggest 使 AJAX 变得流行起来。Google Suggest能够自动帮你完成搜索单词 Google Suggest 使用 AJAX 创造出动态性极强的 web 界面：当您在谷歌的搜索框输入关键字时，JavaScript 会把这些字符发送到服务器，然后服务器会返回一个搜索建议的列表 传统的网页(即不用ajax技术的网页)，想要更新内容或者提交一个表单，都需要重新加载整个网页 使用ajax技术的网页，通过在后台服务器进行少量的数据交换，就可以实现异步局部更新 使用Ajax，用户可以创建接近本地桌面应用的直接、高可用、更丰富、更动态的Web用户界面 模拟Ajax 使用前端的一个iframe标签来伪造一个Ajax页面无刷新的样式 编写一个 ajax-frame.html 使用 iframe 测试，感受下url不变但能刷新网页 1234567891011121314151617181920212223242526272829303132333435&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; var myDate = new Date(); document.getElementById(&#x27;currentTime&#x27;).innerText = myDate.getTime(); &#125;; function LoadPage()&#123; var targetUrl = document.getElementById(&#x27;url&#x27;).value; console.log(targetUrl); document.getElementById(&quot;iframePosition&quot;).src = targetUrl; &#125;&lt;/script&gt;&lt;div&gt; &lt;p&gt;请输入要加载的地址：&lt;span id=&quot;currentTime&quot;&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt; &lt;input id=&quot;url&quot; type=&quot;text&quot; value=&quot;https://www.baidu.com/&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;提交&quot; onclick=&quot;LoadPage()&quot;&gt; &lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;h3&gt;加载页面位置：&lt;/h3&gt; &lt;iframe id=&quot;iframePosition&quot; style=&quot;width: 100%;height: 500px;&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; jQuery实现 Ajax的核心是XMLHttpRequest对象(XHR)。XHR为向服务器发送请求和解析服务器响应提供了接口。能够以异步方式从服务器获取新数据。 jQuery 提供多个与 AJAX 有关的方法。 通过 jQuery AJAX 方法，您能够使用 HTTP Get 和 HTTP Post 从远程服务器上请求文本、HTML、XML 或 JSON – 同时您能够把这些外部数据直接载入网页的被选元素中。 jQuery 不是生产者，而是大自然搬运工。 jQuery Ajax本质就是 XMLHttpRequest，对他进行了封装，方便调用！ jQuery下载地址：https://www.jq22.com/jquery-info122 123456789101112131415161718192021jQuery.ajax(...) 部分参数： url：请求地址 type：请求方式，GET、POST（1.9.0之后用method） headers：请求头 data：要发送的数据 contentType：即将发送信息至服务器的内容编码类型(默认: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;) async：是否异步 timeout：设置请求超时时间（毫秒） beforeSend：发送请求前执行的函数(全局) complete：完成之后执行的回调函数(全局) success：成功之后执行的回调函数(全局) error：失败之后执行的回调函数(全局) accepts：通过请求头发送给服务器，告诉服务器当前客户端可接受的数据类型 dataType：将服务器端返回的数据转换成指定类型 &quot;xml&quot;: 将服务器端返回的内容转换成xml格式 &quot;text&quot;: 将服务器端返回的内容转换成普通文本格式 &quot;html&quot;: 将服务器端返回的内容转换成普通文本格式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。 &quot;script&quot;: 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本格式 &quot;json&quot;: 将服务器端返回的内容转换成相应的JavaScript对象 &quot;jsonp&quot;: JSONP 格式使用 JSONP 形式调用函数时，如 &quot;myurl?callback=?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数 代码测试 配置web.xml 和 springmvc的配置文件【记得静态资源过滤和注解驱动配置上】 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt; &lt;context:component-scan base-package=&quot;com.lzy.controller&quot;/&gt; &lt;!--静态资源过滤！！--&gt; &lt;mvc:default-servlet-handler /&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;!-- 后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 编写一个AjaxController 1234567891011121314@Controllerpublic class AjaxController &#123; @RequestMapping(&quot;/a1&quot;) public void ajax1(String name , HttpServletResponse response) throws IOException &#123; // name对应的是Ajax里的data数据 System.out.println(&quot;a1:param=&gt;&quot;+name); if (&quot;admin&quot;.equals(name))&#123; response.getWriter().print(&quot;true&quot;); &#125;else&#123; response.getWriter().print(&quot;false&quot;); &#125; &#125;&#125; 在WEB-INF/static下存放jQuery本地文件，编写index.jsp测试 1234567891011121314151617181920212223242526272829&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;%--&lt;script src=&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt;--%&gt; &lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/static/jquery-3.5.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; function a1()&#123; &lt;!--post方式--&gt; $.post(&#123; url:&quot;$&#123;pageContext.request.contextPath&#125;/a1&quot;, &lt;!--取输入框的值--&gt; data:&#123;&#x27;name&#x27;:$(&quot;#txtName&quot;).val()&#125;, success:function (data,status) &#123; alert(data); alert(status); &#125; &#125;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;%--onblur：失去焦点触发事件,失去焦点就发送一个请求--%&gt;用户名:&lt;input type=&quot;text&quot; id=&quot;txtName&quot; onblur=&quot;a1()&quot;/&gt;&lt;/body&gt;&lt;/html&gt; 启动tomcat测试！打开浏览器的控制台，当我们鼠标离开输入框的时候，可以看到发出了一个ajax的请求！是后台返回给我们的结果！测试成功！ SpringMVC实现 编写实体类User 12345678910//需要导入lombok@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private String name; private int age; private String sex;&#125; 编写AjaxController用来获取一个集合对象，展示到前端页面 123456789101112@RestControllerpublic class AjaxController &#123; @RequestMapping(&quot;/a2&quot;) public List&lt;User&gt; ajax2()&#123; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(new User(&quot;小李1号&quot;,21,&quot;男&quot;)); list.add(new User(&quot;小李2号&quot;,22,&quot;男&quot;)); list.add(new User(&quot;小李3号&quot;,23,&quot;男&quot;)); return list; //由于@RestController注解，将list转成json格式返回 &#125;&#125; index.jsp前端页面 12345678910111213141516171819202122232425262728293031323334353637383940&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;获取数据&quot;/&gt;&lt;table width=&quot;80%&quot; align=&quot;center&quot;&gt; &lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt; &lt;/tr&gt; &lt;tbody id=&quot;content&quot;&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/static/jquery-3.5.1.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $(function () &#123; $(&quot;#btn&quot;).click(function () &#123; $.post(&quot;$&#123;pageContext.request.contextPath&#125;/a2&quot;,function (data) &#123; console.log(data) var html=&quot;&quot;; for (var i = 0; i &lt;data.length ; i++) &#123; html+= &quot;&lt;tr&gt;&quot; + &quot;&lt;td&gt;&quot; + data[i].name + &quot;&lt;/td&gt;&quot; + &quot;&lt;td&gt;&quot; + data[i].age + &quot;&lt;/td&gt;&quot; + &quot;&lt;td&gt;&quot; + data[i].sex + &quot;&lt;/td&gt;&quot; + &quot;&lt;/tr&gt;&quot; &#125; $(&quot;#content&quot;).html(html); &#125;); &#125;) &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 点击【获取数据】后，成功实现了数据回显！ 注册提示效果 一般用于注册时判断注册的用户名是否已存在！ 在SpringMVC的环境下，新建一个RegisterController类 12345678910111213141516171819202122232425@RestControllerpublic class RegisterController &#123; @RequestMapping(&quot;/a3&quot;) public String ajax(String name,String pwd)&#123; String msg = &quot;&quot;; //模拟数据库中存在数据 if (name!=null)&#123; //admin应该替换为数据库查找的结果 if (&quot;admin&quot;.equals(name))&#123; msg = &quot;OK&quot;; &#125;else &#123; msg = &quot;用户名输入错误&quot;; &#125; &#125; if (pwd!=null)&#123; if (&quot;123456&quot;.equals(pwd))&#123; msg = &quot;OK&quot;; &#125;else &#123; msg = &quot;密码输入有误&quot;; &#125; &#125; return msg; //由于@RestController注解，将msg转成json格式返回 &#125;&#125; 编写前端页面 Login.jsp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;ajax&lt;/title&gt; &lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/static/jquery-3.5.1.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; function a1()&#123; $.post(&#123; url:&quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;, &lt;!--取输入框的值--&gt; data:&#123;&#x27;name&#x27;:$(&quot;#name&quot;).val()&#125;, success:function (data) &#123; if (data.toString()==&#x27;OK&#x27;)&#123; $(&quot;#userInfo&quot;).css(&quot;color&quot;,&quot;green&quot;); &#125;else &#123; $(&quot;#userInfo&quot;).css(&quot;color&quot;,&quot;red&quot;); &#125; $(&quot;#userInfo&quot;).html(data); &#125; &#125;); &#125; function a2()&#123; $.post(&#123; url:&quot;$&#123;pageContext.request.contextPath&#125;/a3&quot;, &lt;!--取输入框的值--&gt; data:&#123;&#x27;pwd&#x27;:$(&quot;#pwd&quot;).val()&#125;, success:function (data) &#123; if (data.toString()==&#x27;OK&#x27;)&#123; $(&quot;#pwdInfo&quot;).css(&quot;color&quot;,&quot;green&quot;); &#125;else &#123; $(&quot;#pwdInfo&quot;).css(&quot;color&quot;,&quot;red&quot;); &#125; $(&quot;#pwdInfo&quot;).html(data); &#125; &#125;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt; 用户名:&lt;input type=&quot;text&quot; id=&quot;name&quot; onblur=&quot;a1()&quot;/&gt; &lt;span id=&quot;userInfo&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt; 密码:&lt;input type=&quot;text&quot; id=&quot;pwd&quot; onblur=&quot;a2()&quot;/&gt; &lt;span id=&quot;pwdInfo&quot;&gt;&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 【记得处理json乱码问题】，测试一下效果，动态请求响应，局部刷新 获取baidu接口Demo 编写baiduDemo.jsp页面 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;JSONP百度搜索&lt;/title&gt; &lt;style&gt; #q&#123; width: 500px; height: 30px; border:1px solid #ddd; line-height: 30px; display: block; margin: 0 auto; padding: 0 10px; font-size: 14px; &#125; #ul&#123; width: 520px; list-style: none; margin: 0 auto; padding: 0; border:1px solid #ddd; margin-top: -1px; display: none; &#125; #ul li&#123; line-height: 30px; padding: 0 10px; &#125; #ul li:hover&#123; background-color: #f60; color: #fff; &#125; &lt;/style&gt; &lt;script&gt; // 2.步骤二 // 定义demo函数 (分析接口、数据) function demo(data)&#123; var Ul = document.getElementById(&#x27;ul&#x27;); var html = &#x27;&#x27;; // 如果搜索数据存在 把内容添加进去 if (data.s.length) &#123; // 隐藏掉的ul显示出来 Ul.style.display = &#x27;block&#x27;; // 搜索到的数据循环追加到li里 for(var i = 0;i&lt;data.s.length;i++)&#123; html += &#x27;&lt;li&gt;&#x27;+data.s[i]+&#x27;&lt;/li&gt;&#x27;; &#125; // 循环的li写入ul Ul.innerHTML = html; &#125; &#125; // 1.步骤一 window.onload = function()&#123; // 获取输入框和ul var Q = document.getElementById(&#x27;q&#x27;); var Ul = document.getElementById(&#x27;ul&#x27;); // 事件鼠标抬起时候 Q.onkeyup = function()&#123; // 如果输入框不等于空 if (this.value != &#x27;&#x27;) &#123; // ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆JSONPz重点☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆ // 创建标签 var script = document.createElement(&#x27;script&#x27;); //给定要跨域的地址 赋值给src //这里是要请求的跨域的地址 我写的是百度搜索的跨域地址 script.src = &#x27;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=&#x27;+this.value+&#x27;&amp;cb=demo&#x27;; // 将组合好的带src的script标签追加到body里 document.body.appendChild(script); &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;text&quot; id=&quot;q&quot; /&gt;&lt;ul id=&quot;ul&quot;&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;","path":"page/SpringMVC06.html","date":"04-04","excerpt":"","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://xiaoliblog.cn/tags/SpringMVC/"}]},{"title":"SpringMVC🍃JSON数据处理","text":"JSON JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛 采用完全独立于编程语言的文本格式来存储和表示数据 简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率 在前后端分离时代，通过JSON来进行前后端数据交换 JSON与JS对象 在 JavaScript 语言中，一切都是对象。因此，任何JavaScript 支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等。看看他的要求和语法格式： 对象表示为键值对，数据由逗号分隔 花括号保存对象 方括号保存数组 JSON 键值对是用来保存 JavaScript 对象的一种方式，和 JavaScript 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 &quot; &quot; 包裹，使用冒号 : 分隔，然后紧接着值： 123&#123;&quot;name&quot;: &quot;小李&quot;&#125;&#123;&quot;age&quot;: &quot;21&quot;&#125;&#123;&quot;sex&quot;: &quot;男&quot;&#125; JSON 和 JavaScript 对象的关系，可以这么理解 JSON 是 JavaScript 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串 12var obj = &#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125;; //这是一个对象，注意键名也是可以使用引号包裹的var json = &#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;; //这是一个 JSON 字符串，本质是一个字符串 JSON 和 JS对象互转 要实现从JSON字符串转换为JavaScript 对象，使用 JSON.parse() 方法： 12var obj = JSON.parse(&#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27;);//结果是 &#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125; 要实现从JavaScript 对象转换为JSON字符串，使用 JSON.stringify() 方法： 12var json = JSON.stringify(&#123;a: &#x27;Hello&#x27;, b: &#x27;World&#x27;&#125;);//结果是 &#x27;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&#x27; 代码测试 在web目录下新建一个 jsontest.html ， 编写测试内容 12345678910111213141516171819202122232425&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt; //编写一个js的对象 var user = &#123; name:&quot;小李&quot;, age:21, sex:&quot;男&quot; &#125;; //将js对象转换成json字符串 var str = JSON.stringify(user); console.log(str); //将json字符串转换为js对象 var user2 = JSON.parse(str); console.log(user2.age,user2.name,user2.sex);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在IDEA中使用浏览器打开，查看控制台输出！ Jackson工具使用 Jackson应该是目前比较好的json解析工具了 当然工具不止这一个，比如还有阿里巴巴的 fastjson 等等。 我们这里使用Jackson，使用它需要导入它的jar包； 123456&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt;&lt;/dependency&gt; Controller返回JSON数据 配置SpringMVC需要的配置，比如web.xml 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--1.注册servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动顺序，数字越小，启动越早 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--所有请求都会被springmvc拦截 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; springmvc-servlet.xml 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt; &lt;context:component-scan base-package=&quot;com.lzy.controller&quot;/&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;!-- 后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 编写一个User的实体类，然后我们去编写我们的测试Controller 123456789101112131415import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;//需要导入lombok@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private String name; private int age; private String sex;&#125; 需要两个新东西，一个是@ResponseBody，一个是ObjectMapper对象，我们看下具体的用法，首先编写一个Controller 1234567891011121314151617@Controllerpublic class UserController &#123; //produces:指定响应体返回类型和编码 @RequestMapping(value = &quot;/json1&quot;,produces = &quot;application/json;charset=utf-8&quot;) //加@ResponseBody就不会找视图解析器,会直接返回一个字符串 @ResponseBody public String json1() throws JsonProcessingException &#123; //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(&quot;小李&quot;, 21, &quot;男&quot;); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); //由于@ResponseBody注解，这里会将str转成json格式返回；十分方便 return str; &#125;&#125; 【注意：使用json记得处理乱码问题】 12//produces:指定响应体返回类型和编码@RequestMapping(value = &quot;/json1&quot;,produces = &quot;application/json;charset=utf-8&quot;) 代码优化乱码统一解决 上一种方法比较麻烦，如果项目中有许多请求则每一个都要添加，可以通过Spring配置统一指定，这样就不用每次都去处理了！ 我们可以在springmvc-servlet.xml的配置文件上添加一段消息StringHttpMessageConverter转换配置！ 1234567891011121314&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;constructor-arg value=&quot;UTF-8&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt; &lt;property name=&quot;objectMapper&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt; &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; 返回json字符串统一解决 在类上直接使用 @RestController ，这样子，里面所有的方法都只会返回 json 字符串了，不用再每一个都添加@ResponseBody ！我们在前后端分离开发中，一般都使用 @RestController ，十分便捷！ 123456789101112131415@RestControllerpublic class UserController &#123; //produces:指定响应体返回类型和编码 @RequestMapping(value = &quot;/json1&quot;) public String json1() throws JsonProcessingException &#123; //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 User user = new User(&quot;小李&quot;, 21, &quot;男&quot;); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(user); //由于@RestController注解，这里会将str转成json格式返回；十分方便 return str; &#125;&#125; 测试集合输出12345678910111213141516171819202122@RestControllerpublic class UserController &#123; @RequestMapping(value = &quot;/json1&quot;) public String json1() throws JsonProcessingException &#123; //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建一个对象 //创建一个对象 User user1 = new User(&quot;小李1号&quot;, 21, &quot;男&quot;); User user2 = new User(&quot;小李2号&quot;, 21, &quot;男&quot;); User user3 = new User(&quot;小李3号&quot;, 21, &quot;男&quot;); User user4 = new User(&quot;小李4号&quot;, 21, &quot;男&quot;); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(list); return str; &#125;&#125; 输出时间对象12345678910111213@RestControllerpublic class UserController &#123; @RequestMapping(value = &quot;/json1&quot;) public String json1() throws JsonProcessingException &#123; //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //创建时间一个对象，java.util.Date Date date = new Date(); //将我们的对象解析成为json格式 String str = mapper.writeValueAsString(date); return str; &#125;&#125; 默认日期格式会变成一个数字，是1970年1月1日到当前日期的毫秒数！ Jackson 默认是会把时间转成timestamps形式 解决方案：取消timestamps形式 ， 自定义时间格式 1234567891011121314151617@RestControllerpublic class UserController &#123; @RequestMapping(value = &quot;/json1&quot;) public String json1() throws JsonProcessingException &#123; //创建一个jackson的对象映射器，用来解析数据 ObjectMapper mapper = new ObjectMapper(); //不使用时间戳的方式 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义日期格式对象 SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); //指定日期格式 mapper.setDateFormat(sdf); Date date = new Date(); String str = mapper.writeValueAsString(date); return str; &#125;&#125; 抽取为工具类 如果要经常使用的话，这样是比较麻烦的，我们可以将这些代码封装到一个工具类中；我们去编写下 123456789101112131415161718192021222324252627282930package com.lzy.utils;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.SerializationFeature;import java.text.SimpleDateFormat;public class JsonUtils &#123; public static String getJson(Object object) &#123; return getJson(object,&quot;yyyy-MM-dd HH:mm:ss&quot;); &#125; public static String getJson(Object object,String dateFormat) &#123; ObjectMapper mapper = new ObjectMapper(); //不使用时间差的方式 mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false); //自定义日期格式对象 SimpleDateFormat sdf = new SimpleDateFormat(dateFormat); //指定日期格式 mapper.setDateFormat(sdf); try &#123; return mapper.writeValueAsString(object); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 使用工具类，代码就更加简洁了！ 123456789@RestControllerpublic class UserController &#123; @RequestMapping(value = &quot;/json1&quot;) public String json1() throws JsonProcessingException &#123; Date date = new Date(); String json = JsonUtils.getJson(date); return json; &#125;&#125; FastJson工具使用 fastjson.jar是阿里开发的一款专门用于Java开发的包，可以方便的实现json对象与JavaBean对象的转换，实现JavaBean对象与json字符串的转换，实现json对象与json字符串的转换。实现json的转换方法很多，最后的实现结果都是一样的 fastjson 的 pom依赖！ 123456&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.75&lt;/version&gt;&lt;/dependency&gt; 主要的类 JSONObject 代表 json 对象 JSONObject实现了Map接口, 猜想 JSONObject底层操作是由Map实现的。 JSONObject对应json对象，通过各种形式的get()方法可以获取json对象中的数据，也可利用诸如size()，isEmpty()等方法获取”键：值”对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。 JSONArray 代表 json 对象数组 内部是有List接口中的方法来完成操作的。 JSON代表 JSONObject和JSONArray的转化 JSON类源码分析与使用 仔细观察这些方法，主要是实现json对象，json对象数组，javabean对象，json字符串之间的相互转化 代码测试 新建一个FastJsonDemo 类 1234567891011121314151617181920212223242526272829303132333435363738394041package com.lzy.controller;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import com.lzy.pojo.User;import java.util.ArrayList;import java.util.List;public class FastJsonDemo &#123; public static void main(String[] args) &#123; //创建一个对象 User user1 = new User(&quot;小李1号&quot;, 21, &quot;男&quot;); User user2 = new User(&quot;小李2号&quot;, 21, &quot;男&quot;); User user3 = new User(&quot;小李3号&quot;, 21, &quot;男&quot;); User user4 = new User(&quot;小李4号&quot;, 21, &quot;男&quot;); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(user1); list.add(user2); list.add(user3); list.add(user4); System.out.println(&quot;*******Java对象 转 JSON字符串*******&quot;); String str1 = JSON.toJSONString(list); System.out.println(&quot;JSON.toJSONString(list)==&gt;&quot;+str1); String str2 = JSON.toJSONString(user1); System.out.println(&quot;JSON.toJSONString(user1)==&gt;&quot;+str2); System.out.println(&quot;\\n****** JSON字符串 转 Java对象*******&quot;); User jp_user1=JSON.parseObject(str2,User.class); System.out.println(&quot;JSON.parseObject(str2,User.class)==&gt;&quot;+jp_user1); System.out.println(&quot;\\n****** Java对象 转 JSON对象 ******&quot;); JSONObject jsonObject1 = (JSONObject) JSON.toJSON(user2); System.out.println(&quot;(JSONObject) JSON.toJSON(user2)==&gt;&quot;+jsonObject1.getString(&quot;name&quot;)); System.out.println(&quot;\\n****** JSON对象 转 Java对象 ******&quot;); User to_java_user = JSON.toJavaObject(jsonObject1, User.class); System.out.println(&quot;JSON.toJavaObject(jsonObject1, User.class)==&gt;&quot;+to_java_user); &#125;&#125;","path":"page/SpringMVC05.html","date":"04-04","excerpt":"","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://xiaoliblog.cn/tags/SpringMVC/"}]},{"title":"SpringMVC🍃数据处理及跳转","text":"结果跳转方式ModelAndView 设置ModelAndView对象 , 根据view的名称 , 和视图解析器跳到指定的页面 . 页面 : &#123;视图解析器前缀&#125; + viewName +&#123;视图解析器后缀&#125; 1234567&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;!--前缀--&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;!--后缀--&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt; 对应的controller类 12345678910public class ControllerTest1 implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;); mv.setViewName(&quot;test&quot;); return mv; &#125;&#125; ServletAPI 通过设置ServletAPI , 不需要视图解析器 . 通过HttpServletResponse进行输出、重定向和转发 12345678910111213141516171819@Controllerpublic class ModelTest1 &#123; @RequestMapping(&quot;/result/t1&quot;) public void test1(HttpServletRequest req, HttpServletResponse rsp) throws IOException, IOException &#123; rsp.getWriter().println(&quot;Hello,Spring BY servlet API&quot;); &#125; @RequestMapping(&quot;/result/t2&quot;) public void test2(HttpServletRequest req, HttpServletResponse rsp) throws IOException &#123; rsp.sendRedirect(&quot;/index.jsp&quot;); &#125; @RequestMapping(&quot;/result/t3&quot;) public void test3(HttpServletRequest req, HttpServletResponse rsp) throws Exception &#123; //转发 req.setAttribute(&quot;msg&quot;,&quot;/result/t3&quot;); req.getRequestDispatcher(&quot;/WEB-INF/jsp/test.jsp&quot;).forward(req,rsp); &#125;&#125; SpringMVC 通过SpringMVC来实现转发和重定向 - 无需视图解析器； 测试前，需要将视图解析器注释掉，return的路径要注意类路径下的相对路径 123456789101112131415161718192021//一定要用Controller注解标注@Controllerpublic class ResultSpringMVC &#123; @RequestMapping(&quot;/rsm/t1&quot;) public String test1()&#123; //转发 return &quot;/index.jsp&quot;; &#125; @RequestMapping(&quot;/rsm/t2&quot;) public String test2()&#123; //转发二 return &quot;forward:/index.jsp&quot;; &#125; @RequestMapping(&quot;/rsm/t3&quot;) public String test3()&#123; //重定向 return &quot;redirect:/index.jsp&quot;; &#125;&#125; 通过SpringMVC来实现转发和重定向 - 有视图解析器； 视图解析器本质就是拼接地址，有了视图解析器，return路径只需要写视图名即可 123456789101112131415@Controllerpublic class ResultSpringMVC2 &#123; @RequestMapping(&quot;/rsm2/t1&quot;) public String test1()&#123; //转发 return &quot;test&quot;; &#125; @RequestMapping(&quot;/rsm2/t2&quot;) public String test2()&#123; //重定向 return &quot;redirect:/index.jsp&quot;; //return &quot;redirect:hello.do&quot;; //hello.do为另一个请求/ &#125;&#125; 数据处理处理提交数据 提交的域名称和处理方法的参数名一致 提交数据 : http://localhost:8080/test?name=李白 12345678910@Controllerpublic class UserController &#123; @RequestMapping(&quot;/test&quot;) public String test(String name)&#123; System.out.println(name); //test为视图名称 return &quot;test&quot;; &#125;&#125;//后台输出为 李白 提交的域名称和处理方法的参数名不一致 提交数据 : http://localhost:8080/hello?username=李白 12345678910@Controllerpublic class UserController &#123; @RequestMapping(&quot;/test&quot;) //@RequestParam(&quot;username&quot;) : username提交的域的名称 . public String test(@RequestParam(&quot;username&quot;) String name)&#123; System.out.println(name); return &quot;test&quot;; &#125;&#125;//后台输出为 李白 提交的是一个对象 要求提交的表单域和对象的属性名一致 , 参数使用对象即可 新建一个实体类 12345678public class User &#123; private int id; private String name; private int age; //构造 //get/set //tostring()&#125; 提交数据 : http://localhost:8080/user?name=李白&amp;id=1&amp;age=15 123456789@Controllerpublic class UserController &#123; @RequestMapping(&quot;/user&quot;) public String test(User user)&#123; System.out.println(user); return &quot;test&quot;; &#125;&#125;//后台输出 : User(id=1, name=李白, age=15) 说明：如果使用对象的话，前端传递的参数名和对象名必须一致，否则就是null 数据显示到前端 第一种 : 通过ModelAndView 123456789101112public class ControllerTest1 implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(&quot;msg&quot;,&quot;ControllerTest1&quot;); //前端通过$&#123;msg&#125;取得 mv.setViewName(&quot;test&quot;); //视图跳转 return mv; &#125;&#125; 第二种 : 通过ModelMap 12345678@RequestMapping(&quot;/test&quot;)public String hello(@RequestParam(&quot;username&quot;) String name, ModelMap model)&#123; //封装要显示到视图中的数据 //相当于req.setAttribute(&quot;name&quot;,name); model.addAttribute(&quot;name&quot;,name); System.out.println(name); return &quot;test&quot;;&#125; 第三种 : 通过Model 12345678@RequestMapping(&quot;/test&quot;)public String hello(@RequestParam(&quot;username&quot;) String name, Model model)&#123; //封装要显示到视图中的数据 //相当于req.setAttribute(&quot;name&quot;,name); model.addAttribute(&quot;msg&quot;,name); System.out.println(name); return &quot;test&quot;;&#125; 对比 Model 只有寥寥几个方法只适合用于储存数据，简化了新手对于Model对象的操作和理解； ModelMap 继承了 LinkedMap ，除了实现了自身的一些方法，同样的继承 LinkedMap 的方法和特性； ModelAndView 可以在储存数据的同时，可以进行设置返回的逻辑视图，进行控制展示层的跳转。 乱码问题测试案例 在index.jsp首页编写一个提交表单 1234&lt;form action=&quot;/e/t&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt; 编写springmvc-servlet.xml视图控制器 1234567&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;!--前缀--&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;!--后缀--&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;&lt;/bean&gt; 后台编写对应的处理类 12345678@Controllerpublic class Encoding &#123; @RequestMapping(&quot;/e/t&quot;) public String test(Model model, String name)&#123; model.addAttribute(&quot;msg&quot;,name); //获取表单提交的值 return &quot;test&quot;; //跳转到test页面显示输入的值 &#125;&#125; 输入中文测试，发现乱码 web.xml配置 以前乱码问题通过过滤器解决 , 而SpringMVC给我们提供了一个过滤器 , 可以在web.xml中配置 . 修改了xml文件需要重启服务器！ 123456789101112&lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 修改Tomcat配置文件 有些极端情况下，这个过滤器对get的支持不好 ，我们可以用以下方法处理 修改tomcat配置文件 ：设置编码！Tomcat安装目录/conf/server.xml 123&lt;Connector URIEncoding=&quot;utf-8&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 自定义过滤器 如果还无法解决，可以配置一下某位大佬写的万能过滤器！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package com.lzy.filter;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletRequestWrapper;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.util.Map;/** * 解决get和post请求 全部乱码的过滤器 */public class GenericEncodingFilter implements Filter &#123; @Override public void destroy() &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; //处理response的字符编码 HttpServletResponse myResponse=(HttpServletResponse) response; myResponse.setContentType(&quot;text/html;charset=UTF-8&quot;); // 转型为与协议相关对象 HttpServletRequest httpServletRequest = (HttpServletRequest) request; // 对request包装增强 HttpServletRequest myrequest = new MyRequest(httpServletRequest); chain.doFilter(myrequest, response); &#125; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125;&#125;//自定义request对象，HttpServletRequest的包装类class MyRequest extends HttpServletRequestWrapper &#123; private HttpServletRequest request; //是否编码的标记 private boolean hasEncode; //定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰 public MyRequest(HttpServletRequest request) &#123; super(request);// super必须写 this.request = request; &#125; // 对需要增强方法 进行覆盖 @Override public Map getParameterMap() &#123; // 先获得请求方式 String method = request.getMethod(); if (method.equalsIgnoreCase(&quot;post&quot;)) &#123; // post请求 try &#123; // 处理post乱码 request.setCharacterEncoding(&quot;utf-8&quot;); return request.getParameterMap(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; else if (method.equalsIgnoreCase(&quot;get&quot;)) &#123; // get请求 Map&lt;String, String[]&gt; parameterMap = request.getParameterMap(); if (!hasEncode) &#123; // 确保get手动编码逻辑只运行一次 for (String parameterName : parameterMap.keySet()) &#123; String[] values = parameterMap.get(parameterName); if (values != null) &#123; for (int i = 0; i &lt; values.length; i++) &#123; try &#123; // 处理get乱码 values[i] = new String(values[i] .getBytes(&quot;ISO-8859-1&quot;), &quot;utf-8&quot;); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; hasEncode = true; &#125; return parameterMap; &#125; return super.getParameterMap(); &#125; //取一个值 @Override public String getParameter(String name) &#123; Map&lt;String, String[]&gt; parameterMap = getParameterMap(); String[] values = parameterMap.get(name); if (values == null) &#123; return null; &#125; return values[0]; // 取回参数的第一个值 &#125; //取所有值 @Override public String[] getParameterValues(String name) &#123; Map&lt;String, String[]&gt; parameterMap = getParameterMap(); String[] values = parameterMap.get(name); return values; &#125;&#125; 在web.xml中注册过滤器 12345678&lt;filter&gt; &lt;filter-name&gt;GenericEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.lzy.filter.GenericEncodingFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;GenericEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 乱码问题，需要平时多注意，在尽可能能设置编码的地方，都设置为统一编码 UTF-8！","path":"page/SpringMVC04.html","date":"04-03","excerpt":"","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://xiaoliblog.cn/tags/SpringMVC/"}]},{"title":"SpringMVC🍃RestFul和控制器","text":"控制器Controller 控制器负责提供访问应用程序的行为，通常通过接口定义或注解定义两种方法实现 控制器负责解析用户的请求并将其转换为一个模型 在Spring MVC中一个控制器类可以包含多个方法 在Spring MVC中，对于Controller的配置方式有很多种 实现Controller接口 Controller是一个接口，在org.springframework.web.servlet.mvc包下，接口中只有一个方法； 12345//实现该接口的类获得控制器功能public interface Controller &#123; //处理请求且返回一个模型与视图对象 ModelAndView handleRequest(HttpServletRequest var1, HttpServletResponse var2) throws Exception;&#125; 测试，web.xml配置如下 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--注册Servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; springmvc-servlet.xml配置如下 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.lzy.controller&quot;/&gt; &lt;mvc:default-servlet-handler/&gt; &lt;mvc:annotation-driven/&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;!--前缀--&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;!--后缀--&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 编写一个Controller类，ControllerTest1 123456789101112//定义控制器//注意点：不要导错包，实现Controller接口，重写方法；public class ControllerTest1 implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; //返回一个模型视图对象 ModelAndView mv = new ModelAndView(); mv.addObject(&quot;msg&quot;,&quot;ConrollerTest1&quot;); mv.setViewName(&quot;test&quot;); return mv; &#125;&#125; 编写完毕后，去springmvc-servlet.xml配置文件中注册请求的bean；name对应请求路径，class对应处理请求的类 1&lt;bean name=&quot;/t1&quot; class=&quot;com.lzy.controller.ControllerTest1&quot;/&gt; 编写前端test.jsp，注意在WEB-INF/jsp目录下编写，对应我们的视图解析器 12345678910&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 实现接口Controller定义控制器是较老的办法 缺点是：一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller；定义的方式比较麻烦； 使用注解@Controller @Controller注解类型用于声明Spring类的实例是一个控制器 Spring可以使用扫描机制来找到应用程序中所有基于注解的控制器类，为了保证Spring能找到你的控制器，需要在配置文件中声明组件扫描 12&lt;!-- 自动扫描指定的包，下面所有注解类交给IOC容器管理 --&gt;&lt;context:component-scan base-package=&quot;com.lzy.controller&quot;/&gt; 增加一个ControllerTest2类，使用注解实现； 12345678910111213//@Controller注解的类会自动添加到Spring上下文中//被这个注解的类中的所有方法,如果返回值是String,并且有具体页面可以跳转，那么就会被视图解析器解析@Controllerpublic class ControllerTest2 &#123; //映射访问路径 @RequestMapping(&quot;/t2&quot;) public String test(Model model)&#123; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(&quot;msg&quot;,&quot;ControllerTest2&quot;); //返回视图位置/WEB-INF/jsp/test.jsp return &quot;test&quot;; &#125;&#125; 可以发现，我们的两个请求都可以指向一个视图test.jsp，但是页面结果的结果是不一样的，从这里可以看出视图是被复用的，而控制器与视图之间是弱偶合关系 这种视图复用的方式，可以运用在前端一些不用不会变化的视图页面上 注解方式是平时使用的最多的方式！ RequestMapping @RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。 为了测试结论更加准确，我们可以加上一个项目名SpringMVC_Demo03测试 以下测试都在com.lzy.controller下，需要在springmvc-servlet.xml中进行包扫描 1&lt;context:component-scan base-package=&quot;com.lzy.controller&quot;/&gt; 只注解在方法上面 12345678@Controllerpublic class TestController &#123; @RequestMapping(&quot;/h1&quot;) public String test(Model model)&#123; model.addAttribute(&quot;msg&quot;,&quot;http://localhost:8080 / 项目名 / h1&quot;); return &quot;test&quot;; &#125;&#125; 同时注解类与方法 123456789@Controller@RequestMapping(&quot;/admin&quot;)public class TestController &#123; @RequestMapping(&quot;/h1&quot;) public String test(Model model)&#123; model.addAttribute(&quot;msg&quot;,&quot;http://localhost:8080 / 项目名/ admin /h1&quot;); return &quot;test&quot;; &#125;&#125; RestFul 风格 Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 功能 资源：互联网所有的事物都可以被抽象为资源 资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。 分别对应 添加、 删除、修改、查询。 传统方式操作资源 ：通过不同的参数来实现不同的效果！方法单一，post 和 get 1234http:&#x2F;&#x2F;127.0.0.1&#x2F;item&#x2F;queryItem.action?id&#x3D;1 #查询,GEThttp:&#x2F;&#x2F;127.0.0.1&#x2F;item&#x2F;saveItem.action #新增,POSThttp:&#x2F;&#x2F;127.0.0.1&#x2F;item&#x2F;updateItem.action #更新,POSThttp:&#x2F;&#x2F;127.0.0.1&#x2F;item&#x2F;deleteItem.action?id&#x3D;1 #删除,GET或POST 使用RESTful操作资源 ：可以通过不同的请求方式来实现不同的效果！如下：请求地址一样，但是功能可以不同！ 1234http:&#x2F;&#x2F;127.0.0.1&#x2F;item&#x2F;1 #查询,GEThttp:&#x2F;&#x2F;127.0.0.1&#x2F;item #新增,POSThttp:&#x2F;&#x2F;127.0.0.1&#x2F;item #更新,PUThttp:&#x2F;&#x2F;127.0.0.1&#x2F;item&#x2F;1 #删除,DELETE 比如百度搜索马云、马化腾等大佬的信息，改变的只是item后面的信息 12https:&#x2F;&#x2F;baike.baidu.com&#x2F;item&#x2F;马云https:&#x2F;&#x2F;baike.baidu.com&#x2F;item&#x2F;马化腾 学习测试 新建一个类 RestFulController，先使用原来的传参方法 123456789@Controllerpublic class RestFulController &#123; @RequestMapping(&quot;/add&quot;) public String test(int a, int b, Model model)&#123; int res = a + b; model.addAttribute(&quot;msg&quot;,&quot;结果为&quot;+res); return &quot;test&quot;; &#125;&#125; 提通过前端传参访问 在Spring MVC中可以使用 @PathVariable 注解，让方法参数的值对应绑定到一个URI模板变量上，在@RequestMapping中使用&#123;参数&#125;绑定 12345678910111213@Controllerpublic class RestFulController &#123; //原来:http://localhost:8080/add?a=1&amp;b=2 //RestFul:http://localhost:8080/add/a/b //映射访问路径 @RequestMapping(&quot;/add/&#123;a&#125;/&#123;b&#125;&quot;) public String test(@PathVariable int a, @PathVariable int b, Model model)&#123; int res = a + b; //Spring MVC会自动实例化一个Model对象用于向视图中传值 model.addAttribute(&quot;msg&quot;,&quot;结果为&quot;+res); return &quot;test&quot;; &#125;&#125; 在地址栏中输入http://localhost:8080/add/1/2后，1和2就对应传入&#123;a&#125;和&#123;b&#125;，再传给@PathVariable标注的参数，然后进入方法运算返回结果 使用路径变量的好处 使路径变得更加简洁 获得参数更加方便，框架会自动进行类型转换 通过路径变量的类型可以约束访问参数，如果类型不一样，则访问不到对应的请求方法，如这里访问是的路径是/add/1/a，则路径与方法不匹配，而不会是参数转换失败 修改下对应的参数类型，再次测试 1234567891011@Controllerpublic class RestFulController &#123; //原来:http://localhost:8080/add?a=1&amp;b=2 //RestFul:http://localhost:8080/add/a/b @RequestMapping(&quot;/add/&#123;a&#125;/&#123;b&#125;&quot;) public String test(@PathVariable int a, @PathVariable int b, Model model)&#123; String res = a + b; model.addAttribute(&quot;msg&quot;,&quot;结果为&quot;+res); return &quot;test&quot;; &#125;&#125; method属性指定请求类型 用于约束请求的类型，可以收窄请求范围。指定请求谓词的类型如GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE等 为类 RestFulController注解增加method属性，修改为POST请求 123456789@Controllerpublic class RestFulController &#123; @RequestMapping(value =&quot;/add/&#123;a&#125;/&#123;b&#125;&quot;,method = RequestMethod.POST) public String test(@PathVariable int a, @PathVariable int b, Model model)&#123; int res = a + b; model.addAttribute(&quot;msg&quot;,&quot;结果为&quot;+res); return &quot;test&quot;; &#125;&#125; 浏览器地址栏进行访问默认是Get请求，会报错405： 如果将POST修改为GET则正常了 123456789@Controllerpublic class RestFulController &#123; @RequestMapping(value =&quot;/add/&#123;a&#125;/&#123;b&#125;&quot;,method = RequestMethod.GET) public String test(@PathVariable int a, @PathVariable int b, Model model)&#123; int res = a + b; model.addAttribute(&quot;msg&quot;,&quot;结果为&quot;+res); return &quot;test&quot;; &#125;&#125; 结合前端页面 假设有一个前端页面如下 1234567&lt;html&gt;&lt;body&gt;&lt;form action=&quot;/add/1/2&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; RestFulController用于处理请求 123456789@Controllerpublic class RestFulController &#123; @RequestMapping(value =&quot;/add/&#123;a&#125;/&#123;b&#125;&quot;,method = RequestMethod.POST) public String test(@PathVariable int a, @PathVariable int b, Model model)&#123; int res = a + b; model.addAttribute(&quot;msg&quot;,&quot;结果为&quot;+res); return &quot;test&quot;; &#125;&#125; 表单提交后就跳转到对应页面","path":"page/SpringMVC03.html","date":"04-02","excerpt":"","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://xiaoliblog.cn/tags/SpringMVC/"}]},{"title":"SpringMVC🍃第一个MVC程序","text":"SpringMVC配置版 首先创建一个空父工程，在其pom.xml用于引入各种依赖，再创建子模块 新建一个Moudle ， 勾选Webapp模板 ， 添加web的支持！ 确定导入了SpringMVC 的依赖！ 123456&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.4&lt;/version&gt;&lt;/dependency&gt; 导入servlet 和 jsp 的 jar 依赖 123456789101112131415161718192021222324&lt;!--junit--&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt;&lt;!--servlet--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt;&lt;/dependency&gt;&lt;!--jsp--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--jstl--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt; 注册DispatcherServlet 配置web.xml ， 注册DispatcherServlet 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--1.注册DispatcherServlet,这是核心控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--启动级别-1--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--/ 匹配所有的请求；（不包括.jsp）--&gt; &lt;!--/* 匹配所有的请求；（包括.jsp）--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; SpringMVC配置文件 编写SpringMVC 的 配置文件！名称：springmvc-servlet.xml : [servletname]-servlet.xml 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 1.添加处理映射器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt; &lt;!-- 2.添加处理器适配器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt; &lt;!-- 3.添加视图解析器--&gt; &lt;!--视图解析器:DispatcherServlet给他的ModelAndView--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;InternalResourceViewResolver&quot;&gt; &lt;!--前缀--&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;!--后缀--&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 创建Controller 编写我们要操作业务Controller ，要么实现Controller接口，要么增加注解；需要返回一个ModelAndView，装数据，封视图； 123456789101112131415161718192021package com.lzy.controller;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;//注意：这里我们先导入Controller接口public class HelloController implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; //ModelAndView 模型和视图 ModelAndView mv = new ModelAndView(); //封装对象，放在ModelAndView中。Model mv.addObject(&quot;msg&quot;,&quot;HelloSpringMVC!&quot;); //封装要跳转的视图，放在ModelAndView中 mv.setViewName(&quot;hello&quot;); //: /WEB-INF/jsp/hello.jsp return mv; &#125;&#125; 将自己的类交给SpringIOC容器，在springmvc-servlet.xml注册bean 12&lt;!--Handler--&gt;&lt;bean id=&quot;/hello&quot; class=&quot;com.kuang.controller.HelloController&quot;/&gt; 创建视图层 在WEB-INF下创建jsp文件夹，里面写要跳转的jsp页面hello.jsp，显示ModelandView存放的数据，以及我们的正常页面； 12345678910&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 配置Tomcat工件为本项目后，运行结果如下 SpringMVC注解版 新建一个Moudle，勾选webapp模板。添加web支持 由于Maven可能存在资源过滤的问题，我们将配置完善 1234567891011121314151617181920&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 在pom.xml文件引入相关的依赖：主要有Spring框架核心库、Spring MVC、servlet , JSTL等。我们在父依赖中已经引入了！ 项目结构 配置web.xml /和 /* 的区别 &lt; url-pattern &gt; / &lt;/ url-pattern &gt; 不会匹配到.jsp， 只针对我们编写的请求；即：.jsp 不会进入spring的 DispatcherServlet类 &lt; url-pattern &gt; /* &lt;/ url-pattern &gt; 会匹配 *.jsp，会出现返回 jsp视图 时再次进入spring的DispatcherServlet 类，导致找不到对应的controller所以报404错。 注意web.xml版本问题，要最新版！ 注册DispatcherServlet 关联SpringMVC的配置文件 启动级别为1 映射路径为/ 【不要用/*，会404】 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--1.注册servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动顺序，数字越小，启动越早 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--所有请求都会被springmvc拦截 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; Spring MVC配置文件 在resource目录下添加springmvc-servlet.xml配置文件，配置的形式与Spring容器配置基本类似，为了支持基于注解的IOC，设置了自动扫描包的功能，具体配置信息如下： 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt; &lt;context:component-scan base-package=&quot;com.lzy.controller&quot;/&gt; &lt;!-- 让Spring MVC不处理静态资源 --&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!-- 支持mvc注解驱动 在spring中一般采用@RequestMapping注解来完成映射关系 要想使@RequestMapping注解生效 必须向上下文中注册DefaultAnnotationHandlerMapping 和一个AnnotationMethodHandlerAdapter实例 这两个实例分别在类级别和方法级别处理。 而annotation-driven配置帮助我们自动完成上述两个实例的注入。 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;!-- 后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 在视图解析器中我们把所有的视图都存放在/WEB-INF/目录下，这样可以保证视图安全，因为这个目录下的文件，客户端不能直接访问。 让IOC的注解生效 静态资源过滤 ：HTML . JS . CSS . 图片 ， 视频 ….. MVC的注解驱动 配置视图解析器 创建Controller 编写一个Java控制类：com.lzy.controller.HelloController , 注意编码规范 1234567891011121314151617181920package com.lzy.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controller//设置父路径,一般不用@RequestMapping(&quot;/HelloController&quot;)public class HelloController &#123; //真实访问地址 : 项目名/HelloController/hello @RequestMapping(&quot;/hello&quot;) public String sayHello(Model model)&#123; //向模型中添加属性msg与值，可以在JSP页面中取出并渲染 model.addAttribute(&quot;msg&quot;,&quot;hello,SpringMVC&quot;); //web-inf/jsp/hello.jsp return &quot;hello&quot;; &#125;&#125; @Controller是为了让Spring IOC容器初始化时自动扫描到； @RequestMapping是为了映射请求路径，这里因为类与方法上都有映射所以访问时应该是/HelloController/hello； 方法中声明Model类型的参数是为了把Action中的数据带到视图中； 方法返回的结果是视图的名称hello，加上配置文件中的前后缀变成WEB-INF/jsp/hello.jsp。 运行可能出现的问题程序包org.springframework.stereotype 不存在 创建视图层 在WEB-INF/jsp目录中创建hello.jsp ， 视图可以直接取出并展示从Controller带回的信息； 可以通过EL表示取出Model中存放的值，或者对象； 12345678910&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page isELIgnored=&quot;false&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 配置Tomcat工件为本项目后，运行结果如下","path":"page/SpringMVC02.html","date":"04-02","excerpt":"","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://xiaoliblog.cn/tags/SpringMVC/"}]},{"title":"SpringMVC🍃SpringMVC概述","text":"MVC设计概述 在早期 Java Web 的开发中，主要分为两层：视图层和模型层，统一把显示层、控制层、数据层的操作全部交给 JSP 或者 JavaBean 来进行处理，我们称之为 Model1 出现的弊端： JSP 和 Java Bean 之间严重耦合，Java 代码和 HTML 代码也耦合在了一起 要求开发者不仅要掌握 Java ，还要有高超的前端水平 前端和后端相互依赖，前端需要等待后端完成，后端也依赖前端完成，才能进行有效的测试 代码难以复用 正因为上面的种种弊端，所以很快这种方式就被 Servlet + JSP + Java Bean 所替代了，早期的 MVC 模型（Model2）就像下图这样： 首先用户的请求会到达 Servlet，然后根据请求调用相应的 Java Bean，并把所有的显示结果交给 JSP 去完成，这样的模式我们就称为 MVC 模式 MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范，是将业务逻辑、数据、显示分离的方法来组织代码。 MVC主要作用是降低了视图与业务逻辑间的双向偶合 MVC不是一种设计模式，MVC是一种架构模式。当然不同的MVC存在差异 Model(模型)：数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。 View(视图)：负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。 Controller(控制器)：接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。也就是说控制器做了个调度员的工作 SpringMVC Spring MVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架 SpringMVC官方文档 || 中文文档：http://c.biancheng.net/spring_mvc/ Spring的web框架围绕DispatcherServlet [ 调度Servlet ] 设计。 DispatcherServlet的作用是将请求分发到不同的处理器。从Spring 2.5开始，使用Java 5或者以上版本的用户可以采用基于注解形式进行开发，十分简洁； 中心控制器 Spring Web 模型-视图-控制（MVC）框架是围绕 DispatcherServlet 设计的，DispatcherServlet 用来处理所有的 HTTP 请求和响应。Spring Web MVC DispatcherServlet 的请求处理的工作流程如下图所示： 下面是对应于 DispatcherServlet 传入 HTTP 请求的事件序列： 收到一个 HTTP 请求后，DispatcherServlet 根据 HandlerMapping 来选择并且调用适当的控制器。 控制器接受请求，并基于使用的 GET 或 POST 方法来调用适当的 service 方法。Service 方法将设置基于定义的业务逻辑的模型数据，并返回视图名称到 DispatcherServlet 中。 DispatcherServlet 会从ViewResolver 获取帮助，为请求检取定义视图。 一旦确定视图，DispatcherServlet 将把模型数据传递给视图，最后呈现在浏览器中 上面所提到的所有组件，即 HandlerMapping、Controller 和 ViewResolver 是 WebApplicationContext 的一部分，而 WebApplicationContext 是带有一些对 web 应用程序必要的额外特性的 ApplicationContext 的扩展 Spring MVC框架像许多其他MVC框架一样, 以请求为驱动 , 围绕一个中心Servlet分派请求及提供其他功能，DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类) SpringMVC执行原理 当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者 下图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现 DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。 我们假设请求的url为 : http://localhost:8080/SpringMVC/hello 如上url拆分成三部分： http://localhost:8080服务器域名 SpringMVC部署在服务器上的web站点 hello表示控制器 通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器 HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping，HandlerMapping根据请求url查找Handler HandlerExecution表示具体的Handler，其主要作用是根据url查找控制器，如上url被查找控制器为：hello HandlerExecution将解析后的信息传递给DispatcherServlet，如解析控制器映射等 HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler Handler让具体的Controller执行 Controller将具体的执行信息返回给HandlerAdapter，如ModelAndView HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。 视图解析器将解析的逻辑视图名传给DispatcherServlet DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。 最终视图呈现给用户","path":"page/SpringMVC01.html","date":"04-02","excerpt":"","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://xiaoliblog.cn/tags/SpringMVC/"}]},{"title":"Spring🍃声明式事务","text":"声明式事务回顾事务 事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！ 事务管理是企业级应用程序开发中必备技术，用来确保数据的完整性和一致性。 事务就是把一系列的动作当成一个独立的工作单元，这些动作要么全部完成，要么全部不起作用 事务四个属性ACID 原子性（atomicity） 事务是原子性操作，由一系列动作组成，事务的原子性确保动作要么全部完成，要么完全不起作用 一致性（consistency） 一旦所有事务动作完成，事务就要被提交。数据和资源处于一种满足业务规则的一致性状态中 隔离性（isolation） 可能多个事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏 持久性（durability） 事务一旦完成，无论系统发生什么错误，结果都不会受到影响。通常情况下，事务的结果被写到持久化存储器中 测试 测试环境中配置文件仍然是上一节不变 User实体类 12345678@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private int id; private String name; private String pwd;&#125; UserMapper 123456789public interface UserMapper &#123; //添加一个用户 int addUser(User user); //根据id删除用户 int deleteUser(int id); public List&lt;User&gt; selectUser();&#125; UserMapper.xml配置文件，故意把delete写成deletes 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.lzy.dao.UserMapper&quot;&gt; &lt;insert id=&quot;addUser&quot; parameterType=&quot;com.lzy.pojo.User&quot;&gt; insert into user(id,name,pwd)value (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;) &lt;/insert&gt; &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; deletes from user where id = #&#123;id&#125; &lt;/delete&gt; &lt;select id=&quot;selectUser&quot; resultType=&quot;User&quot;&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 编写UserMapperImpl接口实现类 12345678910111213141516171819202122232425public class UserMapperImpl extends SqlSessionDaoSupport implements UserMapper&#123; //增加 @Override public int addUser(User user) &#123; UserMapper mapper = getSqlSession().getMapper(UserMapper.class); return mapper.addUser(user); &#125; //删除 @Override public int deleteUser(int id) &#123; UserMapper mapper = getSqlSession().getMapper(UserMapper.class); return mapper.deleteUser(id); &#125; // //增加一些操作 @Override public List&lt;User&gt; selectUser() &#123; User user = new User(4,&quot;小明&quot;,&quot;123456&quot;); UserMapper mapper = getSqlSession().getMapper(UserMapper.class); mapper.addUser(user); mapper.deleteUser(4); return mapper.selectUser(); &#125;&#125; 测试 12345678910public class Test &#123; @Test public void selectUser() throws IOException&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); //从容器里那UserMapper,调其方法即可 UserMapper userMapper = context.getBean(&quot;UserMapper&quot;,UserMapper.class); List&lt;User&gt; userList = userMapper.selectUser(); System.out.println(userList); &#125;&#125; 结果会报错SQL异常，但是插入数据却成功了！ 没有进行事务的管理；我们想让他们都成功才成功，有一个失败，就都失败，我们就应该需要事务！ 以前需要手动管理事务，十分麻烦，但是Spring给我们提供了事务管理，我们只需要配置即可； Spring事务管理 Spring在不同的事务管理API之上定义了一个抽象层，使得开发人员不必了解底层的事务管理API就可以使用Spring的事务管理机制。Spring支持编程式事务管理和声明式的事务管理。 编程式事务管理 将事务管理代码嵌到业务方法中来控制事务的提交和回滚 缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码 声明式事务管理 一般情况下比编程式事务好用。 将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。 将事务管理作为横切关注点，通过aop方法模块化。Spring中通过Spring AOP框架支持声明式事务管理 配置事务 以下均在Spring-config.xml中配置事务 使用Spring管理事务，注意头文件的约束导入 : tx 1234xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;http://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; 事务管理器 无论使用Spring的哪种事务管理策略（编程式或者声明式）事务管理器都是必须的。 就是 Spring的核心事务管理抽象，管理封装了一组独立于技术的方法。 JDBC事务管理 1234&lt;!--配置声明式事务--&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt; 配置好事务管理器后我们需要去配置事务的通知 12345678910111213&lt;!--结合AOP实现事务的织入--&gt;&lt;!--配置事务通知--&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!--配置哪些方法使用什么样的事务,配置事务的传播特性--&gt; &lt;tx:method name=&quot;add&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;delete&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;update&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;search*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;get&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; spring事务传播特性 事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。spring支持7种事务传播行为 事务传播行为 说明 propagation_requierd 如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择 propagation_supports 支持当前事务，如果没有当前事务，就以非事务方法执行 propagation_mandatory 使用当前事务，如果没有当前事务，就抛出异常 propagation_required_new 新建事务，如果当前存在事务，把当前事务挂起 propagation_not_supported 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起 propagation_never 以非事务方式执行操作，如果当前事务存在则抛出异常 propagation_nested 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作 Spring 默认的事务传播行为是 PROPAGATION_REQUIRED，它适合于绝大多数的情况。 假设 ServiveX#methodX() 都工作在事务环境下（即都被 Spring 事务增强了），假设程序中存在如下的调用链：Service1#method1()-&gt;Service2#method2()-&gt;Service3#method3()，那么这 3 个服务类的 3 个方法通过 Spring 的事务传播机制都工作在同一个事务中。 就好比，我们刚才的几个方法存在调用，所以会被放在一组事务当中！ 配置AOP 导入AOP的头文件 1234xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;http://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; 在Spring-config.xml中配置 12345&lt;!--配置aop织入事务--&gt;&lt;aop:config&gt; &lt;aop:pointcut id=&quot;txPointcut&quot; expression=&quot;execution(* com.lzy.dao.*.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointcut&quot;/&gt;&lt;/aop:config&gt; 测试 12345678910public class Test &#123; @Test public void selectUser() throws IOException&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); //从容器里那UserMapper,调其方法即可 UserMapper userMapper = context.getBean(&quot;UserMapper&quot;,UserMapper.class); List&lt;User&gt; userList = userMapper.selectUser(); System.out.println(userList); &#125;&#125; 可以发现报错，并且不会插入成功 Spring-config.xml完整配置如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--配置数据源--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/bean&gt; &lt;!--配置sqlSessionFactory,关联MyBatis--&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!--数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!--加载MyBatis配置文件--&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;!--加载映射文件--&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/lzy/dao/*.xml&quot;/&gt; &lt;/bean&gt; &lt;!--注册sqlSessionTemplate , 关联sqlSessionFactory--&gt; &lt;!--sqlSessionTemplate就是我们使用的sqlSession--&gt; &lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;!--只能利用构造器注入sqlSessionFactory,因为它没有set方法,index=0为第0个参数设置--&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot;/&gt; &lt;/bean&gt; &lt;!--配置声明式事务--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;!--结合AOP实现事务的织入--&gt; &lt;!--配置事务通知--&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!--配置哪些方法使用什么样的事务,配置事务的传播特性--&gt; &lt;tx:method name=&quot;add&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;delete&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;update&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;search*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;tx:method name=&quot;get&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--配置事务切入--&gt; &lt;aop:config&gt; &lt;aop:pointcut id=&quot;txPointcut&quot; expression=&quot;execution(* com.lzy.dao.*.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointcut&quot;/&gt; &lt;/aop:config&gt;&lt;/beans&gt;","path":"page/Spring09.html","date":"04-02","excerpt":"","tags":[{"name":"Spring","slug":"Spring","permalink":"http://xiaoliblog.cn/tags/Spring/"}]},{"title":"Spring🍃整合MyBatis","text":"整合MyBatis 导入Jar包 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!--junit--&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt;&lt;!--mybatis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--mysql-connector-java--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring相关--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.1.10.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--aspectJ AOP 织入器--&gt;&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt;&lt;!--mybatis-spring整合包 【重点】--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt; 配置Maven静态资源过滤问题！ 123456789101112&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 插件推荐 回顾MyBatis 编写pojo实体类 123456@Datapublic class User &#123; private int id; private String name; private String pwd;&#125; 实现mybatis的配置文件 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;!--别名为类名首字母大写--&gt; &lt;package name=&quot;com.lzy.pojo&quot;/&gt; &lt;/typeAliases&gt; &lt;environments default=&quot;MySQL&quot;&gt; &lt;environment id=&quot;MySQL&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;package name=&quot;com.lzy.dao&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; UserDao接口编写 123public interface UserMapper &#123; public List&lt;User&gt; selectUser();&#125; 接口对应的Mapper映射文件 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.lzy.dao.UserMapper&quot;&gt; &lt;select id=&quot;selectUser&quot; resultType=&quot;User&quot;&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 测试类 123456789101112131415public class Test &#123; @org.junit.Test public void selectUser() throws IOException&#123; String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; userList = mapper.selectUser(); for (User user : userList) &#123; System.out.println(user); &#125; sqlSession.close(); &#125;&#125; MyBatis-Spring MyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中 它将允许 MyBatis 参与到 Spring 的事务管理之中，创建映射器 mapper 和 SqlSession 并注入到 bean 中，以及将 Mybatis 的异常转换为 Spring 的 DataAccessException。 最终，可以做到应用代码不依赖于 MyBatis，Spring 或 MyBatis-Spring 官方文档：http://www.mybatis.org/spring/zh/index.html 知识基础 MyBatis-Spring 需要以下版本： MyBatis-Spring MyBatis Spring Framework Spring Batch Java 2.0 3.5+ 5.0+ 4.0+ Java 8+ 1.3 3.4+ 3.2.2+ 2.1+ Java 6+ 如果使用 Maven 作为构建工具，仅需要在 pom.xml 中加入以下代码即可： 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt; 要和 Spring 一起使用 MyBatis，需要在 Spring 应用上下文(applicationContext.xml)中定义至少两样东西：一个 SqlSessionFactory 和至少一个数据映射器类 在 MyBatis-Spring 中，可使用SqlSessionFactoryBean来创建 SqlSessionFactory。要配置这个工厂 bean，只需要把下面代码放在 Spring 的 XML 配置文件中： 123&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt; 注意：SqlSessionFactory需要一个 DataSource（数据源）。这可以是任意的 DataSource，只需要和配置其它 Spring 数据库连接一样配置它就可以了 在基础的 MyBatis 用法中，是通过 SqlSessionFactoryBuilder 来创建 SqlSessionFactory 的。而在 MyBatis-Spring 中，则使用 SqlSessionFactoryBean 来创建 在 MyBatis 中，你可以使用 SqlSessionFactory 来创建 SqlSession。一旦你获得一个 session 之后，你可以使用它来执行映射了的语句，提交或回滚连接，最后，当不再需要它的时候，你可以关闭 session SqlSessionFactory有一个唯一的必要属性：用于 JDBC 的 DataSource。这可以是任意的 DataSource 对象，它的配置方法和其它 Spring 数据库连接是一样的 一个常用的属性是 configLocation，它用来指定 MyBatis 的 XML 配置文件路径。它在需要修改 MyBatis 的基础配置非常有用。通常，基础配置指的是 &lt; settings&gt; 或 &lt; typeAliases&gt;元素 需要注意的是，这个配置文件并不需要是一个完整的 MyBatis 配置。确切地说，任何环境配置（&lt;environments&gt;），数据源（&lt;DataSource&gt;）和 MyBatis 的事务管理器（&lt;transactionManager&gt;）都会被忽略。SqlSessionFactoryBean 会创建它自有的 MyBatis 环境配置（Environment），并按要求设置自定义环境的值。 SqlSessionTemplate 是 MyBatis-Spring 的核心。作为 SqlSession 的一个实现，这意味着可以使用它无缝代替你代码中已经在使用的 SqlSession。 模板可以参与到 Spring 的事务管理中，并且由于其是线程安全的，可以供多个映射器类使用，你应该总是用 SqlSessionTemplate 来替换 MyBatis 默认的 DefaultSqlSession 实现。在同一应用程序中的不同类之间混杂使用可能会引起数据一致性的问题。 可以使用 SqlSessionFactory 作为构造方法的参数来创建 SqlSessionTemplate 对象 123&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot; /&gt;&lt;/bean&gt; 现在，这个 bean 就可以直接注入到你的 DAO bean 中了。你需要在你的 bean 中添加一个 SqlSession 属性，就像下面这样 123456789101112public class UserDaoImpl implements UserDao &#123; private SqlSession sqlSession; public void setSqlSession(SqlSession sqlSession) &#123; this.sqlSession = sqlSession; &#125; public User getUser(String userId) &#123; return sqlSession.getMapper...; &#125;&#125; 按下面这样，注入 SqlSessionTemplate 123&lt;bean id=&quot;userDao&quot; class=&quot;org.mybatis.spring.sample.dao.UserDaoImpl&quot;&gt; &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot; /&gt;&lt;/bean&gt; 整合实现一初始准备 项目结构如下 实现思路 创建Maven工程并导入相关依赖包 创建好User实体类，UserMapper，UserMapper.xml后 创建mybatis-config.xml配置文件，主要写setting配置和别名设置 创建Spring-config.xml配置文件，在里面实现数据库连接以及SqlSession 创建beans.xml配置文件，用来管理Bean 创建UserMapper接口的实现类UserMapperImpl，注入到beans.xml配置文件中，这是与之前不同的地方，用来私有化sqlSessionTemplate，创建一些方法 User实体类 12345678package com.lzy.pojo;import lombok.Data;@Datapublic class User &#123; private int id; private String name; private String pwd;&#125; UserMapper 1234567package com.lzy.dao;import com.lzy.pojo.User;import java.util.List;public interface UserMapper &#123; public List&lt;User&gt; selectUser();&#125; UserMapper.xml 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.lzy.dao.UserMapper&quot;&gt; &lt;select id=&quot;selectUser&quot; resultType=&quot;User&quot;&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 创建mybatis-config.xml文件，主要用来进行别名管理和setting设置，可以看到其他功能已被Spring管理了 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!--用来别名管理和设置--&gt; &lt;settings&gt; &lt;!-- 打开延迟加载的开关 --&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;!-- 将积极加载改为消极加载（即按需加载） --&gt; &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt; &lt;!-- 打开全局缓存开关（二级缓存）默认值就是 true --&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;!--默认为类名首字母大写--&gt; &lt;package name=&quot;com.lzy.pojo&quot;/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; 有了 Spring 托管数据源，在 MyBatis 配置文件中仅仅需要关注性能化配置 核心配置 创建Spring-config.xml配置文件，核心配置文件，用来配置数据库连接和多个Bean 配置了一个名为 dataSrouce 的 bean 的信息，实际上是连接数据库的数据源 设置 sqlSessionFactory 的 bean 实现类为 MyBatis 与 Spring 整合 jar 包中的 SqlSessionFactoryBean 类，在其中只需要注入两个参数：一个是 MyBatis 的全局配置文件，一个是上面配置的数据源 bean 123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--配置数据源--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/bean&gt; &lt;!--配置sqlSessionFactory,关联MyBatis--&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!--数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!--加载MyBatis配置文件--&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;!--加载映射文件--&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/lzy/dao/*.xml&quot;/&gt; &lt;/bean&gt; &lt;!--注册sqlSessionTemplate , 关联sqlSessionFactory--&gt; &lt;!--sqlSessionTemplate就是我们使用的sqlSession--&gt; &lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt; &lt;!--只能利用构造器注入sqlSessionFactory,因为它没有set方法,index=0为第0个参数设置--&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 增加Dao接口的实现类；私有化sqlSessionTemplate 12345678910111213141516171819202122package com.lzy.dao;import com.lzy.pojo.User;import org.mybatis.spring.SqlSessionTemplate;import java.util.List;public class UserMapperImpl implements UserMapper &#123; //我们所有操作,在原来都使用sqlSession来执行 //现在都使用SqlSessionTemplate //sqlSession不用我们自己创建了，Spring来管理 private SqlSessionTemplate sqlSession; public void setSqlSession(SqlSessionTemplate sqlSession) &#123; this.sqlSession = sqlSession; &#125; @Override public List&lt;User&gt; selectUser() &#123; UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.selectUser(); &#125;&#125; 在beans.xml配置文件注册 123456&lt;!--导入Spring配置文件--&gt;&lt;import resource=&quot;Spring-config.xml&quot;/&gt;&lt;!--实现类注入到Spring--&gt;&lt;bean id=&quot;UserMapper&quot; class=&quot;com.lzy.dao.UserMapperImpl&quot;&gt; &lt;property name=&quot;sqlSession&quot; ref=&quot;sqlSession&quot;/&gt;&lt;/bean&gt; 测试 12345678910@Testpublic void selectUser() throws IOException&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); //从容器里那UserMapper,调其方法即可 UserMapper userMapper = context.getBean(&quot;UserMapper&quot;,UserMapper.class); for (User user : userMapper.selectUser()) &#123; System.out.println(user); &#125; &#125;&#125; 整合实现二 mybatis-spring1.2.3版以上的才有这个 UserDaoImpl继承SqlSessionDaoSupport类 , 直接利用 getSqlSession() 获得 , 然后直接注入SqlSessionFactory 比起方式1 , 不需要管理SqlSessionTemplate , 而且对事务的支持更加友好 ,可跟踪源码查看 以下为官方截图 新建一个UserMapperImpl2，也可以改下原来的UserMapperImpl 123456789101112package com.lzy.dao;import com.lzy.pojo.User;import org.mybatis.spring.support.SqlSessionDaoSupport;import java.util.List;public class UserMapperImpl2 extends SqlSessionDaoSupport implements UserMapper &#123; @Override public List&lt;User&gt; selectUser() &#123; UserMapper mapper = getSqlSession().getMapper(UserMapper.class); return mapper.selectUser(); &#125;&#125; 在beans.xml中进行注册 1234567&lt;!--导入Spring配置文件--&gt;&lt;import resource=&quot;Spring-config.xml&quot;/&gt;&lt;!--实现类注入到Spring--&gt;&lt;bean id=&quot;UserMapper2&quot; class=&quot;com.lzy.dao.UserMapperImpl2&quot;&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt; 测试类 123456789@Testpublic void selectUser() throws IOException&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); //从容器里那UserMapper,调其方法即可 UserMapper userMapper = context.getBean(&quot;UserMapper2&quot;,UserMapper.class); for (User user : userMapper.selectUser()) &#123; System.out.println(user); &#125;&#125; 总结 : 整合到spring以后可以完全不要mybatis的配置文件，除了这些方式可以实现整合之外，我们还可以使用注解来实现","path":"page/Spring08.html","date":"04-01","excerpt":"","tags":[{"name":"Spring","slug":"Spring","permalink":"http://xiaoliblog.cn/tags/Spring/"}]},{"title":"Spring🍃AOP面向切面编程","text":"AOP AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术 AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率 切面编程 参考👉细说Spring——AOP详解（AOP概览） 要理解切面编程，就需要先理解什么是切面。用刀把一个西瓜分成两瓣，切开的切口就是切面；炒菜，锅与炉子共同来完成炒菜，锅与炉子就是切面。web层级设计中，web层-&gt;网关层-&gt;服务层-&gt;数据层，每一层之间也是一个切面。编程中，对象与对象之间，方法与方法之间，模块与模块之间都是一个个切面 我们一般做活动的时候，一般对每一个接口都会做活动的有效性校验（是否开始、是否结束等等）、以及这个接口是不是需要用户登录。按照正常的逻辑，我们可以这么做。 这有个问题就是，有多少接口，就要多少次代码copy。这就导致无意义的重复工作，所以提出一个公共方法，每个接口都来调用这个接口。这里有点切面的味道了 同样有个问题，我虽然不用每次都copy代码了，但是，每个接口总得要调用这个方法吧。于是就有了切面的概念，我将方法注入到接口调用的某个地方（切点） 这样接口只需要关心具体的业务，而不需要关注其他非该接口关注的逻辑或处理。红框处，就是面向切面编程 AOP相关概念 AOP在Spring中的作用：提供声明式事务；允许用户自定义切面 横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 …. 术语 说明 切面ASPECT 横切关注点 被模块化 的特殊对象。即，它是一个类 通知Advice 切面必须要完成的工作。即，它是类中的一个方法 目标Target 被通知对象 代理Proxy 向目标对象应用通知之后创建的对象 切入点PointCut 切面通知 执行的 “地点”的定义 连接点JointPoint 与切入点匹配的执行点 SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice 通知类型 连接点 实现接口 前置通知 方法前 org.springframework.aop.MethodBeforeAdvice 后置通知 方法后 org.springframework.aop.AfterReturningAdvice 环绕通知 方法前后 org.aopalliance.intercept.MethodInterceptor 异常抛出通知 方法抛出异常 org.springframework.aop.ThrowsAdvice 引介通知 类中增加新的方法属性 org.springframework.aop.IntroductionInterceptor 带Spring标志的是Spring定义的扩展增强接口带aopalliance标志的是AOP联盟所定义的接口 Spring实现AOP环境搭建 使用AOP织入，需要导入一个依赖包！ 123456&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.5&lt;/version&gt;&lt;/dependency&gt; 首先编写我们的业务接口和实现类 123456public interface UserService &#123; void add(); void delete(); void update(); void query();&#125; 123456789101112131415161718192021public class UserServiceImpl implements UserService &#123; @Override public void add() &#123; System.out.println(&quot;增加了一个用户&quot;); &#125; @Override public void delete() &#123; System.out.println(&quot;删除了一个用户&quot;); &#125; @Override public void update() &#123; System.out.println(&quot;更新了一个用户&quot;); &#125; @Override public void query() &#123; System.out.println(&quot;查询了一个用户&quot;); &#125;&#125; Spring配置约束框架 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;&lt;/beans&gt; Spring API 实现 然后去写我们的增强类 , 我们编写两个 , 一个前置增强 一个后置增强 12345678910public class Log implements MethodBeforeAdvice &#123; //method : 要执行的目标对象的方法 //args : 被调用的方法的参数 //target : 目标对象 @Override public void before(Method method, Object[] args, Object target) throws Throwable &#123; System.out.println( target.getClass().getName() + &quot;的&quot; + method.getName() + &quot;方法被执行了&quot;); &#125;&#125; 123456789101112public class AfterLog implements AfterReturningAdvice &#123; //returnValue 返回值 //method被调用的方法 //args 被调用的方法的对象的参数 //target 被调用的目标对象 @Override public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123; System.out.println(&quot;执行了&quot; + target.getClass().getName() +&quot;的&quot;+method.getName()+&quot;方法,&quot; +&quot;返回值：&quot;+returnValue); &#125;&#125; 最后去spring的文件中注册 , 并实现aop切入实现 , 注意导入约束 . 12345678910111213&lt;!--注册bean--&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.lzy.service.UserServiceImpl&quot;/&gt;&lt;bean id=&quot;log&quot; class=&quot;com.lzy.log.Log&quot;/&gt;&lt;bean id=&quot;afterLog&quot; class=&quot;com.lzy.log.AfterLog&quot;/&gt;&lt;!--aop的配置--&gt;&lt;aop:config&gt; &lt;!--切入点 expression:表达式匹配要执行的方法 execution(要执行的位置)--&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.lzy.service.UserServiceImpl.*(..))&quot;/&gt; &lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt; &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt;&lt;/aop:config&gt; 测试类 123456789public class MyTest &#123; @Test public void test()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); //动态代理的是接口 UserService userService = (UserService) context.getBean(&quot;userService&quot;); userService.query(); &#125;&#125; Spring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理 . 自定义类实现AOP 目标业务类不变依旧是userServiceImpl 定义一个切入类 12345678public class DiyPointcut &#123; public void before()&#123; System.out.println(&quot;---------方法执行前---------&quot;); &#125; public void after()&#123; System.out.println(&quot;---------方法执行后---------&quot;); &#125;&#125; 去Spring配置 123456789101112131415161718192021&lt;!--注册bean--&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.lzy.service.UserServiceImpl&quot;/&gt;&lt;bean id=&quot;log&quot; class=&quot;com.lzy.log.Log&quot;/&gt;&lt;bean id=&quot;afterLog&quot; class=&quot;com.lzy.log.AfterLog&quot;/&gt;&lt;!--第二种方式自定义实现--&gt;&lt;!--注册bean--&gt;&lt;bean id=&quot;diy&quot; class=&quot;com.lzy.config.DiyPointcut&quot;/&gt;&lt;!--aop的配置--&gt;&lt;aop:config&gt; &lt;!--第二种方式：使用AOP的标签实现--&gt; &lt;!--自定义切面,ref为要引入的类--&gt; &lt;aop:aspect ref=&quot;diy&quot;&gt; &lt;!-- 切入点 --&gt; &lt;aop:pointcut id=&quot;diyPonitcut&quot; expression=&quot;execution(* com.lzy.service.UserServiceImpl.*(..))&quot;/&gt; &lt;!-- 通知 --&gt; &lt;aop:before pointcut-ref=&quot;diyPonitcut&quot; method=&quot;before&quot;/&gt; &lt;aop:after pointcut-ref=&quot;diyPonitcut&quot; method=&quot;after&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 测试类 12345678public class MyTest &#123; @Test public void test()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserService userService = (UserService) context.getBean(&quot;userService&quot;); userService.query(); &#125;&#125; 注解实现AOP 编写一个注解实现的增强类 1234567891011121314151617181920212223@Aspect //标注这是类是一个切面public class AnnotationPointcut &#123; //注解内容为切入点 @Before(&quot;execution(* com.lzy.service.UserServiceImpl.*(..))&quot;) public void before()&#123; System.out.println(&quot;---------方法执行前---------&quot;); &#125; @After(&quot;execution(* com.lzy.service.UserServiceImpl.*(..))&quot;) public void after()&#123; System.out.println(&quot;---------方法执行后---------&quot;); &#125; //在环绕增强中,我们可以给定一个参数,代表我们要获取处理切入的点 @Around(&quot;execution(* com.lzy.service.UserServiceImpl.*(..))&quot;) public void around(ProceedingJoinPoint jp) throws Throwable &#123; System.out.println(&quot;环绕前&quot;); System.out.println(&quot;签名:&quot;+jp.getSignature()); //执行目标方法proceed Object proceed = jp.proceed(); System.out.println(&quot;环绕后&quot;); System.out.println(proceed); &#125;&#125; 在Spring配置文件中，注册bean，并增加支持注解的配置 12345678&lt;!--注册bean--&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.lzy.service.UserServiceImpl&quot;/&gt;&lt;bean id=&quot;log&quot; class=&quot;com.lzy.log.Log&quot;/&gt;&lt;bean id=&quot;afterLog&quot; class=&quot;com.lzy.log.AfterLog&quot;/&gt;&lt;!--第三种方式:注解实现--&gt;&lt;bean id=&quot;annotationPointcut&quot; class=&quot;com.lzy.config.AnnotationPointcut&quot;/&gt;&lt;aop:aspectj-autoproxy/&gt; 通过aop命名空间的&lt;aop:aspectj-autoproxy /&gt;声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。当然，spring 在内部依旧采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的创建工作，但具体实现的细节已经被&lt;aop:aspectj-autoproxy /&gt;隐藏起来了 &lt;aop:aspectj-autoproxy /&gt;有一个proxy-target-class属性，默认为false，表示使用jdk动态代理织入增强，当配为&lt;aop:aspectj-autoproxy poxy-target-class=&quot;true&quot;/&gt;时，表示使用CGLib动态代理技术织入增强。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理","path":"page/Spring07.html","date":"03-31","excerpt":"","tags":[{"name":"Spring","slug":"Spring","permalink":"http://xiaoliblog.cn/tags/Spring/"}]},{"title":"Spring🍃静态/动态代理模式","text":"代理模式 代理模式：给目标对象提供一个代理对象，并由代理对象控制对目标对象的访问 通俗理解就是房屋中介的作用，你不能直接接触或不方便接触房东，但中介和房东都有相同的租房接口，所以，可以通过中介完成一系列的租房操作，不仅能帮助房东租房而且还有额外的带客户看房和签合同的功能 代理模式，其实就是将委托类融入到代理类里，换句话说，代理类也就是委托类的扩充而已 代理模式的作用 中介的作用，当调用者不能或不方便调用某个对象时，代理起到中介的作用，帮助调用者间接的调用对象 符合开闭原则，在不修改原有类代码的前提下，对类的功能进行增强 代理模式分类 静态代理：在运行前，通过编写代码的方式生成代理类 动态代理，在运行后，通过反射机制生成代理类 静态代理 静态代理角色分析 抽象角色 : 一般使用接口或者抽象类来实现 真实角色 : 被代理的角色 代理角色 : 代理真实角色 ; 代理真实角色后 , 一般会做一些附属的操作 . 客户 : 使用代理角色来进行一些操作 . 一个接口，两个实现类，代理实现类组合真实实现类，一个使用代理类 代码实现 Rent.java 即抽象角色，房东和中介共同的接口 1234//抽象角色：租房public interface Rent &#123; public void rent();&#125; Host.java 即真实角色房东 1234567//真实角色: 房东，房东要出租房子public class Host implements Rent&#123; @Override public void rent()&#123; System.out.println(&quot;房东要出租房子&quot;); &#125;&#125; Proxy.java 即代理角色中介 123456789101112131415161718192021222324////代理角色：中介public class Proxy implements Rent&#123; private Host host; public Proxy()&#123; &#125; public Proxy(Host host)&#123; this.host=host; &#125; //租房 @Override public void rent()&#123; seeHouse(); host.rent(); fare(); &#125; //看房 public void seeHouse()&#123; System.out.println(&quot;带房客看房&quot;); &#125; //收中介费 public void fare()&#123; System.out.println(&quot;收中介费&quot;); &#125;&#125; Client.java 即客户 1234567891011//客户类，一般客户都会去找代理！public class Client &#123; public static void main(String[] args) &#123; //房东要租房 Host host = new Host(); //中介帮助房东,代理一般会有一些附属操作 Proxy proxy = new Proxy(host); //你去找中介！ proxy.rent(); &#125;&#125; 分析：在这个过程中，你直接接触的就是中介，就如同现实生活中的样子，你看不到房东，但是你依旧租到了房东的房子通过代理，这就是所谓的代理模式，程序源自于生活，所以学编程的人，一般能够更加抽象的看待生活中发生的事情 静态代理的好处 可以使得我们的真实角色更加纯粹 ， 不再去关注一些公共的事情 . 公共的业务由代理来完成 ，实现了业务的分工 , 公共业务发生扩展时变得更加集中和方便 . 静态代理的缺点 类多了 , 多了代理类 , 工作量变大了 ，开发效率降低 . 我们想要静态代理的好处，又不想要静态代理的缺点，所以 , 就有了动态代理 ! 深化理解 创建一个抽象角色，比如咋们平时做的用户业务，抽象起来就是增删改查！ 1234567//抽象角色：增删改查业务public interface UserService &#123; void add(); void delete(); void update(); void query();&#125; 我们需要一个真实对象来完成这些增删改查操作 12345678910111213141516171819//真实对象，完成增删改查操作的人public class UserServiceImpl implements UserService &#123; public void add() &#123; System.out.println(&quot;增加了一个用户&quot;); &#125; public void delete() &#123; System.out.println(&quot;删除了一个用户&quot;); &#125; public void update() &#123; System.out.println(&quot;更新了一个用户&quot;); &#125; public void query() &#123; System.out.println(&quot;查询了一个用户&quot;); &#125;&#125; 需求来了，现在我们需要增加一个日志功能，怎么实现！ 思路1 ：在实现类上增加代码 【麻烦！】 思路2：使用代理来做，能够不改变原来的业务情况下，实现此功能就是最好的了！ 设置一个代理类来处理日志！代理角色 123456789101112131415161718192021222324252627282930313233//代理角色，在这里面增加日志的实现public class UserServiceProxy implements UserService &#123; private UserServiceImpl userService; public void setUserService(UserServiceImpl userService) &#123; this.userService = userService; &#125; public void add() &#123; log(&quot;add&quot;); userService.add(); &#125; public void delete() &#123; log(&quot;delete&quot;); userService.delete(); &#125; public void update() &#123; log(&quot;update&quot;); userService.update(); &#125; public void query() &#123; log(&quot;query&quot;); userService.query(); &#125; public void log(String msg)&#123; System.out.println(&quot;执行了&quot;+msg+&quot;方法&quot;); &#125;&#125; 测试访问类 123456789101112public class Client &#123; public static void main(String[] args) &#123; //真实业务 UserServiceImpl userService = new UserServiceImpl(); //代理类 UserServiceProxy proxy = new UserServiceProxy(); //使用代理类实现日志功能！ proxy.setUserService(userService); proxy.add(); &#125;&#125; 我们在不改变原来的代码的情况下，实现了对原有功能的增强，这是AOP中最核心的思想 AOP：纵向开发-&gt;横向开发 动态代理 动态代理的角色和静态代理的一样 动态代理的代理类是动态生成的， 静态代理的代理类是我们提前写好的 动态代理分为两类 : 一类是基于接口动态代理 , 一类是基于类的动态代理 基于接口的动态代理：JDK动态代理 基于类的动态代理：CGlib字节码动态代理 现在用的比较多的是 javasist 来生成动态代理，网址：http://www.javassist.org/ 参考Spring AOP的底层实现-代理模式 动态代理的好处 静态代理有的它都有，静态代理没有的，它也有！ 可以使得我们的真实角色更加纯粹 ，不再去关注一些公共的事情 . 公共的业务由代理来完成 ， 实现了业务的分工 , 公共业务发生扩展时变得更加集中和方便 . 一个动态代理 , 一般代理某一类业务 一个动态代理可以代理多个类，代理的是接口！ JDK动态代理 JDK动态代理是使用 java.lang.reflect包下的代理类来实现，JDK动态代理动态代理必须要有接口 动态代理就是为了解决静态代理不灵活的缺陷而产生的。静态代理是固定的，一旦确定了代码，如果委托类新增一个方法，而这个方法又需要增强，那么就必须在代理类里重写一个带增强的方法。而动态代理可以灵活替换代理方法，动态就是体现在这里 接口和类 JDK的动态代理需要了一个接口InvocationHandler 和类 Proxy InvocationHandler是由代理实例的调用处理程序实现的接口 每个代理实例都有一个关联的调用处理程序。当在代理实例上调用方法时，方法调用被编码并分派到其调用处理程序的invoke方法 12345Object invoke(Object proxy, 方法 method, Object[] args)；//参数//proxy - 调用该方法的代理实例//method -所述方法对应于调用代理实例上的接口方法的实例。方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口。//args -包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean 。 Proxy提供了创建动态代理类和实例的静态方法，它也是由这些方法创建的所有动态代理类的超类 每个代理实例都有一个关联的调用处理程序对象，它实现了接口InvocationHandler 代码实现 抽象角色和真实角色和之前的一样！ Rent.java 即抽象角色 1234//抽象角色：租房public interface Rent &#123; public void rent();&#125; Host.java 即真实角色 123456//真实角色: 房东，房东要出租房子public class Host implements Rent&#123; public void rent() &#123; System.out.println(&quot;房屋出租&quot;); &#125;&#125; ProxyInvocationHandler.java 即代理角色 123456789101112131415161718192021222324252627282930313233343536//用这个类，自动生成代理类public class ProxyInvocationHandler implements InvocationHandler &#123; //被代理的接口 private Rent rent; public void setRent(Rent rent) &#123; this.rent = rent; &#125; //生成代理类，重点是第二个参数，获取要代理的抽象角色！之前都是一个角色，现在可以代理一类角色 public Object createProxy()&#123; return Proxy.newProxyInstance(this.getClass().getClassLoader(), rent.getClass().getInterfaces(),this); &#125; // proxy : 代理类 method : 代理类的调用处理程序的方法对象. // 处理代理实例上的方法调用并返回结果 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; seeHouse(); //核心：本质利用反射实现！ Object result = method.invoke(rent, args); fare(); return result; &#125; //看房 public void seeHouse()&#123; System.out.println(&quot;带房客看房&quot;); &#125; //收中介费 public void fare()&#123; System.out.println(&quot;收中介费&quot;); &#125;&#125; Client.java即客户 1234567891011121314//租客public class Client &#123; public static void main(String[] args) &#123; //真实角色 Host host = new Host(); //代理实例的调用处理程序 ProxyInvocationHandler pih = new ProxyInvocationHandler(); pih.setRent(host); //将真实角色放置进去！ Rent proxy = (Rent)pih.createProxy(); //动态生成对应的代理类！ proxy.rent(); &#125;&#125; 核心：一个动态代理 , 一般代理某一类业务 , 一个动态代理可以代理多个类，代理的是接口！ 深化理解 使用动态代理实现代理我们后面写的UserService！ 1234567//抽象角色：增删改查业务public interface UserService &#123; void add(); void delete(); void update(); void query();&#125; 12345678910111213141516171819//真实对象，完成增删改查操作的人public class UserServiceImpl implements UserService &#123; public void add() &#123; System.out.println(&quot;增加了一个用户&quot;); &#125; public void delete() &#123; System.out.println(&quot;删除了一个用户&quot;); &#125; public void update() &#123; System.out.println(&quot;更新了一个用户&quot;); &#125; public void query() &#123; System.out.println(&quot;查询了一个用户&quot;); &#125;&#125; 编写一个通用的动态代理实现的类！所有的代理对象设置为Object即可！ 1234567891011121314151617181920212223242526272829//用这个类，自动生成代理类public class ProxyInvocationHandler implements InvocationHandler &#123; //被代理的接口 private Object target; public void setTarget(Object target) &#123; this.target = target; &#125; //生成代理类 public Object createProxy()&#123; return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(),this); &#125; // proxy : 代理类 // method : 代理类的调用处理程序的方法对象. //处理代理实例，并返回结果 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; log(method.getName()); Object result = method.invoke(target, args); return result; &#125; public void log(String methodName)&#123; System.out.println(&quot;执行了&quot;+methodName+&quot;方法&quot;); &#125;&#125; 测试！ 12345678910public class Test &#123; public static void main(String[] args) &#123; //真实对象 UserServiceImpl userService = new UserServiceImpl(); //代理对象的调用处理程序 ProxyInvocationHandler pih = new ProxyInvocationHandler(); pih.setTarget(userService); //设置要代理的对象 UserService proxy = (UserService)pih.createProxy(); //动态生成代理类！ proxy.delete();&#125; CGlib动态代理 JDK动态代理必须要有接口，但如果要代理一个没有接口的类该怎么办呢? 这时我们可以使用CGLIB动态代理，CGLIB动态代理的原理是生成目标类的子类，这个子类对象就是代理对象，代理对象是被增强过的 CGlib包在Spring core包里， 注意: 不管有没有接口都可以使用CGLIB动态代理, 而不是只有在无接口的情况下才能使用 12345public class CGlibTaretClass &#123; public void sayHello()&#123; System.out.println(&quot;我是CGlib,我不需要接口&quot;); &#125;&#125; 12345678910111213141516171819202122232425package CGlibProxyTest;import org.springframework.cglib.proxy.Enhancer;import org.springframework.cglib.proxy.MethodInterceptor;import org.springframework.cglib.proxy.MethodProxy;import java.lang.reflect.Method;public class CGlibProxy implements MethodInterceptor&#123; //代理方法 public Object createProxy(Object target)&#123; //创建一个动态类对象 Enhancer enhancer = new Enhancer(); //确定要增强的类,设置其父类 enhancer.setSuperclass(target.getClass()); //添加回调函数 enhancer.setCallback(this); //返回创建的代理类 return enhancer.create(); &#125; public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println(&quot;CGlib前置增强&quot;); Object obj = methodProxy.invokeSuper(o,objects); System.out.println(&quot;CGlib后置增强&quot;); return obj; &#125;&#125; 1234567public class Test &#123; public static void main(String[] args) &#123; CGlibProxy cGlibProxy = new CGlibProxy(); CGlibTaretClass cGlibTaretClass = new CGlibTaretClass(); CGlibTaretClass cGlibTaretClass1 = (CGlibTaretClass)cGlibProxy.createProxy(cGlibTaretClass); cGlibTaretClass1.sayHello(); &#125;","path":"page/Spring06.html","date":"03-31","excerpt":"","tags":[{"name":"Spring","slug":"Spring","permalink":"http://xiaoliblog.cn/tags/Spring/"}]},{"title":"Spring🍃使用注解开发","text":"注解开发 在spring4之后，想要使用注解形式，必须得要引入aop的包，一般导入webmvc就包含了aop的包 在配置文件当中，还得要引入一个context约束，增加注解支持 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--开启注解支持--&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; Bean的实现 @Component：组件，放在类上，说明这个类被Spring管理了，就是Bean 配置扫描哪些包下的注解 12&lt;!--指定要扫描的包,这个包下的注解就会生效--&gt;&lt;context:component-scan base-package=&quot;com.lzy.pojo&quot;/&gt; 在指定包com.lzy.pojo下编写类，增加注解 12345// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;@Component(&quot;user&quot;)public class User &#123; public String name = &quot;李白&quot;;&#125; 测试 1234567public class test &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); User user = context.getBean(&quot;user&quot;, User.class); System.out.println(user.name); &#125;&#125; 属性注入 可以不用提供set方法，直接在直接名上添加@value(&quot;值&quot;) 1234567// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;@Component(&quot;user&quot;)public class User &#123; // 相当于配置文件中 &lt;property name=&quot;name&quot; value=&quot;李白&quot;/&gt; @Value(&quot;李白&quot;) public String name;&#125; 也可以在set方法上添加注解 1234567@Component(&quot;user&quot;)public class User &#123; public String name; @Value(&quot;李白&quot;) public void setName(String name) &#123; this.name = name; &#125; 衍生注解 这些注解，就是替代了在配置文件当中配置步骤而已！更加的方便快捷！ @Component有三个衍生注解，我们在Web开发中，会按照MVC三层架构分层！ @Controller：web层 @Service：service层 @Repository：dao层 这四个注解功能都是一样的，都是代表将某个类注册的Spring中，装配Bean，就相当于将这个类交给Spring管理装配了！ 1234567package com.lzy.dao;import org.springframework.stereotype.Repository;@Repositorypublic class UserDao &#123;&#125; 1234567package com.lzy.service;import org.springframework.stereotype.Service;@Servicepublic class UserService &#123;&#125; 1234567package com.lzy.controller;import org.springframework.stereotype.Controller;@Controllerpublic class UserController &#123;&#125; 作用域 @scope singleton：默认的，Spring会采用单例模式创建这个对象。关闭工厂 ，所有的对象都会销毁。 prototype：多例模式。关闭工厂 ，所有的对象不会销毁。内部的垃圾回收机制会回收 123456@Component(&quot;user&quot;)@Scope(&quot;prototype&quot;)public class User &#123; @Value(&quot;李白&quot;) public String name;&#125; 总结 XML与注解比较 XML可以适用任何场景 ，结构清晰，维护方便 注解不是自己提供的类使用不了，开发简单方便 xml与注解整合开发 ：推荐最佳实践 xml管理Bean 注解完成属性注入 使用过程中， 可以不用扫描，扫描是为了类上的注解 1&lt;context:annotation-config/&gt; 以上语句作用 进行注解驱动注册，从而使注解生效 用于激活那些已经在spring容器里注册过的bean上面的注解，也就是显示的向Spring注册 如果不扫描包，就需要手动配置bean 如果不加注解驱动，则注入的值为null！ JavaConfig JavaConfig 原来是 Spring 的一个子项目，它通过 Java 类的方式提供 Bean 的定义信息，在 Spring4 的版本， JavaConfig 已正式成为 Spring4 的核心功能 基于Java类进行配置 使用Java的方式配置Spring，完全不需要Spring的xml配置，全权交给Java来做 编写一个实体类Dog 1234@Component //将这个类标注为Spring的一个组件，放到容器中！public class Dog &#123; public String name = &quot;哈士奇&quot;;&#125; 新建一个config配置包，编写一个MyConfig配置类 123456789//这个也会被Spring容器托管,其本身就是一个@Component//@Configuration代表这是一个配置类,相当于Beans.xml配置文件@Configurationpublic class MyConfig &#123; @Bean //通过方法注册一个bean，这里的返回值就Bean的类型，方法名就是bean的id！ public Dog dog()&#123; return new Dog(); &#125;&#125; 测试 12345678public class test &#123; public static void main(String[] args) &#123; //如果使用配置类方式,就只能通过AnnotationConfig上下文来获取容器,通过配置类的class对象加载！ ApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class); Dog dog = context.getBean(&quot;dog&quot;,Dog.class); System.out.println(dog.name); &#125;&#125; 导入其他配置类 再编写一个配置类MyConfig2 1234@Configurationpublic class MyConfig2 &#123;&#125; 在之前的配置MyConfig类中我们来选择导入这个配置类MyConfig2 12345678@Configuration //代表这是一个配置类@Import(MyConfig2.class) //导入合并其他配置类，类似于配置文件中的 inculde 标签public class MyConfig &#123; @Bean //通过方法注册一个bean，这里的返回值就Bean的类型，方法名就是bean的id！ public Dog dog()&#123; return new Dog(); &#125;&#125;","path":"page/Spring05.html","date":"03-30","excerpt":"","tags":[{"name":"Spring","slug":"Spring","permalink":"http://xiaoliblog.cn/tags/Spring/"}]},{"title":"Spring🍃自动装配","text":"Bean的自动装配 自动装配是使用spring满足bean依赖的一种方法，spring会在应用上下文中为某个bean寻找其依赖的bean Spring中bean有三种装配机制，分别是： 在xml中显式配置 在java中显式配置 隐式的bean发现机制和自动装配 Spring的自动装配需要从两个角度来实现，或者说是两个操作： 组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean； 自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC/DI； 组件扫描和自动装配组合发挥巨大威力，使得显示的配置降低到最少 推荐不使用自动装配xml配置 , 而使用注解 测试环境搭建 新建两个实体类，Cat Dog 都有一个shout()的方法 1234567package com.lzy.autowiring;public class Cat &#123; public void shout()&#123; System.out.println(&quot;miao~&quot;); &#125;&#125; 1234567package com.lzy.autowiring;public class Dog &#123; public void shout()&#123; System.out.println(&quot;wang~&quot;); &#125;&#125; 新建一个用户类User 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.lzy.autowiring;public class People &#123; private Cat cat; private Dog dog; private String name; public People() &#123; &#125; public People(Cat cat, Dog dog, String name) &#123; this.cat = cat; this.dog = dog; this.name = name; &#125; public Cat getCat() &#123; return cat; &#125; public void setCat(Cat cat) &#123; this.cat = cat; &#125; public Dog getDog() &#123; return dog; &#125; public void setDog(Dog dog) &#123; this.dog = dog; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;People&#123;&quot; + &quot;cat=&quot; + cat + &quot;, dog=&quot; + dog + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 编写Spring配置文件 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;dog&quot; class=&quot;com.lzy.autowiring.Dog&quot;/&gt; &lt;bean id=&quot;cat&quot; class=&quot;com.lzy.autowiring.Cat&quot;/&gt; &lt;bean id=&quot;people&quot; class=&quot;com.lzy.autowiring.People&quot; autowire=&quot;byName&quot;&gt; &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;/&gt; &lt;property name=&quot;dog&quot; ref=&quot;dog&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;李白&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类 1234567@Testpublic void test()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;autoBean.xml&quot;); People people = context.getBean(&quot;people&quot;,People.class); people.getCat().shout(); people.getDog().shout();&#125; byName autowire byName (按名称自动装配) 由于在手动配置xml过程中，常常发生字母缺漏和大小写等错误，而无法对其进行检查，使得开发效率降低。采用自动装配将避免这些错误，并且使配置简单化 修改bean配置，增加一个属性 autowire=&quot;byName&quot; 123456&lt;bean id=&quot;dog&quot; class=&quot;com.lzy.autowiring.Dog&quot;/&gt;&lt;bean id=&quot;cat&quot; class=&quot;com.lzy.autowiring.Cat&quot;/&gt;&lt;!--byName 会自动在容器上下文中查找和自己对象set方法后面的值对应的beanid！--&gt;&lt;bean id=&quot;people&quot; class=&quot;com.lzy.autowiring.People&quot; autowire=&quot;byName&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;李白&quot;/&gt;&lt;/bean&gt; 再次测试，结果依旧成功输出！ 如果将 cat 的bean id修改为catXXX 再次测试， 执行时报空指针java.lang.NullPointerException。因为按byName规则找不对应set方法，真正的setCat就没执行，对象就没有初始化，所以调用时就会报空指针错误 小结 当一个bean节点带有 autowire byName的属性时 将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat 去spring容器中寻找是否有此字符串名称id的对象 如果有，就取出注入；如果没有，就报空指针异常 byType autowire byType (按类型自动装配) 使用autowire byType首先需要保证：同一类型的对象，在spring容器中唯一。如果不唯一，会报不唯一的异常 1NoUniqueBeanDefinitionException 将people的bean配置修改一下 ： autowire=&quot;byType&quot; 123456&lt;bean id=&quot;dog&quot; class=&quot;com.lzy.autowiring.Dog&quot;/&gt;&lt;bean id=&quot;cat&quot; class=&quot;com.lzy.autowiring.Cat&quot;/&gt;&lt;!--byType 会自动在容器上下文中查找对应的class值！--&gt;&lt;bean id=&quot;people&quot; class=&quot;com.lzy.autowiring.People&quot; autowire=&quot;byType&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;李白&quot;/&gt;&lt;/bean&gt; 测试，正常输出 在注册一个cat 的bean对象！ 123456&lt;bean id=&quot;dog&quot; class=&quot;com.lzy.autowiring.Dog&quot;/&gt;&lt;bean id=&quot;cat&quot; class=&quot;com.lzy.autowiring.Cat&quot;/&gt;&lt;bean id=&quot;cat2&quot; class=&quot;com.lzy.autowiring.Cat&quot;/&gt;&lt;bean id=&quot;people&quot; class=&quot;com.lzy.autowiring.People&quot; autowire=&quot;byType&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;李白&quot;/&gt;&lt;/bean&gt; 测试，报错：NoUniqueBeanDefinitionException byname的时候，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致!bytype的时候，需要保证所有bean的class唯一 ，并且这个bean需要和自动注入的属性的类型一致! 注解自动装配 jdk1.5开始支持注解，spring2.5开始全面支持注解 准备工作：利用注解的方式注入属性。 在spring配置文件中引入context文件头 1234xmlns:context=&quot;http://www.springframework.org/schema/context&quot;http://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd 完整约束 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;&lt;/beans&gt; 开启属性注解支持！ 1&lt;context:annotation-config/&gt; @Autowired @Autowired是按类型自动转配的，不支持id匹配 需要导入 spring-aop的包！ 直接在属性或者set方法上使用即可 1234567 @Autowiredprivate Dog dog;//或者@Autowiredpublic void setDog(Dog dog) &#123; this.dog = dog;&#125; 使用Autowired可以不用编写Set方法，前提是你这个自动装配的属性在IOC(Spring)容器中存在 比如将People类中的set方法去掉，使用@Autowired注解 12345678910111213141516171819package com.lzy.annotation;public class People &#123; @Autowired private Cat cat; @Autowired private Dog dog; private String name; public Cat getCat() &#123; return cat; &#125; public Dog getDog() &#123; return dog; &#125; public String getStr() &#123; return str; &#125;&#125; 配置文件内容 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--开启注解支持--&gt; &lt;context:annotation-config/&gt; &lt;bean id=&quot;dog&quot; class=&quot;com.lzy.annotation.Dog&quot;/&gt; &lt;bean id=&quot;cat&quot; class=&quot;com.lzy.annotation.Cat&quot;/&gt; &lt;bean id=&quot;people&quot; class=&quot;com.lzy.annotation.People&quot;/&gt;&lt;/beans&gt; 测试，成功输出结果！ @Autowired(required=false) 说明： false，对象可以为null； true，对象必须存对象，不能为null 123//如果允许对象为null，设置required = false,默认为true@Autowired(required = false)private Cat cat; @Qualifier @Autowired是根据类型自动装配的，加上@Qualifier则可以根据byName的方式自动装配 @Qualifier不能单独使用 修改配置文件，保证类型存在对象。且名字不为类的默认名字 1234567&lt;!--开启注解支持--&gt;&lt;context:annotation-config/&gt;&lt;bean id=&quot;dog1&quot; class=&quot;com.lzy.annotation.Dog&quot;/&gt;&lt;bean id=&quot;dog2&quot; class=&quot;com.lzy.annotation.Dog&quot;/&gt;&lt;bean id=&quot;cat1&quot; class=&quot;com.lzy.annotation.Cat&quot;/&gt;&lt;bean id=&quot;cat2&quot; class=&quot;com.lzy.annotation.Cat&quot;/&gt;&lt;bean id=&quot;people&quot; class=&quot;com.lzy.annotation.People&quot;/&gt; 没有加Qualifier测试，直接报错 在属性上添加Qualifier注解 123456@Autowired@Qualifier(value = &quot;cat2&quot;)private Cat cat;@Autowired@Qualifier(value = &quot;dog2&quot;)private Dog dog; 测试，成功输出！ Qualifier注解可以显示指定某个装配的ID，前提是类型一致 @Resource @Resource如有指定的name属性，先按该属性进行byName方式查找装配 其次再进行默认的byName方式进行装配 如果以上都不成功，则按byType的方式自动装配 都不成功，则报异常，@Resource相当于一个组合注解 修改实体类 12345678public class People &#123; //如果允许对象为null，设置required = false,默认为true @Resource(name = &quot;cat2&quot;) private Cat cat; @Resource private Dog dog; private String name;&#125; 配置文件 123456&lt;!--开启注解支持--&gt;&lt;context:annotation-config/&gt;&lt;bean id=&quot;dog&quot; class=&quot;com.lzy.annotation.Dog&quot;/&gt;&lt;bean id=&quot;cat1&quot; class=&quot;com.lzy.annotation.Cat&quot;/&gt;&lt;bean id=&quot;cat2&quot; class=&quot;com.lzy.annotation.Cat&quot;/&gt;&lt;bean id=&quot;people&quot; class=&quot;com.lzy.annotation.People&quot;/&gt; 测试：结果OK 再修改配置文件 1234&lt;!--开启注解支持--&gt;&lt;context:annotation-config/&gt;&lt;bean id=&quot;dog&quot; class=&quot;com.lzy.annotation.Dog&quot;/&gt;&lt;bean id=&quot;cat1&quot; class=&quot;com.lzy.annotation.Cat&quot;/&gt; 实体类上只保留注解 1234@Resourceprivate Cat cat;@Resourceprivate Dog dog; 测试：结果OK 结论：先进行byName查找，失败；再进行byType查找，成功。 小结 @Autowired与@Resource都可以用来装配bean。都可以写在字段上，或写在setter方法上。 @Autowired默认按类型装配（属于spring规范），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用 @Resource（属于J2EE复返），默认按照名称进行装配，名称可以通过name属性进行指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。 它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired先byType，@Resource先byName。","path":"page/Spring04.html","date":"03-30","excerpt":"","tags":[{"name":"Spring","slug":"Spring","permalink":"http://xiaoliblog.cn/tags/Spring/"}]},{"title":"Spring🍃依赖注入DI","text":"DI概述 依赖注入（Dependency Injection,DI）。 依赖 : 指Bean对象的创建依赖于容器，Bean对象的依赖资源 . 注入 : 指Bean对象所依赖的资源 ，由容器来设置和装配 注入重点为以下两种 构造器注入（前面已经介绍过） Set注入【重点】 Set 注入 要求被注入的属性 , 必须有set方法 , set方法的方法名由set + 属性首字母大写 , 如果属性是boolean类型 , 没有set方法 , 是is . 在com.lzy.pojo包下创建Address类 1234567891011121314package com.lzy.pojo;public class Address &#123; private String address; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; 在com.lzy.pojo包下创建Student实体类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.lzy.pojo;import java.util.List;import java.util.Map;import java.util.Properties;import java.util.Set;public class Student &#123; private String name; private Address address; private String[] books; private List&lt;String&gt; hobbys; private Map&lt;String,String&gt; card; private Set&lt;String&gt; games; private String wife; private Properties info; //name属性没有get方法，就无法注入 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setAddress(Address address) &#123; this.address = address; &#125; public void setBooks(String[] books) &#123; this.books = books; &#125; public void setHobbys(List&lt;String&gt; hobbys) &#123; this.hobbys = hobbys; &#125; public void setCard(Map&lt;String, String&gt; card) &#123; this.card = card; &#125; public void setGames(Set&lt;String&gt; games) &#123; this.games = games; &#125; public void setWife(String wife) &#123; this.wife = wife; &#125; public void setInfo(Properties info) &#123; this.info = info; &#125; public void show()&#123; System.out.println(&quot;name=&quot;+ name + &quot;,address=&quot;+ address.getAddress() + &quot;,books=&quot; ); for (String book:books)&#123; System.out.print(&quot;&lt;&lt;&quot;+book+&quot;&gt;&gt;\\t&quot;); &#125; System.out.println(&quot;\\n爱好:&quot;+hobbys); System.out.println(&quot;card:&quot;+card); System.out.println(&quot;games:&quot;+games); System.out.println(&quot;wife:&quot;+wife); System.out.println(&quot;info:&quot;+info); &#125;&#125; 常量注入123&lt;bean id=&quot;student&quot; class=&quot;com.kuang.pojo.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;&lt;/bean&gt; 123456789public class test &#123; @Test public void test()&#123; //解析beans.xml文件 , 生成管理相应的Bean对象 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); Student student = (Student)context.getBean(&quot;student&quot;); System.out.println(student.getName()); &#125;&#125; Bean注入注意点：这里的值是一个引用ref 12345678&lt;bean id=&quot;addr&quot; class=&quot;com.lzy.pojo.Address&quot;&gt; &lt;property name=&quot;address&quot; value=&quot;重庆&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;student&quot; class=&quot;com.lzy.pojo.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt; &lt;property name=&quot;address&quot; ref=&quot;addr&quot;/&gt;&lt;/bean&gt; 其他变量注入123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;bean id=&quot;addr&quot; class=&quot;com.lzy.pojo.Address&quot;&gt; &lt;property name=&quot;address&quot; value=&quot;重庆&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;student&quot; class=&quot;com.lzy.pojo.Student&quot;&gt;&lt;!--常量注入--&gt; &lt;property name=&quot;name&quot; value=&quot;李白&quot;/&gt;&lt;!--Bean注入--&gt; &lt;property name=&quot;address&quot; ref=&quot;addr&quot;/&gt;&lt;!--数组注入--&gt; &lt;property name=&quot;books&quot;&gt; &lt;array&gt; &lt;value&gt;西游记&lt;/value&gt; &lt;value&gt;红楼梦&lt;/value&gt; &lt;value&gt;水浒传&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;!--List注入--&gt; &lt;property name=&quot;hobbys&quot;&gt; &lt;list&gt; &lt;value&gt;听歌&lt;/value&gt; &lt;value&gt;看电影&lt;/value&gt; &lt;value&gt;爬山&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--Map注入--&gt; &lt;property name=&quot;card&quot;&gt; &lt;map&gt; &lt;entry key=&quot;中国邮政&quot; value=&quot;456456456465456&quot;/&gt; &lt;entry key=&quot;建设&quot; value=&quot;1456682255511&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--set注入--&gt; &lt;property name=&quot;games&quot;&gt; &lt;set&gt; &lt;value&gt;LOL&lt;/value&gt; &lt;value&gt;BOB&lt;/value&gt; &lt;value&gt;COC&lt;/value&gt; &lt;/set&gt; &lt;/property&gt;&lt;!--Null注入--&gt; &lt;property name=&quot;wife&quot;&gt;&lt;null/&gt;&lt;/property&gt;&lt;!--Properties注入--&gt; &lt;property name=&quot;info&quot;&gt; &lt;props&gt; &lt;prop key=&quot;学号&quot;&gt;20190604&lt;/prop&gt; &lt;prop key=&quot;性别&quot;&gt;男&lt;/prop&gt; &lt;prop key=&quot;姓名&quot;&gt;小明&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 运行结果 扩展方式注入 在com.lzy.pojo包下，创建User实体类 123456789101112131415161718192021package com.lzy.pojo;public class User &#123; private String name; private int age; public void setName(String name) &#123; this.name = name; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 【注意：这里没有有参构造器！】 P命名空间注入 : 需要在头文件中加入约束文件 1xmlns:p=&quot;http://www.springframework.org/schema/p&quot; 12&lt;!--P(属性: properties)命名空间 , 属性依然要设置set方法--&gt;&lt;bean id=&quot;user&quot; class=&quot;com.lzy.pojo.User&quot; p:name=&quot;李白&quot; p:age=&quot;18&quot;/&gt; C命名空间注入 : 需要在头文件中加入约束文件 1xmlns:c=&quot;http://www.springframework.org/schema/c&quot; 12&lt;!--C(构造: Constructor)命名空间 , 属性依然要设置set方法--&gt;&lt;bean id=&quot;user1&quot; class=&quot;com.lzy.pojo.User&quot; c:name=&quot;李四&quot; c:age=&quot;21&quot;/&gt; 发现问题：爆红了，刚才我们没有写有参构造！解决：把有参构造器加上，这里也能知道，c 就是所谓的构造器注入！ 1234567//加入无参和有参构造public User() &#123;&#125;public User(String name, int age) &#123; this.name = name; this.age = age;&#125; 测试代码 12345678910@Testpublic void test1()&#123; //解析beans.xml文件 , 生成管理相应的Bean对象 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;userBean.xml&quot;); //User.class就不要强转了 User user = context.getBean(&quot;user&quot;,User.class); User user1 = context.getBean(&quot;user1&quot;,User.class); System.out.println(user); System.out.println(user1);&#125; 注意点：P命名和C命名空间不能直接使用，需要导入xml约束！ 12xmlns:p=&quot;http://www.springframework.org/schema/p&quot;xmlns:c=&quot;http://www.springframework.org/schema/c&quot; Bean的作用域 在Spring中，那些组成应用程序的主体及由Spring IoC容器所管理的对象，被称之为bean。简单地讲，bean就是由IoC容器初始化、装配及管理的对象 Bean作用域用于确定哪种类型的bean实例应该从Spring容器中返回给调用者，详情请看官方文档 作用域 描述 singleton 在spring IoC容器仅存在一个Bean实例，Bean以单例方式存在，bean作用域范围的默认值 prototype 每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行newXxxBean() request 每次HTTP请求都会创建一个新的Bean，该作用域仅适用于web的Spring WebApplicationContext环境 session 同一个HTTP Session共享一个Bean，不同Session使用不同的Bean。该作用域仅适用于web的Spring WebApplicationContext环境 application 限定一个Bean的作用域为ServletContext的生命周期。该作用域仅适用于web的Spring WebApplicationContext环境 几种作用域中，request、session作用域仅在基于web的应用中使用（不必关心你所采用的是什么web应用框架），只能用在基于web的Spring ApplicationContext环境 Singleton 当一个bean的作用域为Singleton，那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例 Singleton是单例类型，就是在创建起容器时就同时自动创建了一个bean的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。注意，Singleton作用域是Spring中的缺省作用域。要在XML中将bean显示定义成singleton，可以这样配置： 1234&lt;!-- A bean definition with singleton scope --&gt;&lt;bean id=&quot;...&quot; class=&quot;...&quot; scope=&quot;singleton&quot;&gt; &lt;!-- collaborators and configuration for this bean go here --&gt;&lt;/bean&gt; 测试结果为true，说明是同一个对象 1234567@Testpublic void test()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); User user = (User) context.getBean(&quot;user&quot;); User user2 = (User) context.getBean(&quot;user&quot;); System.out.println(user==user2); //为ture&#125; Prototype 当一个bean的作用域为Prototype，表示一个bean定义对应多个对象实例。Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的bean实例 Prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象 根据经验，对有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用singleton作用域。在XML中将bean定义成prototype，可以这样配置： 123 &lt;bean id=&quot;...&quot; class=&quot;...&quot; scope=&quot;prototype&quot;/&gt; &lt;!--或者--&gt; &lt;bean id=&quot;...&quot; class=&quot;...&quot; singleton=&quot;false&quot;/&gt; 测试结果为false，说明不是同一个对象 1234567@Testpublic void test()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); User user = (User) context.getBean(&quot;user&quot;); User user2 = (User) context.getBean(&quot;user&quot;); System.out.println(user==user2); //为false&#125; Request 当一个bean的作用域为Request，表示在一次HTTP请求中，一个bean定义对应一个实例；即每个HTTP请求都会有各自的bean实例，它们依据某个bean定义创建而成。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义： 1&lt;bean id=&quot;loginAction&quot; class=cn.csdn.LoginAction&quot; scope=&quot;request&quot;/&gt; 针对每次HTTP请求，Spring容器会根据loginAction bean的定义创建一个全新的LoginAction bean实例，且该loginAction bean实例仅在当前HTTP request内有效，因此可以根据需要放心的更改所建实例的内部状态，而其他请求中根据loginAction bean定义创建的实例，将不会看到这些特定于某个请求的状态变化。当处理请求结束，request作用域的bean实例将被销毁。 Session 当一个bean的作用域为Session，表示在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。考虑下面bean定义： 1&lt;bean id=&quot;userPreferences&quot; class=&quot;com.foo.UserPreferences&quot; scope=&quot;session&quot;/&gt; 针对某个HTTP Session，Spring容器会根据userPreferences bean定义创建一个全新的userPreferences bean实例，且该userPreferences bean仅在当前HTTP Session内有效 与request作用域一样，可以根据需要放心的更改所创建实例的内部状态，而别的HTTP Session中根据userPreferences创建的实例，将不会看到这些特定于某个HTTP Session的状态变化。当HTTP Session最终被废弃的时候，在该HTTP Session作用域内的bean也会被废弃掉。","path":"page/Spring03.html","date":"03-30","excerpt":"","tags":[{"name":"Spring","slug":"Spring","permalink":"http://xiaoliblog.cn/tags/Spring/"}]},{"title":"Spring🍃Spring快速入门","text":"HelloSpring导入Jar包123456 &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.4&lt;/version&gt;&lt;/dependency&gt; 编写实体类12345678910111213141516package com.lzy.spring;public class Hello &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void show()&#123; System.out.println(&quot;Hello,&quot;+ name ); &#125;&#125; Spring配置 在resources文件夹下创建beans.xml配置文件 在Spring中，每一个对象都叫Bean id：变量名，即对象的别名，测试类中通过getBean(id)获得 class：new 的对象完整路径 property：相当于给对象中的属性设置一个值 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- 类型 变量名 = new 类型(); Hello hello = new Hello(); id = 变量名 class = new 的对象 property 相当于给对象中的属性设置一个值 --&gt; &lt;!--bean就是java对象 , 由Spring创建和管理--&gt; &lt;bean id=&quot;hello&quot; class=&quot;com.lzy.spring.Hello&quot;&gt; &lt;!--给属性string name赋值--&gt; &lt;property name=&quot;name&quot; value=&quot;Spring&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试123456789@Testpublic void test()&#123; //解析beans.xml文件 , 生成管理相应的Bean对象 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); //对象现在都在Spring中管理了,要使用直接去里面取出来就可以 //getBean : 参数即为spring配置文件中bean的id . Hello hello = (Hello) context.getBean(&quot;hello&quot;); hello.show();&#125; 思考 Hello 对象是谁创建的 ? 【hello 对象是由Spring创建的】 Hello 对象的属性是怎么设置的 ? 【hello 对象的属性是由Spring容器设置的】 这个过程就叫控制反转 : 控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的 反转 : 程序本身不创建对象 , 而变成被动的接收对象 . 依赖注入 : 就是利用set方法来进行注入的. IOC是一种编程思想，由主动的编程变成被动的接收 可以通过newClassPathXmlApplicationContext去浏览一下底层源码 . 比如在Beans.xml新增Bean，需要什么数据库就只需要改property即可 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;MysqlImpl&quot; class=&quot;com.lzy.dao.impl.UserDaoMySqlImpl&quot;/&gt; &lt;bean id=&quot;OracleImpl&quot; class=&quot;com.lzy.dao.impl.UserDaoOracleImpl&quot;/&gt; &lt;bean id=&quot;ServiceImpl&quot; class=&quot;com.lzy.service.impl.UserServiceImpl&quot;&gt; &lt;!--注意: 这里的name并不是属性 , 而是set方法后面的那部分 , 首字母小写--&gt; &lt;!--引用另外一个bean , 不是用value 而是用 ref--&gt; &lt;property name=&quot;userDao&quot; ref=&quot;OracleImpl&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试 123456@Testpublic void test2()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserServiceImpl serviceImpl = (UserServiceImpl) context.getBean(&quot;ServiceImpl&quot;); serviceImpl.getUser();&#125; 总结：我们彻底不用再程序中去改动了 ，要实现不同的操作 , 只需要在xml配置文件中进行修改 , 所谓的IoC，一句话搞定 ：对象由Spring 来创建 , 管理 , 装配 ! 相当于你定义的对象由Spring托管了 IOC创建对象方式无参构造方法创建 实体类User 12345678910111213141516171819package com.lzy.spring;public class User &#123; private String name; public User() &#123; System.out.println(&quot;user无参构造方法&quot;); &#125; public void setName(String name) &#123; this.name = name; &#125; public void show()&#123; System.out.println(&quot;name=&quot;+ name ); &#125;&#125; Beans.xml配置文件 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;user&quot; class=&quot;com.lzy.spring.User&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类 12345678910@Testpublic void test()&#123; //解析beans.xml文件 , 生成管理相应的Bean对象 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); //在执行getBean的时候, user已经创建好了 , 通过无参构造 User user = (User) context.getBean(&quot;user&quot;); //调用对象的方法 . user.show();&#125; 结果可以发现，在调用show方法之前，User对象已经通过无参构造初始化了！ 有参构造方法创建 实体类UserT 12345678910111213141516171819package com.lzy.spring;public class UserT &#123; private String name; public UserT(String name) &#123; this.name = name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void show()&#123; System.out.println(&quot;name=&quot;+ name ); &#125;&#125; beans.xml 有三种方式编写 12345&lt;!-- 第一种根据index参数下标设置 --&gt;&lt;bean id=&quot;userT&quot; class=&quot;com.lzy.Spring.UserT&quot;&gt; &lt;!-- index指构造方法 , 下标从0开始 --&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;李四&quot;/&gt;&lt;/bean&gt; 12345&lt;!-- 第二种根据参数名字设置 --&gt;&lt;bean id=&quot;userT&quot; class=&quot;com.lzy.Spring.UserT&quot;&gt; &lt;!-- name指参数名 --&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;李四&quot;/&gt;&lt;/bean&gt; 1234&lt;!-- 第三种根据参数类型设置【类型限制,不建议使用】 --&gt;&lt;bean id=&quot;userT&quot; class=&quot;com.lzy.Spring.UserT&quot;&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;李四&quot;/&gt;&lt;/bean&gt; 测试 123456@Testpublic void testT()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); UserT user = (UserT) context.getBean(&quot;userT&quot;); user.show();&#125; 结论：在配置文件加载的时候。其中管理的对象都已经初始化了！ Spring配置别名 alias 设置别名 , 为bean设置别名 , 可以设置多个别名 12&lt;!--设置别名：在获取Bean的时候可以使用别名获取--&gt;&lt;alias name=&quot;userT&quot; alias=&quot;userNew&quot;/&gt; Bean的配置12345678910111213&lt;!--bean就是java对象,由Spring创建和管理--&gt;&lt;!-- id 是bean的标识符,要唯一,如果没有配置id,name就是默认标识符 如果配置id,又配置了name,那么name是别名 name可以设置多个别名,可以用逗号,分号,空格隔开 如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象;class是bean的全限定名=包名+类名--&gt;&lt;bean id=&quot;hello&quot; name=&quot;hello2 h2,h3;h4&quot; class=&quot;com.kuang.pojo.Hello&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Spring&quot;/&gt;&lt;/bean&gt; import 团队的合作通过import来实现 1&lt;import resource=&quot;&#123;path&#125;/beans.xml&quot;/&gt;","path":"page/Spring02.html","date":"03-21","excerpt":"","tags":[{"name":"Spring","slug":"Spring","permalink":"http://xiaoliblog.cn/tags/Spring/"}]},{"title":"Spring🍃Spring概述及IOC理论推导","text":"SpringSpring简介 Spring是一个开源的Java EE开发框架。Spring框架的核心功能可以应用在任何Java应用程序中，但对Java EE平台上的Web应用程序有更好的扩展性。Spring框架的目标是使得Java EE应用程序的开发更加简捷，通过使用POJO为基础的编程模型促进良好的编程风格 2002年，Rod Jahnson首次推出了Spring框架雏形interface21框架。2004年3月24日，Spring框架以interface21框架为基础，经过重新设计，发布了1.0正式版 Spring理念 ：使现有技术更加实用 ， 其本身就是一个大杂烩 ，整合现有的框架技术，不重复造轮子 SSH：Struct2 + Spring + Hibernate SSM：SpringMVC + Spring + Mybatis 🍃Spring是一个轻量级控制反转（IoC）和面向切面（AOP）的容器框架🍃 官网 ：http://spring.io/ 中文文档：https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference 官方下载地址 ：https://repo.spring.io/libs-release-local/org/springframework/spring/ GitHub ：https://github.com/spring-projects Maven：https://mvnrepository.com/artifact/org.springframework/spring-webmvc 注：POJO和JavaBean的区别 POJO 和JavaBean是我们常见的两个关键字，一般容易混淆，POJO全称是Plain Ordinary Java Object / Pure Old Java Object，中文可以翻译成：普通Java类，具有一部分getter/setter方法的那种类就可以称作POJO，但是JavaBean则比 POJO复杂很多， Java Bean 是可复用的组件，对 Java Bean 并没有严格的规范，理论上讲，任何一个 Java 类都可以是一个 Bean 。但通常情况下，由于 Java Bean 是被容器所创建（如 Tomcat) 的，所以 Java Bean 应具有一个无参的构造器 通常 Java Bean 还要实现 Serializable 接口用于实现 Bean 的持久性。 Java Bean 是不能被跨进程访问的。JavaBean是一种组件技术，就好像你做了一个扳子，而这个扳子会在很多地方被拿去用，这个扳子也提供多种功能(你可以拿这个扳子扳、锤、撬等等)，而这个扳子就是一个组件。一般在web应用程序中建立一个数据库的映射对象时，我们只能称它为POJO。POJO(Plain Old Java Object)这个名字用来强调它是一个普通java对象，而不是一个特殊的对象，其主要用来指代那些没有遵从特定的Java对象模型、约定或框架（如EJB）的Java对象。理想地讲，一个POJO是一个不受任何限制的Java对象（除了Java语言规范） Spring特点 轻量级：Spring在大小和透明性方面绝对属于轻量级的，基础版本的Spring框架大约只有2MB。 控制反转IoC：Spring使用控制反转技术实现了松耦合。控制反转，把创建对象过程交给Spring进行管理，以降低耦合度 面向切面编程AOP： Spring支持面向切面编程，同时把应用的业务逻辑与系统的服务分离开来，即不修改源代码进行功能增加。 容器：Spring包含并管理应用程序对象的配置及生命周期。 MVC框架：Spring的web框架是一个设计优良的web MVC框架，很好的取代了一些web框架。 事务管理：Spring对下至本地业务上至全局业务(JAT)提供了统一的事务管理接口。 异常处理：Spring提供一个方便的API将特定技术的异常(由JDBC, Hibernate, 或JDO抛出)转化为一致的、Unchecked异常。 Spring组成 Spring 总共大约有 20 个模块， 由 1300 多个不同的文件构成。 而这些组件被分别整合在核心容器（Core Container） 、 AOP（Aspect Oriented Programming）和设备支持（Instrmentation） 、数据访问与集成（Data Access/Integeration） 、 Web、 消息（Messaging） 、 Test等 6 个模块中。 以下是 Spring 5 的模块结构图： 模块名称 简介 spring-core 依赖注入IOC与DI的最基本实现 spring-beans Bean工厂与Bean的装配 spring-context 定义基础的Spring的Context上下文即IOC容器 spring-conetext-support 对Spring IOC容器的扩展支持，以及IOC子容器 spring-context-indexer Spring的类管理组件和Classpath扫描 spring-expression Spring表达式语言 Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式 . 组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下： 核心容器 核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。 Spring 上下文 Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。 Spring AOP 通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。 Spring DAO JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。 Spring ORM Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。 Spring Web 模块 Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。 Spring MVC 框架 MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。 Spring扩展Spring官网：现代化的Java开发！说白技术基于Spring的开发！ Spring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务; Spring Cloud是基于Spring Boot实现的； Spring Boot专注于快速、方便集成的单个微服务个体，Spring Cloud关注全局的服务治理框架； Spring Boot使用了约束优于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置 , Spring Cloud很大的一部分是基于Spring Boot来实现，Spring Boot可以离开Spring Cloud独立使用开发项目，但是Spring Cloud离不开Spring Boot，属于依赖的关系。 SpringBoot在SpringClound中起到了承上启下的作用，如果你要学习SpringCloud必须要学习SpringBoot IOC理论推导IOC基础 新建一个空白的maven项目 用原来的方式创建一个项目 先写一个UserDao接口 123public interface UserDao &#123; public void getUser();&#125; 再去写Dao的实现类UserDaoImpl 123456public class UserDaoImpl implements UserDao &#123; @Override public void getUser() &#123; System.out.println(&quot;获取用户数据&quot;); &#125;&#125; 然后去写UserService的接口 123public interface UserService &#123; public void getUser();&#125; 最后写Service的实现类UserServiceImpl 12345678public class UserServiceImpl implements UserService &#123; private UserDao userDao = new UserDaoImpl(); @Override public void getUser() &#123; userDao.getUser(); &#125;&#125; 测试一下 12345@Testpublic void test()&#123; UserService service = new UserServiceImpl(); service.getUser();&#125; 以上就是平时写的代码，但如果Userdao增加一个 实现MySQL的实现类 123456public class UserDaoMySqlImpl implements UserDao &#123; @Override public void getUser() &#123; System.out.println(&quot;MySql获取用户数据&quot;); &#125;&#125; 紧接着我们要去使用MySql的话 , 我们就需要去service实现类里面修改对应的实现，那么UserDaoImpl就不能使用 123456789public class UserServiceImpl implements UserService &#123; //private UserDao userDao = new UserDaoImpl(); private UserDao userDao = new UserDaoMySqlImpl(); @Override public void getUser() &#123; userDao.getUser(); &#125;&#125; 假设, 我们再增加一个Userdao的使用Oracle数据库的实现类 . 123456public class UserDaoOracleImpl implements UserDao &#123; @Override public void getUser() &#123; System.out.println(&quot;Oracle获取用户数据&quot;); &#125;&#125; 那么我们要使用Oracle , 又需要去service实现类里面修改对应的实现 . 假设我们的这种需求非常大 , 这种方式就根本不适用了, 甚至反人类对吧 , 每次变动 , 都需要修改大量代码 . 这种设计的耦合性太高了, 牵一发而动全身 解决方法：我们可以在需要用到他的地方 , 不去实现它 , 而是留出一个接口 , 利用set , 我们去代码里修改下 . 12345678910111213public class UserServiceImpl implements UserService &#123; //private UserDao userDao = new UserDaoImpl(); 之前这行代码是写死的，不灵活 private UserDao userDao;// 利用set实现动态实现值的注入！ 对象成为参数，由调用者选择，相当于一个对象工厂 public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void getUser() &#123; userDao.getUser(); &#125;&#125; 现在去我们的测试类里 , 进行测试 ; 12345678910@Testpublic void test()&#123; UserServiceImpl service = new UserServiceImpl(); //使用MySQL实现，此时程序不再具有主动性，而是被动接收对象 service.setUserDao( new UserDaoMySqlImpl() ); service.getUser(); //那我们现在又想用Oracle去实现呢 service.setUserDao( new UserDaoOracleImpl() ); service.getUser();&#125; 仔细思考一下 , 之前所有东西都是由程序去进行控制创建！控制权在程序员手上！ 而现在是由我们自行控制创建对象 , 把主动权交给了调用者 ， 程序不用去管怎么创建，怎么实现了，它只负责提供一个接口 这种思想 , 从本质上解决了问题 , 我们程序员不再去管理对象的创建了 , 更多的去关注业务的实现 ， 耦合性大大降低，这也就是IOC的原型 ! 个人理解：IOC控制反转就是把控制权转交给调用者，用户该怎么自定义就可以怎么自定义，主动权转交给用户调用者 IOC本质 控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法，也有人认为DI只是IoC的另一种说法 没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了 IOC思想基于IOC容器完成，IOC容器底层就是对象工厂。Spring提供的IOC容器实现的两种方式 BeanFactory接口：IOC容器基本实现是Spring内部接口的使用接口，不提供给开发人员进行使用（加载配置文件时候不会创建对象，在获取对象时才会创建对象） ApplicationContext接口：BeanFactory接口的子接口，提供更多更强大的功能，提供给开发人员使用（加载配置文件时候就会把在配置文件对象进行创建）推荐使用 ApplicationContext通常的实现是什么 FileSystemXmlApplicationContext ：此容器从一个XML文件中加载beans的定义，XML Bean配置文件的全路径名必须提供给它的构造函数 ClassPathXmlApplicationContext：此容器也从一个XML文件中加载beans的定义，这里，你需要正确设置classpath因为这个容器将在classpath里找bean配置 Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象 采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。 控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）","path":"page/Spring01.html","date":"03-21","excerpt":"","tags":[{"name":"Spring","slug":"Spring","permalink":"http://xiaoliblog.cn/tags/Spring/"}]},{"title":"Ngrok内网穿透技术","text":"内网穿透 我们生活中的网络从应用上可以分为内网和外网，内网就是你自己的网络环境，就你自己能访问，比如你本地测试进行的localhost；外网就不言而喻了，你看网页，视频等这些网址都是外网。 那么什么又是内网穿透呢？简单的说就是通过访问一个外网地址，然后穿透到你的内网地址。即将本地服务器暴露在公网上，供公网上的用户访问 Ngrok Ngrok 是一个反向代理，通过在公共的端点和本地运行的 Web 服务器之间建立一个安全的通道。ngrok 可捕获和分析所有通道上的流量，便于后期分析和重放。 反向代理在计算机网络中是代理服务器的一种。服务器根据客户端的请求，从其关系的一组或多组后端服务器（如Web服务器）上获取资源，然后再将这些资源返回给客户端，客户端只会得知反向代理的IP地址，而不知道在代理服务器后面的服务器集群的存在。 说白了就是你写了一个项目，让别人访问，Ngrok这个技术可以把你的本地IP和端口（例如：localhost:8080）转换为www.baidu.com 一样的万网，简而言之就是将内网IP映射成对外可访问的域名 应用场景 假设你写了一个代码功能，本地测试已经OK，此时，你要想让千里之外的朋友帮你测试，会怎么做呢？ A方案：如果你的朋友懂代码，你可以把代码打包发给他，让他在本地测试； B方案：如果你的朋友不懂代码，你只能搭建一套服务器，然后放到服务器上面，让他通过外网访问进行测试； 不论是A方案还是B方案，整个过程复杂繁琐。特别是B方案，如果不会服务器部署那套，那直接白搭。 此时，ngrok 就可以派上用场了，只需要打开输入一个命令，就可以让你千里之外的朋友测试了，整个操作耗时5秒不到。 推荐两款内网穿透工具natapp和Ngrok Sunny-Ngrok注册账户 Ngrok官方文档：https://www.ngrok.cc/_book/ 国内Ngrok官网：https://www.ngrok.cc/，注册一个账号 开通隧道 【开通隧道】找到【美国Ngrok免费服务器】并【立即购买】 隧道管理如下，【确定】后点击【确定开通】 开通成功如下 客户端下载及启动 【隧道管理】【服务器类型】点击【客户端下载】，根据电脑配置自行下载 下载后解压，打开启动工具 输入客户端id，即【隧道管理】里的隧道id 复制id到启动工具然后【Enter】进行启动 本地工具连接隧道ID即可，本地服务需要一直启动，一旦关闭就无法访问 测试 随便搭建一个JavaWeb项目 访问JavaWeb_Demo02工程下的index.jsp文件 index.jsp文件内容如下 12345&lt;html&gt;&lt;body&gt;&lt;h2&gt;Hello World!&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 修改本地映射端口为8080，然后启动 首先本地访问 外网映射后访问 本地访问地址：http://localhost:8080/JavaWeb_Demo02/外网映射后访问地址：http://xiaoliblog.free.idcfengye.com/JavaWeb_Demo02/ NatApp 注册登录natapp：https://natapp.cn/，需要实名认证 购买免费隧道 复制authtoken，然后下载客户端 双击解压后的natapp.exe 输入启动命令 1natapp -authtoken=yourauthtoken 启动成功如下 所提供的域名就等价于localhost","path":"page/Ngrok.html","date":"03-21","excerpt":"","tags":[{"name":"企业常用技术","slug":"企业常用技术","permalink":"http://xiaoliblog.cn/tags/%E4%BC%81%E4%B8%9A%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF/"}]},{"title":"第三方短信接入","text":"","path":"page/message.html","date":"03-21","excerpt":"","tags":[{"name":"企业常用技术","slug":"企业常用技术","permalink":"http://xiaoliblog.cn/tags/%E4%BC%81%E4%B8%9A%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF/"}]},{"title":"POI及EasyExcel技术","text":"","path":"page/EasyEscel.html","date":"03-21","excerpt":"","tags":[{"name":"企业常用技术","slug":"企业常用技术","permalink":"http://xiaoliblog.cn/tags/%E4%BC%81%E4%B8%9A%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF/"}]},{"title":"23种设计模式","text":"","path":"page/Designpattern.html","date":"03-21","excerpt":"","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://xiaoliblog.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Mybatis🎯逆向工程与分页插件","text":"Mybatis插件 MyBatis通过提供插件机制，让我们可以根据自己的需要去增强MyBatis的功能需要注意的是，如果没有完全理解MyBatis的运行原理和播件的工作方式，最好不要使用播件，因为它会改变系底层的工作逻辑，给系统带来很大的影响 MyBatis的插件可以在不修改原来的代码的情况下，通过拦截的方式，改变四大核心对象的行为，比如处理参数，处理SQL，处理结果 四大核心对象 说明 Executor Mybatis的执行器，用于执行增删改查操作 ParameterHandler 数返回SQL的参数对象 ResultSetHandler 处理SQL的返回结果 StatementHandler 数据库的处理对象，用于执行SQL语句 Mybatis插件适用场景 分页功能 mybatis的分页默认是基于内存分页的(查出所有，再截取)， 数据量大的情况下效率较低，不过使用mybatis插件可以改变该行为，只需要拦截StatementHandler类的prepare方法，改变要执行的SQL语句为分页语句（limit）即可; 公共字段统一赋值 一般业务系统都会有创建者，创建时间，修改者，修改时间四个字段，对于这四个字段的赋值，实际上可以在DAO层统一拦截处理，可以用mybatis插件拦截Executor类的update方法，对相关参数进行统已赋值即可; 性能监控 对于SQL语句执行的性能监控，可以通过拦截Executor类的update, query等方法，用日志记录每个方法执行的时间; 其它 其实mybatis扩展性还是很强的，基于插件机制，基本上可以控制SQL执行的各个阶段，如执行阶段，参数处理阶段，语法构建阶段，结果集处理阶段，具体可以根据项目业务来实现对应业务逻辑。 分页插件底层原理 不修改对象的代码，怎么对对象的行为进行修改，比如说在原来的方法前面做一点事情，在原来的方法后面做一点事情? 可以用到代理模式，代理模式也确实是MyBatis 插件的原理 我们可以定义很多的插件，那么这种所有的插件会形成一个链路，比如我们提交一个休假申请，先是项目经理审批，然后是部门经理审批，再是HR审批，再到总经理审批，怎么实现层层的拦截? 插件是层层拦截的，我们又需要用到另一种设计模式：责任链模式 在源码中分析，mybatis内部对于插件的处理确实使用的是代理模式，既然是代理模式，我们应该了解MyBatis允许哪些对象的哪些方法允许被拦截，并不是每一个运行的节点都是可以被修改的。只有清楚了这些对象的方法的作用，当我们自己编写插件的时候才知道从哪里去拦截。在MyBatis官网 可以查看 Executor会拦截到CachingExcecutor或者BaseExecutor。因为创建Executor 时是先创建CachingExcecutor，再包装拦截。从代码顺序上能看到。我们可以通过mybatis的分页插件来看看整个插件从包装拦截器链到执行拦截器链的过程。 在查看插件原理的前提上，我们需要来看看官网对于自定义插件是怎么来做的，官网上有介绍：通过MyBatis提供的强大机制，使用插件是非常简单的，只需实现Interceptor接口，并指定想要拦截的方法签名即可。这里需要注意，拦截器出了问题，可以Debug看一下Configuration配置类中拦截器链的包装情况 分页插件的底层原理详情可以参考：https://www.bilibili.com/video/BV1oz4y1r7ZQ?p=44 分页 如果查询大量数据的时候，我们往往使用分页进行查询，也就是每次处理小部分数据，这样对数据库压力就在可控范围内 limit实现分页123456789101112#语法SELECT * FROM table LIMIT stratIndex,pageSizeSELECT * FROM user limit 5,10; # 检索记录行 6-15 SELECT * FROM user limit 3; #[0,3]#为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1： SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last. #如果只给定一个参数，它表示返回最大的记录行数目： SELECT * FROM table LIMIT 5; //检索前 5 个记录行 [0,n] UserMapper接口添加方法 1List&lt;User&gt; getUserByLimit(Map&lt;String,Object&gt; map); 修改Mapper.xml文件 1234&lt;!--分页查询--&gt;&lt;select id=&quot;getUserByLimit&quot; parameterType=&quot;map&quot; resultType=&quot;lzy.user.User&quot;&gt; select * from mybatis.user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;;&lt;/select&gt; 测试类 12345678910111213@Test public void getUserByLimit()&#123; SqlSession sqlSession = MybatisUtils.getSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;(); map.put(&quot;startIndex&quot;,0); //从0开始 map.put(&quot;pageSize&quot;,2); //每页显示几个 List&lt;User&gt; userList = mapper.getUserByLimit(map); for (User user : userList) &#123; System.out.println(user); &#125; sqlSession.close(); &#125; RowBounds分页 除了使用Limit在SQL层面实现分页，也可以使用RowBounds在Java代码层面实现分页，当然此种方式作为了解即可 UserMapper接口添加方法 12//选择全部用户RowBounds实现分页List&lt;User&gt; getUserByRowBounds(); UserMapper.xml配置 123&lt;select id=&quot;getUserByRowBounds&quot; resultType=&quot;lzy.user.User&quot;&gt; select * from mybatis.user&lt;/select&gt; 测试类 12345678910111213141516@Test public void testUserByRowBounds() &#123; SqlSession session = MybatisUtils.getSession(); int currentPage = 0; //第几页 int pageSize = 2; //每页显示几个 RowBounds rowBounds = new RowBounds((currentPage-1)*pageSize,pageSize); //通过session.**方法进行传递rowBounds，[此种方式现在已经不推荐使用了] List&lt;User&gt; users = session.selectList(&quot;lzy.dao.UserMapper.getUserByRowBounds&quot;, null, rowBounds); for (User user: users)&#123; System.out.println(user); &#125; session.close(); &#125; PageHelper插件 插件项目地址：https://pagehelper.github.io/ PageHelper使用文档 导入依赖123456&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.2.0&lt;/version&gt;&lt;/dependency&gt; 配置拦截器插件 第一种方法是在MyBatis 配置 xml 中配置拦截器插件。mybatis-config.xml中配置如下 123456789101112131415&lt;!-- plugins在配置文件中的位置必须符合要求，否则会报错，顺序如下: properties?, settings?, typeAliases?, typeHandlers?, objectFactory?,objectWrapperFactory?, plugins?, environments?, databaseIdProvider?, mappers?--&gt;&lt;plugins&gt; &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;!-- 分页合理化参数，建议配置 --&gt; &lt;property name=&quot;reasonable&quot; value=&quot;true&quot;/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 第二种方法是在 Spring 配置文件中配置拦截器插件。applicationContext.xml中配置如下 123456789101112131415&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 注意其他配置 --&gt; &lt;property name=&quot;plugins&quot;&gt; &lt;array&gt; &lt;bean class=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;property name=&quot;properties&quot;&gt; &lt;!--使用下面的方式配置参数，一行配置一个 --&gt; &lt;value&gt; params=value1 &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 方法调用 场景从user表中通过分页查询数据 UserMapper 123public interface Mapper &#123; List&lt;User&gt; getUserList(); //返回User对象&#125; UserMapper.xml 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--namespace指定Mapper.xml配置文件的完整路径--&gt;&lt;mapper namespace=&quot;com.lzy.dao.Mapper&quot;&gt; &lt;!--id是对应UserMapper里的重写方法的方法名 resultType返回结果，写实体类完整类名--&gt; &lt;select id=&quot;getUserList&quot; resultType=&quot;com.lzy.user.User&quot;&gt; select * from mybatis.user &lt;/select&gt;&lt;/mapper&gt; MybatisUtls工具类 1234567891011121314151617181920212223//sqlSessionFactory --&gt; SqlSessionpublic class MybatisUtils &#123; //提升作用域 private static SqlSessionFactory sqlSessionFactory; static &#123; try &#123;/*1. 通过mybatis-config配置文件构造SqlSessionFactoryBuilder 2. 通过SqlSessionFactoryBuilder的build()获取SqlSessionFactory*/ String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //3. 通过SqlSessionFactory的openSession()获取SqlSession public static SqlSession getSession()&#123; SqlSession sqlSession = sqlSessionFactory.openSession(); return sqlSession; &#125;&#125; 分页测试 1234567891011121314151617@Test //分页插件查询 public void PageHelper()&#123; // 第一步：通过工具类获得SqlSession对象 SqlSession sqlSession = MybatisUtils.getSession(); //第二步：执行SQL Mapper mapper = sqlSession.getMapper(Mapper.class); // 调用PageHelper参数为(当前页,总条数)，如下为第1页，每页3条数据 PageHelper.startPage(1,3); List&lt;User&gt; userList = mapper.getUserList(); for (User user: userList)&#123; System.out.println(user); &#125; //关闭SqlSession sqlSession.close(); &#125; 封装成PageInfo PageHelper插件提供的PageInfo对象封装了很多分页信息，可以按Ctrl查看源码 12345678910111213141516171819202122232425@Test //分页插件查询 public void PageHelper()&#123; // 第一步：通过工具类获得SqlSession对象 SqlSession sqlSession = MybatisUtils.getSession(); //第二步：执行SQL Mapper mapper = sqlSession.getMapper(Mapper.class); //在需要执行分页查询的上面调用PageHelper.startPage(当前页,总条数)，如下为第1页，每页3条数据 PageHelper.startPage(1,3); List&lt;User&gt; userList = mapper.getUserList(); //封装成PageInfo，PageInfo对象传到request域里，在视图循环显示 // 还可以传入显示页面数量，因为最大显示为8条，超过就需要手动设置参数 PageInfo page = new PageInfo(userList,2); System.out.println(page); System.out.println(&quot;当前页：&quot;+page.getPageNum()); System.out.println(&quot;总条数：&quot;+page.getTotal()); System.out.println(&quot;是否第一页：&quot;+page.isIsFirstPage()); System.out.println(&quot;是否最后一页：&quot;+page.isIsLastPage()); System.out.println(&quot;页码导航：&quot;); for(int i : page.getNavigatepageNums())&#123; System.out.print(i+&quot;\\t&quot;); &#125; //关闭SqlSession sqlSession.close(); &#125; 关于pageInfo对象的属性 12345678910111213141516171819202122232425262728293031323334353637383940414243public class PageInfo&lt;T&gt; implements Serializable &#123;private static final long serialVersionUID = 1L;//当前页private int pageNum;//每页的数量private int pageSize;//当前页的数量private int size;//由于startRow 和endRow 不常用，这里说个具体的用法//可以在页面中&quot;显示startRow 到endRow 共size 条数据&quot;//当前页面第一个元素在数据库中的行号private int startRow;//当前页面最后一个元素在数据库中的行号private int endRow;//总记录数private long total;//总页数private int pages;//结果集private List&lt;T&gt; list;//前一页private int prePage;//下一页private int nextPage;//是否为第一页private boolean isFirstPage = false;//是否为最后一页private boolean isLastPage = false;//是否有前一页private boolean hasPreviousPage = false;//是否有下一页private boolean hasNextPage = false;//导航页码数private int navigatePages;传智播客——专注于Java、.Net 和Php、网页平面设计工程师的培训北京市昌平区建材城西路金燕龙办公楼一层电话：400-618-9090//所有导航页号private int[] navigatepageNums;//导航条上的第一页private int navigateFirstPage;//导航条上的最后一页private int navigateLastPage;&#125; 在Controller中的使用是将Service层返回来的PageInfo对象放入request域中在jsp页面中的取值根据PageInfo中的get方法，使用EL表达式取出保存的值 逆向工程 简单的理解，MyBatis逆向工程，就是通过相应插件，自动生成MyBatis数据库连接的一些文件。 Mybatis需要编写sql语句，Mybatis官方提供逆向工程，可以针对单表自动生成Mybatis执行所需要的代码（mapper.java、mapper.xml、pojo…），提高工作效率 MyBatis Generator项目地址： https://github.com/mybatis/generator/ MyBatis Generator官方文档：http://mybatis.org/generator/ 导入相关依赖123456&lt;!-- https://mvnrepository.com/artifact/org.mybatis.generator/mybatis-generator-core --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt;&lt;/dependency&gt; 编写配置文件 配置文件详情可以查阅文档：http://mybatis.org/generator/quickstart.html 在项目工程文件下（同pom.xml级)创建generatorConfig.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;!--context 生成上下文，配置生成规则 id 随意写 targetRuntime 生成策略 1. MyBatis3 生成通用的查询，可以指定动态where条件 2. MyBatis3DynamicSql 默认的，动态生成SQL的CRUD 3. MyBatis3Simple 只生成简单的CRUD --&gt; &lt;context id=&quot;simple&quot; targetRuntime=&quot;MyBatis3Simple&quot;&gt; &lt;commentGenerator&gt; &lt;!--设置是否生成注释 true 不生成 注意：如果不生成注释，下次生成代码就不会进行合并，防止版本变更被覆盖--&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt; &lt;/commentGenerator&gt; &lt;!--因为是根据表单生成，对应一个数据库一个表一个POJO--&gt; &lt;!--配置数据源--&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis&quot; userId=&quot;root&quot; password=&quot;root&quot; /&gt; &lt;!--注意顺序，否则会报错--&gt; &lt;!--生成pojo javaModelGenerator Java实体生成规则(POJO) targetPackage 生成到哪个包下 targetProject 生成到当前文件的哪个相对路径下 --&gt; &lt;javaModelGenerator targetPackage=&quot;com.lzy.pojo&quot; targetProject=&quot;src/main/java&quot;/&gt; &lt;!--生成mapper xml映射文件 sqlMapGenerator mapper xml生成规则 targetPackage 生成到哪个包下 targetProject 生成到当前文件的哪个相对路径下 --&gt; &lt;sqlMapGenerator targetPackage=&quot;com.lzy.dao&quot; targetProject=&quot;src/main/resources&quot;/&gt; &lt;!--生成mapper接口 javaClientGenerator mapper接口生成规则 targetPackage 生成到哪个包下 targetProject 生成到当前文件的哪个相对路径下 type指定生成的方式 1. 使用注解的方式生成，则不需要配置mapper xml映射文件 2. 使用接口绑定的方式生成 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.lzy.dao&quot; targetProject=&quot;src/main/java&quot;/&gt; &lt;!--配置哪些表需要进行代码生成 tableName 表名 domainObjectName pojo类名 mapperName mapper接口的类名和mapper xml文件的名字 --&gt; &lt;table tableName=&quot;user&quot; domainObjectName=&quot;User&quot; mapperName=&quot;UserMapper&quot;/&gt; &lt;!--也可以指定pojo，mapper接口，mapper映射文件的名字 如果不指定，它会根据表名首字母大写生成 只指定mapper接口的名字，mapper映射文件与其同名 --&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 通常只执行一次生成就好，防止下次生成改变原项目，增加风险。如果非要执行，最好使用命令生成到其他目录 执行配置文件 详情可以查阅官网：http://mybatis.org/generator/running/running.html 可以打开cmd使用java命令运行，但还要配置数据库驱动【不推荐使用这种方式，较麻烦】 1java -jar mybatis-generator-core-x.x.x.jar -configfile \\temp\\generatorConfig.xml -overwrite 12&lt;!--如果需要使用 cmd方式生成需要配置数据库驱动的jar包路径--&gt;&lt;classPathEntry location=&quot;指定数据库驱动的磁盘路径&quot;/&gt; 使用Java程序进行加载，创建测试类MBGTest 1234567891011121314151617181920212223import org.junit.Test;import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.internal.DefaultShellCallback;import java.io.File;import java.util.ArrayList;import java.util.List;public class MBGTest &#123; @Test public void test() throws Exception &#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File(&quot;generatorConfig.xml&quot;); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); &#125;&#125; 运行即可，生成文件中的注解如果代码要修改就不要去掉，否则重新生成的时候会找不到 测试CRUD 创建测试类 123456789@Test public void test_crud()&#123; SqlSession sqlSession = MybatisUtils.getSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); //根据主键id查询 User user = mapper.selectByPrimaryKey(1); System.out.println(user); sqlSession.close(); &#125; Mybatis3通用规则 修改generatorConfig.xml配置文件，type修改为MyBatis3 1234567891011121314151617181920&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;context id=&quot;simple&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt; &lt;/commentGenerator&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis&quot; userId=&quot;root&quot; password=&quot;root&quot; /&gt; &lt;javaModelGenerator targetPackage=&quot;com.lzy.pojo&quot; targetProject=&quot;src/main/java&quot;/&gt; &lt;sqlMapGenerator targetPackage=&quot;com.lzy.dao&quot; targetProject=&quot;src/main/resources&quot;/&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.lzy.dao&quot; targetProject=&quot;src/main/java&quot;/&gt; &lt;table tableName=&quot;user&quot; domainObjectName=&quot;User&quot; mapperName=&quot;UserMapper&quot;/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 测试运行后会生成对应的xxxExample类，这个类主要用于动态的添加条件 模糊查询 提供MyBatis3实现名字模糊查询 123456789101112131415@Test public void test()&#123; SqlSession sqlSession = MybatisUtils.getSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); //使用Example实现动态条件语句 UserExample userExample = new UserExample(); UserExample.Criteria criteria = userExample.createCriteria(); //模糊查询，可以写多个条件 criteria.andNameLike(&quot;%李%&quot;) .andIdEqualTo(1); List&lt;User&gt; userList = mapper.selectByExample(userExample); System.out.println(userList); sqlSession.close(); &#125;","path":"page/Mybatis09.html","date":"03-21","excerpt":"","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://xiaoliblog.cn/tags/Mybatis/"}]},{"title":"第三方滑动验证码接口","text":"腾讯云接口 腾讯云验证码-图形验证能够准确识别可信、可疑和恶意用户，并提供不同的验证体验，令有效验证通过更轻松，机器作恶更困难。防止软件外围发短信被恶意攻击 官方文档地址：https://cloud.tencent.com/document/product/1110/36839 获得腾讯云密钥 接入验证码前，需要先在验证码控制台中注册，并创建验证应用和领取免费体验包 在新建应用的【基础配置】中保存好APPID(CaptchaAppId)和APP Secret Key，用于后端调用的参数 进入云API密钥页面，获取SecretId 和 SecretKey，用于后端实例化一个认证对象 客户端接入 客户端Web前端接入文件：https://007.qq.com/web-access.html?ADTAG=acces.cfg 接入的大概流程 前端页面用户点击验证后会返回2个必要参数 ticket和randstr，然后我们用AJAX异步请求发送到后端，然后后端发送请求到腾讯云服务器，然后服务器会给我们返回最终结果 ok则代表成功 在Head的标签内最后加入以下代码引入验证JS文件（建议直接在html中引入） 123&lt;script src=&quot;https://ssl.captcha.qq.com/TCaptcha.js&quot;&gt;&lt;/script&gt;//用于Aajax&lt;script src=&quot;https://code.jquery.com/jquery-3.5.1.min.js&quot;&gt;&lt;/script&gt; 在你想要激活验证码的DOM元素（eg. button、div、span）内加入以下id及属性 12345678910&lt;!--点击此元素会自动激活验证码--&gt;&lt;!--id : 元素的id(必须)--&gt;&lt;!--data-appid : AppID(必须)--&gt;&lt;!--data-cbfn : 回调函数名(必须)--&gt;&lt;!--data-biz-state : 业务自定义透传参数(可选)--&gt;&lt;button id=&quot;TencentCaptcha&quot; data-appid=&quot;appId&quot; data-cbfn=&quot;callback&quot; type=&quot;button&quot;&gt;验证&lt;/button&gt; 注意：其中Id=&quot;TencentCaptcha&quot;是固定值，data-appid 是你的应用程序APPID 为验证码创建回调函数，注意函数名要与data-cbfn相同，利用AJAX的简单的例子根据自己的需求自己加逻辑 12345678910111213141516171819202122232425262728293031&lt;script&gt; var check = false; window.callback = function (res) &#123; console.log(res); // res（用户主动关闭验证码）= &#123;ret: 2, ticket: null&#125; // res（验证成功） = &#123;ret: 0, ticket: &quot;String&quot;, randstr: &quot;String&quot;&#125; if (res.ret === 0) &#123; $.ajax(&#123; type: &quot;get&quot;, //提交方式 url: &quot;http://localhost:8080/admin/CodeServlet&quot;, //提交路径 data: &quot;ticket=&quot; + res.ticket + &quot;&amp;randstr=&quot; + res.randstr, //提交的数据 dataType: &quot;jsonp&quot;, //服务器返回的数据类型,用于解决跨域问题 success: function (message) &#123; //请求成功后的回调函数 console.log(message); if (message.trim() == &quot;ok&quot;) &#123; console.log(&quot;验证成功&quot;); check = true; &#125; else &#123; $(&quot;#msg&quot;).html(&quot;验证失败&quot;); &#125; &#125;, error: function (e) &#123; //请求失败,包含具体的错误信息 console.log(e.status); console.log(e.responseText); &#125;, &#125;); &#125; &#125;;&lt;/script&gt; 注意：函数名要与 data-cbfn 相同 ticket 和 randstr 都是必要参数都要发送到后端 在提交到腾讯云服务器做校验 至此客户端接入就已经完成了，现在就可以看到效果了： 只要协议、域名、端口有任何一个不同，都被当作是不同的域，两者交互就会出现跨域问题 服务器接入 服务器端Java引入文档：https://007.qq.com/java-access.html?ADTAG=acces.cfg 相关API文档：https://cloud.tencent.com/document/product/1110/36926 总体思路：利用AJAX把ticket和ranstr值传入Servlet 然后调用工具类 根据返回的字符串判断用户是否验证成功，并把结果以流的形式发送到前台，前台AJAX对结果进行判断成功则可以登陆失败则提示验证失败 注意以下参数 参数 描述 SecretId AKIDxxxxxxxxxx SecretKey Zu1xxxx APPID(CaptchaAppId)(必填) 2096471xxx APP Secret Key (必填) 0CB7wV-e7lJXxxxdA1koXQ** Ticket (必填) 验证码客户端验证回调的票据 Randstr (必填) 验证码客户端验证回调的随机串 UserIP (必填) 提交验证的用户的IP地址（eg: 127.0.01） 导入Maven依赖，注意：去Maven仓库下载最新版本老版本可能出问题 1234567&lt;!-- https://mvnrepository.com/artifact/com.tencentcloudapi/tencentcloud-sdk-java --&gt;&lt;dependency&gt; &lt;groupId&gt;com.tencentcloudapi&lt;/groupId&gt; &lt;artifactId&gt;tencentcloud-sdk-java&lt;/artifactId&gt; &lt;version&gt;4.0.11&lt;/version&gt;&lt;/dependency&gt; 创建DescribeCaptchaResult工具类，去官方API填对应的参数生成相应的Java代码，要调用工具类对应的方法向腾讯云服务器发送请求看看用户验证是否成功 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.lzy.SecurityCode;import com.tencentcloudapi.captcha.v20190722.CaptchaClient;import com.tencentcloudapi.captcha.v20190722.models.DescribeCaptchaResultRequest;import com.tencentcloudapi.captcha.v20190722.models.DescribeCaptchaResultResponse;import com.tencentcloudapi.common.Credential;import com.tencentcloudapi.common.exception.TencentCloudSDKException;import com.tencentcloudapi.common.profile.ClientProfile;import com.tencentcloudapi.common.profile.HttpProfile;public class DescribeCaptchaResult &#123; public DescribeCaptchaResult()&#123; &#125; //去腾讯云服务获取结果 public boolean codeResponse(String ticket,String randstr)&#123; String str = &quot;&quot;; try&#123; //实例化一个认证对象，入参需要传入腾讯云账户密钥对 secretId 和 secretKey Credential cred = new Credential(&quot;AKIDyhngMnWRdcxxxxxxf3KR&quot;,&quot;Zu1tqexxxxxxW00iNlYBYeBOO7&quot;); // 实例化一个 http 选项，可选，无特殊需求时可以跳过 HttpProfile httpProfile = new HttpProfile(); //接口请求域名： captcha.tencentcloudapi.com httpProfile.setEndpoint(&quot;captcha.tencentcloudapi.com&quot;); /* 实例化一个客户端配置对象 */ ClientProfile clientProfile = new ClientProfile(); clientProfile.setHttpProfile(httpProfile); /* 实例化 SMS 的 client 对象 * 第二个参数是地域信息，可以直接填写字符串 ap-beijing，或者引用预设的常量 */ CaptchaClient client = new CaptchaClient(cred,&quot;ap-beijing&quot;,clientProfile); //需要UserIP,CaptchaAppId和AppSecretKey String params = &quot;&#123;\\&quot;CaptchaType\\&quot;:9,\\&quot;Ticket\\&quot;:\\&quot;&quot; + ticket + &quot;\\&quot;,\\&quot;UserIp\\&quot;:\\&quot;127.0.0.1\\&quot;,\\&quot;Randstr\\&quot;:\\&quot;&quot; + randstr + &quot;\\&quot;,\\&quot;CaptchaAppId\\&quot;:20xxx931,\\&quot;AppSecretKey\\&quot;:\\&quot;0Sih3-_wxxxxxnvA**\\&quot;&#125;&quot;; DescribeCaptchaResultRequest req = DescribeCaptchaResultRequest.fromJsonString(params,DescribeCaptchaResultRequest.class); DescribeCaptchaResultResponse resp = client.DescribeCaptchaResult(req); str = DescribeCaptchaResultRequest.toJsonString(resp); &#125;catch (TencentCloudSDKException e)&#123; System.out.println(e.toString()); &#125; //打印JSON对象 System.out.println(str); if(str.indexOf(&quot;OK&quot;)&lt;0)&#123; return false; &#125;else &#123; return true; &#125; &#125;&#125; 验证不通过，可以通过打印str查看信息，比对官方的输出参数修改 创建对应的Servlet接收前端请求 123456789101112131415161718192021222324252627282930package com.lzy.SecurityCode;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;//访问路径为http://localhost:8080/admin/CodeServlet?ticket=xxx&amp;randstr=xxx@WebServlet(name = &quot;CodeServlet&quot;,urlPatterns = &quot;/admin/CodeServlet&quot;)public class TCodeServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String ticket = req.getParameter(&quot;ticket&quot;); String randstr = req.getParameter(&quot;randstr&quot;); System.out.println(ticket); System.out.println(randstr); DescribeCaptchaResult describeCaptchaResult = new DescribeCaptchaResult(); PrintWriter out = resp.getWriter(); if(describeCaptchaResult.codeResponse(ticket,randstr))&#123; out.print(&quot;ok&quot;); System.out.println(&quot;ok&quot;); &#125;else&#123; out.print(&quot;fail&quot;); System.out.println(&quot;fail&quot;); &#125; &#125;&#125; 使用@WebServlet Annotation（注解）来配置Servlet，就不需要在web.xml文件中配置该Servlet，以下为其参数 属性名 类型 注解描述 name String 指定Servlet 的 name 属性，等价于 &lt;servlet-name&gt;。如果没有显式指定，则该 Servlet 的取值即为类的全限定名 value String[] 该属性等价于 urlPatterns 属性。两个属性不能同时使用 urlPatterns String[] 指定一组 Servlet 的 URL 匹配模式。等价于&lt;url-pattern&gt;标签 loadOnStartup int 指定 Servlet 的加载顺序，等价于 &lt;load-on-startup&gt;标签 initParams WebInitParam[] 指定一组 Servlet 初始化参数，等价于&lt;init-param&gt;标签 asyncSupported boolean 声明 Servlet 是否支持异步操作模式，等价于&lt;async-supported&gt; 标签 description String 该 Servlet 的描述信息，等价于 &lt;description&gt;标签 displayName String 该 Servlet 的显示名，通常配合工具使用，等价于 &lt;display-name&gt;标签 阿里云接口 详情请参考：Java实现网页滑动验证与短信验证码案例精析 新增配置 首先进入阿里云网站，直接搜索【验证码】，如下，进入【验证码控制台】 点击【新增配置】，工具需求选择【验证方式】 点击下一步让后复制代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;!--适用于主要访问来自中国内地地区用户的业务场景--&gt; &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;//g.alicdn.com/sd/ncpc/nc.js?t=2015052012&quot; &gt;&lt;/script&gt; &lt;!--适用于主要访问来自非中国内地地区用户的业务场景--&gt; &lt;!-- &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;//aeis.alicdn.com/sd/ncpc/nc.js?t=2015052012&quot;&gt;&lt;/script&gt; --&gt; &lt;/head&gt; &lt;body&gt; &lt;!--No-Captcha渲染的位置，其中 class 中必须包含 nc-container--&gt; &lt;div id=&quot;your-dom-id&quot; class=&quot;nc-container&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var nc_token = [&quot;CF_APP_1&quot;, new Date().getTime(), Math.random()].join( &quot;:&quot; ); var NC_Opt = &#123; //声明滑动验证需要渲染的目标元素ID。 renderTo: &quot;#your-dom-id&quot;, //应用类型标识。它和使用场景标识（scene字段）一起决定了滑动验证的业务场景与后端对应使用的策略模型。您可以在阿里云验证码控制台的配置管理页签找到对应的appkey字段值，请务必正确填写。 appkey: &quot;CF_APP_1&quot;, //使用场景标识。它和应用类型标识（appkey字段）一起决定了滑动验证的业务场景与后端对应使用的策略模型。您可以在阿里云验证码控制台的配置管理页签找到对应的scene值，请务必正确填写。 scene: &quot;register&quot;, //滑动验证码的主键，请勿将该字段定义为固定值。确保每个用户每次打开页面时，其token值都是不同的。系统默认的格式为：”您的appkey”+”时间戳”+”随机数”。 token: nc_token, //滑动条的宽度。 customWidth: 300, //业务键字段，可为空。为便于线上问题的排查，建议您按照线上问题定位文档中推荐的方法配置该字段值。 trans: &#123; key1: &quot;code0&quot; &#125;, //语言。PC端Web页面场景默认支持18国语言，详细配置方法请参见自定义文案与多语言文档。 language: &quot;cn&quot;, //是否启用。一般情况，保持默认值（true）即可。 isEnabled: true, //内部网络请求的超时时间。一般情况建议保持默认值（3000ms）。 timeout: 3000, //允许服务器超时重复次数，默认5次。超过重复次数后将触发报错。 times: 5, //前端滑动验证通过时会触发该回调参数。您可以在该回调参数中将请求标识（token）、会话ID（sessionid）、签名串（sig）字段记录下来，随业务请求一同发送至您的服务端调用验签。 callback: function (data) &#123; window.console &amp;&amp; console.log(nc_token); window.console &amp;&amp; console.log(data.csessionid); window.console &amp;&amp; console.log(data.sig); &#125;, &#125;; var nc = new noCaptcha(NC_Opt); //用于自定义文案。详细配置方法请参见自定义文案与多语言文档。 nc.upLang(&quot;cn&quot;, &#123; _startTEXT: &quot;请按住滑块，拖动到最右边&quot;, _yesTEXT: &quot;验证通过&quot;, _error300: &#x27;哎呀，出错了，点击&lt;a href=&quot;javascript:__nc.reset()&quot;&gt;刷新&lt;/a&gt;再来一次&#x27;, _errorNetwork: &#x27;网络不给力，请&lt;a href=&quot;javascript:__nc.reset()&quot;&gt;点击刷新&lt;/a&gt;&#x27;, &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 代码修改 配置jsp页面为将上面的代码复制进去如下完整版： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;/&gt; &lt;!-- 导入的包可以自己下载 --&gt; &lt;script src=&quot;https://code.jquery.com/jquery-3.5.1.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 国内使用 --&gt; &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;//g.alicdn.com/sd/ncpc/nc.js?t=2015052012&quot;&gt;&lt;/script&gt; &lt;!-- 若您的主要用户来源于海外，请替换使用下面的js资源 --&gt; &lt;!-- &lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;//aeis.alicdn.com/sd/ncpc/nc.js?t=2015052012&quot;&gt;&lt;/script&gt; --&gt; &lt;style type=&quot;text/css&quot;&gt; #btnOK &#123; border: none; color: white; text-align: center; display: inline-block; font-size: 16px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=&quot;post&quot; action=&quot;success.jsp&quot;&gt; &lt;div&gt; &lt;label&gt;验证:&lt;/label&gt; &lt;div id=&quot;your-dom-id&quot; class=&quot;nc-container&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot; id=&quot;btnOK&quot; disabled=&quot;disabled&quot;/&gt; &lt;/div&gt;&lt;/form&gt;&lt;script type=&quot;text/javascript&quot;&gt; var nc_token = [&quot;FFFF0N00000000008BB5&quot;, (new Date()).getTime(), Math.random()].join(&#x27;:&#x27;); var NC_Opt = &#123; renderTo: &quot;#your-dom-id&quot;, appkey: &quot;FFFF0N00000000008BB5&quot;, scene: &quot;nc_login&quot;, token: nc_token, customWidth: 300, trans: &#123;&quot;key1&quot;: &quot;code0&quot;&#125;, elementID: [&quot;usernameID&quot;], is_Opt: 0, language: &quot;cn&quot;, isEnabled: true, timeout: 3000, times: 5, apimap: &#123; &#125;, //验证成功后的回调函数 callback: function (data) &#123; $(&quot;#btnOK&quot;).prop(&quot;disabled&quot;, &quot;&quot;); $(&quot;#btnOK&quot;).css(&quot;background-color&quot;, &quot;#008cba&quot;); &#125; &#125; var nc = new noCaptcha(NC_Opt) nc.upLang(&#x27;cn&#x27;, &#123; _startTEXT: &quot;请按住滑块，拖动到最右边&quot;, _yesTEXT: &quot;验证通过&quot;, _error300: &quot;哎呀，出错了，点击&lt;a href=\\&quot;javascript:__nc.reset()\\&quot;&gt;刷新&lt;/a&gt;再来一次&quot;, _errorNetwork: &quot;网络不给力，请&lt;a href=\\&quot;javascript:__nc.reset()\\&quot;&gt;点击刷新&lt;/a&gt;&quot;, &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 样式修改","path":"page/SecurityCode.html","date":"03-20","excerpt":"","tags":[{"name":"企业常用技术","slug":"企业常用技术","permalink":"http://xiaoliblog.cn/tags/%E4%BC%81%E4%B8%9A%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF/"}]},{"title":"MySQL📦权限和如何设计数据库","text":"用户管理基本命令1234567891011121314151617181920212223242526272829303132333435363738/* 用户和权限管理 */ ------------------用户信息表：mysql.user-- 本质对mysql.user表进行增删改查-- 刷新权限FLUSH PRIVILEGES-- 增加用户 CREATE USER kuangshen IDENTIFIED BY &#x27;123456&#x27;CREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串) - 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。 - 只能创建用户，不能赋予权限。 - 用户名，注意引号：如 &#x27;user_name&#x27;@&#x27;192.168.1.1&#x27; - 密码也需引号，纯数字密码也要加引号 - 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD-- 重命名用户 RENAME USER kuangshen TO kuangshen2RENAME USER old_user TO new_user-- 设置密码SET PASSWORD = PASSWORD(&#x27;密码&#x27;) -- 为当前用户设置密码SET PASSWORD FOR 用户名 = PASSWORD(&#x27;密码&#x27;) -- 为指定用户设置密码-- 删除用户 DROP USER kuangshen2DROP USER 用户名-- 分配权限/添加用户GRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] &#x27;password&#x27;] - all privileges 表示所有权限 - *.* 表示所有库的所有表 - 库名.表名 表示某库下面的某表-- 查看权限 SHOW GRANTS FOR root@localhost;SHOW GRANTS FOR 用户名 -- 查看当前用户权限 SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER();-- 撤消权限REVOKE 权限列表 ON 表名 FROM 用户名REVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名 -- 撤销所有权限 权限解释12345678910111213141516171819202122232425262728293031323334353637383940-- 权限列表ALL [PRIVILEGES] -- 设置除GRANT OPTION之外的所有简单权限ALTER -- 允许使用ALTER TABLEALTER ROUTINE -- 更改或取消已存储的子程序CREATE -- 允许使用CREATE TABLECREATE ROUTINE -- 创建已存储的子程序CREATE TEMPORARY TABLES -- 允许使用CREATE TEMPORARY TABLECREATE USER -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。CREATE VIEW -- 允许使用CREATE VIEWDELETE -- 允许使用DELETEDROP -- 允许使用DROP TABLEEXECUTE -- 允许用户运行已存储的子程序FILE -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILEINDEX -- 允许使用CREATE INDEX和DROP INDEXINSERT -- 允许使用INSERTLOCK TABLES -- 允许对您拥有SELECT权限的表使用LOCK TABLESPROCESS -- 允许使用SHOW FULL PROCESSLISTREFERENCES -- 未被实施RELOAD -- 允许使用FLUSHREPLICATION CLIENT -- 允许用户询问从属服务器或主服务器的地址REPLICATION SLAVE -- 用于复制型从属服务器（从主服务器中读取二进制日志事件）SELECT -- 允许使用SELECTSHOW DATABASES -- 显示所有数据库SHOW VIEW -- 允许使用SHOW CREATE VIEWSHUTDOWN -- 允许使用mysqladmin shutdownSUPER -- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。UPDATE -- 允许使用UPDATEUSAGE -- “无权限”的同义词GRANT OPTION -- 允许授予权限/* 表维护 */-- 分析和存储表的关键字分布ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE 表名 ...-- 检查一个或多个表是否有错误CHECK TABLE tbl_name [, tbl_name] ... [option] ...option = &#123;QUICK | FAST | MEDIUM | EXTENDED | CHANGED&#125;-- 整理数据文件的碎片OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... MySQL备份 数据库备份必要性 保证重要数据不丢失 数据转移 MySQL数据库备份方法 mysqldump备份工具 数据库管理工具，如SQLyog 直接拷贝数据库文件和相关配置文件 mysqldump客户端作用 : 转储数据库 搜集数据库进行备份 将数据转移到另一个SQL服务器，不一定是MySQL服务器 使用命令行导出 mysqldump 123456789-- 导出1. 导出一张表 -- mysqldump -uroot -p123456 school student &gt;D:/a.sql mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:/a.sql)2. 导出多张表 -- mysqldump -uroot -p123456 school student result &gt;D:/a.sql mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:/a.sql)3. 导出所有表 -- mysqldump -uroot -p123456 school &gt;D:/a.sql mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:/a.sql)4. 导出一个库 -- mysqldump -uroot -p123456 -B school &gt;D:/a.sql mysqldump -u用户名 -p密码 -B 库名 &gt; 文件名(D:/a.sql) 可以-w携带备份条件 12345-- 导入1. 在登录mysql的情况下：-- source D:/a.sql source 备份文件2. 在不登录的情况下 mysql -u用户名 -p密码 库名 &lt; 备份文件 规范化数据库设计 设计数据库步骤 收集信息，与该系统有关人员进行交流 , 座谈 , 充分了解用户需求 , 理解数据库需要完成的任务. 标识实体[Entity]：标识数据库要管理的关键对象或实体，实体一般是名词 标识每个实体需要存储的详细信息[Attribute] 标识实体之间的关系[Relationship] 三大范式 第一范式 (1st NF) 第一范式的目标是确保每列的原子性,如果每列都是不可再分的最小数据单元,则满足第一范式 第二范式(2nd NF) 第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。 第二范式要求每个表只描述一件事情 第三范式(3rd NF) 如果一个关系满足第二范式，并且除了主键以外的其他列都不传递依赖于主键列,则满足第三范式. 第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。","path":"page/MySQL07.html","date":"03-19","excerpt":"","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://xiaoliblog.cn/tags/MySQL/"}]},{"title":"MySQL📦事务和索引","text":"事务 事务就是将一组SQL语句放在同一批次内去执行 如果一个SQL语句出错,则该批次内的所有SQL都将被取消执行 MySQL事务处理只支持InnoDB和BDB数据表类型 ACID原则 参考博客：https://blog.csdn.net/dengjili/article/details/82468576 原子性(Atomic) 整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（ROLLBACK）到事务开始前的状态，就像这个事务从来没有执行过一样 一致性(Consist) 事务在开始和结束时，应该始终满足一致性约束。比如系统要求A+B=100,那么事务如果改变了A的数值，则B的数值也要相应修改来满足这样一致性要求； 隔离性(Isolated) 主要用于实现并发控制，隔离能够确保并发执行的事务按顺序一个接一个地执行。通过隔离，一个未完成事务不会影响另外一个未完成事务 持久性(Durable) 在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚，即不可逆 事务的隔离级别 脏读：指一个事务读取了另外一个事务未提交的数据 不可重复读：在一个事务内读取表中的某一行数据，多次读取结果不同 虚读(幻读)：是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致 基本语法123456789101112131415161718192021222324-- 使用set语句来改变自动提交模式SET autocommit = 0; /*关闭*/SET autocommit = 1; /*开启*/-- 注意:--- 1.MySQL中默认是自动提交--- 2.使用事务时应先关闭自动提交-- 开始一个事务,标记事务的起始点START TRANSACTION -- 提交一个事务给数据库COMMIT-- 将事务回滚,数据回到本次事务的初始状态ROLLBACK-- 还原MySQL数据库的自动提交SET autocommit =1;-- 保存点SAVEPOINT 保存点名称 -- 设置一个事务保存点ROLLBACK TO SAVEPOINT 保存点名称 -- 回滚到保存点RELEASE SAVEPOINT 保存点名称 -- 删除保存点 测试12345678910111213141516171819202122232425262728293031/*课堂测试题目A在线买一款价格为500元商品,网上银行转账.A的银行卡余额为2000,然后给商家B支付500.商家B一开始的银行卡余额为10000创建数据库shop和创建表account并插入2条数据*/CREATE DATABASE `shop`CHARACTER SET utf8 COLLATE utf8_general_ci;USE `shop`;CREATE TABLE `account` (`id` INT(11) NOT NULL AUTO_INCREMENT,`name` VARCHAR(32) NOT NULL,`cash` DECIMAL(9,2) NOT NULL,PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO account (`name`,`cash`)VALUES(&#x27;A&#x27;,2000.00),(&#x27;B&#x27;,10000.00)-- 转账实现SET autocommit = 0; -- 关闭自动提交START TRANSACTION; -- 开始一个事务,标记事务的起始点UPDATE account SET cash=cash-500 WHERE `name`=&#x27;A&#x27;;UPDATE account SET cash=cash+500 WHERE `name`=&#x27;B&#x27;;COMMIT; -- 提交事务# rollback;SET autocommit = 1; -- 恢复自动提交 索引 MySQL官方对索引的定义为：索引(Index) 是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构 索引的作用 提高查询速度 确保数据的唯一性 可以加速表和表之间的连接 , 实现表与表之间的参照完整性 使用分组和排序子句进行数据检索时 , 可以显著减少分组和排序的时间 全文检索字段进行搜索优化. 分类 主键索引 (Primary Key) 唯一索引 (Unique Key) 常规索引 (Index/Key) 全文索引 (FullText) 主键索引 主键 : 某一个属性组能唯一标识一条记录，主键不可重复 特点 : 最常见的索引类型 确保数据记录的唯一性 确定特定数据记录在数据库中的位置 唯一索引 作用 : 避免同一个表中某数据列中的值重复 与主键索引的区别 主键索引只能有一个，不能重复 唯一索引可能有多个，可以重复 12345CREATE TABLE `Grade`( `GradeID` INT(11) AUTO_INCREMENT PRIMARYKEY, `GradeName` VARCHAR(32) NOT NULL UNIQUE -- 或 UNIQUE KEY `GradeID` (`GradeID`)) 常规索引 作用 : 快速定位特定数据 注意 : index 和 key 关键字都可以设置常规索引 应加在查询找条件的字段 不宜添加太多常规索引,影响数据的插入,删除和修改操作 1234CREATE TABLE `result`( -- 省略一些代码 INDEX/KEY `ind` (`studentNo`,`subjectNo`) -- 创建表时添加) 12-- 创建后添加ALTER TABLE `result` ADD INDEX `ind`(`studentNo`,`subjectNo`); 全文索引 百度搜索：全文索引 作用 : 快速定位特定数据 注意 : 只能用于MyISAM类型的数据表 只能用于CHAR , VARCHAR , TEXT数据列类型 适合大型数据集 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*#方法一：创建表时 CREATE TABLE 表名 ( 字段名1 数据类型 [完整性约束条件…], 字段名2 数据类型 [完整性约束条件…], [UNIQUE | FULLTEXT | SPATIAL ] INDEX | KEY [索引名] (字段名[(长度)] [ASC |DESC]) );#方法二：CREATE在已存在的表上创建索引 CREATE [UNIQUE | FULLTEXT | SPATIAL ] INDEX 索引名 ON 表名 (字段名[(长度)] [ASC |DESC]) ;#方法三：ALTER TABLE在已存在的表上创建索引 ALTER TABLE 表名 ADD [UNIQUE | FULLTEXT | SPATIAL ] INDEX 索引名 (字段名[(长度)] [ASC |DESC]) ; #删除索引：DROP INDEX 索引名 ON 表名字;#删除主键索引: ALTER TABLE 表名 DROP PRIMARY KEY;#显示索引信息: SHOW INDEX FROM student;*//*增加全文索引*/ALTER TABLE `school`.`student` ADD FULLTEXT INDEX `studentname` (`StudentName`);/*EXPLAIN : 分析SQL语句执行性能*/EXPLAIN SELECT * FROM student WHERE studentno=&#x27;1000&#x27;;/*使用全文索引*/-- 全文搜索通过 MATCH() 函数完成。-- 搜索字符串作为 against() 的参数被给定。搜索以忽略字母大小写的方式执行。对于表中的每个记录行，MATCH() 返回一个相关性值。即，在搜索字符串与记录行在 MATCH() 列表中指定的列的文本之间的相似性尺度。EXPLAIN SELECT *FROM student WHERE MATCH(studentname) AGAINST(&#x27;love&#x27;);/*开始之前，先说一下全文索引的版本、存储引擎、数据类型的支持情况MySQL 5.6 以前的版本，只有 MyISAM 存储引擎支持全文索引；MySQL 5.6 及以后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引;只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引。测试或使用全文索引时，要先看一下自己的 MySQL 版本、存储引擎和数据类型是否支持全文索引。*/ 测试索引 建表app_user： 123456789101112CREATE TABLE `app_user` (`id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,`name` varchar(50) DEFAULT &#x27;&#x27; COMMENT &#x27;用户昵称&#x27;,`email` varchar(50) NOT NULL COMMENT &#x27;用户邮箱&#x27;,`phone` varchar(20) DEFAULT &#x27;&#x27; COMMENT &#x27;手机号&#x27;,`gender` tinyint(4) unsigned DEFAULT &#x27;0&#x27; COMMENT &#x27;性别（0:男；1：女）&#x27;,`password` varchar(100) NOT NULL COMMENT &#x27;密码&#x27;,`age` tinyint(4) DEFAULT &#x27;0&#x27; COMMENT &#x27;年龄&#x27;,`create_time` datetime DEFAULT CURRENT_TIMESTAMP,`update_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;app用户表&#x27; 批量插入数据：100w 123456789101112131415DROP FUNCTION IF EXISTS mock_data;DELIMITER $$CREATE FUNCTION mock_data()RETURNS INTBEGINDECLARE num INT DEFAULT 1000000;DECLARE i INT DEFAULT 0;WHILE i &lt; num DO INSERT INTO app_user(`name`, `email`, `phone`, `gender`, `password`, `age`) VALUES(CONCAT(&#x27;用户&#x27;, i), &#x27;24736743@qq.com&#x27;, CONCAT(&#x27;18&#x27;, FLOOR(RAND()*(999999999-100000000)+100000000)),FLOOR(RAND()*2),UUID(), FLOOR(RAND()*100)); SET i = i + 1;END WHILE;RETURN i;END;SELECT mock_data(); 索引效率测试 无索引 12345678910111213141516171819SELECT * FROM app_user WHERE name = &#x27;用户9999&#x27;; -- 查看耗时SELECT * FROM app_user WHERE name = &#x27;用户9999&#x27;;SELECT * FROM app_user WHERE name = &#x27;用户9999&#x27;;mysql&gt; EXPLAIN SELECT * FROM app_user WHERE name = &#x27;用户9999&#x27;\\G*************************** 1. row *************************** id: 1select_type: SIMPLE table: app_user partitions: NULL type: ALLpossible_keys: NULL key: NULL key_len: NULL ref: NULL rows: 992759 filtered: 10.00 Extra: Using where1 row in set, 1 warning (0.00 sec) 创建索引 1CREATE INDEX idx_app_user_name ON app_user(name); 测试普通索引 123456789101112131415161718192021222324mysql&gt; EXPLAIN SELECT * FROM app_user WHERE name = &#x27;用户9999&#x27;\\G*************************** 1. row *************************** id: 1select_type: SIMPLE table: app_user partitions: NULL type: refpossible_keys: idx_app_user_name key: idx_app_user_name key_len: 203 ref: const rows: 1 filtered: 100.00 Extra: NULL1 row in set, 1 warning (0.00 sec)mysql&gt; SELECT * FROM app_user WHERE name = &#x27;用户9999&#x27;;1 row in set (0.00 sec)mysql&gt; SELECT * FROM app_user WHERE name = &#x27;用户9999&#x27;;1 row in set (0.00 sec)mysql&gt; SELECT * FROM app_user WHERE name = &#x27;用户9999&#x27;;1 row in set (0.00 sec) 索引准则 索引不是越多越好 不要对经常变动的数据加索引 小数据量的表建议不要加索引 索引一般应加在查找条件的字段 索引的数据结构 我们可以在创建上述索引的时候，为其指定索引类型，分两类 hash类型的索引：查询单条快，范围查询慢 btree类型的索引：b+树，层数越多，数据量指数级增长（我们就用它，因为innodb默认支持它） 不同的存储引擎支持的索引类型也不一样 InnoDB 支持事务，支持行级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引； MyISAM 不支持事务，支持表级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引； Memory 不支持事务，支持表级别锁定，支持 B-tree、Hash 等索引，不支持 Full-text 索引； NDB 支持事务，支持行级别锁定，支持 Hash 索引，不支持 B-tree、Full-text 等索引； Archive 不支持事务，支持表级别锁定，不支持 B-tree、Hash、Full-text 等索引；","path":"page/MySQL06.html","date":"03-19","excerpt":"","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://xiaoliblog.cn/tags/MySQL/"}]},{"title":"MySQL📦MySQL函数","text":"常用函数数据函数12345SELECT ABS(-8); /*绝对值*/SELECT CEILING(9.4); /*向上取整*/SELECT FLOOR(9.4); /*向下取整*/SELECT RAND(); /*随机数,返回一个0-1之间的随机数*/SELECT SIGN(0); /*符号函数: 负数返回-1,正数返回1,0返回0*/ 字符串函数1234567891011121314SELECT CHAR_LENGTH(&#x27;狂神说坚持就能成功&#x27;); /*返回字符串包含的字符数*/SELECT CONCAT(&#x27;我&#x27;,&#x27;爱&#x27;,&#x27;程序&#x27;); /*合并字符串,参数可以有多个*/SELECT INSERT(&#x27;我爱编程helloworld&#x27;,1,2,&#x27;超级热爱&#x27;); /*替换字符串,从某个位置开始替换某个长度*/SELECT LOWER(&#x27;KuangShen&#x27;); /*小写*/SELECT UPPER(&#x27;KuangShen&#x27;); /*大写*/SELECT LEFT(&#x27;hello,world&#x27;,5); /*从左边截取*/SELECT RIGHT(&#x27;hello,world&#x27;,5); /*从右边截取*/SELECT REPLACE(&#x27;狂神说坚持就能成功&#x27;,&#x27;坚持&#x27;,&#x27;努力&#x27;); /*替换字符串*/SELECT SUBSTR(&#x27;狂神说坚持就能成功&#x27;,4,6); /*截取字符串,开始和长度*/SELECT REVERSE(&#x27;狂神说坚持就能成功&#x27;); /*反转-- 查询姓周的同学,改成邹SELECT REPLACE(studentname,&#x27;周&#x27;,&#x27;邹&#x27;) AS 新名字FROM student WHERE studentname LIKE &#x27;周%&#x27;; 日期和时间函数12345678910111213SELECT CURRENT_DATE(); /*获取当前日期*/SELECT CURDATE(); /*获取当前日期*/SELECT NOW(); /*获取当前日期和时间*/SELECT LOCALTIME(); /*获取当前日期和时间*/SELECT SYSDATE(); /*获取当前日期和时间*/-- 获取年月日,时分秒SELECT YEAR(NOW());SELECT MONTH(NOW());SELECT DAY(NOW());SELECT HOUR(NOW());SELECT MINUTE(NOW());SELECT SECOND(NOW()); 系统信息函数12SELECT VERSION(); /*版本*/SELECT USER(); /*用户*/ 聚合函数 函数名称 描述 COUNT() 返回满足Select条件的记录总和数，如 select count(*) 【不建议使用 *，效率低】 SUM() 返回数字字段或表达式列作统计，返回一列的总和 AVG() 通常为数值字段或表达列作统计，返回一列的平均值 MAX() 可以为数值字段，字符字段或表达式列作统计，返回最大的值 MIN() 可以为数值字段，字符字段或表达式列作统计，返回最小的值 123456789101112131415161718192021222324-- 聚合函数 /*COUNT:非空的*/ SELECT COUNT(studentname) FROM student; SELECT COUNT(*) FROM student; SELECT COUNT(1) FROM student; /*推荐*/ -- 从含义上讲，count(1) 与 count(*) 都表示对全部数据行的查询。 -- count(字段) 会统计该字段在表中出现的次数，忽略字段为null 的情况。即不统计字段为null 的记录。 -- count(*) 包括了所有的列，相当于行数，在统计结果的时候，包含字段为null 的记录； -- count(1) 用1代表代码行，在统计结果的时候，包含字段为null 的记录 。 /* 很多人认为count(1)执行的效率会比count(*)高，原因是count(*)会存在全表扫描，而count(1)可以针对一个字段进行查询。其实不然，count(1)和count(*)都会对全表进行扫描，统计所有记录的条数，包括那些为null的记录，因此，它们的效率可以说是相差无几。而count(字段)则与前两者不同，它会统计该字段不为null的记录条数。 下面它们之间的一些对比： 1）在表没有主键时，count(1)比count(*)快 2）有主键时，主键作为计算条件，count(主键)效率最高； 3）若表格只有一个字段，则count(*)效率较高。 */ SELECT SUM(StudentResult) AS 总和 FROM result; SELECT AVG(StudentResult) AS 平均分 FROM result; SELECT MAX(StudentResult) AS 最高分 FROM result; SELECT MIN(StudentResult) AS 最低分 FROM result; 12345678910111213141516 -- 查询不同课程的平均分,最高分,最低分-- 前提:根据不同的课程进行分组SELECT subjectname,AVG(studentresult) AS 平均分,MAX(StudentResult) AS 最高分,MIN(StudentResult) AS 最低分FROM result AS rINNER JOIN `subject` AS sON r.subjectno = s.subjectnoGROUP BY r.subjectnoHAVING 平均分&gt;80;/*where写在group by前面.要是放在分组后面的筛选要使用HAVING..因为having是从前面筛选的字段再筛选，而where是从数据表中的&gt;字段直接进行的筛选的*/ MD5 加密 MD5即Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有MD5实现。将数据（如汉字）运算为另一固定长度值，是杂凑算法的基础原理，MD5的前身有MD2、MD3和MD4 新建一个表 testmd5 123456CREATE TABLE `testmd5` ( `id` INT(4) NOT NULL, `name` VARCHAR(20) NOT NULL, `pwd` VARCHAR(50) NOT NULL, PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8 插入一些数据 12-- 明文密码 INSERT INTO testmd5 VALUES(1,&#x27;kuangshen&#x27;,&#x27;123456&#x27;),(2,&#x27;qinjiang&#x27;,&#x27;456789&#x27;) 如果我们要对pwd这一列数据进行加密，语法是： 1update testmd5 set pwd = md5(pwd); 如果单独对某个用户(如kuangshen)的密码加密： 12INSERT INTO testmd5 VALUES(3,&#x27;kuangshen2&#x27;,&#x27;123456&#x27;)update testmd5 set pwd = md5(pwd) where name = &#x27;kuangshen2&#x27;; 插入新的数据自动加密 1INSERT INTO testmd5 VALUES(4,&#x27;kuangshen3&#x27;,md5(&#x27;123456&#x27;)); 查询登录用户信息（md5对比使用，查看用户输入加密后的密码进行比对） 12-- 将用户传递过来的密码,进行md5加密,然后比对加密后的值SELECT * FROM testmd5 WHERE `name`=&#x27;kuangshen&#x27; AND pwd=MD5(&#x27;123456&#x27;); 经过MD5加密后，表中的密码为一长串字符，校验就是将用户传递进来的密码进行MD5加密，然后比对加密后的值 总结123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354-- ================ 内置函数 ================-- 数值函数abs(x) -- 绝对值 abs(-10.9) = 10format(x, d) -- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46ceil(x) -- 向上取整 ceil(10.1) = 11floor(x) -- 向下取整 floor (10.1) = 10round(x) -- 四舍五入去整mod(m, n) -- m%n m mod n 求余 10%3=1pi() -- 获得圆周率pow(m, n) -- m^nsqrt(x) -- 算术平方根rand() -- 随机数truncate(x, d) -- 截取d位小数-- 时间日期函数now(), current_timestamp(); -- 当前日期时间current_date(); -- 当前日期current_time(); -- 当前时间date(&#x27;yyyy-mm-dd hh:ii:ss&#x27;); -- 获取日期部分time(&#x27;yyyy-mm-dd hh:ii:ss&#x27;); -- 获取时间部分date_format(&#x27;yyyy-mm-dd hh:ii:ss&#x27;, &#x27;%d %y %a %d %m %b %j&#x27;); -- 格式化时间unix_timestamp(); -- 获得unix时间戳from_unixtime(); -- 从时间戳获得时间-- 字符串函数length(string) -- string长度，字节char_length(string) -- string的字符个数substring(str, position [,length]) -- 从str的position开始,取length个字符replace(str ,search_str ,replace_str) -- 在str中用replace_str替换search_strinstr(string ,substring) -- 返回substring首次在string中出现的位置concat(string [,...]) -- 连接字串charset(str) -- 返回字串字符集lcase(string) -- 转换成小写left(string, length) -- 从string2中的左边起取length个字符load_file(file_name) -- 从文件读取内容locate(substring, string [,start_position]) -- 同instr,但可指定开始位置lpad(string, length, pad) -- 重复用pad加在string开头,直到字串长度为lengthltrim(string) -- 去除前端空格repeat(string, count) -- 重复count次rpad(string, length, pad) --在str后用pad补充,直到长度为lengthrtrim(string) -- 去除后端空格strcmp(string1 ,string2) -- 逐字符比较两字串大小-- 聚合函数count()sum();max();min();avg();group_concat()-- 其他常用函数md5();default();","path":"page/MySQL05.html","date":"03-19","excerpt":"","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://xiaoliblog.cn/tags/MySQL/"}]},{"title":"MySQL📦DQL查询数据","text":"DQL语言 DQL( Data Query Language 数据查询语言 ) 查询数据库数据 , 如SELECT语句 简单的单表查询或多表的复杂查询和嵌套查询 是数据库语言中最核心，最重要的语句 使用频率最高的语句 Select语法12345678910SELECT [ALL | DISTINCT]&#123;* | table.* | [table.field1[as alias1][,table.field2[as alias2]][,...]]&#125;FROM table_name [as table_alias] [left | right | inner join table_name2] -- 联合查询 [WHERE ...] -- 指定结果需满足的条件 [GROUP BY ...] -- 指定结果按照哪几个字段来分组 [HAVING] -- 过滤分组的记录必须满足的次要条件 [ORDER BY ...] -- 指定查询记录按一个或多个条件排序 [LIMIT &#123;[offset,]row_count | row_countOFFSET offset&#125;]; -- 指定查询的记录从哪条至哪条 注意 : [ ] 括号代表可选的 , { }括号代表必选得 测试环境搭建12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788CREATE DATABASE IF NOT EXISTS `school`;-- 创建一个school数据库USE `school`;-- 创建学生表DROP TABLE IF EXISTS `student`;CREATE TABLE `student`( `studentno` INT(4) NOT NULL COMMENT &#x27;学号&#x27;, `loginpwd` VARCHAR(20) DEFAULT NULL, `studentname` VARCHAR(20) DEFAULT NULL COMMENT &#x27;学生姓名&#x27;, `sex` TINYINT(1) DEFAULT NULL COMMENT &#x27;性别，0或1&#x27;, `gradeid` INT(11) DEFAULT NULL COMMENT &#x27;年级编号&#x27;, `phone` VARCHAR(50) NOT NULL COMMENT &#x27;联系电话，允许为空&#x27;, `address` VARCHAR(255) NOT NULL COMMENT &#x27;地址，允许为空&#x27;, `borndate` DATETIME DEFAULT NULL COMMENT &#x27;出生时间&#x27;, `email` VARCHAR (50) NOT NULL COMMENT &#x27;邮箱账号允许为空&#x27;, `identitycard` VARCHAR(18) DEFAULT NULL COMMENT &#x27;身份证号&#x27;, PRIMARY KEY (`studentno`), UNIQUE KEY `identitycard`(`identitycard`), KEY `email` (`email`))ENGINE=MYISAM DEFAULT CHARSET=utf8;-- 创建年级表DROP TABLE IF EXISTS `grade`;CREATE TABLE `grade`( `gradeid` INT(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;年级编号&#x27;, `gradename` VARCHAR(50) NOT NULL COMMENT &#x27;年级名称&#x27;, PRIMARY KEY (`gradeid`)) ENGINE=INNODB AUTO_INCREMENT = 6 DEFAULT CHARSET = utf8;-- 创建科目表DROP TABLE IF EXISTS `subject`;CREATE TABLE `subject`( `subjectno`INT(11) NOT NULL AUTO_INCREMENT COMMENT &#x27;课程编号&#x27;, `subjectname` VARCHAR(50) DEFAULT NULL COMMENT &#x27;课程名称&#x27;, `classhour` INT(4) DEFAULT NULL COMMENT &#x27;学时&#x27;, `gradeid` INT(4) DEFAULT NULL COMMENT &#x27;年级编号&#x27;, PRIMARY KEY (`subjectno`))ENGINE = INNODB AUTO_INCREMENT = 19 DEFAULT CHARSET = utf8;-- 创建成绩表DROP TABLE IF EXISTS `result`;CREATE TABLE `result`( `studentno` INT(4) NOT NULL COMMENT &#x27;学号&#x27;, `subjectno` INT(4) NOT NULL COMMENT &#x27;课程编号&#x27;, `examdate` DATETIME NOT NULL COMMENT &#x27;考试日期&#x27;, `studentresult` INT (4) NOT NULL COMMENT &#x27;考试成绩&#x27;, KEY `subjectno` (`subjectno`))ENGINE = INNODB DEFAULT CHARSET = utf8;-- 插入学生数据 其余自行添加 这里只添加了2行INSERT INTO `student` (`studentno`,`loginpwd`,`studentname`,`sex`,`gradeid`,`phone`,`address`,`borndate`,`email`,`identitycard`)VALUES(1000,&#x27;123456&#x27;,&#x27;张伟&#x27;,0,2,&#x27;13800001234&#x27;,&#x27;北京朝阳&#x27;,&#x27;1980-1-1&#x27;,&#x27;text123@qq.com&#x27;,&#x27;123456198001011234&#x27;),(1001,&#x27;123456&#x27;,&#x27;赵强&#x27;,1,3,&#x27;13800002222&#x27;,&#x27;广东深圳&#x27;,&#x27;1990-1-1&#x27;,&#x27;text111@qq.com&#x27;,&#x27;123456199001011233&#x27;);-- 插入成绩数据 这里仅插入了一组，其余自行添加INSERT INTO `result`(`studentno`,`subjectno`,`examdate`,`studentresult`)VALUES(1000,1,&#x27;2013-11-11 16:00:00&#x27;,85),(1000,2,&#x27;2013-11-12 16:00:00&#x27;,70),(1000,3,&#x27;2013-11-11 09:00:00&#x27;,68),(1000,4,&#x27;2013-11-13 16:00:00&#x27;,98),(1000,5,&#x27;2013-11-14 16:00:00&#x27;,58);-- 插入年级数据INSERT INTO `grade` (`gradeid`,`gradename`) VALUES(1,&#x27;大一&#x27;),(2,&#x27;大二&#x27;),(3,&#x27;大三&#x27;),(4,&#x27;大四&#x27;),(5,&#x27;预科班&#x27;);FullHouse回复 @白条asd :4“-- 插入科目数据INSERT INTO `subject`(`subjectno`,`subjectname`,`classhour`,`gradeid`)VALUES(1,&#x27;高等数学-1&#x27;,110,1),(2,&#x27;高等数学-2&#x27;,110,2),(3,&#x27;高等数学-3&#x27;,100,3),(4,&#x27;高等数学-4&#x27;,130,4),(5,&#x27;C语言-1&#x27;,110,1),(6,&#x27;C语言-2&#x27;,110,2),(7,&#x27;C语言-3&#x27;,100,3),(8,&#x27;C语言-4&#x27;,130,4),(9,&#x27;Java程序设计-1&#x27;,110,1),(10,&#x27;Java程序设计-2&#x27;,110,2),(11,&#x27;Java程序设计-3&#x27;,100,3),(12,&#x27;Java程序设计-4&#x27;,130,4),(13,&#x27;数据库结构-1&#x27;,110,1),(14,&#x27;数据库结构-2&#x27;,110,2),(15,&#x27;数据库结构-3&#x27;,100,3),(16,&#x27;数据库结构-4&#x27;,130,4),(17,&#x27;C#基础&#x27;,130,1); 指定查询字段1234567-- 查询表中所有的数据列结果 , 采用 **&quot; \\* &quot;** 符号; 但是效率低，不推荐 .-- 查询所有学生信息SELECT * FROM student;-- 查询指定列(学号 , 姓名)SELECT studentno,studentname FROM student; AS 子句 AS子句作用 可给数据列取一个新别名 可给表取一个新别名 可把经计算或总结的结果用另一个新名称来代替 123456789-- 这里是为列取别名(当然as关键词可以省略)SELECT studentno AS 学号,studentname AS 姓名 FROM student;-- 使用as也可以为表取别名SELECT studentno AS 学号,studentname AS 姓名 FROM student AS s;-- 使用as,为查询结果取一个新名字-- CONCAT()函数拼接字符串SELECT CONCAT(&#x27;姓名:&#x27;,studentname) AS 新姓名 FROM student; DISTINCT关键字 DISTINCT关键字作用 去掉SELECT查询返回的记录结果中重复的记录 ( 返回所有列的值都相同 ) , 只返回一条 1234-- # 查看哪些同学参加了考试(学号) 去除重复项SELECT * FROM result; -- 查看考试成绩SELECT studentno FROM result; -- 查看哪些同学参加了考试SELECT DISTINCT studentno FROM result; -- 了解:DISTINCT 去除重复项 , (默认是ALL) 使用表达式的列 数据库中的表达式 : 一般由文本值 , 列值 , NULL , 函数和操作符等组成 应用场景 : SELECT语句返回结果列中使用 SELECT语句中的ORDER BY , HAVING等子句中使用 DML语句中的 where 条件语句中使用表达式 避免SQL返回结果中包含 ‘ . ‘ , ‘ * ‘ 和括号等干扰开发语言程序. 1234567-- selcet查询中可以使用表达式SELECT @@auto_increment_increment; -- 查询自增步长SELECT VERSION(); -- 查询版本号SELECT 100*3-1 AS 计算结果; -- 表达式-- 学员考试成绩集体提分一分查看SELECT studentno,StudentResult+1 AS &#x27;提分后&#x27; FROM result; where条件语句 作用：用于检索数据表中 符合条件 的记录 搜索条件可由一个或多个逻辑表达式组成 , 结果一般为真或假. 逻辑操作符 123456789101112131415161718192021222324252627-- 满足条件的查询(where)SELECT Studentno,StudentResult FROM result;-- 查询考试成绩在95-100之间的SELECT Studentno,StudentResultFROM resultWHERE StudentResult&gt;=95 AND StudentResult&lt;=100;-- AND也可以写成 &amp;&amp;SELECT Studentno,StudentResultFROM resultWHERE StudentResult&gt;=95 &amp;&amp; StudentResult&lt;=100;-- 模糊查询(对应的词:精确查询)SELECT Studentno,StudentResultFROM resultWHERE StudentResult BETWEEN 95 AND 100;-- 除了1000号同学,要其他同学的成绩SELECT studentno,studentresultFROM resultWHERE studentno!=1000;-- 使用NOTSELECT studentno,studentresultFROM resultWHERE NOT studentno=1000; 比较操作符 数值数据类型的记录之间才能进行算术运算 ; 相同数据类型的数据之间才能进行比较 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051-- 模糊查询 between and \\ like \\ in \\ null-- =============================================-- LIKE-- =============================================-- 查询姓刘的同学的学号及姓名-- like结合使用的通配符 : % (代表0到任意个字符) _ (一个字符)SELECT studentno,studentname FROM studentWHERE studentname LIKE &#x27;刘%&#x27;;-- 查询姓刘的同学,后面只有一个字的SELECT studentno,studentname FROM studentWHERE studentname LIKE &#x27;刘_&#x27;;-- 查询姓刘的同学,后面只有两个字的SELECT studentno,studentname FROM studentWHERE studentname LIKE &#x27;刘__&#x27;;-- 查询姓名中含有 嘉 字的SELECT studentno,studentname FROM studentWHERE studentname LIKE &#x27;%嘉%&#x27;;-- 查询姓名中含有特殊字符的需要使用转义符号 &#x27;\\&#x27;-- 自定义转义符关键字: ESCAPE &#x27;:&#x27;-- =============================================-- IN-- =============================================-- 查询学号为1000,1001,1002的学生姓名SELECT studentno,studentname FROM studentWHERE studentno IN (1000,1001,1002);-- 查询地址在北京,南京,河南洛阳的学生SELECT studentno,studentname,address FROM studentWHERE address IN (&#x27;北京&#x27;,&#x27;南京&#x27;,&#x27;河南洛阳&#x27;);-- =============================================-- NULL 空-- =============================================-- 查询出生日期没有填写的同学-- 不能直接写=NULL , 这是代表错误的 , 用 is nullSELECT studentname FROM studentWHERE BornDate IS NULL;-- 查询出生日期填写的同学SELECT studentname FROM studentWHERE BornDate IS NOT NULL;-- 查询没有写家庭住址的同学(空字符串不等于null)SELECT studentname FROM studentWHERE Address=&#x27;&#x27; OR Address IS NULL; 连接查询JOIN 对比 七种Join 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/*连接查询 如需要多张数据表的数据进行查询,则可通过连接运算符实现多个查询内连接 inner join 查询两个表中的结果集中的交集外连接 outer join 左外连接 left join (以左表作为基准,右边表来一一匹配,匹配不上的,返回左表的记录,右表以NULL填充) 右外连接 right join (以右表作为基准,左边表来一一匹配,匹配不上的,返回右表的记录,左表以NULL填充) 等值连接和非等值连接自连接*/-- 查询参加了考试的同学信息(学号,学生姓名,科目编号,分数)SELECT * FROM student;SELECT * FROM result;/*思路:(1):分析需求,确定查询的列来源于两个类,student result,连接查询(2):确定使用哪种连接查询?(内连接)*/SELECT s.studentno,studentname,subjectno,StudentResultFROM student sINNER JOIN result rON r.studentno = s.studentno-- 右连接(也可实现)SELECT s.studentno,studentname,subjectno,StudentResultFROM student sRIGHT JOIN result rON r.studentno = s.studentno-- 等值连接SELECT s.studentno,studentname,subjectno,StudentResultFROM student s , result rWHERE r.studentno = s.studentno-- 左连接 (查询了所有同学,不考试的也会查出来)SELECT s.studentno,studentname,subjectno,StudentResultFROM student sLEFT JOIN result rON r.studentno = s.studentno-- 查一下缺考的同学(左连接应用场景)SELECT s.studentno,studentname,subjectno,StudentResultFROM student sLEFT JOIN result rON r.studentno = s.studentnoWHERE StudentResult IS NULL-- 思考题:查询参加了考试的同学信息(学号,学生姓名,科目名,分数)SELECT s.studentno,studentname,subjectname,StudentResultFROM student sINNER JOIN result rON r.studentno = s.studentnoINNER JOIN `subject` subON sub.subjectno = r.subjectno 自连接123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/*自连接 数据表与自身进行连接需求:从一个包含栏目ID , 栏目名称和父栏目ID的表中 查询父栏目名称和其他子栏目名称*/-- 创建一个表CREATE TABLE `category` (`categoryid` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT &#x27;主题id&#x27;,`pid` INT(10) NOT NULL COMMENT &#x27;父id&#x27;,`categoryName` VARCHAR(50) NOT NULL COMMENT &#x27;主题名字&#x27;,PRIMARY KEY (`categoryid`)) ENGINE=INNODB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8-- 插入数据INSERT INTO `category` (`categoryid`, `pid`, `categoryName`)VALUES(&#x27;2&#x27;,&#x27;1&#x27;,&#x27;信息技术&#x27;),(&#x27;3&#x27;,&#x27;1&#x27;,&#x27;软件开发&#x27;),(&#x27;4&#x27;,&#x27;3&#x27;,&#x27;数据库&#x27;),(&#x27;5&#x27;,&#x27;1&#x27;,&#x27;美术设计&#x27;),(&#x27;6&#x27;,&#x27;3&#x27;,&#x27;web开发&#x27;),(&#x27;7&#x27;,&#x27;5&#x27;,&#x27;ps技术&#x27;),(&#x27;8&#x27;,&#x27;2&#x27;,&#x27;办公信息&#x27;);-- 编写SQL语句,将栏目的父子关系呈现出来 (父栏目名称,子栏目名称)-- 核心思想:把一张表看成两张一模一样的表,然后将这两张表连接查询(自连接)SELECT a.categoryName AS &#x27;父栏目&#x27;,b.categoryName AS &#x27;子栏目&#x27;FROM category AS a,category AS bWHERE a.`categoryid`=b.`pid`-- 思考题:查询参加了考试的同学信息(学号,学生姓名,科目名,分数)SELECT s.studentno,studentname,subjectname,StudentResultFROM student sINNER JOIN result rON r.studentno = s.studentnoINNER JOIN `subject` subON sub.subjectno = r.subjectno-- 查询学员及所属的年级(学号,学生姓名,年级名)SELECT studentno AS 学号,studentname AS 学生姓名,gradename AS 年级名称FROM student sINNER JOIN grade gON s.`GradeId` = g.`GradeID`-- 查询科目及所属的年级(科目名称,年级名称)SELECT subjectname AS 科目名称,gradename AS 年级名称FROM SUBJECT subINNER JOIN grade gON sub.gradeid = g.gradeid-- 查询 数据库结构-1 的所有考试结果(学号 学生姓名 科目名称 成绩)SELECT s.studentno,studentname,subjectname,StudentResultFROM student sINNER JOIN result rON r.studentno = s.studentnoINNER JOIN `subject` subON r.subjectno = sub.subjectnoWHERE subjectname=&#x27;数据库结构-1&#x27; 排序和分页123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*============== 排序 ================语法 : ORDER BY ORDER BY 语句用于根据指定的列对结果集进行排序。 ORDER BY 语句默认按照ASC升序对记录进行排序。 如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。 */-- 查询 数据库结构-1 的所有考试结果(学号 学生姓名 科目名称 成绩)-- 按成绩降序排序SELECT s.studentno,studentname,subjectname,StudentResultFROM student sINNER JOIN result rON r.studentno = s.studentnoINNER JOIN `subject` subON r.subjectno = sub.subjectnoWHERE subjectname=&#x27;数据库结构-1&#x27;ORDER BY StudentResult DESC/*============== 分页 ================语法 : SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset好处 : (用户体验,网络传输,查询压力)推导: 第一页 : limit 0,5 第二页 : limit 5,5 第三页 : limit 10,5 ...... 第N页 : limit (pageNo-1)*pageSzie,pageSzie [pageNo:页码,pageSize:单页面显示条数] */-- 每页显示5条数据SELECT s.studentno,studentname,subjectname,StudentResultFROM student sINNER JOIN result rON r.studentno = s.studentnoINNER JOIN `subject` subON r.subjectno = sub.subjectnoWHERE subjectname=&#x27;数据库结构-1&#x27;ORDER BY StudentResult DESC , studentnoLIMIT 0,5-- 查询 JAVA第一学年 课程成绩前10名并且分数大于80的学生信息(学号,姓名,课程名,分数)SELECT s.studentno,studentname,subjectname,StudentResultFROM student sINNER JOIN result rON r.studentno = s.studentnoINNER JOIN `subject` subON r.subjectno = sub.subjectnoWHERE subjectname=&#x27;JAVA第一学年&#x27;ORDER BY StudentResult DESCLIMIT 0,10 子查询1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/*============== 子查询 ================什么是子查询? 在查询语句中的WHERE条件子句中,又嵌套了另一个查询语句 嵌套查询可由多个子查询组成,求解的方式是由里及外; 子查询返回的结果一般都是集合,故而建议使用IN关键字;*/-- 查询 数据库结构-1 的所有考试结果(学号,科目编号,成绩),并且成绩降序排列-- 方法一:使用连接查询SELECT studentno,r.subjectno,StudentResultFROM result rINNER JOIN `subject` subON r.`SubjectNo`=sub.`SubjectNo`WHERE subjectname = &#x27;数据库结构-1&#x27;ORDER BY studentresult DESC;-- 方法二:使用子查询(执行顺序:由里及外)SELECT studentno,subjectno,StudentResultFROM resultWHERE subjectno=( SELECT subjectno FROM `subject` WHERE subjectname = &#x27;数据库结构-1&#x27;)ORDER BY studentresult DESC;-- 查询课程为 高等数学-2 且分数不小于80分的学生的学号和姓名-- 方法一:使用连接查询SELECT s.studentno,studentnameFROM student sINNER JOIN result rON s.`StudentNo` = r.`StudentNo`INNER JOIN `subject` subON sub.`SubjectNo` = r.`SubjectNo`WHERE subjectname = &#x27;高等数学-2&#x27; AND StudentResult&gt;=80-- 方法二:使用连接查询+子查询-- 分数不小于80分的学生的学号和姓名SELECT r.studentno,studentname FROM student sINNER JOIN result r ON s.`StudentNo`=r.`StudentNo`WHERE StudentResult&gt;=80-- 在上面SQL基础上,添加需求:课程为 高等数学-2SELECT r.studentno,studentname FROM student sINNER JOIN result r ON s.`StudentNo`=r.`StudentNo`WHERE StudentResult&gt;=80 AND subjectno=( SELECT subjectno FROM `subject` WHERE subjectname = &#x27;高等数学-2&#x27;)-- 方法三:使用子查询-- 分步写简单sql语句,然后将其嵌套起来SELECT studentno,studentname FROM student WHERE studentno IN( SELECT studentno FROM result WHERE StudentResult&gt;=80 AND subjectno=( SELECT subjectno FROM `subject` WHERE subjectname = &#x27;高等数学-2&#x27; ))","path":"page/MySQL04.html","date":"03-19","excerpt":"","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://xiaoliblog.cn/tags/MySQL/"}]},{"title":"MySQL📦DML语言","text":"外键 如果公共关键字在一个关系中是主关键字，那么这个公共关键字被称为另一个关系的外键。由此可见，外键表示了两个关系之间的相关联系。以另一个关系的外键作主关键字的表被称为主表，具有此外键的表被称为主表的从表。 在实际操作中，将一个表的值放入第二个表来表示关联，所使用的值是第一个表的主键值(在必要时可包括复合主键值)。此时，第二个表中保存这些值的属性称为外键(foreign key)。 外键作用：保持数据一致性，完整性，主要目的是控制存储在外键表中的数据,约束。使两张表形成关联，外键只能引用外表中的列的值或使用空值。 创建外键 创建外键的方式一 : 创建子表同时创建外键，比如学生表的gradeid字段要去引入年级表的gradeid 1234567891011121314151617181920212223242526-- 创建外键的方式一 : 创建子表同时创建外键-- 年级表 (id\\年级名称)CREATE TABLE `grade` (`gradeid` INT(10) NOT NULL AUTO_INCREMENT COMMENT &#x27;年级ID&#x27;,`gradename` VARCHAR(50) NOT NULL COMMENT &#x27;年级名称&#x27;,PRIMARY KEY (`gradeid`)) ENGINE=INNODB DEFAULT CHARSET=utf8-- 学生信息表 (学号,姓名,性别,年级,手机,地址,出生日期,邮箱,身份证号)CREATE TABLE `student` (`studentno` INT(4) NOT NULL COMMENT &#x27;学号&#x27;,`studentname` VARCHAR(20) NOT NULL DEFAULT &#x27;匿名&#x27; COMMENT &#x27;姓名&#x27;,`sex` TINYINT(1) DEFAULT &#x27;1&#x27; COMMENT &#x27;性别&#x27;,`gradeid` INT(10) DEFAULT NULL COMMENT &#x27;年级&#x27;,`phoneNum` VARCHAR(50) NOT NULL COMMENT &#x27;手机&#x27;,`address` VARCHAR(255) DEFAULT NULL COMMENT &#x27;地址&#x27;,`borndate` DATETIME DEFAULT NULL COMMENT &#x27;生日&#x27;,`email` VARCHAR(50) DEFAULT NULL COMMENT &#x27;邮箱&#x27;,`idCard` VARCHAR(18) DEFAULT NULL COMMENT &#x27;身份证号&#x27;,PRIMARY KEY (`studentno`),-- 定义外键，给这个外键添加约束（执行引用） references 引用KEY `FK_gradeid` (`gradeid`),CONSTRAINT `FK_gradeid` FOREIGN KEY (`gradeid`) REFERENCES `grade` (`gradeid`)) ENGINE=INNODB DEFAULT CHARSET=utf8 创建外键方式二 : 创建子表完毕后，修改子表添加外键 123-- 创建外键方式二 : 创建子表完毕后,修改子表添加外键ALTER TABLE `student`ADD CONSTRAINT `FK_gradeid` FOREIGN KEY (`gradeid`) REFERENCES `grade` (`gradeid`); 12ALTER TABLE 表ADD CONSTRAINT 约束名 FOREIGN KEY(作为外键的列) REFERENCES 那个表(哪个字段) 删除外键12345-- 删除外键ALTER TABLE student DROP FOREIGN KEY FK_gradeid;-- 发现执行完上面的,索引还在,所以还要删除索引-- 注:这个索引是建立外键的时候默认生成的ALTER TABLE student DROP INDEX FK_gradeid; 注意 : 删除具有主外键关系的表时 , 要先删子表 , 后删主表 DML语言 数据库意义 ： 数据存储、数据管理 管理数据库数据方法： 通过SQLyog等管理工具管理数据库数据 通过DML语句管理数据库数据 DML语言 ：数据操作语言，用于操作数据库对象中所包含的数据，包括 : INSERT (添加数据语句) UPDATE (更新数据语句) DELETE (删除数据语句) 添加数据1INSERT INTO 表名[(字段1,字段2,字段3,...)] VALUES(&#x27;值1&#x27;,&#x27;值2&#x27;,&#x27;值3&#x27;) 字段或值之间用英文逗号隔开 ‘ 字段1,字段2…’ 该部分可省略，但添加的值务必与表结构，数据列，顺序相对应，且数量一致 可同时插入多条数据， values 后用英文逗号隔开 . 1234567891011121314-- 使用语句如何增加语句?-- 语法 : INSERT INTO 表名[(字段1,字段2,字段3,...)] VALUES(&#x27;值1&#x27;,&#x27;值2&#x27;,&#x27;值3&#x27;)INSERT INTO grade(gradename) VALUES (&#x27;大一&#x27;);-- 主键自增,那能否省略呢?INSERT INTO grade VALUES (&#x27;大二&#x27;);-- 查询:INSERT INTO grade VALUE (&#x27;大二&#x27;)错误代码：1136Column count doesn`t match value count at row 1-- 结论:&#x27;字段1,字段2...&#x27;该部分可省略 , 但添加的值务必与表结构,数据列,顺序相对应,且数量一致.-- 一次插入多条数据INSERT INTO grade(gradename) VALUES (&#x27;大三&#x27;),(&#x27;大四&#x27;); 修改数据1UPDATE 表名 SET column_name=value [,column_name2=value2,...] [WHERE condition]; column_name 为要更改的数据列 value 为修改后的数据 , 可以为变量 , 具体指 , 表达式或者嵌套的SELECT结果 condition 为筛选条件 , 如不指定则修改该表的所有列数据 12345678-- 根据ID修改学员名称UPDATE `student` SET `name` = &#x27;李白&#x27; WHERE id = 1;-- 不指定条件的情况下，会改动所有表UPDATE `student` SET `name` = `岳飞`-- 修改多个属性,用逗号隔开UPDATE `student` SET name = &#x27;李白&#x27;,email = &#x27;2312057536@qq.com&#x27; WHERE id = 1; where条件子句 可以简单的理解为 : 有条件地从表中筛选数据 12-- 修改年级信息UPDATE grade SET gradename = &#x27;高中&#x27; WHERE gradeid = 1; 删除数据1DELETE FROM 表名 [WHERE condition]; 注意：condition为筛选条件 , 如不指定则删除该表的所有列数据 1234-- 删除数据(避免这样写,会全部删除,推荐TRUNCATE)DELETE FROM student-- 删除最后一个数据DELETE FROM grade WHERE gradeid = 5 TRUNCATE命令用于完全清空表数据 , 但表结构 , 索引 , 约束等不变 ; 1234TRUNCATE [TABLE] table_name;-- 清空年级表TRUNCATE grade 区别于DELETE命令 相同 : 都能删除数据 , 不删除表结构 , 但TRUNCATE速度更快 不同 使用TRUNCATE TABLE 重新设置AUTO_INCREMENT计数器 使用TRUNCATE TABLE不会对事务有影响 （事务后面会说） 123456789101112131415161718192021-- 创建一个测试表CREATE TABLE `test` (`id` INT(4) NOT NULL AUTO_INCREMENT,`coll` VARCHAR(20) NOT NULL,PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8-- 插入几个测试数据INSERT INTO test(coll) VALUES(&#x27;row1&#x27;),(&#x27;row2&#x27;),(&#x27;row3&#x27;);-- 删除表数据(不带where条件的delete)DELETE FROM test;-- 结论:如不指定Where则删除该表的所有列数据,自增当前值依然从原来基础上进行,会记录日志.-- 删除表数据(truncate)TRUNCATE TABLE test;-- 结论:truncate删除数据,自增当前值会恢复到初始值重新开始;不会记录日志.-- 同样使用DELETE清空不同引擎的数据库表数据.重启数据库服务后-- InnoDB : 自增列从初始值重新开始 (因为是存储在内存中,断电即失)-- MyISAM : 自增列依然从上一个自增数据基础上开始 (存在文件中,不会丢失)","path":"page/MySQL03.html","date":"03-19","excerpt":"","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://xiaoliblog.cn/tags/MySQL/"}]},{"title":"MySQL📦数据库操作","text":"数据库操作 创建数据库 1create database [if not exists] 数据库名; 删除数据库 1drop database [if exists] 数据库名; 查看数据库 1show databases; 使用数据库 123use 数据库名;-- 如果你的表名或字段名是一个特殊字符,就需要带反引号(tap上面的键)use `school`; MySQL不区分大小写，[ ]用于表示可选 创建数据表123456create table [if not exists] `表名`( &#x27;字段名1&#x27; 列类型 [属性][索引][注释], &#x27;字段名2&#x27; 列类型 [属性][索引][注释], #... &#x27;字段名n&#x27; 列类型 [属性][索引][注释])[表类型][表字符集][注释]; 说明 : 反引号用于区别MySQL保留字与普通字符而引入的 (键盘esc下面的键). 数据值和列类型 列类型 : 规定数据库中该列存放的数据类型 字符串类型 日期和时间型数值类型 NULL值理解为 “没有值” 或 “未知值”，不要用NULL进行算术运算 , 结果仍为NULL 数据字段属性 UnSigned 无符号的 声明该数据列不允许负数 ZEROFILL 0填充的 不足位数的用0来填充 , 如int(3),5则为005 Auto_InCrement 自动增长的 , 每添加一条数据 , 自动在上一个记录数上加 1(默认) 通常用于设置主键 , 且为整数类型 可定义起始值和步长 当前表设置步长(AUTO_INCREMENT=100) : 只影响当前表 SET @@auto_increment_increment=5 ; 影响所有使用自增的表(全局) NULL 和 NOT NULL 默认为NULL , 即没有插入该列的数值 如果设置为NOT NULL , 则该列必须有值 DEFAULT 默认的 用于设置默认值 例如，性别字段,默认为”男” , 否则为 “女” ; 若无指定该列的值 , 则默认值为”男”的值 1234567891011121314151617181920212223242526-- 目标 : 创建一个school数据库-- 创建学生表(列,字段)-- 学号int 登录密码varchar(20) 姓名,性别varchar(2),出生日期(datatime),家庭住址,email-- 创建表之前 , 一定要先选择数据库-- comment为注释,字段名建议带反引号CREATE TABLE IF NOT EXISTS `student` (`id` int(4) NOT NULL AUTO_INCREMENT COMMENT &#x27;学号&#x27;,`name` varchar(30) NOT NULL DEFAULT &#x27;匿名&#x27; COMMENT &#x27;姓名&#x27;,`pwd` varchar(20) NOT NULL DEFAULT &#x27;123456&#x27; COMMENT &#x27;密码&#x27;,`sex` varchar(2) NOT NULL DEFAULT &#x27;男&#x27; COMMENT &#x27;性别&#x27;,`birthday` datetime DEFAULT NULL COMMENT &#x27;生日&#x27;,`address` varchar(100) DEFAULT NULL COMMENT &#x27;地址&#x27;,`email` varchar(50) DEFAULT NULL COMMENT &#x27;邮箱&#x27;,PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8-- InnoDB为数据库类型，字符编码utf8没有--- 查看数据库的定义SQL语句源代码SHOW CREATE DATABASE school;-- 查看数据表的定义SQL语句源代码SHOW CREATE TABLE student;-- 显示表结构DESC student; -- 设置严格检查模式(不能容错了)SET sql_mode=&#x27;STRICT_TRANS_TABLES&#x27;; 数据表的类型 设置数据表的类型 123456789CREATE TABLE 表名( -- 省略一些代码 -- Mysql注释 -- 1. # 单行注释 -- 2. /*...*/ 多行注释)ENGINE = MyISAM (or InnoDB)-- 查看mysql所支持的引擎类型 (表类型)SHOW ENGINES; MySQL的数据表的类型 : MyISAM , InnoDB , HEAP , BOB , CSV等… 常见的 MyISAM 与 InnoDB 类型 经验 ( 适用场合 ) : 适用 MyISAM : 节约空间及相应速度 适用 InnoDB : 安全性 , 事务处理及多用户操作数据表 数据表的存储位置 MySQL数据表以文件方式存放在磁盘中 包括表文件 , 数据文件 , 以及数据库的选项文件 位置 : Mysql安装目录\\data\\下存放数据表 . 目录名对应数据库名 , 该目录下文件名对应数据表 . 格式 说明 * . frm 表结构定义文件 * . MYD 数据文件 ( data ) * . MYI 索引文件 ( index ) InnoDB类型数据表只有一个 *.frm文件 , 以及上一级目录的ibdata1文件 MyISAM类型数据表对应三个文件 : 设置数据表字符集 不设置的话会是MySQL默认的字符集编码Latin1，不支持中文 创建时通过命令来设置 1CREATE TABLE 表名()CHARSET = utf8; 如无设定 , 则根据MySQL数据库配置文件 my.ini 中的参数设定 1character-set-server=utf8 修改数据库修改表 修改表名 12ALTER TABLE 旧表名 RENAME AS 新表名ALTER TABLE teacher RENAME AS teacher1 添加字段 12ALTER TABLE 表名 ADD字段名 列属性[属性]ALTER TABLE teacher1 ADD age INT(11) 修改字段 12345ALTER TABLE 表名 MODIFY 字段名 列类型[属性]ALTER TABLE teacher1 MODIFY age VARCHAR(11) --修改约束ALTER TABLE 表名 CHANGE 旧字段名 新字段名 列属性[属性]ALTER TABLE teacher1 CHANGE age age1 INT(11) --字段名重命名 删除字段 12ALTER TABLE 表名 DROP 字段名ALTER TABLE teacher1 DROP age1 删除数据表1DROP TABLE [IF EXISTS] 表名 IF EXISTS为可选 , 判断是否存在该数据表 如删除不存在的数据表会抛出错误 其他 可用反引号为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！ 每个库目录存在一个保存当前数据库的选项文件db.opt 注释 123# 单行注释/* 多行注释 */-- 单行注释 (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）) 模式通配符 123_ 任意单个字符% 任意多个字符，甚至包括零字符单引号需要进行转义 \\&#x27; CMD命令行内的语句结束符可以为 “;“, “\\G“, “\\g“，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符","path":"page/MySQL02.html","date":"03-19","excerpt":"","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://xiaoliblog.cn/tags/MySQL/"}]},{"title":"MySQL📦MySQL概述及环境配置","text":"MySQL 概念 : 是现在流行的开源的，免费的关系型数据库 历史 : 由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品 特点 : 免费 , 开源数据库 小巧 , 功能齐全 使用便捷 可运行于Windows或Linux操作系统 可适用于中小型甚至大型网站应用 官网 : https://www.mysql.com/ MySQL环境配置 MySQL 5.7 64位下载地址 https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.19-winx64.zip 👉MySQL安装教程 安装步骤 下载后得到zip压缩包 解压到自己想要安装到的目录，推荐创建一个文件夹专门用于放置环境配置，比如D:\\Environment\\mysql-5.7.19 添加环境变量：【我的电脑】-&gt;【属性】-&gt;【高级】-&gt;【环境变量】 选择PATH，在其后面添加mysql 安装文件下面的bin文件夹路径 比如C:\\Program Files\\MySQL\\MySQL Server 5.5\\bin 如果下载的是压缩包（有配置文件可以忽略），需要在MySQK安装目录下新建MySQL配置文件my.ini 编辑 my.ini 文件 ，注意替换你MySQL的路径位置 12345[mysqld]basedir=D:\\Program Files\\mysql-5.7\\datadir=D:\\Program Files\\mysql-5.7\\data\\port=3306skip-grant-tables 启动管理员模式下的CMD，并将路径切换至mysql下的bin目录，然后输入以下命令安装mysql服务 1mysqld –install 再输入以下命令用于初始化数据文件 1mysqld --initialize-insecure --user=mysql 然后再次启动mysql 然后使用以下命令进入mysql管理界面（密码可为空） 1mysql –u root –p 进入界面后更改root密码 1update mysql.user set authentication_string=password(&#x27;123456&#x27;) where user=&#x27;root&#x27; and Host = &#x27;localhost&#x27;; 刷新权限 1flush privileges; 修改 my.ini文件删除最后一句skip-grant-tables 重启mysql即可正常使用 12net stop mysqlnet start mysql SQLyog 为了更好的学习,我们需要可视化界面，而不仅仅是通过命令行黑窗口管理数据库。SQLyog 就是一个快速而简洁的图形化管理MYSQL数据库的工具。 SQLyog12.08下载地址： 链接：https://pan.baidu.com/s/1DTYj3i1Adx24NCAF7u91NA 提取码：ag4q 安装配置 下载安装用的.exe文件和注册信息 双击该文件，安装很简单，下一步即可 安装好后，需要注册激活，从解压包里的安装必看.txt，复制即可 然后新建连接，输入数据库连接密码，初始密码是root，如果修改了密码就改成所修改的密码 安装后的界面","path":"page/MySQL01.html","date":"03-19","excerpt":"","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://xiaoliblog.cn/tags/MySQL/"}]},{"title":"Mybatis🎯缓存","text":"缓存 什么是缓存 [ Cache ]？ 存在内存中的临时数据。 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题 为什么使用缓存？ 减少和数据库的交互次数，减少系统开销，提高系统效率 什么样的数据能使用缓存？ 经常查询并且不经常改变的数据 Mybatis缓存 MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率 MyBatis系统中默认定义了两级缓存：一级缓存和二级缓存 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存） 二级缓存需要手动开启和配置，他是基于namespace级别的缓存 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存 资料参考👉 聊聊MyBatis缓存机制 OR 深入理解mybatis原理 一级缓存 一级缓存也叫本地缓存 与数据库同一次会话期间查询到的数据会放在本地缓存中。 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库； 测试 在mybatis中加入日志，在一个SqlSession中查询两次相同的结果 编写接口方法 12//根据id查询用户User queryUserById(@Param(&quot;id&quot;) int id); 接口对应的Mapper文件 123&lt;select id=&quot;queryUserById&quot; resultType=&quot;lzy.user.User&quot;&gt; select * from user where id = #&#123;id&#125;&lt;/select&gt; 测试 12345678910111213@Testpublic void testQueryUserById()&#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.queryUserById(2); System.out.println(user); User user2 = mapper.queryUserById(2); System.out.println(user2); System.out.println(user==user2); session.close();&#125; 结果分析 一级缓存失效的四种情况 一级缓存是SqlSession级别的缓存，是一直开启的，我们关闭不了它； 一级缓存失效情况：没有使用到当前的一级缓存，效果就是，还需要再向数据库中发起一次查询请求！ 第一种情况：sqlSession不同 12345678910111213141516@Testpublic void testQueryUserById()&#123; SqlSession session = MybatisUtils.getSession(); SqlSession session2 = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); UserMapper mapper2 = session2.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); User user2 = mapper2.queryUserById(1); System.out.println(user2); System.out.println(user==user2); session.close(); session2.close();&#125; 观察结果：发现发送了两条SQL语句！ 结论：每个sqlSession中的缓存相互独立 第二种情况： sqlSession相同，查询条件不同 1234567891011121314@Testpublic void testQueryUserById()&#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); UserMapper mapper2 = session.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); User user2 = mapper2.queryUserById(2); System.out.println(user2); System.out.println(user==user2); session.close();&#125; 观察结果：发现发送了两条SQL语句！很正常的理解 结论：当前缓存中，不存在这个数据 第三种情况： sqlSession相同，两次查询之间执行了增删改操作！ 增加方法 12//修改用户int updateUser(Map map); 编写SQL 123&lt;update id=&quot;updateUser&quot; parameterType=&quot;map&quot;&gt; update user set name = #&#123;name&#125; where id = #&#123;id&#125;&lt;/update&gt; 测试 1234567891011121314151617181920@Testpublic void testQueryUserById()&#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); HashMap map = new HashMap(); map.put(&quot;name&quot;,&quot;kuangshen&quot;); map.put(&quot;id&quot;,4); mapper.updateUser(map); User user2 = mapper.queryUserById(1); System.out.println(user2); System.out.println(user==user2); session.close();&#125; 观察结果：查询在中间执行了增删改操作后，重新执行了 结论：因为增删改操作可能会对当前数据产生影响 第四种情况： sqlSession相同，手动清除一级缓存 1234567891011121314151617@Testpublic void testQueryUserById()&#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); session.clearCache();//手动清除缓存 User user2 = mapper.queryUserById(1); System.out.println(user2); System.out.println(user==user2); session.close();&#125; 一级缓存就是一个map 二级缓存 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存 基于namespace级别的缓存，一个名称空间，对应一个二级缓存； 工作机制 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中； 如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中； 新的会话查询信息，就可以从二级缓存中获取内容； 不同的mapper查出的数据会放在自己对应的缓存（map）中； 官方文档：https://mybatis.org/mybatis-3/zh/sqlmap-xml.html#cache 使用步骤 开启全局缓存 【mybatis-config.xml】 1&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; 去每个mapper.xml中配置使用二级缓存，这个配置非常简单；【xxxMapper.xml】 12&lt;!--在当前Mapper.xml中使用二级缓存--&gt;&lt;cache/&gt; 也可以自定义参数 12345&lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;/&gt; 这个配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突 在xxxMapper.xml中也可以使用useCache开关闭缓存 123&lt;select id=&quot;queryUserById&quot; resultType=&quot;lzy.user.User&quot; useCache=&quot;true&quot;&gt; select * from user where id = #&#123;id&#125;&lt;/select&gt; 代码测试 123456789101112131415161718@Testpublic void testQueryUserById()&#123; SqlSession session = MybatisUtils.getSession(); SqlSession session2 = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); UserMapper mapper2 = session2.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); session.close(); User user2 = mapper2.queryUserById(1); System.out.println(user2); System.out.println(user==user2); session2.close();&#125; 结果分析 结论 只要开启了二级缓存，我们在同一个Mapper中的查询，可以在二级缓存中拿到数据 查出的数据都会被默认先放在一级缓存中 只有会话提交或者关闭以后，一级缓存中的数据才会转到二级缓存中 Mybatis缓存原理 缓存顺序 先看二级缓存中有没有 再查看一级缓存中有没有 都没有就查询数据库 示例图来源Mybatis缓存原理图 测试 12345678910111213141516171819202122232425262728@org.junit.Test public void test()&#123; //通过封装好的工具类获取SqlSession会话 SqlSession sqlSession = MyBatisUtils.getSqlSession(); //获取另一个SqlSession会话 SqlSession sqlSession1 = MyBatisUtils.getSqlSession(); //通过接口类型class获取接口对象实例(动态代理) BlogMapper mapper = sqlSession.getMapper(BlogMapper.class); //获取另一个会话的mapper对象 BlogMapper mapper1 = sqlSession1.getMapper(BlogMapper.class); //执行接口中的方法 //查询一条数据 Blog blog = mapper.queryById(1); System.out.println(blog); //关闭第一次会话，则数据保存到二级缓存中 sqlSession.close(); //此时查询的数据是从二级缓存中查询出 Blog blog1 = mapper1.queryById(1); System.out.println(blog1); //如果在第二个会话中查询一个新的数据，由于二级缓存中没有数据，一级缓存也没有数据，则肯定会从新的数据库中查询数据 Blog blog2 = mapper1.queryById(2); //如果没有关闭会话，则上一行执行结果会保存到一级缓存，会话未提交或关闭不会保存到二级缓存， //所以此次查询是从一级缓存中查询的数据 System.out.println(blog2); Blog blog3 = mapper1.queryById(2); System.out.println(blog3); sqlSession1.close(); &#125; 结果分析 自定义缓存Ehcache 第三方缓存实现–EhCache Ehcache是一种广泛使用的java分布式缓存，用于通用缓存； 要在应用程序中使用Ehcache，需要引入依赖的jar包，MyBatis Ehcache 123456&lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.1.0&lt;/version&gt;&lt;/dependency&gt; 在mapper.xml中使用对应的缓存即可 123&lt;mapper namespace = “org.acme.FooMapper” &gt; &lt;cache type = “org.mybatis.caches.ehcache.EhcacheCache” /&gt; &lt;/mapper&gt; 在resources目录下编写Ehcache-config.xml文件，如果在加载时未找到/Ehcache-config.xml.xml资源或出现问题，则将使用默认配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot; updateCheck=&quot;false&quot;&gt; &lt;!-- diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下： user.home – 用户主目录 user.dir – 用户当前工作目录 java.io.tmpdir – 默认临时文件路径 --&gt; &lt;diskStore path=&quot;./tmpdir/Tmp_EhCache&quot;/&gt; &lt;defaultCache eternal=&quot;false&quot; maxElementsInMemory=&quot;10000&quot; overflowToDisk=&quot;false&quot; diskPersistent=&quot;false&quot; timeToIdleSeconds=&quot;1800&quot; timeToLiveSeconds=&quot;259200&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt; &lt;cache name=&quot;cloud_user&quot; eternal=&quot;false&quot; maxElementsInMemory=&quot;5000&quot; overflowToDisk=&quot;false&quot; diskPersistent=&quot;false&quot; timeToIdleSeconds=&quot;1800&quot; timeToLiveSeconds=&quot;1800&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt; &lt;!-- defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。 --&gt; &lt;!-- name:缓存名称。 maxElementsInMemory:缓存最大数目 maxElementsOnDisk：硬盘最大缓存个数。 eternal:对象是否永久有效，一但设置了，timeout将不起作用。 overflowToDisk:是否保存到磁盘，当系统当机时 timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。 timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。 diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false. diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。 diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。 memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。 clearOnFlush：内存数量最大时是否清除。 memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。 FIFO，first in first out，这个是大家最熟的，先进先出。 LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。 LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。 --&gt;&lt;/ehcache&gt;","path":"page/Mybatis08.html","date":"03-19","excerpt":"","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://xiaoliblog.cn/tags/Mybatis/"}]},{"title":"Mybatis🎯动态SQL","text":"动态SQL动态SQL指的是根据不同的查询条件 , 生成不同的Sql语 动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦 使用动态 SQL 并非一件易事，但借助可用于任何 SQL 映射语句中的强大的动态 SQL 语言，MyBatis 显著地提升了这一特性的易用性 如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少 123456-------------------------------- if- choose (when, otherwise)- trim (where, set)- foreach------------------------------- 搭建环境新建数据表1234567CREATE TABLE `blog` (`id` varchar(50) NOT NULL COMMENT &#x27;博客id&#x27;,`title` varchar(100) NOT NULL COMMENT &#x27;博客标题&#x27;,`author` varchar(30) NOT NULL COMMENT &#x27;博客作者&#x27;,`create_time` datetime NOT NULL COMMENT &#x27;创建时间&#x27;,`views` int(30) NOT NULL COMMENT &#x27;浏览量&#x27;) ENGINE=InnoDB DEFAULT CHARSET=utf8 创建项目及配置 在utils包下创建IDUtlis.java工具类，用于把”-“替换掉 1234567891011121314package lzy.utils;import org.apache.ibatis.annotations.ResultType;import org.junit.jupiter.api.Test;import java.util.UUID;@SuppressWarnings(&quot;all&quot;) //抑制警告public class IDUtils &#123; public static String getId()&#123; return UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;); &#125;&#125; 编写实体类Blog.java 123456789101112package lzy.user;import lombok.Data;import java.util.Date;@Datapublic class Blog &#123; private String id; private String title; private String author; private Date CreateTime; //属性名和字段不一致 private int views;&#125; 在dao包下创建BlogMapper接口 1234package lzy.dao;public interface BlogMapper &#123;&#125; 创建BlogMapper.xml配置文件 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;lzy.dao.BlogMapper&quot;&gt;&lt;/mapper&gt; 在mybatis-config.xml配置文件中注册，并配置下划线驼峰自动转换 1234567&lt;settings&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;&lt;/settings&gt;&lt;mappers&gt; &lt;mapper resource=&quot;lzy/dao/BlogMapper.xml&quot;/&gt;&lt;/mappers&gt; 插入初始数据，BlogMapper中编写接口 12//插入数据int addBlog(Blog blog); BlogMapper.xml配置文件 123456&lt;mapper namespace=&quot;lzy.dao.BlogMapper&quot;&gt; &lt;insert id=&quot;addBlog&quot; parameterType=&quot;lzy.user.Blog&quot;&gt; insert into blog (id,title,author,create_time,views ) values(#&#123;id&#125;,#&#123;title&#125;,#&#123;author&#125;,#&#123;createTime&#125;,#&#123;views&#125;); &lt;/insert&gt;&lt;/mapper&gt; 初始化博客方法，插入数据 1234567891011121314151617181920212223242526272829303132333435363738394041import lzy.dao.BlogMapper;import lzy.user.Blog;import lzy.utils.IDUtils;import lzy.utils.MybatisUtils;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import java.util.Date;public class MyTest &#123; @Test public void addBlog() &#123; SqlSession session = MybatisUtils.getSession(); BlogMapper mapper = session.getMapper(BlogMapper.class); Blog blog = new Blog(); blog.setId(IDUtils.getId()); blog.setTitle(&quot;Mybatis如此简单&quot;); blog.setAuthor(&quot;狂神说&quot;); blog.setCreateTime(new Date()); blog.setViews(9999); mapper.addBlog(blog); blog.setId(IDUtils.getId()); blog.setTitle(&quot;Java如此简单&quot;); mapper.addBlog(blog); blog.setId(IDUtils.getId()); blog.setTitle(&quot;Spring如此简单&quot;); mapper.addBlog(blog); blog.setId(IDUtils.getId()); blog.setTitle(&quot;微服务如此简单&quot;); mapper.addBlog(blog); session.close(); &#125;&#125; 环境搭建完成 if 语句 使用动态 SQL 最常见情景是根据条件包含 where 子句的一部分。比如： 12345678&lt;select id=&quot;findActiveBlogWithTitleLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;if test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/if&gt;&lt;/select&gt; 这条语句提供了可选的查找文本功能。如果不传入 “title”，那么所有处于 “ACTIVE” 状态的 BLOG 都会返回；如果传入了 “title” 参数，那么就会对 “title” 一列进行模糊查找并返回对应的 BLOG 结果 需求：根据作者名字和博客名字来查询博客！如果作者名字为空，那么只根据博客名字查询，反之，则根据作者名来查询 BlogMapper接口新加方法 12//查询博客List&lt;Blog&gt; queryBlogIF(Map map); BlogMapper.xml配置SQL 123456789&lt;select id=&quot;queryBlogIF&quot; parameterType=&quot;map&quot; resultType=&quot;lzy.user.Blog&quot;&gt; select * from blog where &lt;if test=&quot;title != null&quot;&gt; title = #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and author = #&#123;author&#125; &lt;/if&gt;&lt;/select&gt; 测试类 1234567891011121314@Test public void testQueryBlogIf()&#123; SqlSession session = MybatisUtils.getSession(); BlogMapper mapper = session.getMapper(BlogMapper.class); HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(&quot;title&quot;,&quot;Mybatis如此简单&quot;); map.put(&quot;author&quot;,&quot;狂神说&quot;); List&lt;Blog&gt; blogs = mapper.queryBlogIF(map); System.out.println(blogs); session.close(); &#125; 运行结果 这样写我们可以看到，如果 author 等于 null，那么查询语句为 select * from user where title=#{title},但是如果title为空呢？那么查询语句为 select * from user where and author=#{author}，这是错误的 SQL 语句，如何解决呢？请看下面的 where 语句 Where 修改上面的SQL语句； 1234567891011&lt;select id=&quot;queryBlogIF&quot; parameterType=&quot;map&quot; resultType=&quot;lzy.user.Blog&quot;&gt; select * from blog &lt;where&gt; &lt;if test=&quot;title != null&quot;&gt; title = #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and author = #&#123;author&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 这个“where”标签会知道如果它包含的标签中有返回值的话，它就插入一个‘where’。此外，如果标签返回的内容是以AND 或OR 开头的，则它会剔除掉。 Set 同理，上面的对于查询 SQL 语句包含 where 关键字，如果在进行更新操作的时候，含有 set 关键词，我们怎么处理呢？ BlogMapper接口新加方法 1int updateBlog(Map map); BlogMapper.xml配置SQL 12345678910111213&lt;!--注意set是用的逗号隔开--&gt;&lt;update id=&quot;updateBlog&quot; parameterType=&quot;map&quot;&gt; update blog &lt;set&gt; &lt;if test=&quot;title != null&quot;&gt; title = #&#123;title&#125;, &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; author = #&#123;author&#125; &lt;/if&gt; &lt;/set&gt; where id = #&#123;id&#125;;&lt;/update&gt; 测试 123456789101112@Testpublic void testUpdateBlog()&#123; SqlSession session = MybatisUtils.getSession(); BlogMapper mapper = session.getMapper(BlogMapper.class); HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(&quot;title&quot;,&quot;动态SQL&quot;); map.put(&quot;author&quot;,&quot;岳飞&quot;); map.put(&quot;id&quot;,&quot;9d6a763f5e1347cebda43e2a32687a77&quot;); mapper.updateBlog(map); session.close();&#125; choose语句 有时候，我们不想用到所有的查询条件，只想选择其中的一个，查询条件有一个满足即可，使用 choose 标签可以解决此类问题，类似于 Java 的 switch 语句 BlogMapper接口新加方法 1List&lt;Blog&gt; queryBlogChoose(Map map); BlogMapper.xml配置SQL 12345678910111213141516&lt;select id=&quot;queryBlogChoose&quot; parameterType=&quot;map&quot; resultType=&quot;lzy.user.Blog&quot;&gt; select * from blog &lt;where&gt; &lt;choose&gt; &lt;when test=&quot;title != null&quot;&gt; title = #&#123;title&#125; &lt;/when&gt; &lt;when test=&quot;author != null&quot;&gt; and author = #&#123;author&#125; &lt;/when&gt; &lt;otherwise&gt; and views = #&#123;views&#125; &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; 测试类 123456789101112131415@Testpublic void testQueryBlogChoose()&#123; SqlSession session = MybatisUtils.getSession(); BlogMapper mapper = session.getMapper(BlogMapper.class); HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;title&quot;,&quot;Java如此简单&quot;); map.put(&quot;author&quot;,&quot;狂神说&quot;); map.put(&quot;views&quot;,9999); List&lt;Blog&gt; blogs = mapper.queryBlogChoose(map); System.out.println(blogs); session.close();&#125; SQL片段 有时候可能某个 sql 语句我们用的特别多，为了增加代码的重用性，简化代码，我们需要将这些代码抽取出来，然后使用时直接调用。 提取SQL片段 12345678&lt;sql id=&quot;if-title-author&quot;&gt; &lt;if test=&quot;title != null&quot;&gt; title = #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and author = #&#123;author&#125; &lt;/if&gt;&lt;/sql&gt; 引用SQL片段 12345678&lt;select id=&quot;queryBlogIf&quot; parameterType=&quot;map&quot; resultType=&quot;lzy.user.Blog&quot;&gt; select * from blog &lt;where&gt; &lt;!-- 引用 sql 片段，如果refid 指定的不在本文件中，那么需要在前面加上 namespace --&gt; &lt;include refid=&quot;if-title-author&quot;&gt;&lt;/include&gt; &lt;!-- 在这里还可以引用其他的 sql 片段 --&gt; &lt;/where&gt;&lt;/select&gt; 注意 好基于 单表来定义 sql 片段，提高片段的可重用性 sql 片段中不要包括 where Foreach 将数据库中前三个数据的id修改为1,2,3； 需求：我们需要查询 blog 表中 id 分别为1,2,3的博客信息 编写接口 1List&lt;Blog&gt; queryBlogForeach(Map map); 编写SQL语句 12345678910111213141516&lt;select id=&quot;queryBlogForeach&quot; parameterType=&quot;map&quot; resultType=&quot;lzy.user.Blog&quot;&gt; select * from blog &lt;where&gt; &lt;!-- collection:指定输入对象中的集合属性 item:每次遍历生成的对象 open:开始遍历时的拼接字符串 close:结束时拼接的字符串 separator:遍历对象之间需要拼接的字符串 select * from blog where 1=1 and (id=1 or id=2 or id=3) --&gt; &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;and (&quot; close=&quot;)&quot; separator=&quot;or&quot;&gt; id=#&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 测试 123456789101112131415161718@Testpublic void testQueryBlogForeach()&#123; SqlSession session = MybatisUtils.getSession(); BlogMapper mapper = session.getMapper(BlogMapper.class); HashMap map = new HashMap(); List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;(); ids.add(1); ids.add(2); ids.add(3); map.put(&quot;ids&quot;,ids); List&lt;Blog&gt; blogs = mapper.queryBlogForeach(map); System.out.println(blogs); session.close();&#125; 小结：其实动态 sql 语句的编写往往就是一个拼接的问题，为了保证拼接准确，我们最好首先要写原生的 sql 语句出来，然后在通过 mybatis 动态sql 对照着改，防止出错。多在实践中使用才是熟练掌握它的技巧。","path":"page/Mybatis07.html","date":"03-19","excerpt":"","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://xiaoliblog.cn/tags/Mybatis/"}]},{"title":"Mybatis🎯一对多和多对一处理","text":"Lombok Lombok是一款Java开发插件， 使得Java开发者可以通过其定义的一些注解来消除业务工程中冗长和繁琐的代码，尤其对于简单的Java模型对象(POJO)。 在开发环境中使用Lombok插件后，Java开发人员可以节省出重复构建，诸如hashCode和equals这样的方法以及各种业务对象模型的accessor和ToString等方法的大量时间。 对于这些方法，它能够在编译源代码期间自动帮我们生成这些方法，并没有如反射那样降低程序的性能 Lombok的优缺点 优点 能通过注解的形式自动生成构造器、getter/setter、equals、hashcode、 toString等方法， 提高了一定的开发效率 让代码变得简洁，不用过多的去关注相应的方法 属性做修改时，也简化了维护为这些属性所生成的getter/setter方法等 缺点 不支持多种参数构造器的重载 虽然省去了手动创建getter/setter方法的麻烦，但大大降低了源代码的可读性和完整性，降低了阅读源代码的舒适度 知乎上有位大神发表过对Lombok的一些看法 这是一种低级趣味的插件，不建议使用。JAVA发展到今天，各种插件层出不穷，如何甄别各种插性的优劣? 能从架构上优化你的设计的，能提高应用程序性能的，实现高度封装可扩展….像lombok这种， 像这种插件，已经不仅仅是插件了，改变了你如何编写源码事实上，少去了的代码，你写上去又如何?如果JAVA家族到处充斥这样的东西，那只不过是一坨披着金属颜色的屎，迟早会被其它的语言取代 LomBok使用 官方文档：https://projectlombok.org/ 在IDEA中安装Lombok插件 在项目中导入Lombok的Jar包 1234567&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.18&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; LomBok可以说是一个偷懒神器，通过一个注解就可以省去很多工作 12345678910111213141516@Getter and @Setter@FieldNameConstants@ToString@EqualsAndHashCode@AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor@Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger, @CustomLog@Data@Builder@SuperBuilder@Singular@Delegate@Value@Accessors@Wither@With@SneakyThrows @Data @Data可以生成无参构造、get、set、tostring、hashcode… 比如实体类User，写上@Data注解 123456789package lzy.user;import lombok.Data;@Datapublic class User &#123; private int id; private String name; private String pwd;&#125; 然后在右侧【结构】就可以看到生成的一些方法 还有以下构造有参和无参构造方法 12@AllArgsConstructor //有参@NoArgsConstructor //无参 生成getter和setter方法 12@Getter@Setter 多对一处理 多对一的理解 多个学生对应一个老师 如果对于学生这边，就是一个多对一的现象，即从学生这边关联一个老师！ 数据库设计 数据库结构如下（学生和老师是多对一的关系） 创建表时，要一段一段的查询编译，一次性编译会出问题 123456789101112131415161718192021222324USE mybatisCREATE TABLE `teacher` (`id` INT(10) NOT NULL,`name` VARCHAR(30) DEFAULT NULL,PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO teacher(`id`, `name`) VALUES (1, &#x27;李老师&#x27;);CREATE TABLE `student` (`id` INT(10) NOT NULL,`name` VARCHAR(30) DEFAULT NULL,`tid` INT(10) DEFAULT NULL,PRIMARY KEY (`id`),KEY `fktid` (`tid`),CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;1&#x27;, &#x27;小明&#x27;, &#x27;1&#x27;);INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;2&#x27;, &#x27;小红&#x27;, &#x27;1&#x27;);INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;3&#x27;, &#x27;小张&#x27;, &#x27;1&#x27;);INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;4&#x27;, &#x27;小李&#x27;, &#x27;1&#x27;);INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;5&#x27;, &#x27;小王&#x27;, &#x27;1&#x27;); IDEA查询数据库 连接好数据库后，可以在IDEA中执行SQL语句 右侧【数据库】，选择对应数据库然后选择【控制台（默认）】 搭建测试环境 IDEA安装Lombok插件 引入Maven依赖 1234567&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.18&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 创建项目结构 新建Teacher.java、Student.java两个实体类，并在代码中增加注解 12345@Data //GET,SET,ToString，有参，无参构造public class Teacher &#123; private int id; private String name;&#125; 1234567@Datapublic class Student &#123; private int id; private String name; //多个学生可以是同一个老师，即多对一 private Teacher teacher;&#125; 编写实体类对应的Mapper接口 【两个】 12public interface StudentMapper &#123;&#125; 12public interface TeacherMapper &#123;&#125; 编写Mapper接口对应的 mapper.xml配置文件 【两个】 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;lzy.dao.StudentMapper&quot;&gt;&lt;/mapper&gt; 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;lzy.dao.TeacherMapper&quot;&gt;&lt;/mapper&gt; 在mybatis-config.xml中注册 1234&lt;mappers&gt; &lt;mapper resource=&quot;lzy/dao/StudentMapper.xml&quot;/&gt; &lt;mapper resource=&quot;lzy/dao/TeacherMapper.xml&quot;/&gt;&lt;/mappers&gt; 按查询嵌套处理 有以下需求：查询出学生信息及对应老师 给StudentMapper接口增加方法 1234public interface StudentMapper &#123; //查询所有的学生信息 public List&lt;Student&gt; getStudent();&#125; 编写对应的StudentMapper.xml文件 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;lzy.dao.StudentMapper&quot;&gt; &lt;!-- 1. 查询所有学生信息 2. 根据查询出来的学生的tid，寻找对应的老师！ --&gt; &lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;lzy.user.Student&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;id property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;!--复杂属性需要单独处理 对象：association 集合: collection --&gt; &lt;!--property实体属性名 column数据库列名--&gt; &lt;!--javaType属性类型 select嵌套查询，即查询出老师的ID--&gt; &lt;association property=&quot;teacher&quot; column=&quot;tid&quot; javaType=&quot;lzy.user.Teacher&quot; select=&quot;getTeacher&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;getStudent&quot; resultMap=&quot;StudentTeacher&quot;&gt; select * from student; &lt;/select&gt; &lt;select id=&quot;getTeacher&quot; resultType=&quot;lzy.user.Teacher&quot;&gt; select * from teacher where id = #&#123;id&#125;; &lt;/select&gt;&lt;/mapper&gt; 测试类 12345678910@Test public void testStudent()&#123; SqlSession sqlSession = MybatisUtils.getSession(); StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); List&lt;Student&gt; studentlist = mapper.getStudent(); for (Student student : studentlist) &#123; System.out.println(student); &#125; sqlSession.close(); &#125; 按结果嵌套处理 给StudentMapper接口增加方法 1public List&lt;Student&gt; getStudentResult(); 编写对应的StudentMapper.xml文件 12345678910111213&lt;!--按照结果嵌套处理--&gt; &lt;select id=&quot;getStudentResult&quot; resultMap=&quot;StudentTeacher2&quot;&gt; select s.id sid,s.name sname,t.name tname from student s,teacher t where s.tid = t.id; &lt;/select&gt; &lt;resultMap id=&quot;StudentTeacher2&quot; type=&quot;lzy.user.Student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt; &lt;association property=&quot;teacher&quot; javaType=&quot;lzy.user.Teacher&quot;&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt; 测试类 123456789public void testStudent()&#123; SqlSession sqlSession = MybatisUtils.getSession(); StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); List&lt;Student&gt; studentlist = mapper.getStudentResult(); for (Student student : studentlist) &#123; System.out.println(student); &#125; sqlSession.close(); &#125; 按照查询进行嵌套处理就像SQL中的子查询按照结果进行嵌套处理就像SQL中的联表查询 一对多处理 一对多的理解 一个老师拥有多个学生 如果对于老师这边，就是一个一对多的现象，即从一个老师下面拥有一群学生（集合）！ 实体类编写123456@Datapublic class Student &#123; private int id; private String name; private int tid;&#125; 1234567@Data public class Teacher &#123; private int id; private String name; //一个老师多个学生 private List&lt;Student&gt; students;&#125; 按结果嵌套查询 TeacherMapper接口编写方法 12//获取指定老师，及老师下的所有学生Teacher getTeacher(@Param(&quot;tid&quot;) int id); 编写接口对应的TeacherMapper.xml配置文件 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;lzy.dao.TeacherMapper&quot;&gt; &lt;!--按结果嵌套查询--&gt; &lt;!-- 思路: 1. 从学生表和老师表中查出学生id，学生姓名，老师姓名 2. 对查询出来的操作做结果集映射 1. 集合的话，使用collection！ JavaType和ofType都是用来指定对象类型的 JavaType是用来指定pojo中属性的类型 ofType指定的是映射到list集合属性中pojo的类型。 --&gt; &lt;select id=&quot;getTeacher&quot; resultMap=&quot;TeacherStudent&quot;&gt; select s.id sid,s.name sname,t.name tname,t.id tid from student s,teacher t where s.tid = t.id and t.id = #&#123;tid&#125; &lt;/select&gt; &lt;resultMap id=&quot;TeacherStudent&quot; type=&quot;lzy.user.Teacher&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;tid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;collection property=&quot;students&quot; ofType=&quot;lzy.user.Student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;saname&quot;/&gt; &lt;result property=&quot;tid&quot; column=&quot;tid&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 测试类 12345678@Test public void test()&#123; SqlSession sqlSession = MybatisUtils.getSession(); TeacherMapper mapper = sqlSession.getMapper(TeacherMapper.class); Teacher teacher = mapper.getTeacher(1); System.out.println(teacher); sqlSession.close(); &#125; 按查询嵌套处理 TeacherMapper接口编写方法 1Teacher getTeacherResult(@Param(&quot;tid&quot;) int id); 编写接口对应的TeacherMapper.xml配置文件 123456789101112&lt;!--按查询嵌套处理--&gt; &lt;select id=&quot;getTeacherResult&quot; resultMap=&quot;TeacherStudent2&quot;&gt; select * from teacher where id = #&#123;tid&#125; &lt;/select&gt; &lt;resultMap id=&quot;TeacherStudent2&quot; type=&quot;lzy.user.Teacher&quot;&gt; &lt;collection property=&quot;students&quot; column=&quot;id&quot; javaType=&quot;ArrayList&quot; ofType=&quot;lzy.user.Student&quot; select=&quot;getStudentByTeacherID&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;getStudentByTeacherID&quot; resultType=&quot;lzy.user.Student&quot;&gt; select * from student where tid = #&#123;tid&#125; &lt;/select&gt; 测试类 12345678910public class MyTest &#123; @Test public void test()&#123; SqlSession sqlSession = MybatisUtils.getSession(); TeacherMapper mapper = sqlSession.getMapper(TeacherMapper.class); Teacher teacher = mapper.getTeacherResult(1); System.out.println(teacher); sqlSession.close(); &#125; 总结 关联-association &amp; 集合-collection association是用于一对一和多对一，而collection是用于一对多的关系 JavaType和ofType都是用来指定对象类型的 JavaType是用来指定pojo中属性的类型 ofType指定的是映射到list集合属性中pojo的类型。 注意说明： 保证SQL的可读性，尽量通俗易懂 根据实际要求，尽量编写性能更高的SQL语句 注意属性名和字段不一致的问题 注意一对多和多对一 中：字段和属性对应的问题 尽量使用Log4j，通过日志来查看自己的错误","path":"page/Mybatis06.html","date":"03-19","excerpt":"","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://xiaoliblog.cn/tags/Mybatis/"}]},{"title":"Mybatis🎯使用注解开发","text":"注解开发 使用注解来映射简单语句会使代码显得更加简洁，但对于稍微复杂一点的语句，最好用 XML 来映射语句 SQL类型主要分成 @select () @update () @Insert () @delete () 注意：利用注解开发就不需要mapper.xml映射文件了 在接口中添加注解 123456789package lzy.dao;import lzy.user.User;import org.apache.ibatis.annotations.Select;import java.util.List;public interface UserMapper &#123; @Select(&quot;select * from user&quot;) List&lt;User&gt; getUsers();&#125; 在mybatis的核心配置文件中注入 1234&lt;mappers&gt; &lt;!--使用class绑定接口--&gt; &lt;mapper class=&quot;lzy.dao.UserMapper&quot;&gt;&lt;/mapper&gt;&lt;/mappers&gt; 测试类 123456789101112131415161718192021222324import lzy.dao.UserMapper;import lzy.user.User;import lzy.utils.MybatisUtils;import org.apache.ibatis.session.RowBounds;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import java.util.List;public class UserDaoTest &#123; @Test public void getUserById()&#123; //获取执行SQL的对象 SqlSession sqlSession = MybatisUtils.getSession(); //获得接口 UserMapper mapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; users = mapper.getUsers(); for (User user : users) &#123; System.out.println(user); &#125; //关闭 sqlSession.close(); &#125;&#125; 利用Debug调试查看本质 本质：底层主要应用反射 底层：动态代理 Mybatis执行过程 注解增删改 我们可以在工具类创建的时候实现自动事务提交 修改MybatisUtils工具类的getSession()方法，重载实现 12345public static SqlSession getSession()&#123; //事务自动提交 SqlSession sqlSession = sqlSessionFactory.openSession(true); return sqlSession;&#125; 查询 编写接口方法注解 1234//根据id查询用户//方法存在多个参数，所有参数前面必须加上@Param(&quot;id&quot;)注解@Select(&quot;select * from user where id = #&#123;id&#125; and name = #&#123;name&#125;&quot;)User getUserById(@Param(&quot;id&quot;) int id, @Param(&quot;name&quot;) String name); 测试类 12345678910public void getUserById()&#123; //获取执行SQL的对象 SqlSession sqlSession = MybatisUtils.getSession(); //获得接口 UserMapper mapper = sqlSession.getMapper(UserMapper.class); User UserByID = mapper.getUserById(3); System.out.println(UserByID); //关闭 sqlSession.close(); &#125; 新增 编写接口注解 123//添加一个用户 @Insert(&quot;insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)&quot;) int addUser(User user); 测试类 12345678910@Test public void testAddUser() &#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = new User(10, &quot;张飞&quot;, &quot;123456&quot;); mapper.addUser(user); session.close(); &#125; 修改 编写接口注释 123//修改一个用户 @Update(&quot;update user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id = #&#123;id&#125;&quot;) int updateUser(User user); 测试类 12345678910@Test public void testUpdateUser() &#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); User user = new User(10, &quot;李白&quot;, &quot;12345&quot;); mapper.updateUser(user); session.close(); &#125; 删除 编写接口方法注解 123//根据id删除用 @Delete(&quot;delete from user where id = #&#123;id&#125;&quot;) int deleteUser(@Param(&quot;id&quot;)int id); 测试类 1234567@Test public void testDeleteUser() &#123; SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); mapper.deleteUser(10); session.close(); &#125; 注解解析关于@Param @Param注解用于给方法参数起一个名字。以下是总结的使用原则 在方法只接受一个参数的情况下，可以不使用@Param 在方法接受多个参数的情况下，建议一定要使用@Param注解给参数命名 如果参数是 JavaBean ， 则不能使用@Param 不使用@Param注解时，参数只能有一个，并且是Javabean #与$的区别 #&#123;&#125; 的作用主要是替换预编译语句(PrepareStatement)中的占位符? 【推荐使用】 12INSERT INTO user (name) VALUES (#&#123;name&#125;);INSERT INTO user (name) VALUES (?); $&#123;&#125; 的作用是直接进行字符串替换 12INSERT INTO user (name) VALUES (&#x27;$&#123;name&#125;&#x27;);INSERT INTO user (name) VALUES (&#x27;李白&#x27;); 使用注解和配置文件协同开发，才是MyBatis的最佳实践！","path":"page/Mybatis05.html","date":"03-18","excerpt":"","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://xiaoliblog.cn/tags/Mybatis/"}]},{"title":"Mybatis🎯ResultMap及日志","text":"ResultMap结果集映射 resultMap 元素是MyBatis中最重要最强大的元素 ResultMap的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语句只需要描述它们的关系就行了 属性名和字段名不一致 要解决的问题：属性名和字段名不一致 查看之前的数据库的字段名 Java中的实体类设计 12345678910public class User &#123; private int id; //id private String name; //姓名 private String password; //密码和数据库不一样！ //构造 //set/get //toString()&#125; 接口 12// 根据id查找用户User getUserById(int id); mapper.xml映射文件 123&lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultType=&quot;lzy.user.User&quot;&gt; select * from mybatis.user where id = #&#123;id&#125;;&lt;/select&gt; 测试 12345678910111213public class UserDaoTest &#123; @Test public void getUserById()&#123; //获取执行SQL的对象 SqlSession sqlSession = MybatisUtils.getSession(); //获得接口 UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.getUserById(8); System.out.println(user); //关闭 sqlSession.close(); &#125;&#125; 结果 1User&#123;id&#x3D;8, name&#x3D;&#39;赵八&#39;, password&#x3D;&#39;null&#39;&#125; 查询出来发现 password 为空 . 说明出现了问题！ 分析： 12select * from user where id &#x3D; #&#123;id&#125; 可以看做select id,name,pwd from user where id &#x3D; #&#123;id&#125; mybatis会根据这些查询的列名(会将列名转化为小写，数据库不区分大小写) , 去对应的实体类中查找相应列名的set方法设值 , 由于找不到setPwd() , 所以password返回null ; 【自动映射】 解决方法 方案一 为列名指定别名 , 别名和java实体类的属性名一致 123&lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultType=&quot;lzy.user.User&quot;&gt; select id,name,pwd as password from mybatis.user where id = #&#123;id&#125;;&lt;/select&gt; 方案二 使用结果集映射-&gt;ResultMap 【推荐】 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--namespace指定Dao/Mapper的完整路径--&gt;&lt;mapper namespace=&quot;lzy.dao.UserMapper&quot;&gt; &lt;!--结果集映射,id对应下面的resultMap，把结果集映射为User--&gt; &lt;resultMap id=&quot;UserMap&quot; type=&quot;lzy.user.User&quot;&gt; &lt;!--column为数据库中字段 property为实体类中的属性--&gt; &lt;result column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/result&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;&gt;&lt;/result&gt; &lt;result column=&quot;pwd&quot; property=&quot;password&quot;&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;!--根据ID查找用户--&gt; &lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultMap=&quot;UserMap&quot;&gt; select * from mybatis.user where id = #&#123;id&#125;; &lt;/select&gt;&lt;/mapper&gt; sql复用 在mybatis中，我们可以將sql语句中公共的部分提取出来，然后需要该段sql的地方通过include标签引入即可，这样可以达到sql语句复用的目的 例如查找表中的某些字段，用sql包围成公共部分 123&lt;sql id=&quot;Base_Column_List&quot;&gt; id, name, images, price, sale_price, sale_point, type_id&lt;/sql&gt; 通过include标签使用 12345&lt;select id=&quot;selectProducts&quot; resultMap=&quot;BaseResultMap&quot;&gt; select &lt;include refid=&quot;Base_Column_List&quot; /&gt; from t_product&lt;/select&gt; 日志工厂 我们在测试SQL的时候，要是能够在控制台输出 SQL 的话，是不是就能够有更快的排错效率？ 如果一个 数据库相关的操作出现了问题，我们可以根据输出的SQL语句快速排查问题 对于以往的开发过程，我们会经常使用到debug模式来调节，跟踪我们的代码执行过程。但是现在使用Mybatis是基于接口，配置文件的源代码执行过程。因此，我们必须选择日志工具来作为我们开发，调节程序的工具 Mybatis内置的日志工厂提供日志功能，具体的日志实现有以下几种工具 SLF4J Apache Commons Logging Log4j 2 Log4j JDK logging STDOU_LOGGINT标准日志 具体选择哪个日志实现工具由MyBatis的内置日志工厂确定。它会使用最先找到的（按上文列举的顺序查找）。如果一个都未找到，日志功能就会被禁用。 标准日志实现 指定 MyBatis 应该使用哪个日志记录实现。如果此设置不存在，则会自动发现日志记录实现。 1234&lt;!--配置日志公场--&gt;&lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;&lt;/settings&gt; 测试，可以看到控制台有大量的输出！我们可以通过这些输出来判断程序到底哪里出了Bug Log4j Log4j是Apache的一个开源项目 通过使用Log4j，我们可以控制日志信息输送的目的地：控制台，文本，GUI组件…. 我们也可以控制每一条日志的输出格式； 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 导入log4j的包123456&lt;!--Log4j--&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt;&lt;/dependency&gt; 配置文件编写 在resources文件夹下创建log4j.properties配置文件 123456789101112131415161718192021222324#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码log4j.rootLogger=DEBUG,console,file#控制台输出的相关设置log4j.appender.console = org.apache.log4j.ConsoleAppenderlog4j.appender.console.Target = System.outlog4j.appender.console.Threshold=DEBUGlog4j.appender.console.layout = org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n#文件输出的相关设置log4j.appender.file = org.apache.log4j.RollingFileAppenderlog4j.appender.file.File=./log/kuang.loglog4j.appender.file.MaxFileSize=10mblog4j.appender.file.Threshold=DEBUGlog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n#日志输出级别log4j.logger.org.mybatis=DEBUGlog4j.logger.java.sql=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.ResultSet=DEBUGlog4j.logger.java.sql.PreparedStatement=DEBUG setting设置日志实现123&lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;&lt;/settings&gt; 配置测试类 注意导包：improt org.apache.log4j.Logger 12345678910111213141516//注意导包：improt org.apache.log4j.Loggerstatic Logger logger = Logger.getLogger(MyTest.class);@Testpublic void selectUser() &#123; logger.info(&quot;info：进入selectUser方法&quot;); logger.debug(&quot;debug：进入selectUser方法&quot;); logger.error(&quot;error: 进入selectUser方法&quot;); SqlSession session = MybatisUtils.getSession(); UserMapper mapper = session.getMapper(UserMapper.class); List&lt;User&gt; users = mapper.selectUser(); for (User user: users)&#123; System.out.println(user); &#125; session.close();&#125;","path":"page/Mybatis04.html","date":"03-18","excerpt":"","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://xiaoliblog.cn/tags/Mybatis/"}]},{"title":"Mybatis🎯配置解析及优化","text":"配置解析 官方文档：https://mybatis.org/mybatis-3/zh/configuration.html 核心配置文件 mybatis-config.xml 系统核心配置文件 MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息 配置 说明 configuration 配置 properties 属性 settings 设置 typeAliases 类型别名 typeHandlers 类型处理器 objectFactory 对象工厂 plugins 插件 environments 环境配置 environment 环境变量 transactionManager 事务管理器 dataSource 数据源 databaseIdProvider 数据库厂商标识 mappers 映射器 注意元素节点的顺序！顺序不对会报错 环境配置environments12345678910111213&lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt; &lt;property name=&quot;...&quot; value=&quot;...&quot;/&gt; &lt;/transactionManager&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 配置MyBatis的多套运行环境，将SQL映射到多个不同的数据库上，必须指定其中一个为默认运行环境（通过default指定） 子元素节点：environment dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。 数据源是必须配置的。有三种内建的数据源类型：type=&quot;[UNPOOLED|POOLED|JNDI]&quot;） unpooled：这个数据源的实现只是每次被请求时打开和关闭连接。 pooled：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来 , 这是一种使得并发 Web 应用快速响应请求的流行处理方式。 jndi：这个数据源的实现是为了能在如 Spring 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。 数据源也有很多第三方的实现，比如dbcp，c3p0，druid等等…. 创建多套套环境，通过设置id进行区别，id保证唯一！ 子元素节点：transactionManager - [ 事务管理器 ] 12&lt;!-- 语法 --&gt;&lt;transactionManager type=&quot;[ JDBC | MANAGED ]&quot;/&gt; 配置优化属性properties优化 可以通过properties属性来实现引用配置文件 这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。【db.properties】 在resources目录下编写一个DB.properties配置文件 1234driver = com.mysql.jdbc.Driverurl = jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8username = rootpassword = root mybatis-config.xml配置优化如下 123456789101112131415161718192021222324252627282930&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;!--configuration核心配置文件--&gt;&lt;configuration&gt; &lt;!--注意添加顺序的问题，否则会报错--&gt; &lt;!--引入外部配置文件--&gt; &lt;properties resource=&quot;DB.properties&quot;/&gt; &lt;!--环境配置，连接的数据库，可以配置多个环境，但只能使用其中一个，用default选择，这里使用的是MySQL--&gt; &lt;environments default=&quot;MySQL&quot;&gt; &lt;!--配置MyBatis运行环境--&gt; &lt;environment id=&quot;MySQL&quot;&gt; &lt;!--指定事务管理的类型为JDBC--&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;!--dataSource 指连接源配置，POOLED是JDBC连接对象的数据源连接池的实现--&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--引入DB.properties外部文件后,可以通过$&#123;&#125;取值--&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!--每一个Mapper.XML文件都需要在Mybatis核心配置文件中注册！--&gt; &lt;mapper resource=&quot;com/lzy/dao/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 或者不在DB.properties外部文件写，可以在properties属性里添加键值对子标签 1234567&lt;!--引入外部配置文件--&gt; &lt;properties resource=&quot;DB.properties&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/properties&gt; 当外部文件和内部定义属性冲突时，外部文件优先级高，会优先使用外部文件的属性值 别名typeAliases优化 类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。 第一种方法 在mybatis-config.xml中设置别名，User可以用在任何使用 com.lzy.user.User 的地方 12345&lt;!--设置别名--&gt; &lt;typeAliases&gt; &lt;!--给实体类路径写别名--&gt; &lt;typeAlias type=&quot;com.lzy.user.User&quot; alias=&quot;User&quot;&gt;&lt;/typeAlias&gt; &lt;/typeAliases&gt; 在UserMapper.xml中使用 1234&lt;!--User别名优化，等价于com.lzy.user.User--&gt; &lt;select id=&quot;getUserList&quot; resultType=&quot;User&quot;&gt; select * from mybatis.user; &lt;/select&gt; 第二种方法 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean 扫描实体类的包，它的默认别名就为这个类的类名，首字母小写！ 1234&lt;typeAliases&gt; &lt;!--指定包的别名--&gt; &lt;package name=&quot;com.lzy.user&quot;/&gt;&lt;/typeAliases&gt; 在UserMapper.xml中使用，注意首字母小写 1234&lt;!--com.lzy.user包别名默认为类名首字母小写--&gt;&lt;select id=&quot;getUserList&quot; resultType=&quot;user&quot;&gt; select * from mybatis.user;&lt;/select&gt; 以上两种方法的区别 在实体类比较少的时候，使用给类路径写别名 如果实体类比较多，建议使用给包起别名 第一种可以自定义别名，第二种则不行，如果非要自定义则还需要使用注解 第三种方法 这种方法是在使用了给包别名的基础上使用@Alias(&quot;别名&quot;)注解 比如给com.lzy.user.User类添加Test_User注解 123456789package com.lzy.user;import org.apache.ibatis.type.Alias;//添加注解@Alias(&quot;Test_User&quot;)public class User &#123; private int id; private String name; private String pwd;&#125; 在UserMapper.xml配置文件中配置 123&lt;select id=&quot;getUserList&quot; resultType=&quot;Test_User&quot;&gt; select * from mybatis.user;&lt;/select&gt; 映射器mappers MapperRegistry：注册绑定我们的Mapper文件 映射器 : 定义映射SQL语句文件 方式一 12345&lt;!-- 使用相对于类路径的资源引用 --&gt;&lt;mappers&gt; &lt;!--每一个Mapper.XML文件都需要在Mybatis核心配置文件中注册！--&gt; &lt;mapper resource=&quot;com/lzy/dao/UserMapper.xml&quot;/&gt;&lt;/mappers&gt; 方式二：使用class文件绑定注册 注意：接口和它的Mapper配置文件必须同名且在同一个包下 1234&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;&lt;mappers&gt; &lt;mapper class=&quot;com.lzy.dao.UserMapper&quot;/&gt;&lt;/mappers&gt; 方式三：将包内的映射器接口实现全部注册为映射器 注意：接口和它的Mapper配置文件必须同名且在同一个包下 123&lt;mappers&gt; &lt;package name=&quot;com.lzy.dao&quot;/&gt;&lt;/mappers&gt; 推荐使用第一种方式或者接口和Mapper配置文件同名！","path":"page/Mybatis03.html","date":"03-18","excerpt":"","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://xiaoliblog.cn/tags/Mybatis/"}]},{"title":"Mybatis🎯CRUD增删改查实现","text":"查询查询全部 在UserMapper接口中添加对应的方法 12345678package com.lzy.dao;import com.lzy.user.User;import java.util.List;public interface UserMapper &#123; //查询全部用户 List&lt;User&gt; getUserList();&#125; 在UserMapper.xml中添加语句 namespace指定Dao/Mapper配置文件的完整路径 id是对应UserMapper里的重写方法的方法名 resultType返回结果，写实体类完整类名 parameterType参数类型 #&#123;id&#125;取得参数 123456&lt;mapper namespace=&quot;com.lzy.dao.UserMapper&quot;&gt; &lt;!--查询全部用户--&gt; &lt;select id=&quot;getUserList&quot; resultType=&quot;com.lzy.user.User&quot;&gt; select * from mybatis.user &lt;/select&gt;&lt;/mapper&gt; 测试类 1234567891011121314151617public class UserDaoTest &#123; @Test //查询所有用户 public void getUserList() &#123; // 第一步：通过工具类获得SqlSession对象 SqlSession sqlSession = MybatisUtils.getSession(); //第二步：执行SQL //下条语句相当于UserMapper mapper = new UserMapperImpl(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; userList = mapper.getUserList(); for (User user: userList)&#123; System.out.println(user); &#125; //关闭SqlSession sqlSession.close(); &#125; 根据ID查询 在UserMapper接口中添加对应的方法 12345678package com.lzy.dao;import com.lzy.user.User;import java.util.List;public interface UserMapper &#123; // 根据id查找用户 User getUserById(int id);&#125; 在UserMapper.xml中添加语句，其中#&#123;id&#125;相当于占位符? 1234&lt;!--根据ID查找用户--&gt; &lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.lzy.user.User&quot;&gt; select * from mybatis.user where id = #&#123;id&#125; &lt;/select&gt; 测试类 12345678910public void getUserById()&#123; //获取执行SQL的对象 SqlSession sqlSession = MybatisUtils.getSession(); //获得接口 UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.getUserById(1); System.out.println(user); //关闭 sqlSession.close(); &#125; 模糊查询 在UserMapper接口中添加方法 12//模糊查询 List&lt;User&gt; getUserLike(String value); UserMapper.XML配置 12345678&lt;!--第一种方式是在Java代码中传递通配符--&gt;&lt;select id=&quot;getUserLike&quot; resultType=&quot;com.lzy.user.User&quot;&gt; select * from mybatis.user where name like #&#123;value&#125;;&lt;/select&gt;&lt;!--第二种方式，在SQL拼接中使用通配符--&gt;&lt;select id=”selectlike”&gt; select * from foo where bar like &quot;%&quot;#&#123;value&#125;&quot;%&quot;&lt;/select&gt; 测试类 123456789101112131415@Test public void getUserLike()&#123; SqlSession sqlSession = MybatisUtils.getSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); //第一种方式 在Java代码传递通配符%% List&lt;User&gt; userList = mapper.getUserLike(&quot;%李%&quot;); //第二种方式 在SQL中拼接了通配符 //List&lt;User&gt; userList = mapper.getUserLike(&quot;李&quot;); for(User user : userList)&#123; System.out.println(user); &#125; sqlSession.close(); &#125; 增加 在UserMapper接口中增加方法 123456789101112package com.lzy.dao;import com.lzy.user.User;import java.util.List;public interface UserMapper &#123; //查询全部用户 List&lt;User&gt; getUserList(); // 根据id查找用户 User getUserById(int id); //增加一个用户，参数为一个User对象 int addUser(User user);&#125; 在UserMappper.XML配置 1234&lt;!--增加用户，返回值为int，对象中的属性可以之间取出来--&gt; &lt;insert id=&quot;addUser&quot; parameterType=&quot;com.lzy.user.User&quot;&gt; insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;) &lt;/insert&gt; 测试类 123456789101112131415161718//增删改需要提交事务 public void addUser()&#123; //获取执行SQL的对象 SqlSession sqlSession = MybatisUtils.getSession(); //获得接口 UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = new User(5,&quot;王五&quot;,&quot;123nm&quot;); int result = mapper.addUser(user); if(result &gt; 0)&#123; System.out.println(&quot;添加成功！&quot;); &#125;else&#123; System.out.println(&quot;添加失败&quot;); &#125; //提交事务 sqlSession.commit(); //关闭 sqlSession.close(); &#125; 注意点：增、删、改操作需要提交事务！ 更新 在UserMapper接口里添加方法 12345678910111213package com.lzy.dao;import com.lzy.user.User;import java.util.List;public interface UserMapper &#123; //查询全部用户 List&lt;User&gt; getUserList(); // 根据id查找用户 User getUserById(int id); //增加一个用户，参数为一个User对象 int addUser(User user); //修改一个用户 int updateUser(User user);&#125; UserMapper.xml配置 1234&lt;!--更新用户信息--&gt; &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.lzy.user.User&quot;&gt; update user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id = #&#123;id&#125; &lt;/update&gt; 测试类 123456789101112131415@Test //更新操作 public void UpdateUser() &#123; SqlSession sqlSession = MybatisUtils.getSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = new User(5,&quot;萧炎&quot;,&quot;abc123&quot;); int result = mapper.updateUser(user); if(result &gt; 0)&#123; System.out.println(&quot;更新成功！&quot;); &#125;else&#123; System.out.println(&quot;更新失败&quot;); &#125; sqlSession.commit(); //提交事务,重点!不写的话不会提交到数据库 sqlSession.close(); &#125; 删除 在UserMapper接口中添加方法 1234567891011121314151617package com.lzy.dao;import com.lzy.user.User;import java.util.List;public interface UserMapper &#123; //查询全部用户 List&lt;User&gt; getUserList(); // 根据id查找用户 User getUserById(int id); //增加一个用户，参数为一个User对象 int addUser(User user); //修改一个用户 int updateUser(User user); //删除一个用户 int deleteUser(int id);&#125; UserMapper.xml配置 1234&lt;!--删除一个用户--&gt; &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; delete from mybatis.user where id = #&#123;id&#125;; &lt;/delete&gt; 测试类 123456789@Test //删除一个用户 public void deleteUser()&#123; SqlSession sqlSession = MybatisUtils.getSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); mapper.deleteUser(1); sqlSession.commit(); sqlSession.close(); &#125; 万能Map技巧 使用传入对象操作时，当字段或实体类属性很多且不能为空时，创建对象就会变的很麻烦 可以引入Map创建，其优点就是不需要了解字段是什么，只需要传入一个key即可 Map传递参数，直接在sq|中取出key即可! 对象传递参数，直接在sq|中取对象的属性即可! UserMapper接口中添加方法 1234// 查询操作User getUserByIdMap(Map&lt;String,Object&gt; map);// 增加操作int addUserMap(Map&lt;String,Object&gt; map); UserMapper.XML配置 1234567891011&lt;!--查询操作，根据id和name查询--&gt; &lt;select id=&quot;getUserByIdMap&quot; parameterType=&quot;map&quot; resultType=&quot;com.lzy.user.User&quot;&gt; select * from mybatis.user where id = #&#123;helloId&#125; and name = #&#123;name&#125;; &lt;/select&gt; &lt;!--增加操作--&gt; &lt;insert id=&quot;addUserMap&quot; parameterType=&quot;map&quot;&gt; &lt;!--传递Map的key，key值可以随便取--&gt; insert into user (id,name,pwd) values (#&#123;userid&#125;,#&#123;username&#125;,#&#123;password&#125;) &lt;!--以下普通方法，可以看到参数要和实体属性一一对应而Map不需要--&gt; &lt;!--insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)--&gt; &lt;/insert&gt; 测试类 1234567891011121314151617181920212223242526272829//Map操作 @Test public void getUserByIdMap()&#123; //获取执行SQL的对象 SqlSession sqlSession = MybatisUtils.getSession(); //获得接口 UserMapper mapper = sqlSession.getMapper(UserMapper.class); //创建Map Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;(); map.put(&quot;helloId&quot;,3); //map作为参数传入方法 mapper.addUserMap(map); //关闭 sqlSession.close(); &#125; @Test public void addUserMap()&#123; SqlSession sqlSession = MybatisUtils.getSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); //创建一个HasnMap Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;(); //传入键值对，key值要和配置文件里一致 map.put(&quot;userid&quot;,7); map.put(&quot;username&quot;,&quot;Hello&quot;); map.put(&quot;password&quot;,&quot;123map&quot;); //把创建的map传入方法中执行SQL语句 mapper.addUserMap(map); sqlSession.close(); &#125; 总结：如果参数过多，我们可以考虑直接使用Map实现，如果参数比较少，直接传递参数即可 CURD 学会IDEA的断点调试，单独对一个方法调试 UserMapper123456789101112131415161718192021222324package com.lzy.dao;import com.lzy.user.User;import java.util.List;/** * @Auther: http://xiaoliblog.cn * @Date: 2021/3/17 * @Description: com.lzy.dao * @version: 1.0 */public interface UserMapper &#123; //查询全部用户 List&lt;User&gt; getUserList(); // 根据id查找用户 User getUserById(int id); //增加一个用户，参数为一个User对象 int addUser(User user); //修改一个用户 int updateUser(User user); //删除一个用户 int deleteUser(int id);&#125; UserMapper.XML12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--namespace指定Dao/Mapper的完整路径--&gt;&lt;mapper namespace=&quot;com.lzy.dao.UserMapper&quot;&gt; &lt;!--id是对应UserMapper里的重写方法的方法名 resultType返回结果，写实体类完整类名--&gt; &lt;select id=&quot;getUserList&quot; resultType=&quot;com.lzy.user.User&quot;&gt; select * from mybatis.user &lt;/select&gt; &lt;!--根据ID查找用户--&gt; &lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.lzy.user.User&quot;&gt; select * from mybatis.user where id = #&#123;id&#125; &lt;/select&gt; &lt;!--增加用户，返回值为int，对象中的属性可以之间取出来--&gt; &lt;insert id=&quot;addUser&quot; parameterType=&quot;com.lzy.user.User&quot;&gt; insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;) &lt;/insert&gt; &lt;!--更新用户信息--&gt; &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.lzy.user.User&quot;&gt; update user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;!--删除一个用户--&gt; &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; delete from mybatis.user where id = #&#123;id&#125;; &lt;/delete&gt;&lt;/mapper&gt; 测试类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.lzy.dao;import com.lzy.user.User;import com.lzy.utils.MybatisUtils;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import java.util.List;/** * @Auther: http://xiaoliblog.cn * @Date: 2021/3/17 * @Description: com.lzy.dao * @version: 1.0 */public class UserDaoTest &#123; @Test public void getUserList() &#123; // 第一步：通过工具类获得SqlSession对象 SqlSession sqlSession = MybatisUtils.getSession(); //第二步：执行SQL UserMapper mapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; userList = mapper.getUserList(); for (User user: userList)&#123; System.out.println(user); &#125; //关闭SqlSession sqlSession.close(); &#125; @Test public void getUserById()&#123; //获取执行SQL的对象 SqlSession sqlSession = MybatisUtils.getSession(); //获得接口 UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.getUserById(1); System.out.println(user); //关闭 sqlSession.close(); &#125; @Test //增删改需要提交事务 public void addUser()&#123; //获取执行SQL的对象 SqlSession sqlSession = MybatisUtils.getSession(); //获得接口 UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = new User(6,&quot;王五&quot;,&quot;123nm&quot;); int result = mapper.addUser(user); if(result &gt; 0)&#123; System.out.println(&quot;添加成功！&quot;); &#125;else&#123; System.out.println(&quot;添加失败&quot;); &#125; //提交事务 sqlSession.commit(); //关闭 sqlSession.close(); &#125; @Test //更新操作 public void UpdateUser() &#123; SqlSession sqlSession = MybatisUtils.getSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = new User(5,&quot;萧炎&quot;,&quot;abc123&quot;); int result = mapper.updateUser(user); if(result &gt; 0)&#123; System.out.println(&quot;更新成功！&quot;); &#125;else&#123; System.out.println(&quot;更新失败&quot;); &#125; sqlSession.commit(); //提交事务,重点!不写的话不会提交到数据库 sqlSession.close(); &#125; @Test //删除一个用户 public void deleteUser()&#123; SqlSession sqlSession = MybatisUtils.getSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); mapper.deleteUser(1); sqlSession.commit(); sqlSession.close(); &#125;&#125;","path":"page/Mybatis02.html","date":"03-18","excerpt":"","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://xiaoliblog.cn/tags/Mybatis/"}]},{"title":"Mybatis🎯Mybatis概述及配置","text":"Mybatis 环境 JDK1.8 MySQL5.7 Maven 3.6.1 IDEA Mybatis简介 MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射 MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作 MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录 MyBatis 本是apache的一个开源项目ibatis, 2010年这个项目由apache 迁移到了google code，并且改名为MyBatis 2013年11月迁移到Github Mybatis官方文档 ：http://www.mybatis.org/mybatis-3/zh/index.html 获得Mybatis GitHub ：https://github.com/mybatis/mybatis-3 Maven：https://mvnrepository.com/artifact/org.mybatis/mybatis 123456&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt; Mybatis特性 Mybatis帮助程序猿将数据存入数据库中 , 和从数据库中取数据 传统的jdbc操作 , 有很多重复代码块，比如 : 数据取出时的封装 , 数据库的建立连接等等… , 通过框架可以减少重复代码,提高开发效率 . MyBatis 是一个半自动化的ORM框架 (Object Relationship Mapping) ，即ORMapping对象关系映射 对象指面向对象 关系指关系型数据库 简单理解就是Java到MySQL的映射 MyBatis的优点 简单易学 本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件就可以了，易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现 灵活 mybatis不会对应用程序或者数据库的现有设计强加任何影响。sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求 解除sql与程序代码的耦合 通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性 提供xml标签，支持编写动态sql MyBatis的缺点 SQL语句的编写工作量较大，尤其是字段多、关联表多时，更是如此，对开发人员编写SQL语句的功底有一定要求 SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。 核心接口和类 三大对象 说明 SqlSessionFactoryBuilder 负责构建SqlSessionFactory，并且提供了多个build()方法的重载 SqlSessionFactory 创建SqlSession实例的工厂 SqlSession 用于执行持久化操作的对象 三大对象获取的步骤 每个MyBatis的应用程序都以一个SqlSessionFactory对象的实例为核心 首先获取SqlSessionFactoryBuilder对象，可以根据XML配置文件的实例构建该对象 然后获取SqlSessionFactory对象，该对象实例可以通过SqlSessionFactoryBuilder对象来获得 有了SqlSessionFactory对象之后，通过SqlSessionFactory对象的openSession()方法就可以获取SqlSession实例，SqlSession对象中完全包含以数据库为背景的所有执行SQL操作的方法 三大对象的声明周期和作用域 SqlSessionFactoryBuilder的最大特点是：用过即丢。一旦创建了SqlSessionFactoryBuilder对象之后，这个类就不再需要存在了，因此SqlSessionFactoryBuilder的最佳范围是存在方法体内，也就是局部变量而已。 SqlSessionFactory对象一旦创建，就会在整个应用运行过程中始终存在，因此SqlSessionFactory的最佳作用域是Application（单例模式） SqlSession对应着一次数据库回话。在每次访问数据库时都需要创建它，每个线程都有自己的SqlSession实例，SqlSession实例不能被共享，也不是线程安全的。因此最佳的作用域范围是request作用域或者方法体作用域内 Mybatis程序 项目结构 搭建测试数据库 搭建测试数据库，使用MySQL语句，图形化界面SQLyog工具 1234567891011121314CREATE DATABASE `mybatis`;USE `mybatis`;DROP TABLE IF EXISTS `user`;CREATE TABLE `user` (`id` int(20) NOT NULL,`name` varchar(30) DEFAULT NULL,`pwd` varchar(30) DEFAULT NULL,PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;insert into `user`(`id`,`name`,`pwd`) values (1,&#x27;狂神&#x27;,&#x27;123456&#x27;),(2,&#x27;张三&#x27;,&#x27;abcdef&#x27;),(3,&#x27;李四&#x27;,&#x27;987654&#x27;); 导入Mybatis 创建普通Maven项目，不需要勾选模板 删除src目录，当成父工程，然后就可以创建多个子工程 导入MyBatis相关 jar 包和MySQL，可以在官网查找 1234567891011121314151617181920212223&lt;!--导入依赖--&gt; &lt;dependencies&gt; &lt;!--导入mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入Mybatis依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junity测试依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 连接MySQL数据库 点击右侧【数据库】，【+】选择MySQL添加 配置数据库名称和密码 然后确认下载驱动即可 设置时区问题，去 【Advanced】中修改 【serverTimezone】为 【Asia/Shanghai】 设置成功后可以在【架构】里面选择数据库 MyBatis核心配置文件 MyBatis核心配置文件用于连接数据库 创建一个子模块Mybatis_demo01，并在resources文件夹下创建一个mybatis-config.xml配置文件 编写MyBatis核心配置文件，详情查看官网Mybatis入门 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;!--configuration核心配置文件--&gt;&lt;configuration&gt; &lt;!--环境配置，连接的数据库，可以配置多个环境，但只能使用其中一个，用default选择，这里使用的是MySQL--&gt; &lt;environments default=&quot;MySQL&quot;&gt; &lt;!--配置MyBatis运行环境--&gt; &lt;environment id=&quot;MySQL&quot;&gt; &lt;!--指定事务管理的类型为JDBC--&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;!--dataSource 指连接源配置，POOLED是JDBC连接对象的数据源连接池的实现--&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;!--&amp;amp;就是&amp;符号，在XML中需要转义--&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;!--MySQL初始密码为root--&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;!--每一个Mapper.XML文件都需要在Mybatis核心配置文件中注册！--&gt; &lt;mapper resource=&quot;com/lzy/dao/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 编写MyBatis工具类 工具类读取MyBtais配置文件，并用于获得能执行SQL的SqlSession对象，等价于Connection对象 在子模块Mybatis_demo01下创建MybatisUtils工具类 编码如下 1234567891011121314151617181920212223242526272829303132package com.lzy.utils;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;//sqlSessionFactory --&gt; SqlSessionpublic class MybatisUtils &#123; //提升作用域 private static SqlSessionFactory sqlSessionFactory; static &#123; try &#123;/*1. 通过mybatis-config配置文件构造SqlSessionFactoryBuilder 2. 通过SqlSessionFactoryBuilder的build()获取SqlSessionFactory */ String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //3. 通过SqlSessionFactory的openSession()获取SqlSession public static SqlSession getSession()&#123; SqlSession sqlSession = sqlSessionFactory.openSession(); return sqlSession; &#125;&#125; 创建实体类 创建User实体类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.lzy.user;public class User &#123; private int id; private String name; private String pwd; //AIt+F12可以快速生成以下方法 public User() &#123; &#125; public User(int id, String name, String pwd) &#123; this.id = id; this.name = name; this.pwd = pwd; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPwd() &#123; return pwd; &#125; public void setPwd(String pwd) &#123; this.pwd = pwd; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, pwd=&#x27;&quot; + pwd + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 创建Mapper接口类 UserMapper相当于UserDao，即持久层 1234567package com.lzy.dao;import com.lzy.user.User;import java.util.List;public interface UserMapper &#123; List&lt;User&gt; getUserList(); //返回User对象&#125; 编写Mapper.xml配置文件 Mapper.xml配置文件用于编写和运行SQL，等价于UserDaoImpl接口实现类 创建UserMapper.xml配置文件，通过XML文件编写JDBC，这就不需要写UserDaoImpl实现类来写大量JDBC代码了，简化了代码量 注意：每一个Mapper.XML文件都需要在Mybatis-config.xml文件里进行注册 namespace要和Mapper.xml配置文件的完整路径一致！ ·id就是对应namespace中的方法名，相当于重写方法 resultTypeSQL语句执行的返回值 parameterType参数类型 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--namespace指定Mapper.xml配置文件的完整路径--&gt;&lt;mapper namespace=&quot;com.lzy.dao.UserMapper&quot;&gt; &lt;!--id是对应UserMapper里的重写方法的方法名 resultType返回结果，写实体类完整类名--&gt; &lt;select id=&quot;getUserList&quot; resultType=&quot;com.lzy.user.User&quot;&gt; select * from mybatis.user &lt;/select&gt;&lt;/mapper&gt; 代码结构如下 编写测试类 Junit 包测试 在test目录下新建相同的包 12345678910111213141516171819202122232425package com.lzy.dao;import com.lzy.user.User;import com.lzy.utils.MybatisUtils;import org.apache.ibatis.session.SqlSession;import org.junit.Test;import java.util.List;public class UserDaoTest &#123; @Test public void getUserList() &#123; // 第一步：通过工具类获得SqlSession对象 SqlSession sqlSession = MybatisUtils.getSession(); //第二步：执行SQL UserMapper mapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; userList = mapper.getUserList(); for (User user: userList)&#123; System.out.println(user); &#125; //关闭SqlSession sqlSession.close(); &#125;&#125; 问题说明 可能会出现找不到UserMapper.xml的文件，是因为只能从resource文件夹找配置文件 需要配置静态资源过滤 放置bulid标签类 123456789101112131415161718&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt;&lt;/resources&gt;","path":"page/Mybatis01.html","date":"03-17","excerpt":"","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://xiaoliblog.cn/tags/Mybatis/"}]},{"title":"Maven🧰项目创建及常用操作","text":"创建Java项目 创建一个普通Maven项目，并勾选quickstart 补全项目目录 编译项目 点击【Add Configuration】 选择【+】添加Maven，并选择命令 运行编译后，会生成target目录，里面存放了生成的字节码文件 打包项目 选择【+】添加命令 注意命令切换为创建的package命令 编译后会在target目录下生成项目jar包 创建Web项目创建项目 创建一个MavenWeb项目 创建组ID和项目名 设置Maven安装目录、配置文件和本地仓库目录 等待项目初始化完毕，并选择右下角的自动导入包 出现以下说明初始化成功 目录配置 需要安装Maven标准创建和标记修改文件夹 在src\\main目录下创建java和resources文件夹 把java文件夹标记为蓝色源文件 把resources标记为resources文件 在src\\目录下创建test文件夹，并在其下创建java和resources文件夹 把java文件夹标记为绿色测试源文件 把resources标记为测试resources文件 MavenWeb项目目录如下 启动配置 主要针对pom.xml文件进行修改配置 修改JDK版本 修改为自己的JDK版本，可以通过Win+R，cmd命令输入java -version查看版本 123456&lt;!-- JDK的版本修改为1.8 --&gt;&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;&lt;/properties&gt; 修改单元测试的版本123456789&lt;!-- junit的版本修改为4.12 --&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 删除无关标签1234&lt;!-- 将这个标签及标签中的内容全部删除 --&gt;&lt;pluginManagement&gt;...&lt;/pluginManagement&gt; 添加Web部署插件 在pom.xml&lt;build&gt;标签中添加&lt;plugins&gt;标签，注意先要写一个&lt;plugins&gt;标签 Maven官网插件库：https://maven.apache.org/plugins/index.html Jetty插件 Eclipse官网jetty插件网址：http://wiki.eclipse.org/Jetty/Feature/Jetty_Maven_Plugin 12345678910111213141516171819 &lt;!-- 设置在plugins标签中 --&gt;&lt;plugin&gt; &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt; &lt;version&gt;8.1.16.v20140903&lt;/version&gt; &lt;configuration&gt; &lt;!-- 热部署，每10秒扫描一次 --&gt; &lt;scanIntervalSeconds&gt;10&lt;/scanIntervalSeconds&gt; &lt;!--可指定当前项目的站点名 --&gt; &lt;webApp&gt; &lt;contextPath&gt;/test&lt;/contextPath&gt; &lt;/webApp&gt; &lt;connectors&gt; &lt;connector implementation=&quot;org.eclipse.jetty.server.nio.SelectChannelConnector&quot;&gt; &lt;port&gt;8082&lt;/port&gt; &lt;!-- 启动的端口号 --&gt; &lt;/connector&gt; &lt;/connectors&gt; &lt;/configuration&gt; &lt;/plugin&gt; Tomcat插件 Tomcat官网Maven Plugin地址：https://tomcat.apache.org/maven-plugin.html 1234567891011121314&lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;configuration&gt; &lt;!--端口控制--&gt; &lt;port&gt;8080&lt;/port&gt; &lt;!--项目路径控制意味着http://localhost:8080/tomcat_test--&gt; &lt;path&gt;/tomcat_test&lt;/path&gt; &lt;!--编码--&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;server&gt;tomcat 8&lt;/server&gt; &lt;!--服务器名称--&gt; &lt;/configuration&gt; &lt;/plugin&gt; 启动项目 配置好Web插件后，需要等待下载完成，保证不出现红色报错即可 然后点击【Add Configuration】 Jetty启动 添加Maven命令，配置命令为jetty:run 运行结果如下 配置文件中端口为8082，也可以自定义端口，先把原来开启的服务器关闭（点击红色方框），然后把配置文件里的&lt;/connector&gt;端口标签注释掉，然后添加以下命令 1jetty:run -D jetty.port=9090 #需要将插件配置里的port标签去掉或注释掉 运行结果如下 tomcat启动 添加Maven命令，配置命令为tomcat7:run 运行后会自动提示访问路径 结果如下 创建Spring项目 首先创建一个普通Java项目 然后右击项目，点击【添加框架支持】，点击【Spring】 在pom.xml中写入Spring相关jar包依赖 12345678&lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 在resource目录下创建xml配置文件 构建多模块项目 使用maven提供的多模块构建的特性完成maven环境下多个模块的项目的管理与构建 Maven多模块项目，适用于一些比较大的项目，通过合理的模块拆分，实现代码的复用，便于维护和管理。尤其是一些开源框架，也是采用多模块的方式，提供插件集成，用户可以根据需要配置指定的模块 以四个模块为例来搭建项目 模块 说明 maven_parent 基模块，就是常说的parent (pom) maven_dao 数据库的访问层， 例如jdbc操作(jar) maven_service 项目的业务逻辑层(jar) maven_controller 用来接收请求，响应数据(war) 创建maven_parent项目 不要勾选模块 创建maven_dao模块 项目项目maven_parent，右键选择New，选择Module 选择Maven项目的模板（普通java项目） 设置子模块的ArtifactId 其他模块 maven_service模块创建和maven_dao模块一致 maven_controller模块模板要勾选maven-archetype-webapp模板 创建后目录如下 修改模块配置 设置JDK版本1.8 单元测试Junit版本4.12 删除多余的配置，比如&lt;pluginManagement&gt; 设置模块之间的依赖 controller依赖service，service依赖dao，直白点就是controller调用service方法，service调用dao方法 需要引入对应的依赖才能调用方法 【文件】【项目结构】【模块】选择相应依赖 Maven打包操作 对于企业级项目，无论是进行本地测试，还是测试环境测试以及最终的项目上线，都会涉及项目的打包操作。 对于每个环境下的项目打包，对应的项目所需要的配置资源都会有所区别，实现打包的方式有很多种，可以通过ant，或者通过idea自带的打包功能实现项目打包，但当项目很大并且需要的外界配置很多时，此时打包的配置就会异常复杂 对于maven项目，我们可以用过pom.xml配置的方式来实现打包时的环境选择，相比较其他形式打包工具，通过maven只需要通过简单的配置，就可以轻松完成不同环境下项目的整体打包 比如下面这样一个项目，项目中配置了不同环境下项目所需要的配置文件，这时候需要完成不同环境下的打包操作，此时通过修改pom.xml，Java项目会被打包成jar包，Web项目会被打包成war包 建立对应的目录结构 创建一个MavenWeb项目 添加对应的文件夹目录，以及添加配置文件，并随意添加一些配置信息 添加Profile配置12345678910111213141516171819202122232425262728293031&lt;!-- 打包环境配置:开发环境 测试环境 正式环境--&gt;&lt;profiles&gt; &lt;!--对应dev开发环境--&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;properties&gt; &lt;env&gt;dev&lt;/env&gt; &lt;/properties&gt; &lt;!--未指定环境时，默认打包dev环境--&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;/profile&gt; &lt;!--对应test测试环境--&gt; &lt;profile&gt; &lt;id&gt;test&lt;/id&gt; &lt;properties&gt; &lt;env&gt;test&lt;/env&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;!--对应product正式环境--&gt; &lt;profile&gt; &lt;id&gt;product&lt;/id&gt; &lt;properties&gt; &lt;env&gt;product&lt;/env&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt; 设置资源文件配置 配置资源路径及打包哪些文件，注意应该放在build标签内 12345678910111213141516&lt;!--对于项目资源文件的配置放在build中--&gt; &lt;resources&gt; &lt;resource&gt; &lt;!--&#123;env&#125;取profile配置里env的值--&gt; &lt;directory&gt;src/main/ resources/S&#123;env&#125;&lt;/directory&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.tld&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; 执行打包操作 点击【Add Configuration】 选择【+】添加Maven，并选择命令 -P：比如-Pdev指定profile配置里id为dev的环境 123clean compile package -Pdev -Dmaven.test.skip=true #指定为dev 并跳过测试clean complie package -Dmaven.test.skip=true # 不指定环境，默认dev，并跳过测试package # 最简单的打包命令 执行命令后，会在target目录下生成一个.war的压缩包","path":"page/Maven02.html","date":"03-14","excerpt":"","tags":[{"name":"Maven","slug":"Maven","permalink":"http://xiaoliblog.cn/tags/Maven/"}]},{"title":"Maven🧰Maven概述及环境配置","text":"Maven简介 Maven这个词可以翻译为”专家”，”内行”。作为Apache组织中的一 个颇为成功的开源项目，Maven主要服务于基于java平台的项目构建，依赖管理和项目信息管理。 Maven四大特性 Maven为Java世界引入了一个新的依赖管理系统，当jar包管理jar升级时修改配置文件即可。在Java世界中，可以用groupld、 artifactld、 version组成的Coordination (坐标)唯一标识一个依赖 任何基于Maven构建的项目自身也必须定义这三项属性，生成的包可以是jar包，也可以是war包或者jar包。 使用Maven管理的Java 项目都有着相同的项目结构。 有一个pom.xml 用于维护当前项目都用了哪些jar包；所有的java代码都放在 src/main/java 下面； 所有的测试代码都放在src/test/java 下面 便于统一维护jar包。maven风格的项目，把所有的jar包都放在了本地”仓库“ 里，然后哪个项目需要用到这个jar包，只需要给出jar包的名称和版本号就行了，这样就实现了jar包共享，避免每一个项目都有自己的jar包带来的麻烦。如下图所示pom.xml文件声明项目所需要的jar包版本。 12345&lt;dependency&gt; &lt;groupId&gt; javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api &lt;/artifactId&gt; &lt;version&gt;3. 1.0&lt;/version&gt;&lt;/dependency&gt; 坐标属性的理解 Maven坐标为各种组件引入了秩序，任何一个组件都必须明确定义自己的坐标 groupld 定义当前Maven项目隶属的实际项目公司名称。(jar包所在仓库路径)电于Maven中模块的概念，因此一个实际项目往往会被划分为很多模块。比如spring是一个实际项目， 其对应的Maven模块会有很多，如spring-core，spring-webmvc等 artifactld 该元素定义实际项目中的一个Maven模块项目名，推荐的做法是使用实际项目名称作为artifactld的前缀。比如: spring-bean, spring-webmvc等。 version 该元素定义Maven项目当前所处的版本。 Maven环境搭建参考👉2021最新Maven教程 Maven下载 官网地址：https://maven.apache.org/download.cgi 下载后解压即可 配置环境变量 右击【我的电脑】选【属性】-&gt;【高级】-&gt;【环境变量】-&gt;【系统变量】 配置如下变量 变量名 变量值 M2_HOME Maven目录下的bin目录 MAVEN_HOME Maven的目录 在系统的Path中配置Maven的目录 %MAVEN_HOME%\\bin Win+R打开命令窗口，输入mvn -version查看是否配置成功，出现如下版本信息即可 阿里云镜像 镜像：mirrors 作用：加速下载，建议使用阿里云镜像 在Maven安装目录文件conf\\setttins.xml文件中找到&lt;mirrors&gt;&lt;/mirrors&gt;标签对,进行修改： 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 本地仓库 本地仓库即在本地的仓库，此外还有远程仓库 在Maven根目录建立一个仓库maven-repo文件夹 在Maven安装目录文件conf\\setttins.xml文件中找到localRepository 标签对，修改其中的值为本地仓库的目录 IDEA集成Maven 打开【文件】，选择【其他设置】 修改IDEA默认的Maven目录 Maven命令 作为开发利器的maven,为我们提供了十分丰富的命令，了解maven的命令行操作并熟练运用常见的maven命令还是十分必要的，即使譬如IDEA等工具给我提供了图形界面化工具,但其底层还是依靠maven命令来驱动的 常用命令 Maven的命令格式如下: 1mvn [plugin-name] : [goal-name] 命令代表的含义：执行plugin-name插件的goal-name目标 命令 描述 mvn -version 显示版本信息 mvn clean 清理项目生产的临时文件，一般是模块下的target目录 mvn compile 编译源代码，一般编译模块下的src/main/java目录 mvn package 项目打包工具会在模块下的target目录生成jar或war等文件 mvn test 测试命令，或执行src/testjava/下junit的测试用例. mvn install 将打包的jar/war文件复制到你的本地仓库中，供其他模块使用 mvn deploy 将打包的文件发布到远程参考，提供其他人员进行下载依赖 mvn site 生成项目相关信息的网站 mvn eclipse:eclipse 将项目转化为Eclipse项目 mvn dependengy.tree 打印出项目的整个依赖树 mvn archetype:generate 创建Maven的普通java项目 mvn tomcat7:run 在tomcat容器中运行web应用 mvn jetty:run 调用Jetty插件的Run目标在Jetty Servlet容器中启动web应用 注意：运行maven命令的时候，首先需要定位到maven项目的目录，也就是项目的pom . xm1文件所在的目录。否则，必以通过参数来指定项目的目录。 命令参数 上面列举的只是比较通用的命令，其实很多命令都可以携带参数以执行更精准的任务。 例如 -D 传入属性参数 1mvn package -Dmaven.test.skip &#x3D; ture 以-D开头，将maven.test.skip的值设为true ，就是告诉maven打包的时候跳过单元测试。同理，以下命令代表部署项目并跳过单元测试 1mvn deploy -Dmaven.test.skip &#x3D; true Maven仓库 当第一次运行Maven命令的时候，你需要Internet链接， 因为它需要从网上下载一 些文件。那么它从哪里下载呢?它是从Maven默认的远程库下载的。这个远程仓库有Maven的核心插件和可供下载的jar文件 对于Maven来说，仓库只分为两类：本地仓库和远程仓库 当Maven根据坐标寻找构件的时候，它首先会查看本地仓库，如果本地仓库存在，则直接使用；如果本地没有，Maven就会去远程仓库查找，发现需要的构件之后，下载到本地仓库再使用。如果本地仓库和远程仓库都没有，Maven就会报错 远程仓库分为三种：中央仓库，私服，其他公共库 中央仓库是默认配置下，Maven下载jar包的地方。 私服是另一种特殊的远程仓库,，为了节省带宽和时间，应该在局域网内架设一个私有的仓库服务器， 用其代理所有外部的远程仓库。内部的项目还能部署到私服上供其他项目使用。 一般来说，在Maven项目目录下，没有诸如Iib/这样用来存放依赖文件的目录。当Maven在执行编译或测试时，如果需要使用依赖文件，它总是基于坐标使用本地仓库的依赖文件。 默认情况下，每个用户在自己的用户目录下都有一个路径名为.m2/repository/的仓库目录。有时候， 因为某些原因(比如c盘空间不足)需要修改本地仓库目录地址 对于仓库路径的修改，可以通过maven 配置文件conf目录下settings.xml来指定仓库路径 1234&lt;!-- 设置到指定目录中，路径的斜杠不要写反 --&gt;&lt;settings&gt; &lt;localRepository&gt;D:/m2/repository&lt;/localRepository&gt;&lt;/settings&gt; 中央仓库 由于原始的本地仓库是空的，maven必须知道至少一个可用的远程仓库，才能执行maven命令的时候下载到需要的构件。中央仓库就是这样一个默认的远程仓库. maven-model-builder-3.3.9.jar maven自动的jar中包含了一个超级POM。定义了默认中央仓库的位置。中央仓库包含了2000多个开源项目，接收每天1亿次以上的访问。 私服 私服是一种特殊的远程仓库，它是架设在局域网内的仓库服务，私服代理广域网上的远程仓库，供局域网内的maven用户使用。当maven需要下载物件时，它去私服当中找,，如果私服没有，则从外部远程仓库下载，并存在私服上，再为maven提供。 此外，一些无法从外部仓库下载的构件也能从本地上传到私服提供局域网中其他人使用 配置方式项目pom.xml配置 1234567891011121314&lt;repositories&gt; &lt;repository&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;id&gt;public&lt;/id&gt; &lt;name&gt;Public Repositories&lt;/name&gt; &lt;ur1&gt;http://192.168.0.96:8081/content/groups/public/&lt;/ur1&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;getui -nexus&lt;/id&gt; &lt;ur1&gt;http://mvn.gt.igexin.com/nexus/content/repositories/releases/&lt;/ur1&gt; &lt;/repository&gt;&lt;/repositories&gt; 公司内部应该建立私服 节省自己的外网带宽 加速maven构建 部署第三方控件 提高稳定性 降低中央仓库的负荷 其他公共库 常用的阿里云仓库配置 123456&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt; 其他Maven仓库可以查看官网：https://mvnrepository.com/ 比如想要配置Servlet API，直接搜索Servlet即可，然后复制依赖粘贴到pom.xml文件中 1234567&lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; Maven依赖依赖的基本配置 根元素project下的dependencies可以包含多个dependence元素，以声明多个依赖。每个依赖都应该包含以下元素: groupld， artifactld，version ：依赖的基本坐标，对于任何一个依赖来说，基本坐标是最重要的，Maven根据坐标才能找到需要的依赖 Type：依赖的类型, 大部分情况下不需要声明。默认值为jar Scope：依赖范围(compile,testprovided,runtime,system) Optional：标记依赖是否可选 Exclusions：用来排除传运递性依赖 依赖范围 首先需要知道，Maven在编译项目主代码的时候需要使用一套classpath.。比如：编译项目代码的时候需要用到spring-core，该文件以依赖的方式被引入到classpath中。其次，Maven在执行测试的时候会使用另外一套classpath。如: junit. 最后在实际运行项目时，又会使用一套classpath， spring-core需要在该classpath中，而junit不需要。 那么依赖范围就是用来控制依赖与这种classpath(编译classpath,测试classpath, 运行时classpath)的关系，Maven有以下几种依赖范围 Compile编译依赖范围 如果没有指定， 就会默认使用该依赖范围。使用此依赖范围的Maven依赖， 对于编译，测试，运行都有效。 Test测试依赖范围 只在测试的时候需要。比如junit Provided已提供依赖范围。 使用此依赖范 围的Maven依赖，对于编译和测试有效，但在运行时无效。典型的例子是servlet-API,编译和测试项目的需要，但在运行项目时，由于容器已经提供， 就不需要Maven重复地引入一遍。 Runtime运行时依赖范围 使用此依赖范围的Maven依赖，对于测试和运行classpath有效， 但在编译主代码时无效。典型的例子是JDBC驱动实现，项目主代码的编译只需要JDK提供的JDBC接口，只有在执行测试或者运行项目的时候才需要实现上述接口的具体JDBC驱动 System系统依赖范围 该依赖与三种classpath的关系，和provided依赖范围完全一致。 但是，使用system范围依赖时必须通过systemPath元素显式地指定依赖文件的路径。由于此类依赖不是通过Maven仓库解析的，而且往往与本机系统绑定，可能造成构建的不可移植，因此应该谨慎使用。 传递性依赖 传递依赖机制，让我们在使用某个jar的时候就不用去考虑它依赖了什么。 也不用担心引入多余的依赖。Maven会解析各个直接依赖的POM，将那些必要的间接依赖，以传递性依赖的形式引入到当前项目中。 注意:传递依赖有可能产生冲突! ! 冲突场景 12A--&gt;B---&gt;C (2.0) A--&gt;E---&gt;C (1.0) 如果A下同时存在两个不同version的C，冲突! ! (选取同时适合A. B的版本) 123456789101112131415161718&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;A&lt;/groupId&gt; &lt;artifactId&gt;A&lt;/artifactId&gt; &lt;version&gt;xx&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;c&lt;/groupId&gt; &lt;artifactId&gt;C&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;A&lt;/groupId&gt; &lt;artifactId&gt;A&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 父模块传递子模块 在子模块的pom.xml文件中添加以下配置： 12345&lt;parent&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;SSM_Project&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/parent&gt; 以上信息均可在父模块中找到","path":"page/Maven01.html","date":"03-12","excerpt":"","tags":[{"name":"Maven","slug":"Maven","permalink":"http://xiaoliblog.cn/tags/Maven/"}]},{"title":"Linux🎯三种软件安装方式及服务器基本环境搭建","text":"环境安装 安装软件一般有以下四种方式 rpm安装，以JDK安装为例，在线发布一个SpringBoot项目 解压缩安装，以Tomcat安装为例，启动并通过外网访问，发布网站 yum在线安装，以Docker安装为例 宝塔面板（懒人安装） jdk安装 JDK安装是开发Java程序必须的环境 下载JDK rpm，去Oracle官网下载即可 rpm下载地址：http://www.oracle.com/technetwork/java/javase/downloads/index.html 网盘资源：https://pan.baidu.com/s/1CtkiSxmoER6lkoeYp1_eDQ，提取码：iu4p 下载后通过Xftp把本地jdk rpm转到服务器的/home/JDK目录下 安装Java环境 如果有安装JDK则卸载 123456789[root@xiaoliblog ~]# java -versionjava version &quot;1.8.0_121&quot;# 检查[root@xiaoliblog ~]# rpm -qa|grep jdkjdk1.8.0_121-1.8.0_121-fcs.x86_64# 卸载 -e --nodeps 强制删除[root@xiaoliblog ~]# rpm -e --nodeps jdk1.8.0_121-1.8.0_121-fcs.x86_64[root@xiaoliblog ~]# java -version-bash: /usr/bin/java: No such file or directory # OK 安装新的JDK 12# 安装java rpm[root@xiaoliblog JDK]# rpm -ivh jdk-8u151-linux-x64.rpm 通过vim配置环境变量，路径可以在`/usr/java下找 1234567[root@xiaoliblog JDK]# vim /etc/profile# 安装完成后配置环境变量 文件：/etc/profileJAVA_HOME=/usr/java/jdk1.8.0_151CLASSPATH=%JAVA_HOME%/lib:%JAVA_HOME%/jre/libPATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/jre/binexport PATH CLASSPATH JAVA_HOME# 保存退出 让新增的环境变量生效! 12# 让新增的环境变量生效！source /etc/profile 检查是否配置成功 1234[root@xiaoliblog JDK]# java -versionjava version &quot;1.8.0_151&quot;Java(TM) SE Runtime Environment (build 1.8.0_151-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.151-b12, mixed mode) Tomcat安装 安装好了Java环境后我们可以测试下Tomcat！准备好Tomcat的安装包！ 将文件移动到/usr/tomcat/下，并解压 1[root@xiaoliblog tomcat]# unzip apache-tomcat-8.0.zip 开启和关闭 运行Tomcat，进入bin目录，和我们以前在Windows下看的都是一样的 1234567891011121314# 改变权限[root@xiaoliblog bin]# chmod u+x *.sh# 开启Tomcat[root@xiaoliblog bin]# ./startup.shUsing CATALINA_BASE: /usr/tomcatUsing CATALINA_HOME: /usr/tomcatUsing CATALINA_TMPDIR: /usr/tomcat/tempUsing JRE_HOME: /usr/java/jdk1.8.0_151Using CLASSPATH: /usr/tomcat/bin/bootstrap.jar:/usr/tomcat/bin/tomcat-juli.jarTomcat started.# 关闭Tomcat[root@xiaoliblog bin]# ./shutdown.sh 防火墙 开启Tomcat后，确保Linux的防火墙8080端口是开启的，如果是阿里云，需要保证阿里云的安全组策略8080是开放的！ 1234567891011121314151617181920212223# 查看firewall服务状态systemctl status firewalld# 开启、重启、关闭、firewalld.service服务# 开启service firewalld start# 重启service firewalld restart# 关闭service firewalld stop# 查看防火墙规则firewall-cmd --list-all # 查看全部信息firewall-cmd --list-ports # 只看端口信息# 开启端口开端口命令：firewall-cmd --zone=public --add-port=80/tcp --permanent重启防火墙：systemctl restart firewalld.service命令含义：--zone #作用域--add-port=80/tcp #添加端口，格式为：端口/通讯协议--permanent #永久生效，没有此参数重启后失效 Docker安装 官网安装参考手册：https://docs.docker.com/install/linux/docker-ce/centos/ 确定你是CentOS7及以上版本 12[root@192 Desktop]# cat /etc/redhat-releaseCentOS Linux release 7.2.1511 (Core) yum安装gcc相关（需要确保 虚拟机可以上外网 ） 12yum -y install gccyum -y install gcc-c++ 卸载旧版本 12345678910yum -y remove docker docker-common docker-selinux docker-engine# 官网版本yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 安装需要的软件包 1yum install -y yum-utils device-mapper-persistent-data lvm2 设置stable镜像仓库 12345678# 错误yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo## 报错[Errno 14] curl#35 - TCP connection reset by peer[Errno 12] curl#35 - Timeout# 正确推荐使用国内的yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 更新yum软件包索引 1yum makecache fast 安装Docker CE 1yum -y install docker-ce docker-ce-cli containerd.io 启动docker 1systemctl start docker 测试 12345docker versiondocker run hello-worlddocker images 宝塔面板参考我的另一篇博客服务器购买及宝塔部署环境说明","path":"page/linux05.html","date":"03-07","excerpt":"","tags":[{"name":"Linux","slug":"Linux","permalink":"http://xiaoliblog.cn/tags/Linux/"}]},{"title":"Linux🎯磁盘和进程管理","text":"磁盘管理 Linux磁盘管理好坏直接关系到整个系统的性能问题 Linux磁盘管理常用命令为 df、du df ：列出文件系统的整体磁盘使用量 du：检查磁盘空间使用量 df命令 df命令参数功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息 1df [-ahikHTm] [目录或文件名] 选项与参数 说明 -a 列出所有的文件系统，包括系统特有的 /proc 等文件系统 -k 以 KBytes 的容量显示各文件系统 -m 以 MBytes 的容量显示各文件系统 -h 以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示 -H 以 M=1000K 取代 M=1024K 的进位方式 -T 显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出 -i 不用硬盘容量，而以 inode 的数量来显示 1234# 将 /etc 底下的可用的磁盘容量以易读的容量格式显示[xiaoliblog@localhost /]# df -h /etc文件系统 容量 已用 可用 已用% 挂载点/dev/mapper/centos-root 18G 5.0G 13G 28% / du命令 Linux du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的，这里介绍Linux du命令 1du [-ahskm] 文件或目录名称 选项与参数 说明 -a 列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已 -h 以人们较易读的容量格式 (G/M) 显示 -s 列出总量而已，而不列出每个各别的目录占用容量 -S 不包括子目录下的总计，与 -s 有点差别 -k 以 KBytes 列出容量显示 -m 以 MBytes 列出容量显示 123456# 检查根目录底下每个目录所占用的容量[root@localhost home]# du -sm /*0 /bin153 /boot0 /dev... 通配符* 来代表每个目录 与 df 不一样的是，du 这个命令其实会直接到文件系统内去搜寻所有的文件数据 磁盘挂载与卸除 根文件系统之外的其他文件要想能够被访问，都必须通过“关联”至根文件系统上的某个目录来实现，此关联操作即为“挂载”，此目录即为“挂载点”,解除此关联关系的过程称之为“卸载” Linux 的磁盘挂载使用mount命令，卸载使用umount命令 1mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 装置文件名 挂载点 123456# 将 /dev/hdc6 挂载到 /mnt/hdc6 上面！[root@localhost home]# mkdir /mnt/hdc6[root@localhost home]# mount /dev/hdc6 /mnt/hdc6[root@localhost home]# dfFilesystem 1K-blocks Used Available Use% Mounted on/dev/hdc6 1976312 42072 1833836 3% /mnt/hdc6 磁盘卸载命令 umount 语法： 1umount [-fn] 装置文件名或挂载点 选项与参数： -f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下； -n ：不升级 /etc/mtab 情况下卸除 12#卸载/dev/hdc6[root@localhost home]# umount /dev/hdc6 进程管理 在Linux中，每一个程序都有自己的一个进程，每一个进程都有一个PID号！ 每一个进程都会有一个父进程 进程可以有两种存在方式：前台和后台运行 一般服务都是后台运行，基本的程序都是前台运行的 ps命令 ps用于查看当前系统中正在执行的各种进程信息！。能列出系统中运行的进程，包括进程号、命令、CPU使用量、内存使用量等。下述选项可以得到更多有用的消息 1ps [-aux] 选项或参数 说明 -a 显示当前终端运行的所有的进程信息(当前进程) -u 以用户的信息显示进程 -x 显示后台运行进程的参数 在Liunx中 | 叫做管道符，比如A|B是指A命令的结果做为输出来操作B命令 结合gerp命令可以列出需要的进程 1ps -aux|grep 进行名称 1234# ps -aux 查看所有的进程# grep 查找文件中符合条件的字符串ps -aux|grep mysql# 以上代码只过滤mysql的进程,即只查看mysql进程 ps -ef 命令可以查看父进程的信息 1ps -ef|grep mysql 看父进程一般可以通过目录树来查看 pstree目录 linux中，每一个进程都是由其父进程创建的。此命令以可视化方式显示进程，通过显示进程的树状图来展示进程间关系 1pstree [-pu] 选项或参数 说明 -p 显示父进程PID -u 显示用户组 结束进程 kill命令用于发送信号来结束进程。如果一个进程没有响应杀死命令，这也许就需要强制杀死，使用-9参数来执行 注意，使用强制杀死的时候一定要小心，因为进程没有时机清理现场，也许写入文件没有完成。如果我们不知道进程PID或者打算用名字杀死进程时候，killall就能派上用场 1kill -9 进程PID 以上表示强制杀死进程","path":"page/linux04.html","date":"03-07","excerpt":"","tags":[{"name":"Linux","slug":"Linux","permalink":"http://xiaoliblog.cn/tags/Linux/"}]},{"title":"Linux🎯Vim使用及账号用户管理","text":"Vim编辑器 Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。 简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。vim 则可以说是程序开发者的一项很好用的工具。 所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。 连 vim 的官方网站 (http://www.vim.org) 自己也说 vim 是一个程序开发工具而不是文字处理软件 三种使用模式 基本上 vi/vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode） 命令模式 用户刚刚启动 vi/vim，便进入了命令模式 1[xiaoliblog@localhost ~]$ vim xiaoli.txt #创建一个文件并用vim打开 此状态下敲击键盘动作会被Vim识别为命令，而非输入字符；若想要编辑文本：按下i，切换到输入模式 以下是常用的几个命令： i 切换到输入模式，以输入字符 x 删除当前光标所在处的字符，前提是ESC退出了输入模式 : 切换到底线命令模式，以在最底一行输入命令，前提是通过ESC退出输入模式 命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令，通过输入:进入底线模式 输入模式： 在命令模式下按下i就进入了输入模式 在输入模式中，可以使用以下按键： 按键 说明 字符按键以及Shift组合 输入字符 ENTER 回车键，换行 BACK SPACE 退格键，删除光标前一个字符 DEL 删除键，删除光标后一个字符 方向键 在文本中移动光标 HOME/END 移动光标到行首/行尾 Page Up/Page Down 上/下翻页 Insert 切换光标为输入/替换模式，光标将变成竖线/下划线 ESC 退出输入模式，切换到命令模式 底线命令模式 在命令模式下按下:（英文冒号）就进入了底线命令模式 底线命令模式可以输入单个或多个字符的命令，可用的命令非常多 在底线命令模式中，基本的命令有（已经省略了冒号）： q 退出程序 w 保存文件 按ESC键可随时退出底线命令模式 一般退出vim编辑组合键是:wq 简单的说，我们可以将这三个模式想成底下的图标来表示： 用户权限12[xiaoliblog@localhost ~]$# xiaoliblog代表当前用户，localhost指的是主机名，~表示当前用户，$表示普通用户 12[xiaoliblog@localhost ~]## 代表root用户 用户之间切换 普通用户切换为root用户，输入命令：su -，此时输入当前用户的密码（root用户没有修改过密码，那么就是当前用户的密码） 1[xiaoliblog@localhost ~]$ su - 输入命令sudo passwd root，可以修改root用户密码 root用户切换成普通用户，输入命令：su - 用户名 要重新切换回root用户，输入命令：exit,直接切换回root用户，不用再输入密码 修改用户密码及Root密码 介绍虚拟机Linux系统CentOS 7环境下忘记用户密码怎样修改密码 重启系统，把鼠标光标放置虚拟机内，使用↑和↓将选择行设置为第一行（背景高亮即为选中），按下键盘上的e，进入编辑模式 按方向键↑和↓，将光标一直移动到 LANG=en_US.UTF-8 后面，再添加“init=/bin/sh” ，这里特别注意，需要写在UTF-8后，保持在同一行，并注意空格不能缺。有些虚拟机由于屏幕太小，会自动添加\\换行，这个是正常的 按下Ctrl+X进行引导启动，成功后进入该界面 输入命令，挂载根目录 1mount -o remount, rw / 输入 passwd 用户名重置密码，这里填写我的用户xiaoliblog进行修改，这里可以更换为你要修改的用户 （注：用户名字母统一输入小写，即使你的是大写字母） 如果修改root用户，只需把用户名改为root即可 1passwd xiaoliblog 如果已经开启了SElinux，则需要输入以下命令（一般直接输入就行了） 1touch /.autorelabel 最后输入以下命令重启系统即可 1exec /sbin/init 参考👉如何在虚拟机Linux系统centos 7中修改用户密码 账号管理 Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统 用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护 每个用户账号都拥有一个唯一的用户名和各自的口令 用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录 实现用户账号的管理，要完成的工作主要有如下几个方面： 用户账号的添加、删除与修改 用户口令的管理 用户组的管理 用户账号的管理工作主要涉及到用户账号的添加、修改和删除。 添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源 添加账号必须在root权限下才能进行 增加用户账户使用useradd命令，格式如下： 1[xiaoliblog@localhost home]# useradd 选项 用户名 选项 说明 -c comment 指定一段注释性描述 -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录 -g 用户组 指定用户所属的用户组 -G 用户组,用户组 指定用户所属的附加组 -m 使用者目录如不存在则自动建立 -s Shell文件 指定用户的登录Shell -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号 此命令创建了一个用户xiaoliuser，其中-m选项用来为登录名xiaoliuser产生一个主目录 /home/xiaoliuser 理解一下本质：Linux中一切皆文件，这里的添加用户说白了就是往某一个文件中写入用户的信息了！即增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等 可以通过以下命令查看 1[xiaoliblog@localhost home]# cd /etc/passwd 删除用户 如果一个用户的账号不再使用，可以从系统中删除 删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录 删除一个已有的用户账号使用userdel命令，其格式如下： 1userdel 选项 用户名 常用的选项是 -r，它的作用是把用户的主目录一起删除 123[root@localhost home]# userdel -r xiaoliuser[root@localhost home]# lsxiaoliblog 此命令删除用户xiaoliuser在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录 修改账号 修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等 修改已有用户的信息使用usermod命令，其格式如下： 1usermod 选项 用户名 常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值 1# usermod -s /bin/ksh -d /home/z –g developer xiaoliuser 此命令将用户xiaoliuser的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer 用户口令的管理 用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令 修改口令 指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令 命令的格式为： 1passwd 选项 用户名 可使用的选项： -l 锁定口令，即禁用账号 -u 口令解锁 -d 使账号无口令 -f 强迫用户下次登录时修改口令 如果默认用户名，则修改当前用户的口令 密码设置 一般通过root创建用户的时候需要配置密码 如果是普通用户，则下面的命令修改该用户自己的口令 1234$ passwd Old password:******New password:*******Re-enter new password:******* 如果是超级用户，可以用下列形式指定任何用户的口令 123# passwd xiaoliblogNew password:*******Re-enter new password:******* 普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令 为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用8位长的口令，口令中包含有大写、小写字母和数字，并且应该与姓名、生日等不相同 锁定账户 比如某人离职了，可以冻结锁定这个账户，这个人就登录不是系统！很多黑客就是通过获取root权限，锁定账户 为用户指定空口令时，执行下列形式的命令： 1# passwd -d xiaoliuser 此命令将用户 xiaoliuser的口令删除，这样用户 xiaoliuser下一次登录时，系统就不再允许该用户登录了 passwd 命令还可以用 -l(lock) 选项锁定某一用户，使其不能登录，例如： 1# passwd -l xiaoliuser 用户组管理 每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理（比如开发、运维、测试等）。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建 用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新 增加用户组 增加一个新的用户组使用groupadd命令 1groupadd 选项 用户组 可以使用的选项有： -g GID 指定新用户组的组标识号（GID）。 -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同 12# groupadd mygroup1# cat /etc/group 此命令向系统中增加了一个新组mygroup1，新组的组标识号是在当前已有的最大组标识号的基础上加1 12# groupadd -g 101 mygroup2# cat /etc/group 此命令向系统中增加了一个新组mygroup2，同时指定新组的组标识号是101 删除用户组 如果要删除一个已有的用户组，使用groupdel命令 1groupdel 用户组 例如 1# groupdel group1 此命令从系统中删除组group1 修改用户组 修改用户组的属性使用groupmod命令 1groupmod 选项 用户组 常用的选项有： -g GID 为用户组指定新的组标识号。 -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。 -n 新用户组名 将用户组的名字改为新名字 12345# 此命令将组group2的组标识号修改为102。groupmod -g 102 group2# 将组group2的标识号改为10000，组名修改为group3。groupmod –g 10000 -n group3 group2 切换组 如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。 用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如: 1$ newgrp root 这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组 系统文件 完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。 与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等。 /etc/passwd /etc/passwd文件是用户管理工作涉及的最重要的一个文件 Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。 这个文件对所有用户都是可读的。它的内容类似下面的例子 123456789101112＃ cat /etc/passwdroot:x:0:0:Superuser:/:daemon:x:1:1:System daemons:/etc:bin:x:2:2:Owner of system commands:/bin:sys:x:3:3:Owner of system files:/usr/sys:adm:x:4:4:System accounting:/usr/adm:uucp:x:5:5:UUCP administrator:/usr/lib/uucp:auth:x:7:21:Authentication administrator:/tcb/files/auth:cron:x:9:16:Cron daemon:/usr/spool/cron:listen:x:37:4:Network daemon:/usr/net/nls:lp:x:71:18:Printer administrator:/usr/spool/lp: 从上面的例子我们可以看到，/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下 1用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell 用户名是代表用户账号的字符串 通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符 为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头 口令一些系统中，存放着加密后的用户口令字 虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*” 用户标识号是一个整数，系统内部用它来标识用户 一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等 通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。 组标识号字段记录的是用户所属的用户组。 它对应着/etc/group文件中的一条记录。 注释性描述字段记录着用户的一些个人情况。 例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用作finger命令的输出。 主目录，也就是用户的起始工作目录。 它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。 用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。 Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。 系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。 用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。 利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。 系统中有一类用户称为伪用户（pseudo users）。 这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。 常见的伪用户如下所示： 伪用户 说明 bin 拥有可执行的用户命令文件 sys 拥有系统文件 adm 拥有帐户文件 uucp UUCP使用 lp lp或lpd子系统使用 nobody NFS使用 /etc/shadow 除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要 由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是/etc/shadow文件。有超级用户才拥有该文件读权限，这就保证了用户密码的安全性 /etc/shadow中的记录行与/etc/passwd中的一一对应，它由pwconv命令根据/etc/passwd中的数据自动产生 它的文件格式与/etc/passwd类似，由若干个字段组成，字段之间用”:“隔开。这些字段是： 1登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志 登录名是与/etc/passwd文件中的登录名相一致的用户账号 口令字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。 最后一次修改时间表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。 最小时间间隔指的是两次修改口令之间所需的最小天数。 最大时间间隔指的是口令保持有效的最大天数。 警告时间字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。 不活动时间表示的是用户没有登录活动但账号仍能保持有效的最大天数。 失效时间字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了 /etc/group 用户组的所有信息都存放在/etc/group文件中 将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段 每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组 当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组 用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员 用户组的所有信息都存放在/etc/group文件中。此文件的格式也类似于/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有： 1组名:口令:组标识号:组内用户列表 组名是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复 口令字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是* 组标识号与用户标识号类似，也是一个整数，被系统内部用来标识组。 组内用户列表是属于这个组的所有用户的列表/b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组","path":"page/linux03.html","date":"03-06","excerpt":"","tags":[{"name":"Linux","slug":"Linux","permalink":"http://xiaoliblog.cn/tags/Linux/"}]},{"title":"Linux🎯文件系统管理","text":"目录管理命令绝对路径和相对路径 Linux的目录结构为树状结构，最顶级的目录为根目录/ 其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们 绝对路径 路径的写法，由根目录/写起，例如：/usr/share/doc 这个目录。 相对路径 路径的写法，不是由 / 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成：cd ../man 这就是相对路径的写法啦！ 处理目录的常用命令 命令 描述 ls 列出目录 cd 切换目录 pwd 显示目前的目录 mkdir 创建一个新的目录 rmdir 删除一个空的目录 cp 复制文件或目录 rm 移除文件或目录 mv 移动文件与目录，或修改文件与目录的名称 可以使用man [命令]来查看各个命令的使用文档，如 ：man cp ls（列出目录） 在Linux系统当中， ls 命令可能是最常被运行的 语法 1$ ls [参数] 目录名称 选项与参数 -a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用) -l ：长数据串列出，包含文件的属性与权限等等数据；(常用) 组合用法：将目录下的所有文件列出来(含属性与隐藏档) 1$ ls -al ~ cd（切换目录） cd是Change Directory的缩写，这是用来变换工作目录的命令 语法 1$ cd [相对路径或绝对路径] CentOS7设置中文输入：【应用程序】–&gt;【系统工具】–&gt;【设置】–&gt;【Region &amp; Language】–&gt;【输入源】设置为汉语（Intelligent Pinyin） 1234567891011121314151617181920# 切换到用户目录下$ cd home # 使用 mkdir 命令创建 music 目录$ mkdir music# 进入 指弹 目录$ cd music# 进入多层目录 music下的local目录$ cd music/local# 回到上一级$ cd ..# 回到根目录$ cd /# 表示回到自己的家目录，亦即是 /root 这个目录$ cd ~ pwd ( 显示目前所在的目录 ) pwd 是 Print Working Directory 的缩写，也就是显示目前所在目录的命令。 语法 1$ pwd [-P] 选项与参数 -P ：显示出确实的路径，而非使用连接(link) 路径 12345# 单纯显示出目前的工作目录$ pwd# 如果是链接，要显示真实地址，可以使用 -P参数$ pwd -P mkdir（创建新目录） 如果想要创建新的目录的话，那么就使用mkdir (make directory) 语法 1$ mkdir [-mp] 目录名称 选项与参数 -m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～ p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！ 123456789101112# 进入我们用户目录下$ cd home# 创建test文件夹$ mkdir test# 创建多层文件夹$ mkdir -p test1/test2/test3/test4# 创建权限为 rwx--x--x 的目录$ mkdir -m 711 test2$ ls -l rmdir ( 删除空的目录 ) 语法 1$ rmdir [-p] 目录名称 选项与参数 -p ：连同上一级『空的』目录也一起删除 12345678# 看看有多少目录存在？$ ls -l# 可以删掉空目录$ rmdir test# 利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 依次删除$ rmdir -p test1/test2/test3/test4 注意：这个 rmdir 仅能删除空的目录，你可以使用rm命令来删除非空目录，后面会提到！ cp ( 复制文件或目录 ) 语法 12$ cp [-adfilprsu] 来源档(source) 目标档(destination)$ cp [options] source1 source2 source3 .... directory 选项与参数 说明 -a 相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用) -p 连同文件的属性一起复制过去，而非使用默认属性(备份常用)； -d 若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身； -r 递归持续复制，用於目录的复制行为；(常用) -f 为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次； -i 若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用) -l 进行硬式连结(hard link)的连结档创建，而非复制文件本身。 -s 复制成为符号连结档 (symbolic link)，亦即『捷径』文件； -u 若 destination 比 source 旧才升级 destination 123456# 复制 root目录下的test 到 home目录下$ cp /root/test /home# 再次复制，加上-i参数，增加覆盖询问？$ cp -i /root/test /homecp: overwrite ‘/home/test’? y # n不覆盖，y为覆盖 rm ( 移除文件或目录 ) 语法 1$ rm [-fir] 文件或目录 选项与参数 -f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息； -i ：互动模式，在删除前会询问使用者是否动作 -r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！ 123456# 将刚刚在 cp 的实例中创建的 test 删除掉！$ rm -i testrm: remove regular file ‘test’? y# 如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！# 尽量不要在服务器上使用 rm -rf / rm -rf /* 命令要慎用！，一旦执行系统中的所有文件被删除 mv ( 移动文件与目录，或修改名称 ) 语法 12$ mv [-fiu] source destination$ mv [options] source1 source2 source3 .... directory 选项与参数 -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖； -i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！ -u ：若目标文件已经存在，且 source 比较新，才会升级 (update) 12345# 将test文件移动到 home目录$ mv test home# 将test文件重命名为test1$ mv test test1 打包压缩与解压缩相关概念 打包：默认情况下，Linux的压缩概念一次只能压缩一个文件。针对多文件或文件夹无法进行直接压缩。所以需要提前对多个文件或文件夹进行打包，这样才可以进行压缩操作 12345671.txt 5MB2.txt 10MB3.txt 15MB1.txt + 2.txt + 3.txt &#x3D; 打包 &#x3D; 123.tar &#x3D; 30MB 打包只是把多个文件或文件夹打包放在一个文件中，但是并没有进行压缩，所以其大小还是原来所有文件的总和 压缩：也是一个文件和目录的集合，且这个集合也被存储在一个文件中，但它们的不同之处在于，压缩文件所占用的磁盘空间比集合中所有文件大小的总和要小。 12345671.txt 5MB2.txt 10MB3.txt 15MB1.txt + 2.txt + 3.txt &#x3D; 压缩 &#x3D; 123.tar.gz &#x3D; 20MB（体积变小了） Linux打包操作 基本操作 1tar [选项] 打包后的名称.tar 多个文件或文件夹 选项 说明 -c 打包 -f filename，打包后的文件名称 -v 显示打包的进度 -u update缩写，更新原打包文件中的文件（了解） -t 查看打包的文件内容（了解） 案例：把a.txt、b.txt、c.txt文件打包到abc.tar文件中 1tar -cvf abc.tar a.txt b.txt c.txt 案例：把wechat文件夹进行打包wechat.tar 1tar -cvf wechat.tar wechat 查看和更新 查看tar包中的文件信息 1tar -tf 打包后的文件名称 案例：查看abc.tar包中的文件信息 1tar -tf abc.tar 更新tar包中的文件 1tar -uf 打包后的文件名称 u = update，更新，如果还想往tar包中更新或追加内容都可以通过-u选项 案例：向abc.tar包中添加一个d.txt文件 1234touch d.txttar -uf abc.tar d.txt#查看是否添加成功tar -tf abc.tar 扩展：如何把tar包中的文件释放出来 1234567# 打包tar -cf abc.tar a.txt b.txt c.txt# 打包 =&gt; 释放（-c 变成 -x）# 释放tar -xf abc.tar 打包并压缩 基本语法 1tar [选项] 压缩后的压缩包名称 要压缩的文件或文件夹 选项 说明 -cf 对文件或文件夹进行打包 -v 显示压缩进度 -z 使用gzip压缩工具把打包后的文件压缩为.gz -j 使用bzip2压缩工具把打包后的文件压缩为.bz2 -J 使用xz压缩工具把打包后的文件压缩为.xz 压缩速度：gzip &gt; bzip2 &gt; xz 压缩率：gzip &lt; bzip2 &lt; xz 案例：把a.txt、b.txt、c.txt文件打包并压缩为abc.tar.gz 1tar -zcf abc.tar.gz a.txt b.txt c.txt 案例：把wechat文件夹压缩为wechat.tar.gz格式的压缩包 1tar -zcf wechat.tar.gz wechat 压缩包解压 解压过程非常简单，就是把压缩的参数中的c换成x就可以实现解压缩了 12345678# *.tar.gz格式的压缩包tar -zxf 名称.tar.gz# *.tar.bz2格式的压缩包tar -jxf 名称.tar.bz2# *.tar.xz格式的压缩包tar -Jxf 名称.tar.xz 案例：把abc.tar.gz格式的压缩包进行解压缩操作 1tar -zxf abc.tar.gz 案例：把wechat.tar.gz格式的压缩包进行解压缩操作 1# tar -zxf wechat.tar.gz zip压缩与解压缩zip压缩 基本语法： 1zip [选项] 压缩后的文件名称.zip 文件或文件夹 选项说明： -r ：递归压缩，主要针对的是文件夹 案例：把a.txt、b.txt、c.txt进行压缩为abc.zip 1zip abc.zip a.txt b.txt c.txt 案例：把wechat文件夹压缩为wechat.zip 1zip -r wechat.zip wechat unzip解压缩 基本语法 12unzip 压缩包名称 # 解压到当前目录unzip 压缩包名称 -d 指定路径 # 解压到指定路径下 案例：对abc.zip文件进行解压缩 1unzip abc.zip 案例：把wechat.zip解压到/usr/local/nginx目录下 1unzip wechat.zip -d /usr/local/nginx/ 文件基本属性创建文件 使用touch或者vim创建文件 1touch 文件名称 比如以下命令，但是注意Linux 系统并不以文件的扩展名开分区文件类型，redame.txt只是一个文件，其扩展名 .txt 并不代表此文件就一定是文本文件的 1touch readme.txt 在Linux系统中，文件扩展名的用途为了使运维人员更好的区分不同的文件类型 使用touch命令同时创建多个文件 1touch 文件名称1 文件名称2 文件名称3 ... 案例：创建一个shop商城文件夹，然后在内部创建 index.php，admin.php，config.php 三个文件 123456mkdir shoptouch shop/index.phptouch shop/admin.phptouch shop/config.php# 或者touch shop/index.php shop/admin.php shop/config.php &#123;1…5&#125;根据序号同时创建多个文件 1touch 文件名称&#123;开始序号..结束序号&#125; 案例：创建file1、file2、file3、file4、file5共5个文件 1234567# touch file1# touch file2# touch file3# touch file4# touch file5或者# touch file&#123;1..5&#125; 看懂文件属性 Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。 在Linux中我们可以使用ll或者ls –l命令来显示一个文件的属性以及文件所属的用户和组，如： 实例中，boot文件的第一个属性用”d”表示。”d”在Linux中代表该文件是一个目录文件。 在Linux中第一个字符代表这个文件是目录、文件或链接文件等等： 当为[ d ]则是目录 当为[ - ]则是文件； 若是[ l ]则表示为链接文档 ( link file )，比如应用的快捷方式； 若是[ b ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )； 若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。 接下来的九个字符中，以三个为一组，且均为『rwx』 的三个参数的组合 其中，[r ]代表可读(read)、[w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。 每个文件的属性由左边第一部分的10个字符来确定（如下图） 从左至右用0-9这些数字来表示 第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限，即root。第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限 第1、4、7位表示读权限，如果用”r“字符表示，则有读权限，如果用”-“字符表示，则没有读权限； 第2、5、8位表示写权限，如果用”w“字符表示，则有写权限，如果用”-“字符表示没有写权限； 第3、6、9位表示可执行权限，如果用”x“字符表示，则有执行权限，如果用”-“字符表示，则没有执行权限。 对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。 同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。 文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。 因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。 在以上实例中，boot文件是一个目录文件，属主和属组都为 root。 修改文件属性 chgrp：更改文件属组 1$ chgrp [-R] 属组名 文件名 -R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。 chown：更改文件属主，也可以同时更改文件属组 12$ chown [–R] 属主名 文件名$ chown [-R] 属主名：属组名 文件名 chmod：更改文件9个属性 1chmod [-R] xyz 文件或目录 Linux文件属性有两种设置方法，一种是数字（常用），一种是符号。 Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限 文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下： 字符 对应的数字 r 4 w 2 x 1 每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的 例如当权限为：[-rwxrwx—] 分数则是： owner = rwx = 4+2+1 = 7 group = rwx = 4+2+1 = 7 others= — = 0+0+0 = 0 举例 权限 字符 数字 可读可写不可执行 rw- 6 可读可写可执行 rwx 7 123456789# 赋予文件最高权限，所有用户可读可写可执行$ chmod 777 filenamedrwxrwxrwx$ chmod 700 filenamedrwx------$ chmod 761 filenamedrwxrw---x 文件内容查看命令概述 Linux系统中使用以下命令来查看文件的内容： 命令 描述 cat 由第一行开始显示文件内容 tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！ nl 显示的时候，顺道输出行号！ more 一页一页的显示文件内容 less 与 more 类似，但是比 more 更好的是，他可以往前翻页！ head 只看头几行 tail 只看尾巴几行 你可以使用 man [命令]来查看各个命令的使用文档，如 ：man cp。 cat &amp; taccat 命令适合查看不太大的文件，文件非常大，会导致文件开头的内容看不到 语法 1$ cat [-AbEnTv] 选项与参数 说明 -A 相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已； -b 列出行号，仅针对非空白行做行号显示，空白行不标行号！ -E 将结尾的断行字节 $ 显示出来； -n 列印出行号，连同空白行也会有行号，与 -b 的选项不同； -T 将 [tab] 按键以 ^I 显示出来； -v 列出一些看不出来的特殊字符 网络配置目录：cd/etc/sysconfig/network-scripts/ windows下用ipconfig查看网络配置，Linux使用ifconfig查看网络配置 12345# 查看网络配置: 文件地址 /etc/sysconfig/network-scripts/$ cat /etc/sysconfig/network-scripts/ifcfg-eth0DEVICE=eth0BOOTPROTO=dhcpONBOOT=yes tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如： 1234$ tac /etc/sysconfig/network-scripts/ifcfg-eth0ONBOOT=yesBOOTPROTO=dhcpDEVICE=eth0 nl nl 显示符号，可以用于显示行号 语法 1$ nl [-bnw] 文件 选项与参数 -b ：指定行号指定的方式，主要有两种： -b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)； -b t ：如果有空行，空的那一行不要列出行号(默认值)； -n ：列出行号表示的方法，主要有三种： -n ln ：行号在荧幕的最左方显示； -n rn ：行号在自己栏位的最右方显示，且不加 0 ； -n rz ：行号在自己栏位的最右方显示，且加 0 ； -w ：行号栏位的占用的位数。 1234$ nl /etc/sysconfig/network-scripts/ifcfg-eth01DEVICE=eth02BOOTPROTO=dhcp3ONBOOT=yes more &amp; less more 可以一页一页翻动 在 more 这个程序的运行过程中，你有几个按键可以按的： 空白键 (space)：代表向下翻一页； Enter ：代表向下翻『一行』； /字串 ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字； :f ：立刻显示出档名以及目前显示的行数； q ：代表立刻离开 more ，不再显示该文件内容。 b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用 123$ more /etc/csh.login....(中间省略)....--More--(28%) # 重点在这一行喔！你的光标也会在这里等待你的命令 less 一页一页翻动，以下实例输出/etc/man.config文件的内容： less运行时可以输入的命令有： 空白键 ：向下翻动一页； [pagedown]：向下翻动一页； [pageup] ：向上翻动一页； /字串 ：向下搜寻『字串』的功能； ?字串 ：向上搜寻『字串』的功能； n ：重复前一个搜寻 (与 / 或 ? 有关！) N ：反向的重复前一个搜寻 (与 / 或 ? 有关！) q ：离开 less 这个程序； head &amp; tall head 取出文件前面几行 语法 1$ head [-n number] 文件 选项与参数 -n 后面接数字，代表显示几行的意思！ 默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样： 1$ head -n 20 /etc/csh.login tail 取出文件后面几行 语法 1$ tail [-n number] 文件 选项与参数 -n ：后面接数字，代表显示几行的意思 默认的情况中，显示最后 10 行！若要显示最后 20 行，就得要这样： 1$ tail -n 20 /etc/csh.login Linux 链接 Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link） 情况下，ln 命令产生硬链接 硬链接 硬连接指通过索引节点来进行连接 在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index) 在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问 硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能 其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。 软链接 另外一种连接称之为符号连接（Symbolic Link），也叫软连接 软链接文件有类似于 Windows 的快捷方式，删除了源文件，快捷方式也访问不了。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。 比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。 测试12345678910[root@kuangshen /]# cd /home[root@kuangshen home]# touch f1 # 创建一个测试文件f1[root@kuangshen home]# lsf1[root@kuangshen home]# ln f1 f2 # 创建f1的一个硬连接文件f2[root@kuangshen home]# ln -s f1 f3 # 创建f1的一个符号连接文件f3[root@kuangshen home]# ls -li # -i参数显示文件的inode节点信息397247 -rw-r--r-- 2 root root 0 Mar 13 00:50 f1397247 -rw-r--r-- 2 root root 0 Mar 13 00:50 f2397248 lrwxrwxrwx 1 root root 2 Mar 13 00:50 f3 -&gt; f1 从上面的结果中可以看出，硬连接文件 f2 与原文件 f1 的 inode 节点相同，均为 397247，然而符号连接文件的 inode 节点不同。 12345678910111213# echo 字符串输出 &gt;&gt; f1 输出到 f1文件[root@kuangshen home]# echo &quot;I am f1 file&quot; &gt;&gt;f1[root@kuangshen home]# cat f1I am f1 file[root@kuangshen home]# cat f2I am f1 file[root@kuangshen home]# cat f3I am f1 file[root@kuangshen home]# rm -f f1[root@kuangshen home]# cat f2I am f1 file[root@kuangshen home]# cat f3cat: f3: No such file or directory 通过上面的测试可以看出：当删除原始文件 f1 后，硬连接 f2 不受影响，但是符号连接 f1 文件无效； 做一些相关的测试，可以得到以下全部结论： 删除符号连接f3,对f1,f2无影响； 删除硬连接f2，对f1,f3也无影响； 删除原文件f1，对硬连接f2没有影响，导致符号连接f3失效； 同时删除原文件f1,硬连接f2，整个文件会真正的被删除。","path":"page/linux02.html","date":"03-05","excerpt":"","tags":[{"name":"Linux","slug":"Linux","permalink":"http://xiaoliblog.cn/tags/Linux/"}]},{"title":"Linux🎯概述及环境搭建","text":"Linux简介 Linux 内核最初只是由芬兰人林纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写的 Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX（可移植操作系统接口） 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统 Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统 Linux运维笔记参考机智的小锐 Linux 发行版 Linux 的发行版说简单点就是将 Linux 内核与应用软件做一个打包 目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等 Linux应用领域 今天各种场合都有使用各种 Linux 发行版，从嵌入式设备到超级计算机，并且在服务器领域确定了地位，通常服务器使用 LAMP（Linux + Apache + MySQL + PHP）或 LNMP（Linux + Nginx+ MySQL + PHP）组合 目前 Linux 不仅在家庭与企业中使用，并且在政府中也很受欢迎 巴西联邦政府由于支持 Linux 而世界闻名 有新闻报道俄罗斯军队自己制造的 Linux 发布版的，做为 G.H.ost 项目已经取得成果 印度的 Kerala 联邦计划在向全联邦的高中推广使用 Linux 中华人民共和国为取得技术独立，在龙芯处理器中排他性地使用 Linux 在西班牙的一些地区开发了自己的 Linux 发布版，并且在政府与教育领域广泛使用，如 Extremadura 地区的 gnuLinEx 和 Andalusia 地区的 Guadalinex 葡萄牙同样使用自己的 Linux 发布版 Caixa Mágica，用于 Magalh?es 笔记本电脑和 e-escola 政府软件 法国和德国同样开始逐步采用 Linux 环境搭建 Linux环境搭建共有两种方式 安装CentOS（本地安装） 购买云服务器（推荐） VMware本地安装CentOS7安装VMware Linux是一个操作系统，可以把电脑安装成双系统！但会占用一部分资源，推荐安装虚拟机 虚拟机（VMware下载），下载安装有两种方法 官网下载：https://www.vmware.com/cn.html ，但是下载速度很慢，可以通过镜像下载 搜索网页版腾讯软件中心，选择普通下载即可，下载后安装很简单，无脑下一步即可 VMware16.1.0版本百度云资源链接：https://pan.baidu.com/s/1Wlan4uliAFNwIWFgyqFCqQ，提取码：17tc 打开VMware软件后，如果需要输入许可证密钥，可以百度搜索或者复制以下任意一条即可 123ZF3R0-FHED2-M80TY-8QYGC-NPKYFYF390-0HF8P-M81RQ-2DXQE-M2UT6ZF71R-DMX85-08DQY-8YMNC-PPHV8 如果还是无法打开软件，可以选择重启一下，打开软件界面如下 下载安装CentOS7 通过阿里云镜像下载：http://mirrors.aliyun.com/centos/7.9.2009/isos/x86_64/ 安装过程可以百度搜索相关教程，👉VMware安装CentOS7超详细版 注意：在虚拟机内存配置中可以依据自己电脑配置进行选择，比如你的电脑是8GB，可以选择2048MB即2G，但如果内存较小，可以选择1024MB即1G 创建虚拟机后配置CentOS7补充 创建好虚拟机后，右击选择设置，选择CD/DVD，在选择ISO映像文件，浏览找到下载的CentOS7镜像文件 然后开启此虚拟机，按回车安装CentOS7即可 安装过程中有以下配置 设置语言，可以选择简体中文 设置时间，时区选择上海，查看时间是否正确 选择需要安装的软件，可以选择安装GNOME桌面，一个友好的图形化界面 根据需要禁用Kdump 选择安装位置，在这里可以选择进行磁盘划分，一般化为4个分区，以下详解如何配置 安装位置在本地标准磁盘手动配置分区 挂载点选择并添加 /home分配300）MB /boot 启动空间目录 200MB即可 swap 虚拟空间 内存的2倍，比如2048MB，最大不超过8GB /根目录 分完上面两个目录 剩下的都分派给/ 然后点击安装，安装过程中需要设置密码和创建用户，填好并记住密码 安装完成后点击重启，看到如下界面，接受许可证和进行网络连接，然后点击完成配置 进行登录后就可以看到图形化界面 Xshell远程连接阿里云服务器 由于虚拟机安装后占用空间，也会有些卡顿，其实可以选择购买一台自己的服务器，这样的话更加接近真实线上工作 云服务相当于一台远程电脑，服务器一般不会关机 购买云服务器 阿里云购买服务器：https://www.aliyun.com/minisite/goods?userCode=0phtycgr 关于服务器的相关配置可以查看狂神的教学视频👉服务器购买及宝塔部署环境说明 | | Xshell远程连接阿里云服务器 购买完毕后，获取服务器的公网ip地址，重置服务器密码，就可以远程登录了 下载 xShell 工具(22端口），进行远程连接使用！还需要一个xFtp文件上传！ 连接成功效果如下： 注意事项：如果要打开端口，需要在阿里云的安全组面板中开启对应的出入规则，不然的话会被阿里拦截！ 如果前期不好操作，可以推荐安装宝塔面板，傻瓜式管理服务器 安装教程：https://www.bt.cn/bbs/thread-19376-1-1.html 开启对应的端口 一键安装 安装完毕后会得到远程面板的地址，账号，密码，就可以登录了 登录之后就可以可视化的安装环境和部署网站！ 走近Linux系统开机登录 开机会启动许多程序。它们在Windows叫做服务（service），在Linux就叫做守护进程（daemon） 开机成功后，它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份，密码是不显示的，输完回车即可！ 一般来说，用户的登录方式有三种： 命令行登录 ssh登录 图形界面登录 最高权限账户为 root，可以操作一切！ 关机 在linux领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机 关机指令为：shutdown 12345678910111213141516171819sync # 将数据由内存同步到硬盘中。shutdown # 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：shutdown –h 10 # 这个命令告诉大家，计算机将在10分钟后关机shutdown –h now # 立马关机shutdown –h 20:25 # 系统会在今天20:25关机shutdown –h +10 # 十分钟后关机shutdown –r now # 系统立马重启shutdown –r +10 # 系统十分钟后重启reboot # 就是重启，等同于 shutdown –r nowhalt # 关闭系统，等同于shutdown –h now 和 poweroff 总结一下，不管是重启系统还是关闭系统，首先要运行 sync命令，把内存中的数据写到磁盘中 系统目录结构 Linux系统中一切皆文件！ 根目录/，所有的文件都挂载在这个节点下 登录系统后，在当前命令窗口下输入命令： 1ls / 树状目录结构 /bin：bin是Binary的缩写, 这个目录存放着最经常使用的命令 /boot： 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件（不要动） /dev ： dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的 /etc： 这个目录用来存放所有的系统管理所需要的配置文件和子目录 /home：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的 /lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件（不要动) /lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。（存放一些突然关机的文件） /media：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下 /mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了 /opt：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的 /proc：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息 /root：该目录为系统管理员，也称作超级权限者的用户主目录 /sbin：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序 /srv：该目录存放一些服务启动之后需要提取的数据 /sys：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs /tmp：这个目录是用来存放一些临时文件的，用完即丢的文件，可以放在这个目录下，比如安装包 /usr：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录 /usr/bin： 系统用户使用的应用程序 /usr/sbin： 超级用户使用的比较高级的管理程序和系统守护程序 /usr/src： 内核源代码默认的放置目录 /var：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件 /run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除 /www：存放服务器网站相关的资源，比如环境、网站相关资源（本地配置是没有的）","path":"page/linux01.html","date":"03-05","excerpt":"","tags":[{"name":"Linux","slug":"Linux","permalink":"http://xiaoliblog.cn/tags/Linux/"}]},{"title":"IntelliJ IDEA🍊项目创建及配置","text":"IDEA项目概念 Create New Project:创建一个新的工程 Import Project:导入一个现有的工程 Open:打开一个已有工程。比如：可以打开 Eclipse 项目。 Check out from Version Control:可以通过服务器上的项目地址 check out Github上面项目或其他 Git 托管服务器上的项目 IntelliJ IDEA 没有类似 Eclipse 的工作空间的概念（Workspaces），最大单元就是Project。这里可以把 Project 理解为 Eclipse 中的 Workspace。 创建模块(Module) 在 Eclipse 中我们有 Workspace（工作空间）和 Project（工程）的概念，在 IDEA中只有 Project（工程）和 Module（模块）的概念。这里的对应关系为： 从 Eclipse 转过来的人总是下意识地要在同一个窗口管理 n 个项目，这在IntelliJ IDEA 是无法做到的。IntelliJ IDEA 提供的解决方案是打开多个项目实例，即打开多个项目窗口。即：一个 Project 打开一个 Window 窗口 在 IntelliJ IDEA 中 Project 是最顶级的级别，次级别是 Module。一个 Project可以有多个Module。目前主流的大型项目都是分布式部署的，结构都是类似这种多 Module 结构 这类项目一般是这样划分的，比如：core Module、web Module、plugin Module、solr Module 等等，模块之间彼此可以相互依赖。通过这些 Module 的命名也可以看出，他们之间都是处于同一个项目业务下的模块，彼此之间是有不可分割的业务关系的。 相比较于多 Module 项目，小项目就无需搞得这么复杂。只有一个 Module 的结构 IntelliJ IDEA 也是支持的，并且 IntelliJ IDEA 创建项目的时候，默认就是单Module 的结构的 之后，我们可以在 Module 的 src 里写代码，此时 Project 工程下的 src 就没什么用了。可以删掉 删除模块，右击-&gt;【开启模块设置】，然后点击减号删除 创建普通Java项目 选择指定目录下的 JDK 作为 Project SDK JDK官网下载地址：https://www.oracle.com/cn/java/technologies/javase/javase-jdk8-downloads.html 如果要创建 Web 工程，则需要勾选上面的 Web Application。如果不需要创建 Web工程的话，则不需要勾选 可以看到项目相关目录结构，其中.idea和.iml是Idea自带的配置文件，如果不想看见可以隐藏起来 【File】【setting】【FileType】右下角进行过滤，在后面添加.idea;*.iml;，注意用分号隔开 创建JavaWeb项目 2020.3.x版IDEA创建Web项目，可以查看IntelliJ IDEA2020.2.2创建Servlet方法及404问题 【File】–&gt;【New】–&gt;【Project】，选择Java Enterprise版本，然后配置tomcat 注意：这里关联的tomcat home指的是tomcat的解压目录（bin目录的上一级目录）； 选择使用模板创建项目，并配置Tomcat WEB项目结构介绍 创建Servlet 编辑index.jsp文件，创建form表单 123456789101112&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;addUser&quot; method=&quot;post&quot;&gt; 用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/br&gt; 密码:&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 新建Servlet 12345678910111213141516171819202122232425262728package com.lzy.web;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @Auther: http://xiaoliblog.cn * @Date: 2021/3/13 * @Description: $&#123;PACKAGE_NAME&#125; * @version: 1.0 */@WebServlet(name = &quot;addUser&quot;,urlPatterns=(&quot;/addUser&quot;))public class addUser extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(&quot;utf-8&quot;); String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); System.out.println(username+&quot;---&quot;+password); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request,response); &#125;&#125; IDEA会默认有一个参数提示的功能，可以在【设置】【编辑器】【常规】【外观】里面取消【显示参数名提示】 配置Tomcat参考使用IntelliJ IDEA配置Tomcat（详细操作） 点击工具栏中的添加配置 选择本地Local的Tomcat 可以查看Tomcat的一些配置 解决出现警告的问题，点击【Deployment】，然后选择【+】选择Artifact即可 关于没有Artifact选项可以参考👉没有Artifact选项解决方法参考 虚拟路径映射 访问出现404的原因，可能是以下模块目录设置不对，可以选择项目结构，找到模块设置 创建Maven项目参考我的Maven包管理工具博文地址：https://xiaoliblog.cn/page/Maven02.html 2020.3.xIDEA 2020.3.x版相较于其他版本有稍许改变，详情可以查看官网IntelliJ IDEA 2020.3 最新变化 以idea 2020.3.2 为例，默认新建项目栏里已经没有 web、spring 等字眼了 创建一个普通的 Java 项目 右键点击项目名，选择 “Add Framework Support…”，即添加框架支持 这里面web和Spring都能找到 其他配置参考👉带你玩转IntelliJ IDEA 使用教程(2019图文版)","path":"page/idea02.html","date":"03-03","excerpt":"","tags":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"http://xiaoliblog.cn/tags/IntelliJ-IDEA/"}]},{"title":"Git🧰GitHub开源项目查找及插件推荐","text":"GitHub项目查找开源项目的组成部分 了解一下一个开源项目有哪些组成部分： name: 项目名 description: 项目的简要描述 项目的源码 README.md: 项目的详细情况的介绍 项目本身的star数和fork数 按照 name 搜索 搜索项目名里面包含React的项目: in:name React 可以看到，这些搜索结果都是项目名里面带有“React”关键字的项目，但是项目数量依旧很多。可以对搜索进行约束。比如精确到项目的star数目大于1000 in:name React stars:&gt;1000 同理，也可以按照fork数量来进行搜索 in:name React stars:&gt;1000 forks:&gt;3000 按照README来搜索 搜索README.md里面包含React的项目: in:readme React 结果有这么多，那么我们再限制一下它的star数和fork数： in:readme React stars:&gt;3000 forks:&gt;3000 按照descriptin搜索 假设我们现在要学习微服务的项目，我们搜索项目描述(description)里面包含微服务的项目: in:description 微服务 结果有这么多，那我们接着增加一些筛选条，language限制语言，pushed更新时间限制到2020-01-01: in:description 微服务 language:python pushed:&gt;2020-01-01 GitHub插件推荐 插件百度云链接：https://pan.baidu.com/s/1A4iubKQrAZ_TrgCSTx94tQ提取码：w5yo Octotree 因为GItHub的文件结构并不明显，但当你安装了这个插件，打开 GitHub 仓库时会在左边有一个按钮，点击按钮就会有这个项目的完整目录树了，体验方式和在 IDE 中差不多 Sourcegraph 当查看GitHub项目源码时，如果懒得下载源码，但直接在 GitHub 上看源码又没有结构层次。此时就可以使用插件Sourcegraph，安装插件完毕，打开 GitHub ，下图所示这个炫酷的图标就会出现，点击它你就会发现新世界 GitZip 该插件就能帮助你轻松下载一个仓库中的部分代码，使用起来也很简单。安装插件后，找到你想下载的目录，在空白处点击鼠标右键，点击 Download 目录名 就可以下载了 Open in VSCode GitHub项目地址：https://github.com/conwnet/github1s 此项目可以用VS Code直接浏览GitHub代码，操作方式非常的简单，只需要在浏览器网址部分中的“github”后边，添加一个“1s”就可以了 除了手动输入网址的方式外，作者还开发了Chrome扩展程序Open in VSCode 在安装完毕后，只需要在GitHub项目页面右击，就会出现相应选项，一键即可转换成VS Code","path":"page/git03.html","date":"03-03","excerpt":"","tags":[{"name":"Git","slug":"Git","permalink":"http://xiaoliblog.cn/tags/Git/"}]},{"title":"Git🧰解决GitHub被墙的问题","text":"GitHub加速访问 中国大陆的用户访问 GitHub 的速度很慢，如果不「科学上网」，下载一个项目可能需要等很多时间 速度慢的原因有很多，但最直接和最主要的原因是 GitHub 的分发加速网络的域名遭到 DNS 污染 由于 GitHub 的加速分发 CDN 域名 assets-cdn.github.com 遭到 DNS 污染，导致无法连接使用 GitHub的加速分发服务器，才使得中国大陆访问速度很慢 我们解决污染问题一般是通过通过修改 Hosts ，GitHub 的 CDN 域名被污染问题也不例外。将域名解析直接指向 IP 地址来绕过 DNS 的解析，以此解决污染问题 解决污染 打开 https://www.ipaddress.com 查询下面主要网站的 IP github.com github.global.ssl.fastly.net 把网站的地址复制到刚刚的完整进行查询，假如查询结果如下（包括其他IP）: 12345678910111213141516171819202122232425140.82.113.3 github.com199.232.69.194 github.global.ssl.Fastly.net185.199.108.154 github.githubassets.com199.232.68.133 camo.githubusercontent.com199.232.68.133 github.map.fastly.net199.232.69.194 github.global.ssl.fastly.net140.82.113.3 gist.github.com #gist现在被墙的很彻底，就算添加进hosts也访问不了。185.199.108.153 github.io140.82.113.4 github.com140.82.114.5 api.github.com199.232.68.133 raw.githubusercontent.com199.232.68.133 user-images.githubusercontent.com199.232.68.133 favicons.githubusercontent.com199.232.68.133 avatars5.githubusercontent.com199.232.68.133 avatars4.githubusercontent.com199.232.68.133 avatars3.githubusercontent.com199.232.68.133 avatars2.githubusercontent.com199.232.68.133 avatars1.githubusercontent.com199.232.68.133 avatars0.githubusercontent.com140.82.114.9 codeload.github.com52.217.83.84 github-cloud.s3.amazonaws.com52.216.229.155 github-com.s3.amazonaws.com52.216.30.60 github-production-release-asset-2e65be.s3.amazonaws.com52.216.17.0 github-production-user-asset-6210df.s3.amazonaws.com52.216.236.43 github-production-repository-file-5c1aeb.s3.amazonaws.com 找到 Windows下的 hosts 文件，进行 DNS 映射 将 IP 地址写入hosts文件里 然后win+R输入cmd，打开命令行界面。输入ipconfig/flushdns刷新DNS缓存即可，如果某一天发现网速又变慢了, 可以重新按上面的步骤查询最新的 ip 即可 因为上述域名的 IP 是不停在变的，这一串映射仅仅适用于今天而已，到了明天，ip 一变动，又登不上了，如果明天到查询IP重新写入岂不是很麻烦 使用爬虫脚本实时获取最新 ip转载自：https://akilar.top/posts/61b3e163/ 因为 github 相关的诸多域名的 ip 是在变动的，为了能够实时获取最新的 ip，我们可以使用爬虫来从站长之家或其余 ip 查询网站上爬取最新 ip 这里要用到 python，安装推荐使用 Anaconda，根据 Anaconda 版本与 python 版本的对照选择自己需要的 Anaconda 安装包，然后直接安装即可，路径建议修改为非系统盘，同时务必勾选将 python 路径加入到环境变量的选项 具体下载及安装配置参考👉Anaconda的安装教程 新建一个 python 脚本 ——githosts.py（最简单的方法，新建一个 txt 文本文件，把下面的代码粘贴进去以后，修改后缀为.py） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/env python# 待查询的域名s = &quot;&quot;&quot;github.githubassets.comcamo.githubusercontent.comgithub.map.fastly.netgithub.global.ssl.fastly.netgist.github.comgithub.iogithub.comapi.github.comraw.githubusercontent.comuser-images.githubusercontent.comfavicons.githubusercontent.comavatars5.githubusercontent.comavatars4.githubusercontent.comavatars3.githubusercontent.comavatars2.githubusercontent.comavatars1.githubusercontent.comavatars0.githubusercontent.comcodeload.github.comgithub-cloud.s3.amazonaws.comgithub-com.s3.amazonaws.comgithub-production-release-asset-2e65be.s3.amazonaws.comgithub-production-user-asset-6210df.s3.amazonaws.comgithub-production-repository-file-5c1aeb.s3.amazonaws.com&quot;&quot;&quot;# 引入必要的包库import requestsfrom bs4 import BeautifulSoupimport os# 分割s list，然后逐个查询对应的ip，之后逐个加入到ans list中ans = []for i in s.split(): url = &quot;http://ip.tool.chinaz.com/&quot; + i.strip() resp = requests.get(url) soup = BeautifulSoup(resp.text,&quot;html5lib&quot;) x = soup.find(class_=&quot;IcpMain02&quot;) x = x.find_all(&quot;span&quot;, class_=&quot;Whwtdhalf&quot;) x = &quot;%s %s&quot; % (x[5].string.strip(), i.strip()) print(x) ans.append(x)# 打开hosts文件，写入结果hosts = r&quot;C:\\Windows\\System32\\drivers\\etc\\hosts&quot;with open(hosts, &quot;r&quot;) as f: content = [i for i in f.readlines() if i.startswith(&quot;#&quot;)] content.extend(ans)with open(hosts, &quot;w&quot;) as f: f.write(&quot;\\n&quot;.join(content))# 调用os，执行刷新dns指令os.system(&#x27;ipconfig /flushdns&#x27;) 然后把 githosts.py 放到 C:\\Windows\\System32 目录下（不放其实也可以，只是这样一来每次都要自己 cd 路径。） Shift+右键或者win+x+A，以管理员启动Powershell，输入 1python githosts.py 然后脚本就会自动爬取最新的 IP 与域名到你的 hosts 文件中 Chrom插件 这款 GitHub 加速插件挺好用的，如果你没办登录谷插件商店，可以通过百度云链接，提取码：zxn8 下载 GitHub克隆网站 下面这两个网站是 GitHub 的克隆版，也就是该网站的镜像。当你下载、克隆很慢时，可以随意访问下面这俩网站 https://github.com.cnpmjs.org https://hub.fastgit.org 项目加速下载网站 下面这个网站是一个 GitHub 加速下载网站，打开你要下载的 GitHub 仓库页面，点击右侧额绿色按钮点击 Download ZIP，等浏览器弹出下载框后复制下载框中的链接地址粘贴到这个网站即可。 http://toolwa.com/github/ 参考git clone 过慢解决方案：https://akilar.top/posts/24a51aa5/参考从 github 下载 release 速度过慢的解决方案https://akilar.top/posts/7357e481/","path":"page/git04.html","date":"03-03","excerpt":"","tags":[{"name":"Git","slug":"Git","permalink":"http://xiaoliblog.cn/tags/Git/"}]},{"title":"IntelliJ IDEA🍊下载及基本配置","text":"IntelliJ IDEA介绍 IntelliJ IDEA 是 java语言开发的集成环境，在业界被公认为最好的 java开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE支持、各类版本工具（git、svn等）、JUnit、CVS整合、代码分析、 创新的 GUI设计等方面的功能可以说是超常的 下面就以ideaIU-2020.3.2版64 位的 IntelliJ IDEA Ultimate Windows版本做详细介绍 参考地址：https://www.bilibili.com/video/BV1bJ411P7cQ IntelliJ IDEA下载安装 硬件要求 个人建议配置：内存 8G 或以上，CPU 最好 i5 以上，最好安装块固态硬盘(SSD)，将 IDEA安装在固态硬盘上，这样流畅度会加快很多 官方网址下载IEDA：https://www.jetbrains.com/idea/download/#section=windows 官方使用文档：https://www.jetbrains.com/help/ 选择对应系统版本下载；官网上提供了 Windows，macOS 和 Linux 三个操作系统，每个系统都有两个版本可供下载： Ultimate和 Community Ultimate 为旗舰版；功能全面，插件丰富，但是收费，按年收费；Community 为社区版；免费试用，功能相对而言不是很丰富，但是不影响开发使用。 目录结构IntelliJ IDEA 的安装、配置与使用 安装后的目录结构即用处如下 bin目录及VM配置 其中，bin目录下 可以根据电脑系统的位数，选择 32 位的 VM 配置文件或者 64 位的 VM 配置文件 32 位操作系统内存不会超过 4G，所以没有多大空间可以调整，建议不用调整了 64 位操作系统中 8G 内存以下的机子或是静态页面开发者是无需修改的 64 位操作系统且内存大于 8G 的，如果你是开发大型项目、Java 项目或是 Android 项目，建议进行修改，常修改的就是下面 3 个参数： 查看设置目录结构 在目录C:\\Users\\(主机名)朕爷专属pro\\.IntelliJIdea2018.2下 这是 IDEA 的各种配置的保存目录。这个设置目录有一个特性，就是你删除掉整个目录之后，重新启动 IntelliJ IDEA 会再自动帮你生成一个全新的默认配置，所以很多时候如果你把 IntelliJ IDEA 配置改坏了，没关系，删掉该目录，一切都会还原到默认 config 目录是 IntelliJ IDEA 个性化化配置目录，或者说是整个 IDE 设置目录。此目录可看成是最重要的目录，没有之一，如果你还记得安装篇的介绍的时候，安装新版本的 IntelliJ IDEA 会自动扫描硬盘上的旧配置目录，指的就是该目录。这个目录主要记录了：IDE 主要配置功能、自定义的代码模板、自定义的文件模板、自定义的快捷键、Project 的 tasks 记录等等个性化的设置 system 目录是 IntelliJ IDEA 系统文件目录，是 IntelliJ IDEA 与开发项目一个桥梁目录，里面主要有：缓存、索引、容器文件输出等等，虽然不是最重要目录，但也是最不可或缺的目录之一 启动后简单配置汉化教程参考👉IntelliJ IDEA 2020.1官方汉化 首先确认你所用IDEA版本, 如果小于2020.1版本可能无法使用官方汉化，其他版本可以去百度搜索语言包，放在\\lib目录下 打开【setting】设置页面,，导航到【Editor】–&gt; 【Proofreading】, 点【+】添加中文包; 添加完不要关闭setting设置, 继续切到【Plugins】页面，安装汉化插件，重启后进入汉化idea. 激活破解参考👉IntelliJ IDEA 2020.3.2激活破解教程 || IDEA激活教程 本教程适用于 JetBrains 全系列产品，包括 Pycharm、IDEA、WebStorm、Phpstorm、Datagrip、RubyMine、CLion、AppCode 等 安装后首次开启, 中间会先弹出一个注册框，我们勾选 Evaluate for free, 点击 Evaluate， 先试用30天: 破解补丁链接：&lt;https://pan.baidu.com/s/1QS6X6ccPwtLk9sK10xHz0w &gt; ， 提取码：`uc0m 下载解压，最好解压到一个固定位置，因为次文件不能删除，打开该文件夹后，有对应系统的执行脚本，执行即可： 12windows系统：reset_jetbrains_eval_windows.vbslinux&#x2F;mac系统：reset_jetbrains_eval_mac_linux.sh 进入 IDEA 中， 先随便建个 Java 工程， 然后将网盘中最新的 IDEA 破解补丁 BetterIntelliJ.zip拖入 IDEA 界面中，如下图所示： 重启后，复制网盘中的 激活补丁key.txt文件中的激活码，拷贝到输入框中，然后点击 Activate 按钮激活： 进入 IDEA 界面后，点击 【Help】 -&gt; 【Register】 查看，已经破解到2099年了 设置插件 IDEA插件官方下载地址：https://plugins.jetbrains.com/idea，载压缩包之后，选择install from disk 【File】 -&gt; 【Setting】 -&gt; 【Plugin】 推荐插件 说明 Alibaba Java Coding Guidelines 阿里Java编程规约插件 FindBugs 代码缺陷扫描 PMD 代码缺陷扫描 InnerBuilder builder模式快速生成 lombok plugin lombok 插件 maven helper maven 依赖管理助手 ，解析maven pom结构，分析冲突； Rainbow brackets 不同颜色的括号，让代码中的括号更具标识性 String Manipulation String相关辅助简化，搭配 CTRL+W 、ALT+J等文本选择快捷键使用 Translation 翻译插件，阅读源码必备 GenerateSerialVersionUID Alt + Insert 快速生成SerialVersionUID MyBatis Log Plugin 把 Mybatis 输出的sql日志还原成完整的sql语句，看起来更直观 IDEA快捷键查找相关 快捷键 介绍 Ctrl+ F 在当前文件进行文本查找 Ctrl + R 在当前文件进行文本替换 Ctrl + Shift + F 在项目进行文本查找 Ctrl + Shift + R 在项目进行文本替换 Shift + Shift 快速搜索 Ctrl + N 查找class Ctrl + Shift + N 查找文件 Ctrl+Shift+Alt+N 查找symbol (查找某个方法名) 跳转切换 快捷键 介绍 Ctrl + E 最近文件 Ctrl + Tab 切换文件 CtrI+ Alt+←/→ 跳转历史光标所在处 Alt +←/→方向键 切换子tab CtrI+ G go to (跳转指定行号) Ctrl + Shift + Enter 快速换行到下一行，当光标不在代码尾部时很好用 编码相关 快捷键 说明 Ctrl+D 快速复制粘贴到下一行 Ctrl+Y 快速删除选中代码行 AIt+Enter 根据光标所在位置，提供快速修改，比如导包和类 Shift+[Fn]+F6 快速重命名类、方法等 Ctrl+/ 单行注释 Ctrl+AIt+T 表示用代码块包裹选中的代码，比如try…catch Ctrl+Z 回退 AIt+Insert(F12) 快速生成getter和setter方法 Ctrl+Shift+/ 多行注释选中代码块 Ctrl+Shift+空格 新建类时在new后面使用(提示自动创建类) Ctrl+AIt+B 查看接口或者抽象类的子类 Ctrl+Shift+L 格式化代码 Ctrl+Alt+V 快速生成变量名 代码阅读相关 快捷键 介绍 Ctrl + P 方法参数提示显示 Ctrl + Shift + i 就可以在当前类里再弹出一一个窗口出来 Alt + F7 可以列出变量在哪些地方被使用了 光标在子类接口名，Ctrl+ u 跳到父类接口 (Shift) + Ctrl + +/- 代码块折叠 CtrI + Shift+←/→ 移动窗口分割线 Ctrl+ (Alt) + B 跳转方法定义/实现 CtrI + H 类的层级关系 CtrI + F12 Show Members类成员快速显示 快速生成代码 缩写 说明 psvm 快速生成main函数 sout 快速生成输出语句 fori 快速生成for循环结构 x.for 快速生成增强for结构 说明：在 IDEA 里要说的是，写完代码，不用点击保存。IDEA 会自动保存代码。 IDEA可以集成了Eclipse的快捷键，可以在【设置】【快捷键】里修改 代码模板代码模板 在Eclipse中输入syso便可以快速生成输出语句，我们可以通过自定义代码模块，来自定义快速代码生成 【设置】【编辑器】【代码模板】，先创建分组【Template Group】，然后再在分组下创建模板【Live Template】 编辑模板内容并选择应用的语言 注释模板 【设置】【编辑器】【文件和代码模板】，可以选择对应的模板进行修改 类注释模板 【设置】【编辑器】【文件和代码模板】【包含】，选择File Header进行修改 修改如下 123456&#x2F;** * @Auther: http:&#x2F;&#x2F;xiaoliblog.cn * @Date: $&#123;DATE&#125; * @Description: $&#123;PACKAGE_NAME&#125; * @version: 1.0 *&#x2F; 设置后，新建一个类class，就会自动生成注释 方法注释模板 【设置】【编辑器】【代码模板】，新建一个代码模板，缩写为/**，模板文本如下 1234567&#x2F;** * 功能描述 * @param: $param$ * @return: $return$ * @auther: $user$ * @date: $date$$time$ *&#x2F; 设置好模板内容后，再选择语言 触发：/**+Tab，然后就可以自定义内容","path":"page/idea01.html","date":"03-02","excerpt":"","tags":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"http://xiaoliblog.cn/tags/IntelliJ-IDEA/"}]},{"title":"Node.js🚀操作MySQL数据库","text":"连接 MySQL 官方文档地址：https://www.npmjs.com/package/mysql 新建一个项目文件夹node_mysql，右击终端打开输入命令进行项目初始化 1$ npm init 安装 mysql 包 1$ npm install mysql 引入 mysql 包 1var mysql = require(&quot;mysql&quot;); 建立连接 123456789101112131415161718192021var mysql = require(&quot;mysql&quot;);var options = &#123; host: &quot;localhost&quot;, //127.0.0.1 //port:&quot;3306&quot;, //可选，默认3306 user: &quot;root&quot;, password: &#x27;xxx&#x27;, // 数据库连接密码 database: &quot;database_name&quot;, //连接数据库名&#125;;//创建与数据库进行连接的连接对象 以下方法接收一个对象var connection = mysql.createConnection(options);//建立连接connection.connect((err) =&gt; &#123; if (err) &#123; // 数据库连接成功 console.log(err); &#125; else &#123; // 数据库连接失败 console.log(&quot;数据库连接成功&quot;); &#125;&#125;); 正常来说，运行程序后，应该会提示数据库连接成功。 如果在运行时提示错误Client does not support authentication protocol requested by server，解决办法如下：(在终端进入 sql 之后，输入如下命令) 12345# 注意，这里的 &#x27;root&#x27; 请填你的user账号， &#x27;localhost&#x27; 请填 你的 host， &#x27;password&#x27; 请填你的密码ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;password&#x27;;# 然后执行如下命令flush privileges; 查询操作 官方文档地址：https://www.npmjs.com/package/mysql#introduction 1234567891011121314151617181920212223242526272829303132333435363738394041// 引入mysqlvar mysql = require(&#x27;mysql&#x27;);// 设置连接信息var options = &#123; host: &#x27;localhost&#x27;, //port:&quot;3306&quot;,//可选，默认3306 user: &#x27;root&#x27;, password: &#x27;xxx&#x27;, // 这里改成你自己的数据库密码 database: &#x27;database_name&#x27;&#125;//创建与数据库进行连接的连接对象var connection = mysql.createConnection(options);//建立连接connection.connect((err) =&gt; &#123; if (err) &#123; // 数据库连接成功 console.log(err) &#125; else &#123; // 数据库连接失败 console.log(&#x27;数据库连接成功&#x27;) &#125;&#125;);// 查询表var sql = &#x27;select * from user&#x27;; //user表名//发送sql语句connection.query(sql,function(err, result, fields)&#123;//回调获取sql返回的数据 if (err) &#123; // 表查询失败 console.log(err); &#125; else &#123; // 表查询成功 console.log(&#x27;user 表查询结果：&#x27; + JSON.stringify(result)); console.log(&#x27;fields:&#x27; + JSON.stringify(fields)); &#125;&#125;)//结束连接connection.end(); 打印结果如下： 12345678user 表查询结果：[&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;千古壹号&quot;,&quot;age&quot;:28&#125;,&#123;&quot;id&quot;:2,&quot;name&quot;:&quot;许嵩&quot;,&quot;age&quot;:34&#125;,&#123;&quot;id&quot;:3,&quot;name&quot;:&quot;邓紫棋&quot;,&quot;age&quot;:28&#125;]fields:[ &#123;&quot;catalog&quot;:&quot;def&quot;,&quot;db&quot;:&quot;qiangu_database&quot;,&quot;table&quot;:&quot;qiangu_student_table&quot;,&quot;orgTable&quot;:&quot;qiangu_student_table&quot;,&quot;name&quot;:&quot;id&quot;,&quot;orgName&quot;:&quot;id&quot;,&quot;charsetNr&quot;:63,&quot;length&quot;:11,&quot;type&quot;:3,&quot;flags&quot;:0,&quot;decimals&quot;:0,&quot;zeroFill&quot;:false,&quot;protocol41&quot;:true&#125;, &#123;&quot;catalog&quot;:&quot;def&quot;,&quot;db&quot;:&quot;qiangu_database&quot;,&quot;table&quot;:&quot;qiangu_student_table&quot;,&quot;orgTable&quot;:&quot;qiangu_student_table&quot;,&quot;name&quot;:&quot;name&quot;,&quot;orgName&quot;:&quot;name&quot;,&quot;charsetNr&quot;:33,&quot;length&quot;:765,&quot;type&quot;:253,&quot;flags&quot;:0,&quot;decimals&quot;:0,&quot;zeroFill&quot;:false,&quot;protocol41&quot;:true&#125;, &#123;&quot;catalog&quot;:&quot;def&quot;,&quot;db&quot;:&quot;qiangu_database&quot;,&quot;table&quot;:&quot;qiangu_student_table&quot;,&quot;orgTable&quot;:&quot;qiangu_student_table&quot;,&quot;name&quot;:&quot;age&quot;,&quot;orgName&quot;:&quot;age&quot;,&quot;charsetNr&quot;:63,&quot;length&quot;:11,&quot;type&quot;:3,&quot;flags&quot;:0,&quot;decimals&quot;:0,&quot;zeroFill&quot;:false,&quot;protocol41&quot;:true&#125;] 删除操作删除表1234567891011// 删除表var sql = &#x27;drop table user&#x27;;connection.query(sql, function(err, result)&#123; if (err) &#123; // 表删除失败 console.log(err); &#125; else &#123; // 表删除成功 console.log(&#x27;表删除成功：&#x27; + result); &#125;&#125;); 打印结果： 1234567891011表删除成功：OkPacket &#123; fieldCount: 0, affectedRows: 0, insertId: 0, serverStatus: 2, warningCount: 0, message: &#x27;&#x27;, protocol41: true, changedRows: 0&#125; 删除数据库1var sql = &#x27;drop database database_name&#x27;; 新增操作创建数据库12345678910111213141516171819202122232425262728293031323334var mysql = require(&#x27;mysql&#x27;);var options = &#123; host: &#x27;localhost&#x27;, //port:&quot;3306&quot;,//可选，默认3306 user: &#x27;root&#x27;, password: &#x27;xxxx&#x27;, // database: &#x27;database_name&#x27; // 注意，因为代码里是创建新的数据库，所以这里不需要填其他的数据库名&#125;//创建与数据库进行连接的连接对象var connection = mysql.createConnection(options);//建立连接connection.connect((err) =&gt; &#123; if (err) &#123; // 数据库连接成功 console.log(err); &#125; else &#123; // 数据库连接失败 console.log(&#x27;数据库连接成功&#x27;) &#125;&#125;);// 创建新的数据库const sql = &#x27;create database Student&#x27;;connection.query(sql, (err, result) =&gt; &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(&#x27;新建数据库成功：&#x27; + JSON.stringify(result)); &#125;&#125;); 打印结果： 12345数据库连接成功新建数据库成功：&#123; &quot;fieldCount&quot;:0,&quot;affectedRows&quot;:1,&quot;insertId&quot;:0,&quot;serverStatus&quot;:2,&quot;warningCount&quot;:0,&quot;message&quot;:&quot;&quot;,&quot;protocol41&quot;:true,&quot;changedRows&quot;:0&#125; 新建表新建表的sql语句举例： 123456CREATE TABLE `student` ( `id` int NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, `age` int DEFAULT NULL, PRIMARY KEY (`id`)); 如果是在 js 代码中执行上面这样命令的话，要记得把 sql 语句存放在字符串里的同一行。 代码举例如下： 12345678910111213141516171819202122232425262728293031323334353637var mysql = require(&#x27;mysql&#x27;);var options = &#123; host: &#x27;localhost&#x27;, //port:&quot;3306&quot;,//可选，默认3306 user: &#x27;root&#x27;, password: &#x27;smyhvae001&#x27;, database: &#x27;database_name&#x27;&#125;//创建与数据库进行连接的连接对象var connection = mysql.createConnection(options);//建立连接connection.connect((err) =&gt; &#123; if (err) &#123; // 数据库连接成功 console.log(err); &#125; else &#123; // 数据库连接失败 console.log(&#x27;数据库连接成功&#x27;) &#125;&#125;);// 新建表// 注意，在 js 代码中，sql 语句要存放在字符串里的同一行。const strSql5 = &#x27;CREATE TABLE `student` (`id` int NOT NULL AUTO_INCREMENT,`name` varchar(255) DEFAULT NULL,`age` int DEFAULT NULL,PRIMARY KEY (`id`));&#x27;;connection.query(strSql5, (err, result) =&gt; &#123; if (err) &#123; // 新建表失败 console.log(err); &#125; else &#123; // 新建表成功 console.log(&#x27;student 新建表成功：&#x27; + JSON.stringify(result)); &#125;&#125;) 打印结果： 12345数据库连接成功qianguyihao 新建表成功：&#123; &quot;fieldCount&quot;:0,&quot;affectedRows&quot;:0,&quot;insertId&quot;:0,&quot;serverStatus&quot;:2,&quot;warningCount&quot;:0,&quot;message&quot;:&quot;&quot;,&quot;protocol41&quot;:true,&quot;changedRows&quot;:0&#125; 插入操作 在指定的表中插入数据： 12345678910111213// 在指定的表中插入数据const sql = &quot;insert into student (name, age) values (&#x27;千古壹号&#x27;, &#x27;28&#x27;)&quot;;connection.query(student, (err, result) =&gt; &#123; if (err) &#123; // 插入数据失败 console.log(err); &#125; else &#123; // 在指定的表中插入数据成功 console.log(&#x27;student 在指定的表中插入数据成功：&#x27; + JSON.stringify(result)); &#125;&#125;); 打印结果： 1234qianguyihao 在指定的表中插入数据成功：&#123; &quot;fieldCount&quot;:0,&quot;affectedRows&quot;:1,&quot;insertId&quot;:1,&quot;serverStatus&quot;:2,&quot;warningCount&quot;:0,&quot;message&quot;:&quot;&quot;,&quot;protocol41&quot;:true,&quot;changedRows&quot;:0&#125; 如果插入的数据是变量（比如是用户提交上来的数据），那么，sql 语句可以这样写： 12345678910111213// 在指定的表中插入数据（数据作为变量）const sql = &quot;insert into student (name, age) values (?, ?)&quot;;connection.query(sql, [&#x27;许嵩&#x27;, &#x27;34&#x27;], (err, result) =&gt; &#123; if (err) &#123; // 插入数据失败 console.log(err); &#125; else &#123; // 在指定的表中插入数据成功 console.log(&#x27;student 在指定的表中插入数据成功：&#x27; + JSON.stringify(result)); &#125;&#125;);","path":"page/Nodejs04.html","date":"03-01","excerpt":"","tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://xiaoliblog.cn/tags/Node-js/"}]},{"title":"Node.js🚀Node模块化及CommonJS规范","text":"CommonJS规范的由来 JS的表现能力取决于宿主环境提供的API，在web1.0时代， W3C组织提供了浏览器的规范支持，在web2.0时代，随着HTML5的发展，更多的标准API出现在了浏览器中，但是，在后端JS中标准的制定纹丝不动 由Mozilla工程师Kevin Dangoor于2009年1月提出名为Server JS的规范; 2009年8月，更名为CommonJS ，以显示API的更广泛适用性 我在这里描述的不是技术问题。这是一个人们聚在一起并决定前进并开始建立更大和更冷的东西的问题 —– Kevin Dangoor CommonJS的模块规范 模块引用 使用require()方法引入一个模块API 模块定义 在模块中使用exports对象导出当前模块数据或方法; 在模块中还存在一个module对象 ，它代表模块自身， module对象有一个exports 属性，用于数据导出; 其实exports对象就是module.exports的引用; exports === module . exports 模块标识 其实就是模块的文件名，必须符合小驼峰法命名规则，使用require()引入时使用.或.. 开头的相对路径或/开头的绝对路径，引入时可以不写文件后缀名 重点注意：模块中的方法和变量的作用域仅在模块内部，每个模块具有独立的空间，互不干扰; CommonJS构建的模块机制中的引入与导出是我们完全不用考虑变量污染或者替换的问题，相比与命名空间的机制，简直就是天才和菜鸟的区别; 自定义模块导出和引入 自定义一个b.js文件模块 12var a = 4;exports.data = a; //exports对象导出数据，data为自定义的属性 自定义一个a.js文件模块，并且引入b模块 123456789//使用b.js模块,可以不带后缀名，但要使用.开头的路径var b = require(&#x27;./b&#x27;); //导入模块var x = 1;var y = 2;var z = x+y+b.data; //1+2+4//exports === module.exports; //导出模块exports.data=z; //exports对象导出数据，data为自定义的属性//不能使用exports = z; 自定义一个c.js文件，引入a模块 12var a = require(&#x27;./a&#x27;);console.log(a.data); 最后运行c.js module.exports 可以直接赋值，值会被导出exports直接赋值不能导出；必须使用exports.xxx 模块加载的顺序和规则 在CommonJS规范中，使用require() 加载(引入)模块时，模块标识必须使用相对路径或绝对路径指明模块位置，但是在node的实现中，我们可以不指明模块路径;如: require(&#39;fs&#39;)、require(&#39;moment&#39;); 如果没有指明路径，那就是加载核心模块或第三方模块，指明加载路径一般就是加载自定义模块; 不管加载什么模块，都是优先从缓存中加载: Node 加载模块时，如果这个模块已经被加载过了，则会直接缓存起来，将来再次引用时不会再次加加载这个模块( 即：如果一个模块被加载两次，则模块中的代码只会被执行一次) 而核心模块和第三方模块的的加载顺序就是: 先加载核心模块，核心模块的内容都是在安装node时已经编译好的可执行的二进制代码，加载执行的速度，仅次于缓存加载，如果核心模块中没有，则加载第三方模块 第三方模块的加载规则: 先在当前文件的模块所属目录去找node. modules目录 如果找到，则去该目录中找模块名的目录如: moment 如果找到moment目录，则找该目录中的package.json文件 如果找到package.json文件，则找该文件中的main属性 如果找到main属性，则拿到该属性对应的文件 如果找到moment目录之后 没有package.json 或者有package.json 没有 main属性 或者有main属性，但是指向的路径不存在 则node会默认去看一下moment自录中有没有index.js –&gt; index.json–&gt; index.node文件 如果找不到 index 或者找不到 moment 或者找不到 node. modules 则进入上一级目录找 node_moudles 查找(规则同上) 如果上一级还找不到，继续向上，一直到当前文件所属磁盘的根目录 如果到磁盘概目录还没有找到，直接报错","path":"page/Nodejs03.html","date":"02-28","excerpt":"","tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://xiaoliblog.cn/tags/Node-js/"}]},{"title":"Node.js🚀包管理器npm","text":"npm命令 npm是node中自带的包(模块)管理工具; 借助NPM可以帮助我们快速安装和管理依赖包，使Node与第三方模块之间形成了一个良好的生态系统 npm命令的使用 直接输入npm可以查看命令 123npm &lt;command&gt; -h #查看单个命令npm install xxx # 安装模块 npm uninstall xxx # 卸载模块 npm初始化项目 npm初始化项目，输入以下命令 1npm init //初始化项目 输入yes确认后，会生成package.json文件，记录了项目的信息 1234567891011&#123; &quot;name&quot;: &quot;node&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;这是一个项目描述&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;author&quot;: &quot;小李博客&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; 解决npm被墙问题 npm存储包文件的服务器在国外，会出现npm安装模块较慢的问题，可以通过换源来解决，详情查看淘宝 NPM 镜像 通过以下的换源命令，将淘宝镜像选项加入配置文件中 12345# 配置到淘宝服务器npm config set registry https://registry.npm.taobao.org# 查看 npm 配置信息npm config list 经过上面命令的配置，以后的npm install都会默认通过淘宝的服务器来下载 强烈建议不要用直接使用 cnpm 安装，会有各种诡异的 bug package.json与package-lock.json文件 package.json文件记录你项目中所需要的所有模块 执行npm install后，node会先从package.json文件中读取所有dependencies信息，然后根据dependencies中的信息与node_modules中的模块进行对比，没有的直接下载，已有的检查更新（最新版本的nodejs不会更新，因为有package-lock.json文件，下面再说）。另外，package.json文件只记录你通过npm install方式安装的模块信息，而这些模块所依赖的其他子模块的信息不会记录 package-lock.json文件锁定所有模块的版本号，包括主模块和所有依赖子模块 当你执行npm install的时候，node从package.json文件读取模块名称，从package-lock.json文件中获取版本号，然后进行下载或者更新 比如下载jquery后，查看package.json和package-lock.json文件 123456789101112131415// package.json文件&#123; &quot;name&quot;: &quot;node&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;这是一个项目描述&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;author&quot;: &quot;小李博客&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;jquery&quot;: &quot;^3.5.1&quot; &#125;&#125; 1234567891011121314// package-lock.json文件&#123; &quot;name&quot;: &quot;node&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;lockfileVersion&quot;: 1, &quot;requires&quot;: true, &quot;dependencies&quot;: &#123; &quot;jquery&quot;: &#123; &quot;version&quot;: &quot;3.5.1&quot;, &quot;resolved&quot;: &quot;https://registry.npm.taobao.org/jquery/download/jquery-3.5.1.tgz?cache=0&amp;other_urls=https%3A%2F%2Fregistry.npm.taobao.org%2Fjquery%2Fdownload%2Fjquery-3.5.1.tgz&quot;, &quot;integrity&quot;: &quot;sha1-17TQjhv9uGrS8aPQOeoXMEcXq7U=&quot; &#125; &#125;&#125; 通过package.json文件和npm install命令配合使用，可以进行项目的迁移 当你的项目转交到另一个项目文件时，只需要拷贝package.json和JS文件，然后在当前项目文件目录下执行npm install命令，就会根据package.json的模块信息下载原项目所需的模块，省去了拷贝各种模块的麻烦 网页调试工具postman PostMan是一款非常著名的HTTP客户端工具，可以帮助你发送一切可发送的请求信息 POSTMAN下载地址：https://app.getpostman.com/app/download/win64 发生POST请求到127.0.0.1:8080 发生文件选择form-data","path":"page/Nodejs02.html","date":"02-28","excerpt":"","tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://xiaoliblog.cn/tags/Node-js/"}]},{"title":"Node.js🚀核心模块的使用","text":"Node基础 Node是一个基于Chrome V8引擎的JavaScript运行环境 Node不是一种独立的语言、Node 不是JavaScript 框架 Node是一个除了浏览器之外的，可以让JavaScript运行的环境 Node.js是一个让JavaScript运行在服务端的开发平台，是使用事件驱动，异步非阻塞I/O ，单线程，跨平台的JS运行环境 Node官方文档：http://nodejs.cn/learn Node运行JS 官方网站下载地址：http://nodejs.cn/download/ 安装路径推荐默认C盘即可，然后无脑下一步即可 使用Node环境运行JS，有以下几种方法 直接找到安装路径双击node.exe文件即可输入JS代码 找到cmd命令窗口，直接输入node命令，按两次Ctrl+C退出 创建xxx.js文件，在里面编写JS代码，然后在文件路径下使用Node xxx.js运行 VsCode选择JS文件右击在集成终端中打开，然后运行Node xxx.js 以上打开的Node能运行JS的环境被称为REPL环境，比如F12中Console下可以运行JS代码 扩展：如何在当前目录文件夹下直接使用cmd命令（以下只适用于Win10系统） 在当前目录下Shift+右键选择打开Powershell窗口即可 FS模块读取文件内容 官方文档：http://nodejs.cn/api/fs.html#fs_file_system 异步读取文件内容用fs.readFile(&#39;文件名&#39;, &#39;utf8&#39;, callback);，相关操作可以参考官方文档API 创建文本文件test.txt，内容为hello node!，创建fs.js文件，编写以下代码 12345678var fs=require(&#x27;fs&#x27;); //引入fs模块//读取text.txt内容，调用redaFile方法，传入文件路径，编码，回调函数等参数fs.readFile(&#x27;./test.txt&#x27;,&#x27;utf-8&#x27;,function(err,data)&#123; console.log(err); console.log(&#x27;---------&#x27;) console.log(data); //data为数据，err为数据，是文件读取完后回调传入参数&#125;); 右击fs.js文件，在集成终端中打开，输入node fs.js命令 异步的理解：引入fs后并调用方法js代码运行完成后才读取文本内容，然后内容做参数data传入回调函数，并不是同步的 写入文件内容 写文件使用fs.writeFile(&#39;文件.txt&#39;, &#39;content&#39;, &#39;utf8&#39;, callback);相关操作可以参考官方文档API 1234567var fs=require(&#x27;fs&#x27;); //引入fs模块//写文件会覆盖用来的内容，可以使用追加内容fs.writeFile(&#x27;./test.txt&#x27;,&#x27;写入的内容&#x27;,&#x27;utf-8&#x27;,function(err)&#123; if(!err)&#123; console.log(&#x27;写入成功！&#x27;) &#125;&#125;); 追加内容写入 12345678910var fs=require(&#x27;fs&#x27;); //引入fs模块fs.readFile(&#x27;./test.txt&#x27;,&#x27;utf-8&#x27;,function(err,data)&#123; data += &#x27;,追加的内容&#x27;; fs.writeFile(&#x27;./test.text&#x27;,data,&#x27;utf-8&#x27;,function(err)&#123; if(!err)&#123; console.log(&quot;追加成功！&quot;); &#125; &#125;);&#125;); 通过以上fs模块的演示，需要学会查找Node文档使用其他模块 HTTP模块 Node核心模块之一，用于搭建HTTP服务器 官方文档API 客户端发送请求给服务器，服务器需要接收并处理请求将结果返回给客户端 开启服务器12345678910111213141516171819202122//1. 引入http模块var http=require(&#x27;http&#x27;); //2. 使用http模块中的createServer()创建一个服务器实例对象var server=http.createServer(); //3. 绑定端口号，启动web服务器server.listen(8080,function()&#123; //监听8080端口(0~65535) console.log(&#x27;请访问 http://localhost:8080&#x27;);&#125;);//4. 为这个服务器实例对象注册 request 请求处理函数//所有请求信息都包含在第一个参数request对象中server.on(&#x27;request&#x27;,function(request,response)&#123; //绑定请求事件处理函数 if(request.method == &#x27;GET&#x27;)&#123; console.log(&#x27;GET请求&#x27;); &#125;else if(request.method == &#x27;POST&#x27;)&#123; console.log(&#x27;POST请求&#x27;); &#125; response.write(&#x27;hello!&#x27;); //向响应的客户端写入内容(往流里面写内容，可以不断写入内容) response.end();&#125;); 设置响应信息响应中文123456789var http=require(&#x27;http&#x27;); var server=http.createServer(); server.on(&#x27;request&#x27;,function(request,response)&#123; //绑定请求事件处理函数 console.log(request.method); response.setHeader(&#x27;Content-type&#x27;,&#x27;text/plain;charset=utf-8&#x27;); response.write(&#x27;hello!&#x27;); //向响应的客户端写入内容(往流里面写内容，可以不断写入内容) response.write(&#x27;中文&#x27;); //响应中文要注意编码问题 response.end(); &#125;); 1response.end(&#x27;hello! 中文&#x27;); //可以直接写在end参数里 响应HTML页面1234567var http=require(&#x27;http&#x27;); var server=http.createServer(); server.on(&#x27;request&#x27;,function(request,response)&#123; //绑定请求事件处理函数 console.log(request.method); response.setHeader(&#x27;Content-type&#x27;,&#x27;text/html;charset=utf-8&#x27;); response.end(&#x27;hello！中文 &lt;h1&gt;HTML&lt;/h1&gt;&#x27;);&#125;); 配合FS模块读取整个HTML页面并响应返回 12345678910var fs=require(&#x27;fs&#x27;);var http=require(&#x27;http&#x27;); var server=http.createServer(); server.on(&#x27;request&#x27;,function(request,response)&#123; //绑定请求事件处理函数 console.log(request.method); response.setHeader(&#x27;Content-type&#x27;,&#x27;text/html;charset=utf-8&#x27;); fs.readFile(&#x27;./index.html&#x27;,&#x27;utf-8&#x27;,function(err,data)&#123; response.end(data); &#125;);&#125;); 响应图片信息12&lt;h2&gt;HTML&lt;/h2&gt;&lt;img src=&quot;./img/logo.png&quot;&gt; 图片和HTML请求的资源路径不一样，所以需要改变路径判断进行读取 123456789101112131415161718var fs=require(&#x27;fs&#x27;);var http=require(&#x27;http&#x27;); var server=http.createServer(); server.on(&#x27;request&#x27;, function (request, response) &#123; //绑定请求事件处理函数 console.log(request.url); var urls = request.url; //url表示请求的内容资源路径 if (urls == &#x27;/&#x27;) &#123; response.setHeader(&#x27;Content-type&#x27;, &#x27;text/html;charset=utf-8&#x27;); fs.readFile(&#x27;./index.html&#x27;, &#x27;utf-8&#x27;, function (err, data) &#123; response.end(data); &#125;); &#125;else&#123; //组成./img/logo.png路径，表示当前路径下img里的图片 fs.readFile(&#x27;.&#x27;+urls,function(err,data)&#123; response.end(data); &#125;); &#125;&#125;); 响应其他静态资源123&lt;h2&gt;HTML&lt;/h2&gt;&lt;img src=&quot;./img/logo.png&quot;&gt;&lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt; 123456789101112131415161718var fs=require(&#x27;fs&#x27;);var http=require(&#x27;http&#x27;); var server=http.createServer(); server.on(&#x27;request&#x27;, function (request, response) &#123; //绑定请求事件处理函数 console.log(request.url); var urls = request.url; //url表示请求的内容资源路径 if (urls == &#x27;/&#x27;) &#123; response.setHeader(&#x27;Content-type&#x27;, &#x27;text/html;charset=utf-8&#x27;); fs.readFile(&#x27;./index.html&#x27;, &#x27;utf-8&#x27;, function (err, data) &#123; response.end(data); &#125;); &#125;else&#123; ////读取.当前目录下的资源（包括图片和其他静态资源） fs.readFile(&#x27;.&#x27;+urls,function(err,data)&#123; response.end(data); &#125;); &#125;&#125;);","path":"page/Nodejs01.html","date":"02-27","excerpt":"","tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://xiaoliblog.cn/tags/Node-js/"}]},{"title":"Canvas画布","text":"Canvas简介 HTML5&lt;canvas&gt;标签用于绘制图像(通过脚本，通常是JavaScript ) 不过，&lt;canvas&gt;元素本身并没有绘制能力(它仅仅是图形的容器) ，必须使用脚本来完成实际的绘图任务 getContext()方法可返回一个对象，该对象提供了用于在画布上绘图的方法和属性 提供完整的getContext(&quot;2d&quot;)对象的属性和方法，可用于在画布上绘制文本、线条、矩形、圆形等等 SVG基于XML，放大不会失真，但性能差于Canvas Canvas相关属性和方法请戳👉HTML 5 Canvas 参考手册 ||学习 HTML5 Canvas 这一篇文章就够了 Canvas实例 Canvas三要素 id：作为唯一的标识 width：画布内容宽度的像素大小（与style的宽度和高度是有区别的） height：画布内容高度的像素大小 123&lt;canvas id=&quot;mycanvas&quot; width=&quot;500&quot; height=&quot;500&quot;&gt; 这里的内容，正常的画布是不显示的，你的浏览器不支持Canvas&lt;/canvas&gt; Canvas相当于定义一个画布，而JavaScript就是画笔 123456789101112131415161718192021&lt;canvas id=&quot;mycanvas&quot; width=&quot;500&quot; height=&quot;500&quot;&gt; 这里的内容，正常的画布是不显示的，你的浏览器不支持Canvas&lt;/canvas&gt;&lt;script type=&quot;text/javascript&quot;&gt; //1. 找到画布对象 var canvas = document.getElementById(&quot;mycanvas&quot;); console.log([canvas]); //2. 上下文对象（画笔） var ctx= canvas.getContext(&quot;2d&quot;); //画2d //var ctx= canvas.getContext(&quot;webgl&quot;); 画3d console.log(ctx); //通过F12可以查询相关属性和方法 //3. 绘制路径 ctx.rect(50,50,300,300); //4. 填充 ctx.fillStyle=&quot;skyblue&quot;; //设置样式 ctx.fill(); //最终渲染 //5. 描边，渲染路径 ctx.lineWidth = 20; //线段宽度 ctx.strokeStyle=&quot;red&quot;; ctx.stroke();&lt;/script&gt; Canvas基础绘制路径 方法 描述 fill() 填充当前绘图（路径） stroke() 绘制已定义的路径 beginPath() 起始一条路径，或重置当前路径 moveTo() 把路径移动到画布中的指定点，不创建线条 closePath() 创建从当前点回到起始点的路径 lineTo() 添加一个新点，然后在画布中创建从该点到最后指定点的线条 clip() 从原始画布剪切任意形状和尺寸的区域 quadraticCurveTo() 创建二次贝塞尔曲线 bezierCurveTo() 创建三次方贝塞尔曲线 arc() 创建弧/曲线（用于创建圆形或部分圆） arcTo() 创建两切线之间的弧/曲线 isPointInPath() 如果指定的点位于当前路径中，则返回 true，否则返回 false 12345678910111213141516&lt;canvas id=&quot;mycanvas&quot; width=&quot;500&quot; height=&quot;500&quot;&gt;&lt;/canvas&gt;&lt;script type=&quot;text/javascript&quot;&gt; var canvas = document.getElementById(&quot;mycanvas&quot;); var ctx= canvas.getContext(&quot;2d&quot;); ctx.beginPath(); //设置开始路径 //设置绘制的起始点 ctx.moveTo(50,50); //设置经过某个位置 ctx.lineTo(50,300); ctx.lineTo(300,100); ctx.closePath(); //设置结束路径，会关闭路径即连接起始点不会出现连笔 //绘制路径 ctx.strokeStyle=&quot;skyblue&quot;; ctx.lineWidth=10; ctx.stroke();&lt;/script&gt; 线段 属性 描述 lineCap 设置或返回线条的结束端点样式 lineJoin 设置或返回两条线相交时，所创建的拐角类型 lineWidth 设置或返回当前的线条宽度 miterLimit 设置或返回最大斜接长度 12345678910111213141516171819202122&lt;canvas id=&quot;mycanvas&quot; width=&quot;500&quot; height=&quot;500&quot;&gt;&lt;/canvas&gt;&lt;script type=&quot;text/javascript&quot;&gt; var canvas = document.getElementById(&quot;mycanvas&quot;); var ctx= canvas.getContext(&quot;2d&quot;); ctx.beginPath(); //设置开始路径 //设置绘制的起始点 ctx.moveTo(50,50); //设置经过某个位置 ctx.lineTo(50,300); ctx.lineTo(300,100); ctx.lineTo(300,250); ctx.closePath(); //设置结束路径，会关闭路径不会出现连笔 //绘制路径 ctx.lineCap=&quot;round&quot;; //设置起始路径线段设置为圆角 ctx.lineJoin=&quot;round&quot;; //设置拐角线段设置为圆角 // ctx.miterLimit = 2; //设置最大斜接长度，设置多少就会砍掉多少像素 ctx.strokeStyle=&quot;skyblue&quot;; ctx.lineWidth=20; ctx.stroke();&lt;/script&gt; 圆 绘制圆形使用arc(x,y,r,start,stop)方法 1234567891011&lt;canvas id=&quot;mycanvas&quot; width=&quot;600&quot; height=&quot;600&quot;&gt;&lt;/canvas&gt;&lt;script type=&quot;text/javascript&quot;&gt; var canvas = document.getElementById(&quot;mycanvas&quot;); var ctx = canvas.getContext(&quot;2d&quot;); // 默认false顺时针画圆可不写，true为逆时针 ctx.arc(300, 300, 100, 0, 2*Math.PI,true); //(cx,cy,r,开始角度，结束角度，顺时针或者逆时针) ctx.fillStyle=&quot;skyblue&quot;; ctx.fill(); ctx.stroke();&lt;/script&gt; 文本 属性 描述 font 设置或返回文本内容的当前字体属性 textAlign 设置或返回文本内容的当前对齐方式 textBaseline 设置或返回在绘制文本时使用的当前文本基线 方法 描述 fillText() 在画布上绘制“被填充的”文本 strokeText() 在画布上绘制文本（无填充） measureText() 返回包含指定文本宽度的对象 1234567891011121314151617&lt;canvas id=&quot;mycanvas&quot; width=&quot;600&quot; height=&quot;600&quot;&gt;&lt;/canvas&gt;&lt;script type=&quot;text/javascript&quot;&gt; var canvas = document.getElementById(&quot;mycanvas&quot;); var ctx = canvas.getContext(&quot;2d&quot;); console.log(ctx); //设置字号和字体 ctx.font = &quot;50px 微软雅黑&quot;; // 设置样式 （这些属性都可以输出ctx在F12中查看） ctx.shadowBlur = 20; //阴影的模糊度 ctx.shadowColor = &quot;rgba(0,0,0,1)&quot;; //阴影的颜色 ctx.shadowOffsetX = 10; //阴影水平偏移量 ctx.shadowOffsetY = 10; //阴影垂直偏移量 // 设置文字填充 fillText(text,x,y); ctx.fillText(&quot;Hello World&quot;, 100, 100); // 设置描边无填充内容 ctx.strokeText(&quot;描边内容&quot;, 100, 200);&lt;/script&gt; 增加定时器实现弹幕效果 12345678910111213var x = 600;setInterval(function () &#123; //清空画布 ctx.clearRect(0, 0, 600, 600); x -= 10; if(x&lt;-100)&#123; x=600; &#125; // 设置文字填充 fillText(text,x,y); ctx.fillText(&quot;Hello World&quot;, x, 100); // 设置描边无填充内容 ctx.strokeText(&quot;描边内容&quot;, x, 200); &#125;, 30); Canvas常见操作图像绘制 在画布上定位图像 context.drawImage(图片对象,x位置,y位置); 在画布上定位图像，并规定图像的宽度和高度 context.drawImage(图片对象,x位置,y位置,width,height); 剪切图像，并在画布上定位被剪切的部分： context.drawImage(图片对象,图像裁剪的位置x,图像裁剪的位置y,裁剪的宽度,裁剪的高度,x,y,width,height); 12345678910111213&lt;canvas id=&quot;mycanvas&quot; width=&quot;600&quot; height=&quot;600&quot;&gt;&lt;/canvas&gt;&lt;script type=&quot;text/javascript&quot;&gt; var canvas = document.getElementById(&quot;mycanvas&quot;); var ctx = canvas.getContext(&quot;2d&quot;); //绘制图像 var img = new Image(); img.src = &quot;logo.png&quot;; //图片载入数据后再绘制 img.onload = function () &#123; ctx.drawImage(img,50, 50,200,200); ctx.fillText(&quot;水印&quot;,40,40); //添加水印&#125;;&lt;/script&gt; 视频处理 通过Canvas画视频可以防止视频被盗 123456789101112131415161718192021222324 &lt;canvas id=&quot;mycanvas&quot; width=&quot;800&quot; height=&quot;600&quot;&gt;&lt;/canvas&gt;&lt;video width=&quot;800&quot; height=&quot;600&quot; src=&quot;movie.mp4&quot; controls=&quot;controls&quot;&lt;/video&gt;&lt;script type=&quot;text/javascript&quot;&gt; var video = document.querySelector(&quot;video&quot;); var canvas = document.getElementById(&quot;mycanvas&quot;); var ctx = canvas.getContext(&quot;2d&quot;); var interId; // 视频开始播放就开始一帧一帧绘制 video.onplay=function()&#123; interId= setInterval(function()&#123; //实现底色为黑色 ctx.clearRect(0,0,800,600); ctx.fillRect(0,0,800,600); ctx.drawImage(video,0,70,800,440); //加水印 ctx.font=&quot;20px 微软雅黑&quot;; ctx.strokeStyle=&quot;#999&quot;; ctx.strokeText(&quot;我是水印&quot;,50,50); &#125;,16); //16为最适应刷新率 &#125; video.onpause=function()&#123; clearInterval(interId); &#125;;&lt;/script&gt; 绘制时钟 方法 描述 scale() 缩放当前绘图至更大或更小 rotate() 旋转当前绘图 translate() 重新映射画布上的 (0,0) 位置 transform() 替换绘图的当前转换矩阵 setTransform() 将当前转换重置为单位矩阵。然后运行 transform() 123456789101112131415&lt;canvas id=&quot;mycanvas&quot; width=&quot;800&quot; height=&quot;600&quot;&gt;&lt;/canvas&gt;&lt;script type=&quot;text/javascript&quot;&gt; var canvas = document.getElementById(&quot;mycanvas&quot;); var ctx = canvas.getContext(&quot;2d&quot;); ctx.translate(300,0); //tanslate会改变整个画布坐标尺 ctx.rotate(Math.PI/4); //整个画布坐标旋转 ctx.scale(2,2); //x,y放大画布坐标尺 ctx.fillStyle=&quot;skyblue&quot;; ctx.fillRect(100,100,300,100); //直接填充一个矩形 ctx.fillStyle=&quot;pink&quot;; ctx.fillRect(0,0,100,100);&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;mycanvas&quot; width=&quot;800&quot; height=&quot;600&quot;&gt;&lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot;&gt; var canvas = document.getElementById(&quot;mycanvas&quot;); var ctx = canvas.getContext(&quot;2d&quot;); function renderClock() &#123; ctx.clearRect(0,0,800,600); ctx.save(); //保留环境的状态（画笔的状态） //将坐标移动到画布的中央 ctx.translate(400, 300); ctx.rotate(-2 * Math.PI / 4); ctx.save();//保留环境的状态（画笔的状态） //绘制表盘 ctx.beginPath(); ctx.arc(0, 0, 200, 0, 2 * Math.PI); ctx.strokeStyle = &quot;darkgray&quot;; ctx.lineWidth = 10; ctx.stroke(); ctx.closePath(); //绘制秒钟刻度 for (var j = 0; j &lt; 60; j++) &#123; ctx.rotate(2 * Math.PI / 60); //旋转会改变坐标尺 ctx.beginPath(); ctx.moveTo(180, 0); ctx.lineTo(190, 0); ctx.lineWidth = 2; ctx.strokeStyle = &quot;orangered&quot;; ctx.stroke(); ctx.closePath(); &#125; ctx.restore(); ctx.save(); //绘制时钟刻度 for (var i = 0; i &lt; 12; i++) &#123; ctx.rotate(2 * Math.PI / 12); //旋转会改变坐标尺 ctx.beginPath(); ctx.moveTo(180, 0); ctx.lineTo(200, 0); ctx.lineWidth = 10; ctx.strokeStyle = &quot;darkgray&quot;; ctx.stroke(); ctx.closePath(); &#125; ctx.restore(); ctx.save(); // 获取时间 var time = new Date(); var hour = time.getHours(); var min = time.getMinutes(); var sec = time.getSeconds(); //如果时间是大于12的话，就减去12 hour = hour &gt; 12 ? hour - 12 : hour; //绘制秒针 ctx.beginPath(); //根据秒针的时间进行旋转 ctx.rotate(2 * Math.PI / 60 * sec); ctx.moveTo(-30, 0); ctx.lineTo(170, 0); ctx.lineWidth = 2; ctx.strokeStyle = &quot;red&quot;; ctx.stroke(); ctx.closePath(); ctx.restore(); ctx.save(); //绘制分针 ctx.beginPath(); //根据分针的时间进行旋转 ctx.rotate(2 * Math.PI / 60 * min + 2 * Math.PI / 3600 * sec); ctx.moveTo(-20, 0); ctx.lineTo(150, 0); ctx.lineWidth = 3; ctx.strokeStyle = &quot;skyblue&quot;; ctx.stroke(); ctx.closePath(); ctx.restore(); ctx.save(); //绘制时针 ctx.beginPath(); //根据时针的时间进行旋转 ctx.rotate(2 * Math.PI / 12 * hour + 2 * Math.PI / 60 / 12 * min + 2 * Math.PI / 12 / 60 / 60 * sec); ctx.moveTo(-10, 0); ctx.lineTo(140, 0); ctx.lineWidth = 6; ctx.strokeStyle = &quot;darkgray&quot;; ctx.stroke(); ctx.closePath(); console.log(time); //绘制中心小圆点 ctx.beginPath(); ctx.arc(0, 0, 10, 0, 2 * Math.PI); ctx.fillStyle = &quot;skyblue&quot;; ctx.fill(); ctx.closePath(); ctx.restore(); ctx.restore(); &#125;; setInterval(function()&#123; renderClock(); &#125;,1000); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 刮刮卡 globalCompositeOperation：设置或返回新图像如何绘制到已有的图像上 globalCompositeOperation属性设置或返回如何将一个源(新的)图像绘制到目标(已有的)的图像上 源图像=您打算放置到画布上的绘图 目标图像=您已经放置在画布上的绘图 属性值查看HTML 5 canvas globalCompositeOperation 属性 默认值: source-over JavaScript语法: context.globalCompositeOperation=”source-in”; 123456789101112131415&lt;canvas id=&quot;mycanvas&quot; width=&quot;800&quot; height=&quot;600&quot;&gt;&lt;/canvas&gt;&lt;script type=&quot;text/javascript&quot;&gt; var canvas = document.getElementById(&quot;mycanvas&quot;); var ctx = canvas.getContext(&quot;2d&quot;); //第一个红色矩形为目标图像 ctx.fillStyle = &quot;hotpink&quot;; ctx.fillRect(100, 100, 200, 200); ctx.globalCompositeOperation=&quot;source-atop&quot;;//源图像位于目标图像之外的部分是不可见的 //默认值为source-over，源图像在目标图像之上 //第二个蓝色为打算放置的图像即源图像 ctx.fillStyle = &quot;deepskyblue&quot;; ctx.fillRect(200, 200, 200, 200);&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #ggk &#123; width: 400px; height: 100px; position: relative; &#125; #ggk .jp &#123; width: 400px; height: 100px; position: absolute; left: 0; right: 0; text-align: center; color: cornflowerblue; font-size: 50px; line-height: 100px; &#125; #ggk #mycanvas &#123; width: 400px; height: 100px; position: absolute; left: 0; right: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;ggk&quot;&gt; &lt;div class=&quot;jp&quot;&gt;谢谢惠顾&lt;/div&gt; &lt;canvas id=&quot;mycanvas&quot; width=&quot;400&quot; height=&quot;100&quot;&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var canvas = document.getElementById(&quot;mycanvas&quot;); var ctx = canvas.getContext(&quot;2d&quot;); var ggkDom = document.getElementById(&quot;ggk&quot;); var jpDom=document.querySelector(&quot;.jp&quot;); //画一层灰色覆盖 ctx.fillStyle = &quot;gray&quot;; ctx.fillRect(0, 0, 400, 100); ctx.fillStyle = &quot;#fff&quot;; ctx.font = &quot;20px 微软雅黑&quot;; ctx.fillText(&quot;刮刮卡&quot;, 160, 50); // 鼠标按下事件，设置允许绘制isDraw=true var isDraw = false; canvas.onmousedown = function () &#123; isDraw = true; console.log(isDraw); &#125;; //移动的适合绘制圆形，将源图像内的目标内容清除掉 canvas.onmousemove = function (e) &#123; if (isDraw) &#123; var x = e.pageX - ggkDom.offsetLeft; var y = e.pageY - ggkDom.offsetTop; ctx.globalCompositeOperation = &quot;destination-out&quot;; ctx.arc(x, y, 10, 0, 2 * Math.PI); //以鼠标位置为中心画圆 ctx.fill(); &#125; &#125;; // 鼠标抬起，不需要绘制 canvas.onmouseup = function () &#123; isDraw = false; console.log(isDraw); &#125;; var arr = [ &#123; content: &quot;一等奖:IPhoneXs&quot;, p: 0.1 &#125;, &#123; content: &quot;二等奖:IPad2018&quot;, p: 0.2 &#125;, &#123; content: &quot;三等奖:HUAWEI&quot;, p: 0.3 &#125;, ]; var randomNum = Math.random(); console.log(randomNum); if (randomNum &lt; arr[0].p) &#123; jpDom.innerHTML = arr[0].content; &#125; else if (randomNum &lt; arr[1].p + arr[0].p) &#123; jpDom.innerHTML = arr[1].content; &#125; else if (randomNum &lt; arr[2].p + arr[1].p + arr[0].p) &#123; jpDom.innerHTML = arr[2].content; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 画板 画笔功能： 能够拖动鼠标在页面内绘图，能够设置画笔粗细和颜色 能够在任意位置绘制图形：拖动鼠标即可随意在任意位置绘制图形，并且随意定制大小 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; body &#123; display: flex; width: 100vw; height: 100vh; flex-direction: column; justify-content: flex-start; &#125; .caidan &#123; height: 100px; width: 100vw; display: flex; border-bottom: 3px solid #ccc; justify-content: space-around; align-items: center; &#125; #mycanvas &#123; flex: 1; width: 100vw; &#125; .btn &#123; width: 200px; height: 50px; border: 1px solid #ccc; border-radius: 20px; text-align: center; line-height: 50px; color: green; &#125; .btn.active &#123; box-shadow: 0 0 20px skyblue; /*发光*/ background-color: darkturquoise; border-color: greenyellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;caidan&quot;&gt; &lt;div class=&quot;btn&quot; id=&quot;huabi&quot;&gt;画笔&lt;/div&gt; &lt;div class=&quot;btn&quot; id=&quot;rect&quot;&gt;矩形&lt;/div&gt; &lt;div class=&quot;btn&quot;&gt;圆形&lt;/div&gt; &lt;div class=&quot;btn&quot;&gt;线段粗细&lt;/div&gt; &lt;div class=&quot;btn&quot;&gt;画笔颜色&lt;/div&gt; &lt;/div&gt; &lt;canvas id=&quot;mycanvas&quot;&gt;&lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot;&gt; //获取所有按钮 var allBtn = document.querySelectorAll(&quot;.btn&quot;); //获取Canvas var canvas = document.getElementById(&quot;mycanvas&quot;); var ctx = canvas.getContext(&quot;2d&quot;); //设置Canvas宽度和高度 canvas.setAttribute(&quot;width&quot;, canvas.offsetWidth); canvas.setAttribute(&quot;height&quot;, canvas.offsetHeight); var huaban = &#123; //画笔对象 type: &quot;none&quot;, isDraw: false, beginX: 0, //开始位置 beginY: 0, imageData:null, //绘制画笔 huabiFn: function (e) &#123; var x = e.pageX - canvas.offsetLeft; var y = e.pageY - canvas.offsetTop; ctx.beginPath(); ctx.arc(x, y, 3, 0, 2 * Math.PI); ctx.fill(); ctx.closePath(); &#125;, //绘制矩阵 rectFn: function (e) &#123; var x = e.pageX - canvas.offsetLeft; var y = e.pageY - canvas.offsetTop; ctx.clearRect(0, 0, canvas.offsetWidth, canvas.offsetHeight); if(huaban.imageData!=null)&#123; ctx.putImageData(huaban.imageData,0,0,0,0,canvas.offsetWidth, canvas.offsetHeight); &#125; ctx.beginPath(); ctx.rect(huaban.beginX, huaban.beginY, x - huaban.beginX, y - huaban.beginY); //ctx.fill(); ctx.stroke(); ctx.closePath(); &#125; &#125;; //设置画笔功能 var huabibtn = document.getElementById(&quot;huabi&quot;); huabibtn.onclick = function () &#123; //其他按钮去掉样式 allBtn.forEach(function (item, i) &#123; item.classList.remove(&quot;active&quot;); &#125;); huabibtn.classList.add(&quot;active&quot;); huaban.type = &quot;huabi&quot;; &#125;; //设置画矩形功能 var rectBtn = document.getElementById(&quot;rect&quot;); rectBtn.onclick = function () &#123; //其他按钮去掉样式 allBtn.forEach(function (item, i) &#123; item.classList.remove(&quot;active&quot;); &#125;); rectBtn.classList.add(&quot;active&quot;); huaban.type = &quot;rect&quot;; &#125;; //监听鼠标按下事件，允许画 canvas.onmousedown = function (e) &#123; huaban.isDraw = true; if (huaban.type == &quot;rect&quot;) &#123; var x = e.pageX - canvas.offsetLeft; var y = e.pageY - canvas.offsetTop; huaban.beginX = x; //更改起始点 huaban.beginY = y; &#125; &#125;; //监听鼠标抬起事件，不允许画 canvas.onmouseup = function () &#123; huaban.imageData= ctx.getImageData(0,0,canvas.offsetWidth, canvas.offsetHeight); huaban.isDraw = false; &#125;; // 鼠标移动事件监听，开始绘制 canvas.onmousemove = function (e) &#123; if (huaban.isDraw) &#123; //允许为true 可以画 var str = huaban.type + &#x27;Fn&#x27;; huaban[str](e); &#125; &#125;; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 验证码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;mycanvas&quot; width=&quot;120&quot; height=&quot;40&quot;&gt;&lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot;&gt; //封装成一个函数 function YZM(selector, w, h) &#123; //随机数生成函数 function rondomNum(min, max) &#123; return parseInt(Math.random() * (max - min) + min); &#125; //随机生成颜色的函数 function rondomColor(min, max) &#123; var r = rondomNum(min, max); var g = rondomNum(min, max); var b = rondomNum(min, max); return `rgb($&#123;r&#125;,$&#123;g&#125;,$&#123;b&#125;)`; &#125; //获取Canvas var w = w; var h = h; var canvas = document.getElementById(&quot;mycanvas&quot;); //画布 var ctx = canvas.getContext(&quot;2d&quot;); //画笔 //在canvas上绘制背景颜色 ctx.fillStyle = rondomColor(180, 230); ctx.fillRect(0, 0, w, h); // 生成随机字符串 var pool = &#x27;ABCDEFGHIGKLIMNOPQRSTUVWXYZabcdefghijkopqrstuvwxvz1234567890&#x27;; var result = &quot;&quot;; for (var i = 0; i &lt; 4; i++) &#123; //取出随机字符串 var str = pool[rondomNum(0, pool.length)]; //随机字体大小 var font_size = rondomNum(18, 40); //随机字体旋转角度 var font_angle = rondomNum(-30, 30); ctx.font = font_size + &#x27;px Simhei&#x27;; ctx.textBaseline = &#x27;top&#x27;; //设置基线 //设置字体随机填充颜色 ctx.fillStyle = rondomColor(80, 150); ctx.save(); //保存当前设置 ctx.translate(30 * i + 15, 15); ctx.rotate(font_angle * Math.PI / 180); ctx.fillText(str, -10, -10); ctx.restore(); //恢复 result+=str; //连接验证码 &#125; // 随机生成干扰线 for (var i = 0; i &lt; 5; i++) &#123; ctx.beginPath(); ctx.moveTo(rondomNum(0, w), rondomNum(0, h)); ctx.lineTo(rondomNum(0, w), rondomNum(0, h)); ctx.strokeStyle = rondomColor(180, 230); ctx.closePath(); ctx.stroke(); &#125; //随机产生40个小干扰圆点 for (var i = 0; i &lt; 40; i++) &#123; ctx.beginPath(); ctx.arc(rondomNum(0, w), rondomNum(0, h), 1, 0, 2 * Math.PI); ctx.closePath(); ctx.fillStyle = rondomColor(150, 200); ctx.fill(); ctx.stroke(); &#125; return result; //返回验证码 &#125; //调用函数 let yzm = YZM(&#x27;#mycanvas&#x27;, 120, 40); //得到验证码 console.log(yzm); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","path":"page/Canvas.html","date":"02-24","excerpt":"","tags":[{"name":"Canvas","slug":"Canvas","permalink":"http://xiaoliblog.cn/tags/Canvas/"}]},{"title":"SVG矢量图","text":"SVG素材 flation：https://www.flaticon.com/ The largest database of free icons available in PNG, SVG, EPS, PSD and BASE 64 formats undraw：http://undraw.co 一个提供完全免费的 SVG/PNG 图片素材的站点，网站由 KaterinaLimpitsouni 创建创办，该网站所有的素材图片遵循 MIT 协议许可（开源协议），网站不断更新 SVG 图像素材，并完全免费使用，并且支持一键换色 iconninja：https://www.iconninja.com/ 素材格式是 PNG、SVG。图标忍者( Icon Ninja )是一个支持近 100 万免费图标素材的搜索引擎，支持关键词搜索，所有的素材均提供详细的如格式、宽度、高度、文件大小等信息，适合前端工程师或 PPT 设计师使用。 Shareicon：https://www.shareicon.net/ 一个免费提供超过 25 万 icon 矢量图片素材的站点，120 多种分类，所有的素材都提供 PNG、SVG 格式下载。 iconfont：https://www.iconfont.cn/ 国内功能很强大且图标内容很丰富的矢量图标库,提供矢量图标下载、在线存储、格式转换等功能。阿里巴巴体验团队倾力打造,设计和前端开发的便捷工具 worldvectorlogo：https://worldvectorlogo.com/ 世界品牌标志(World Vector Logo)是一个提供完全免费和无任何限制的所有品牌logo素材下载站点,支持通过品牌名称来搜索相关的logo素材 SVG简介 SVG是一种基于XML语法的图像格式。全称是可缩放矢量图( Scalable Vector Graphics) 其他图像格式都是基于像素处理的，SVG则是属于对图像的形状描述，所以它本质上是文本文件，体积较小，且不管放大多少倍都不会失 SVG文多可以直接插入网页，成为DOM的一部分，然后用JavaScript和CSS进行操作 SVG实例123456&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt;&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;circle cx=&quot;100&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke=&quot;black&quot; stroke-width=&quot;2&quot; fill=&quot;red&quot; /&gt;&lt;/svg&gt; 第一行包含了 XML 声明。请注意 standalone 属性！该属性规定此 SVG 文件是否是”独立的”，或含有对外部文件的引用。standalone=&quot;no&quot; 意味着 SVG 文档会引用一个外部文件；在这里，是 DTD 文件。 第二行引用了这个外部的 SVG DTD。该 DTD 位于 “http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot; 该 DTD 位于 W3C，含有所有允许的 SVG 元素。 SVG 代码以 &lt;svg&gt; 元素开始，包括开启标签&lt;svg&gt;和关闭标签 &lt;/svg&gt; 。这是根元素。width 和 height 属性可设置此 SVG 文档的宽度和高度。version 属性可定义所使用的 SVG 版本，xmlns 属性可定义 SVG 命名空间。 SVG 的 &lt;circle&gt; 标签用来创建一个圆。cx 和 cy 属性定义圆中心的 x 和 y 坐标。如果忽略这两个属性，那么圆点会被设置为 (0, 0)。r 属性定义圆的半径。 stroke 和 stroke-width 属性控制如何显示形状的轮廓。我们把圆的轮廓设置为 2px 宽，黑边框。 fill 属性设置形状内的颜色。我们把填充颜色设置为红色。 关闭标签的作用是关闭 SVG 元素和文档本身。SVG文件后缀为.svg 注释：所有的开启标签必须有关闭标签！ HTML引入SVG SVG 文件可通过以下标签嵌入 HTML 文档：&lt;img&gt;、&lt;embed&gt;、&lt;object&gt; 或者 &lt;iframe&gt; 1234&lt;img src=&quot;circle.svg&quot;&gt;&lt;embed src=&quot;circle1.svg&quot; type=&quot;image/svg+xml&quot; /&gt;&lt;object data=&quot;circle1.svg&quot; type=&quot;image/svg+xml&quot;&gt;&lt;/object&gt;&lt;iframe src=&quot;circle1.svg&quot;&gt;&lt;/iframe&gt; SVG的代码可以直接嵌入到HTML页面中 123&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;circle cx=&quot;100&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke=&quot;black&quot; stroke-width=&quot;2&quot; fill=&quot;red&quot; /&gt;&lt;/svg&gt; 可以用 &lt;a&gt; 标签链接到一个 SVG 文件 1&lt;a href=&quot;circle1.svg&quot;&gt;查看 SVG 文件&lt;/a&gt; CSS也可以使用SVG文件 123.logo&#123; background: url(icon.svg);&#125; 实例：在HTML中引入博学.svg 123456&lt;body&gt; &lt;img src=&quot;博学.svg&quot;&gt; &lt;embed src=&quot;博学.svg&quot; type=&quot;image/svg+xml&quot; /&gt; &lt;object data=&quot;博学.svg&quot; type=&quot;image/svg+xml&quot;&gt;&lt;/object&gt; &lt;iframe src=&quot;博学.svg&quot; scrolling=&quot;no&quot; width=&quot;271&quot; height=&quot;200&quot; style=&quot;border:none;&quot;&gt;&lt;/iframe&gt;&lt;/body&gt; SVG语法 SVG代码都放在顶层标签&lt;svg&gt;中 123&lt;svg width=&quot;100%&quot; height=&quot;100%&quot;&gt; &lt;circle id=&quot;mycircle&quot; cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;50&quot;/&gt;&lt;/svg&gt; &lt;svg&gt;的width属性和height属性，制定了SVG图像在HTML元素中所占据的宽度和高度。除了相对单位，也可以采用绝对单位(单位: 像素)。如果不指定这两个属性，SVG图像默认大小是300像素(宽) *150像素(高) SVG 的 &lt;circle&gt; 标签用来创建一个圆。cx 和 cy 属性定义圆中心的 x 和 y 坐标，r为半径 如果只想展示SVG图像的一部分，就要指定viewBox属性。 123&lt;svg width=&quot;100&quot; height=&quot;100&quot; viewBox=&quot;50 50 50 50&quot;&gt; &lt;circle id=&quot;mycircle&quot; cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;50&quot;/&gt;&lt;/svg&gt; viewBox属性的值有四个数字，分别是左上角的横坐标和纵坐标、视口的高度和宽度。上面代码中 , SVG图像是100像素宽*100像素高， viewBox属性指定视口从(50, 50 )这个点开始。所以,实际看到的是右下角的四分之一圆。 注意，视口必须适配所在的空间。上面代码中，视口的大小是50*50 ，由于SVG图像的大小是100*100 ,所以视口会放大去适配SVG图像的大小，即放大了四倍。 如果不指定width属性和height属性，只指定viewBox属性，则相当于只给到定SVG图像的长宽比。这时, SVG图像的默认大小将等于所在的HTML元素的大小。 SVG基础绘制圆 &lt;circle&gt;标签代表圆形 12345&lt;svg width=&quot;300&quot; height=&quot;180&quot;&gt; &lt;circle cx=&quot;30&quot; cy=&quot;50&quot; r=&quot;25&quot;/&gt; &lt;circ1e cx=&quot;90&quot; cy=&quot;50&quot; r=&quot;25&quot; class=&quot;red&quot;/&gt; &lt;circle cx=&quot;150&quot; cy=&quot;50&quot; r=&quot;25&quot; class=&quot;fancy&quot; /&gt;&lt;/svg&gt; 上面的代码定义了三个圆。&lt;circle&gt; 标签的cx、cy和r属性分别为横坐标、纵坐标和半径，单位为像素。坐标都是相对于&lt;svg&gt;画布的左上角原点。 class属性用来指定对应的CSS类 12345678.red &#123; fi11: red;&#125;.fancy &#123; fi11: none; stroke: black; stroke-width: 3pt;&#125; SVG的CSS属性与网页元素有所不同 fill：填充色. stroke ：边框颜色 stroke-width ：边框宽度 矩形 &lt;rect&gt; 标签可用来创建矩形，以及矩形的变种 123&lt;svg width=&quot;300&quot; hei ght=&quot;180&quot;&gt; &lt;rect x=&quot;10&quot; y=&quot;10&quot; height=&quot;100&quot; width=&quot;200&quot; style=&quot;stroke: #70d5dd; fill: #dd524b&quot;/&gt;&lt;/svg&gt; &lt;rect&gt;的x属性和y属性，指定了矩形左上角端点的横坐标和纵坐标; width属性和height属性指定了矩形的宽度和高度(单位像索) 椭圆 &lt;ellipse&gt; 标签是用来创建一个椭圆 椭圆与圆很相似。不同之处在于椭圆有不同的x和y半径，而圆的x和y半径是相同的 123&lt;svg width=&quot;300&quot; height=&quot;180&quot;&gt; &lt;ellipse cx=&quot;60&quot; cy=&quot;60&quot; ry=&quot;40&quot; rx=&quot;20&quot; stroke=&quot;black&quot; stroke-width=&quot;2&quot; fill=&quot;silver&quot;/&gt;&lt;/svg&gt; &lt;ellipse&gt;的cx属性和cy属性，指定了椭圆中心的横坐标和纵坐标(单位像素) ; rx属性和ry属性，指定了椭圆横向轴（水平半径）和纵向轴的半径（垂直半径），单位像素 多边形 &lt;polygon&gt; 标签用来创建含有不少于三个边的图形 多边形是由直线组成，其形状是”封闭”的（所有的线条 连接起来） 1234&lt;svg height=&quot;210&quot; width=&quot;500&quot;&gt; &lt;polygon points=&quot;100,10 40,198 190,78 10,78 160,198&quot; style=&quot;fill:lime;stroke:purple;stroke-width:5;fill-rule:nonzero;&quot; /&gt;&lt;/svg&gt; &lt;polygon&gt; 的points属性指定了每个端点的坐标，横坐标与纵坐标之间与逗号分隔，点与点之间用空格分隔 SVG的图形填充规则通过fill-rule属性来指定，有三个属性值nonzero(默认) 、 evenodd 、inherit nonzero 字面意思是“非零”。按该规则，要判断一个点是否在图形内，从该点作任意方向的一条射线，然后检测射线与图形路径的交点情况。从0开始计数，路径从左向右穿过射线则计数加1，从右向左穿过射线则计数减1。得出计数结果后，如果结果是0，则认为点在图形外部，否则认为在内部。下图演示了nonzero规则: evenodd 字面意思是“奇偶”。按该规则，要判断一个点是否在图形内，从该点作任意方向的一条射线，然后检测射线与图形路径的交点的数量。如果结果是奇数则认为点在内部，是偶数则认为点在外部。下图演示了evenodd 规则: 直线 &lt;line&gt;标签用来绘制直线，两点确定一条直线，所以先要确定两个点的位置 123&lt;svg width=&quot;300&quot; height=&quot;180&quot;&gt; &lt;line x1=&quot;0&quot; y1=&quot;0&quot; x2=&quot;200&quot; y2=&quot;200&quot; style=&quot;stroke:rgb(255,0,0);stroke-width:2&quot;/&gt;&lt;/svg&gt; &lt;line&gt; 标签的x1属性和y1属性，表示线段起点的横坐标和纵坐标; x2属性和y2属性，表示线段终点的横坐标和纵坐标; style属性表示线段的样式。 折线 &lt;polyline&gt; 标签用来绘制折线 123&lt;svg width=&quot;300&quot; height=&quot;180&quot;&gt; &lt;polyline points=&quot;3,3 30,28 3,53&quot; style=&quot;fill:none;stroke:black;stroke-width:3&quot; /&gt;&lt;/svg&gt; &lt;polyline&gt;的points属性指定了每个端点的坐标，横坐标与纵坐标之间与逗号分隔，点与点之间用空格分隔。 路径 &lt;path&gt; 元素用于定义一个路径 123456789101112&lt;svg width=&quot;600&quot; height=&quot;600&quot;&gt; &lt;path d=&quot; M 18,3 L 46,3 L 45,40 L 61,40 L 32,68 L 3,40 L 18,40 Z &quot;&gt;&lt;/path&gt;&lt;/svg&gt; &lt;path&gt;的d属性表示绘制顺序，它的值是一个长字符串 ，每个字母表示一个绘制动作 ，后面跟着坐标 M：移动到(moveto)，相当于起始点 L：画直线到( lineto)，经过的点 Z：闭合路径，是否闭合 文本 &lt;text&gt; 标签用于绘制文本 123&lt;svg width=&quot;300&quot; height=&quot;180&quot;&gt; &lt;text x=&quot;50&quot; y=&quot;25&quot;&gt;Hello World&lt;/text&gt;&lt;/svg&gt; &lt;text&gt;的x属性和y属性，表示文本区块基线( baseline )起点的横坐标和纵坐标。文字的样式可以用class或style属性指定。 SVG高级绘制复制形状 &lt;use&gt;标签用于复制一个形状 12345&lt;svg width=600 height=600&gt; &lt;circle id=&quot;myCircle&quot; cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;40&quot;/&gt; &lt;use href=&quot;#myCircle&quot; x=&quot;100&quot; y=&quot;0&quot; fill=&quot;blue&quot; /&gt; &lt;use href=&quot;#myCircle&quot; x=&quot;200&quot; y=&quot;0&quot; fill=&quot;white&quot; stroke=&quot;blue&quot; stroke-width=&quot;5&quot; /&gt; &lt;/svg&gt; &lt;use&gt;的href属性指定所要复制的节点，x属性和y属性是左上角的坐标。另外，还可以指定width和height坐标 组合 &lt;g&gt; 标签用于将多个形状组成一个组( group) , 方便复用。 12345678&lt;svg width=&quot;1500&quot; height=&quot;1000&quot;&gt; &lt;g id=&quot;miqi&quot;&gt; &lt;circle cx=&quot;100&quot; cy=&quot;100&quot; r=&quot;50&quot;&gt;&lt;/circle&gt; &lt;circle cx=&quot;500&quot; cy=&quot;100&quot; r=&quot;50&quot;&gt;&lt;/circle&gt; &lt;circle cx=&quot;300&quot; cy=&quot;300&quot; r=&quot;200&quot;&gt;&lt;/circle&gt; &lt;/g&gt; &lt;use href=&quot;#miqi&quot; x=&quot;600&quot; y=&quot;0&quot; fill=&quot;skyblue&quot;&gt;&lt;/use&gt;&lt;/svg&gt; 自定义形状 &lt;defs&gt; 标签用于自定义形状，它内部的代码不会显示，仅供引用。 相当于一个函数封装，只会在调用时出现 12345678910&lt;svg width=&quot;1500&quot; height=&quot;1000&quot;&gt; &lt;defs&gt; &lt;g id=&quot;miqi&quot;&gt; &lt;circle cx=&quot;100&quot; cy=&quot;100&quot; r=&quot;50&quot;&gt;&lt;/circle&gt; &lt;circle cx=&quot;500&quot; cy=&quot;100&quot; r=&quot;50&quot;&gt;&lt;/circle&gt; &lt;circle cx=&quot;300&quot; cy=&quot;300&quot; r=&quot;200&quot;&gt;&lt;/circle&gt; &lt;/g&gt; &lt;/defs&gt; &lt;use href=&quot;#miqi&quot; x=&quot;600&quot; y=&quot;0&quot; fill=&quot;skyblue&quot;&gt;&lt;/use&gt;&lt;/svg&gt; 平铺 &lt;pattern&gt; 标签用于自定义一个形状，该形状可以被引用来平铺一个区域。 12345678&lt;svg width=&quot;500&quot; height=&quot;500&quot;&gt; &lt;defs&gt; &lt;pattern id=&quot;dots&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;100&quot; height=&quot;100&quot; patternUnits=&quot;userSpaceOnUse&quot;&gt; &lt;circle fill=&quot;#bee9e8&quot; cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;35&quot;/&gt; &lt;/pattern&gt; &lt;/defs&gt; &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;100%&quot; height=&quot;100%&quot; fill=&quot;url(#dots)&quot; /&gt;&lt;/svg&gt; 上面代码中，&lt;pattern&gt; 标签将一个圆形定 义为dots模式。patternUnits=&quot;userSpaceOnUse&quot;表示 &lt;pattern&gt;的宽度和长度是实际的像素值。然后，指定这个模式去填充下面的矩形 插入图片 &lt;image&gt;标签用于插入图片文件 123&lt;svg width=&quot;500&quot; height=&quot;500&quot;&gt; &lt;image xlink:href=&quot;logo.png&quot; width=&quot;100%&quot; height=&quot;100%&quot;/&gt;&lt;/svg&gt; 上面代码中，&lt;image&gt;的xlink:href属性表示图像的来源 动画 &lt;animate&gt; 标签用于产生动画效果 12345&lt;svg width=&quot;500px&quot; height=&quot;500px&quot;&gt; &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;100&quot; height=&quot;100&quot; fill=&quot;#feac5e&quot;&gt; &lt;animate attributeName=&quot;x&quot; from=&quot;0&quot; to=&quot;500&quot; dur=&quot;2s&quot; repeatCount=&quot;indefinite&quot;/&gt; &lt;/rect&gt;&lt;/svg&gt; 上面代码中，矩形会不断移动，产生动画效果 animate属性 说明 attributeName 发生动画效果的属性名 from 单次动画的初始值 to 单次动画的结束值 dur 单次动画的持续时间 repeatCount 动画的循环模式 可以在多个属性上面定义动画 12&lt;animate attributeName=&quot;x&quot; from=&quot;0&quot; to=&quot;500&quot; dur=&quot;2s&quot; repeatCount=&quot;indefinite&quot;/&gt;&lt;animate attributeName=&quot;width&quot; to=&quot;500&quot; dur=&quot;2s&quot; repeatCount=&quot;indefinite&quot;/&gt; 变形 &lt;animate&gt;标签对 CSS的transform属性不起作用，如果需要变形，就要使用&lt;animateTransform&gt;标签 12345&lt;svg width=&quot;500px&quot; height=&quot;500px&quot;&gt; &lt;rect x=&quot;250&quot; y=&quot;250&quot; width=&quot;50&quot; height=&quot;50&quot; fill=&quot;#4bc0c8&quot;&gt; &lt;animateTransform attributeName=&quot;transform&quot; type=&quot;rotate&quot; begin=&quot;0s&quot; dur=&quot;10s&quot; from=&quot;0 200 200&quot; to=&quot;360 400 400&quot; repeatCount=&quot;indefinite&quot; /&gt; &lt;/rect&gt;&lt;/svg&gt; 上面代码中，&lt;animateTransform&gt;的效果为旋转( rotate ) 这时from和to属性值有三个数字，第一个数字是角度值，第二个值和第三个值是旋转中心的坐标 from=”0 200 200”表示开始时，角度为0 ，围绕(200, 200)开始旋转; to=”360 400 400”表示结束时，角度为360 ,围绕(400, 400)旋转。 JavaScript操作SVGDOM操作 如果SVG代码直接写在HTML网页之中，它就成为网页DOM的一部分，可以直接用DOM操作 123456789101112131415&lt;svg width=&quot;800&quot; height=&quot;400&quot;&gt; &lt;rect x=&quot;50&quot; y=&quot;50&quot; width=&quot; 250&quot; height=&quot;150&quot; class=&quot;rect&quot;&gt;&lt;/rect&gt;&lt;/svg&gt;&lt;button&gt;放大矩形&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt; var btn = document.querySelector(&quot;button&quot;) btn.onclick = function () &#123; var svgRect = document.querySelector(&quot;rect&quot;) console.log([svgRect]) svgRect.setAttribute(&quot;width&quot;, &quot;350&quot;) svgRect.setAttribute(&quot;height&quot;, &quot;250&quot;) svgRect.style.fill=&quot;orangered&quot; svgRect.setAttribute(&quot;x&quot;, &quot;250&quot;) &#125; &lt;/script&gt; SVG DOM 使用&lt;object&gt;、&lt;embed&gt;标签插入SVG文件，可以获取SVG DOM 123var svgObject= document.getElementById(&#x27;object&#x27;).contentDocument;var svgIframe = document.getElementById(&#x27;iframe&#x27;).contentDocument;var svgEmbed = document.getElementById(&#x27;embed&#x27;).getSVGDocument; 注意：如果使用&lt;img&gt;标签插入SVG文件,就无法获取SVG DOM.","path":"page/svg.html","date":"02-23","excerpt":"","tags":[{"name":"SVG","slug":"SVG","permalink":"http://xiaoliblog.cn/tags/SVG/"}]},{"title":"数据结构💰排序","text":"排序 排序(Sort) 就是重新排列表中的元素，使表中的元素满足按关键字有序的过程 排序算法的评价指标 时间复杂度、空间复杂度和稳定性 动画演示：算法可视化演示||前端面试十大经典排序算法（动画演示） 插入排序简单插入排序(Insertion Sort)算法思想 算法思想：每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成 算法描述 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5 算法实现 算法效率 空间复杂度：O(1) 最好时间复杂度(全部有序) ：O(n) 最坏时间复杂度(全部逆序) ： O(n2) 平均时间复杂度： O(n2) 算法稳定性：稳定 折半插入排序 思路：先用折半查找找到应该插入的位置，再移动元素 希尔排序(Shell Sort)算法思想 希尔排序(shell sort)：追求表中元素部分有序，再逐渐逼近全局有序 先将待排序表分成若干特殊子表 第一趟增量d=数据个数/2=8/2=4，例如49-76，38-13相隔4 再对每个子表排序 每次将增量d缩小一半，直到d=1 第一趟，增量为4 第二趟，增量为2 第三趟，增量为1，对整体进行排序 动画演示 算法实现 交换排序冒泡排序(Bubble Sort) 冒泡排序：从后往前(或从前往后) 两两比较相邻元素的值，若为逆序(即A[i-1]&gt;A[i]) ，则交换它们，直到序列比较完。称这样过程为“一趟” 冒泡排序。总共需要n-1趟冒泡 算法思想 算法描述 比较相邻的元素。如果第一个比第二个大，就交换它们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 重复步骤1~3，直到排序完成。 算法实现 算法效率 快速排序(Quick Sort)算法思想 快速排序：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序 算法描述 快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下： 从数列中挑出一个元素，称为 “基准”（pivot）； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 算法实现1234567891011121314151617181920212223242526272829303132function quickSort(arr, left, right) &#123; var len = arr.length,partitionIndex, left =typeof left !=&#x27;number&#x27; ? 0 : left, right =typeof right !=&#x27;number&#x27; ? len - 1 : right;if (left &lt; right) &#123; partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex-1); quickSort(arr, partitionIndex+1, right);&#125; return arr;&#125;function partition(arr, left ,right) &#123; // 分区操作 var pivot = left, // 设定基准值（pivot） index = pivot + 1;for (var i = index; i &lt;= right; i++) &#123; if (arr[i] &lt; arr[pivot]) &#123; swap(arr, i, index); index++; &#125; &#125;swap(arr, pivot, index - 1); return index-1;&#125;function swap(arr, i, j) &#123; var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125; 选择排序 选择排序：每一趟在待排序元素中选取关键字最小(或最大)的元素加入有序子序列 简单选择排序(Sellection Sort)算法思想 选择排序(Selection-sort)工作原理 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 算法实现 算法效率 堆排序(Heap Sort)基本概念 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 建立大根堆 思路：把所有非终端结点都检查一遍，是否满足大根堆的要求，如果不满足，则进行调整 检查当前结点是否满足根≥左、右若不满足，将当前结点与更大的一个孩子互换 若元素互换破坏了下一级的堆，则采用相同的方法继续往下调整（小元素不断下坠） 算法思想 堆排序：每一趟将堆顶元素加入有序子序列(与待排序序列中的最后一个元素交换)，并将待排序元素序列再次调整为大根堆(小元素不断“下坠”) 算法描述 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区； 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]； 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。 基于大根堆算法实现 算法效率 堆插入操作 对于小根堆，新元素放表尾与父元素比较，通过i/2向下取整找到其父节点 例如：插入13，下标为9，其父元素9/2=4，父元素下标为4，即32，比32小交换 删除元素 例如把13删除 被删除的元素用堆底元素替代，然后让该元素不断“下坠”，直到无法下坠为止 归并排序(Merge Sort)算法思路 归并：把两个或多个已经有序的序列合并成一个 设置i、j、k三个指针，对比i、j所指元素，选择更小的一个放入k所指位置，然后后移继续对比 当j所指向的数据全部对比完后，只剩一个子表未合并时，可以将该表中剩余元素全部加到总表 m路归并，每选出一个元素需要对比关键字m-1次 算法描述 把长度为n的输入序列分成两个长度为n/2的子序列； 对这两个子序列分别采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列 算法实现在内部中一般使用二路排序 算法效率 基数排序(Radix Sort) 算法思路 基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。 算法描述 取得数组中的最大数，并取得位数； arr为原始数组，从最低位开始取每个位组成radix数组； 对radix进行计数排序（利用计数排序适用于小范围数的特点）； 第一趟：以个位进行分配 第二趟：以十位进行分配，个位数越大的越先入队 第三趟：以百位进行分配，十位数越大的越先入队 算法实现12345678910111213141516171819202122232425// LSD Radix Sortvar counter = [];function radixSort(arr, maxDigit) &#123; var mod = 10; var dev = 1; for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123; for(var j = 0; j &lt; arr.length; j++) &#123; var bucket = parseInt((arr[j] % mod) / dev); if(counter[bucket]==null) &#123; counter[bucket] = []; &#125; counter[bucket].push(arr[j]); &#125; var pos = 0; for(var j = 0; j &lt; counter.length; j++) &#123; var value =null; if(counter[j]!=null) &#123; while ((value = counter[j].shift()) !=null) &#123; arr[pos++] = value; &#125; &#125; &#125; &#125; return arr;&#125; 计数排序（Counting Sort）算法思想 计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 算法描述 找出待排序的数组中最大和最小的元素； 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。 算法实现12345678910111213141516171819function countingSort(arr, maxValue) &#123; var bucket =new Array(maxValue + 1), sortedIndex = 0; arrLen = arr.length, bucketLen = maxValue + 1; for (var i = 0; i &lt; arrLen; i++) &#123; if (!bucket[arr[i]]) &#123; bucket[arr[i]] = 0; &#125; bucket[arr[i]]++; &#125; for (var j = 0; j &lt; bucketLen; j++) &#123; while(bucket[j] &gt; 0) &#123; arr[sortedIndex++] = j; bucket[j]--; &#125; &#125; return arr;&#125; 算法分析 计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。 桶排序（Bucket Sort）算法思想 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。 算法描述 设置一个定量的数组当作空桶； 遍历输入数据，并且把数据一个一个放到对应的桶里去； 对每个不是空的桶进行排序； 从不是空的桶里把排好序的数据拼接起来 算法实现1234567891011121314151617181920212223242526272829303132333435function bucketSort(arr, bucketSize) &#123; if (arr.length === 0) &#123; return arr; &#125; var i; var minValue = arr[0]; var maxValue = arr[0]; for (i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &lt; minValue) &#123; minValue = arr[i]; // 输入数据的最小值 &#125;else if (arr[i] &gt; maxValue) &#123; maxValue = arr[i]; // 输入数据的最大值 &#125; &#125; // 桶的初始化 var DEFAULT_BUCKET_SIZE = 5; // 设置桶的默认数量为5 bucketSize = bucketSize || DEFAULT_BUCKET_SIZE; var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1; var buckets =new Array(bucketCount); for (i = 0; i &lt; buckets.length; i++) &#123; buckets[i] = []; &#125; // 利用映射函数将数据分配到各个桶中 for (i = 0; i &lt; arr.length; i++) &#123; buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]); &#125; arr.length = 0; for (i = 0; i &lt; buckets.length; i++) &#123; insertionSort(buckets[i]); // 对每个桶进行排序，这里使用了插入排序 for (var j = 0; j &lt; buckets[i].length; j++) &#123; arr.push(buckets[i][j]); &#125; &#125; return arr;&#125; 算法分析 桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。","path":"page/datastructure08.html","date":"02-20","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://xiaoliblog.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构💰查找","text":"查找查找基本概念 查找 在数据 集合中寻找满足某种条件的数据元素的过程称为查找 查找表(查找结构) 一用于查找的数据集合称为查找表，它由同一类型的数据元素(或记录)组成 关键字 数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的 查找算法的评价指标 查找长度 在查找运算中， 需要对比关键字的次数称为查找长度 平均查找长度(ASL, Average Search Length) 所有查找过程中进行关键字的比较次数的平均值 评价一个查找算法的效率时，通常考虑查找成功/查找失败两种情况的ASL ASL的数量级反应了查找算法时间复杂度 顺序查找算法思想 顺序查找，又叫“线性查找”，通常用于线性表。 算法思想：从头到jio挨个找(或者反过来也OK) 算法实现 哨兵实现方式 把0下标位置空出来，从后往前查找，优点：无需判断是否越界，效率更高 算法优化 折半查找算法思想 折半查找，又称“二分查找”，仅适用于有序的顺序表 两个指针low和high，low指向第一个元素，high指向最后一个元素，中间元素用mid指针指向，指向下标为(0+10)/2=5的位置； 假如查找33，33&gt;mid(29)，只可能在右边区域 low指针移向右边区域（mid下标+1）的位置 此时的mid指针指向(6+10)/2=8，下标为8的位置即37，33&lt;mid，只可能在左边区域 移动high指针至(mid-1)=7的位置 继续(low+high)/2=(6+7)/2，向下取整为6，33&gt;mid，只可能在右边区域 low右移，此时low=high=7，(low+high)/2=7，33==mid查找成功 如果查找过程中出现low&gt;high，则查找失败 算法实现 查找判定树 分块查找算法思想特点：块内无线，块间有序 例如查找22，先查找索引表找到分块30(30&gt;=22)，然后就再30分块内查找，如果超出分块范围则查找失败 用折半查找找索引 查找效率分析","path":"page/datastructure07.html","date":"02-20","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://xiaoliblog.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构💰图","text":"图图的基本概念 图的顶点集一定是非空集，边集可以是空集 无向图、有向图 顶点的度、入度、出度 顶点之间的关系描述 连通图、强连通图 子图无向图和有向图子图概念相同 连通分量、强连通分量连通分量是相对于无向图，强连通分量是相当于有向图 生成树、森林 边的权、带权图/网 几种特殊形态的图 图的存储邻接矩阵邻接矩阵：数组实现的顺序存储，空间复杂度高，不适合存储稀疏图 存储不带权图无向图：1表示两个顶点之间是连接的，0表示无连接有向图：每一条弧代表一个1 存储带权图（网）无向图：两个顶点之间有连接则写上权值，无连接用无穷大符号表示，也有人习惯把结点自己指向自己的用0表示有向图：与无向图类似 邻接矩阵的性质 邻接表法邻接表法：顺序+链式存储 十字链表（存储有向图） 邻接多重表（存储无向图） 图的基本操作 边操作Adjacent(G,x,y): 判断图G是否存在边&lt;x, y&gt;或(x, y) &lt;x,y&gt;表示有向边，(x,y)表示无向边 用邻接矩阵存储，判断是否有边，只需要判断是否为1即可，比如A和B为1 用邻接表存储，只需要判断结点的边结点是否含有目标结点的下标，比如A和D，A的边结点含有3，即D的下标 Neighbors(G,x):列出图G中与结点x邻接的边。 邻接矩阵存储，找到目标结点所在行和列中为1的结点即为邻接的边，比如C和A、E有邻接边 邻接表存储，只需要找到目标节点的边结点即可，比如C的边结点0和4，对应A和E AddEdge(G,x,y):若无向边(x, y)或有向边&lt;x, y&gt;不存在，则向图G中添加该边 RemoveEdge(G,x,y):若无向边(x, y)或有向边&lt;x, y&gt;存在，则从图G中删除该边 顶点操作InsertVertex(G,x):在图G中插入顶点x 邻接矩阵和邻接表存储都只需要在存储结点数组的末尾插入新结点 DeleteVertex(G,x):从图G中删除顶点x 邻接矩阵存储：删除某一个结点，需要把它所在行和列置为0，并设置一个布尔变量在数组中标志是否为空 邻接表存储：删除某一个结点，不仅要删除其边结点，还需要删除其他数据指向它的边结点 FirstNeighbor(G,x): 求图G中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点或图中不存在x，则返回-1。 NextNeighbor(G,x,y):假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1。 图的遍历广度优先遍历BFS BFS算法 广度优先遍历序列同一个图的邻接矩阵表示方式唯一，因此广度优先遍历序列唯一同一个图邻接表表示方式不唯一，因此广度优先遍历序列不唯一 复杂度分析 广度优先生成树、森林 深度优先遍历DFS 树的深度优先遍历(先根、后根) 从根节点出发，能往更深处走就尽量往深处走。每当访问一个结点的时候，要检查是否还有与当前结点相邻的且没有被访问过的结点，如果有的话就往下一层钻 图的深度优先遍历类似于树的先根遍历 DFC算法 复杂度分析 最小生成树基本概念 求最小生成树 Prim算法 Kruskal算法 Prim算法 Prim算法(普里姆) 从某一个顶点开始构建生成树;每次将代价最小的新顶点纳入生成树，直到所有顶点都纳入为止。 下列以P城开始-&gt;学校(1)-&gt;矿场(4)-&gt;渔村(2)-&gt;农村(5)-&gt;电站(3)，其中在渔村处到电站为6权重大于P城到农村，所以选择后者 Prim算法实现思路 Kruskal算法 Kruskal算法(克鲁斯卡尔) 每次选择一条权值最小的边，使这条边的两头连通(原本已经连通的不选)直到所有结点都连通 Kruskal算法实现思路属于同一个集合就跳过，不属于同一个集合就连通 对比","path":"page/datastructure06.html","date":"02-19","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://xiaoliblog.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构💰树与二叉树","text":"树树的基本概念 空树 结点数为0的树 非空树的特性 有且仅有一个根节点 没有后继的结点称为“叶子结点”(或终端结点) 有后继的结点称为“分支结点”(或非终端结点) 除了根节点外，任何一个结点都有且仅有一个前驱 每个结点可以有0个或多个后继。 树的基础术语 有序树 逻辑上看，树中结点的各子树从左至右是有次序的，不能互换 无序树 逻辑上看，树中结点的各子树从左至右是无次序的，可以互换 森林 森林是m(m&gt;=0)棵互不相交的树的集合 树的性质 结点数=总度数+1 结点的度：结点有几个分支 度为m的树、m叉树的区别 结点计算 度为m的树第i层至多有mi-1个结点(i&gt;=1) m叉树第i层至多有mi-1个结点(i&gt;=1) 高度为h的m叉树至多有mh-1/(m-1) 个结点 高度为h的m叉树至少有h个结点 高度为h、度为m的树至少有h+m-1个结点 二叉树二叉树基本定义 特殊的二叉树 二叉树的性质 二叉树第i层至多有2i-1个结点（i&gt;=1) m叉树第i层至多有mi-1个结点（i&gt;=1) 完全二叉树性质 二叉树存储结构顺序存储 二叉树的顺序存储中一定要把二叉树的结点编号与完全二叉树对应起来 二叉树的顺序存储结构，只适合存储完全二叉树 链式存储 二叉树的遍历 遍历：按照某种次序把所有结点都访问一遍 二叉树的递归特性: 要么是个空二叉树 要么就是由“根节点+左子树+右子树”组成的二叉树 先序遍历 中序遍历 后序遍历 层序遍历 算法思想： 初始化一个辅助队列 根结点入队 若队列非空，则队头结点出队，访问该结点，并将其左、右孩子插入队尾(如果有的话) 重复第三步直至队列为空 遍历序列构造二叉树 中序遍历:中序遍历左子树、根结点、中序遍历右子树 前序遍历:根结点、前序遍历左子树、前序遍历右子树 后序遍历:前序遍历左子树、前序遍历右子树、根结点 若只给出一棵二叉树 的前/中/后/层 序遍历序列中的一种，不能唯一确定一棵二叉树 前序+中序遍历序列 例题 后序+中序遍历序列 例题 层序+中序遍历序列 例题 前序、后序、层序序列的两两组合无法唯一确定一科二叉树，必须有中序序列 线索二叉树 线索二叉树：一个结点的左右指针指向其前驱和后继，而不是左右孩子 作用：方便从一个指定结点出发，找到其前驱、后继;方便遍历 存储结构中序 先序 后序 二叉树线索化中序线索化 先序线索化 后序线索化 找前驱/后继中序线索二叉树 先序线索二叉树 后序线索二叉树 树的存储结构双亲表示法“指针”即双亲的数组下标 增加元素：无需按逻辑上的次序存储 删除元素 方案一：双亲指针设置为-1 方案二：把尾部的数据移上来覆盖，填充删除的空白位置 孩子表示法孩子表示法：顺序存储各个节点，每个结点中保存孩子链表头指针 孩子兄弟表示法 森林和二叉树的转换各个树的根节点视为兄弟关系 树和森林的遍历树的遍历先根遍历 后根遍历 层次遍历 森林的遍历先序遍历效果等同于依次对二叉树的先序遍历 中序遍历效果等同于依次对二叉树的中序遍历 二叉排序树BST 查找操作 插入操作 二次排序树的构造 删除操作 先搜索找到目标结点: 若被删除结点z是叶结点，则直接删除，不会破坏二叉排序树的性质。 若结点z只有一棵左子树或右子树，则让z的子树成为z父结点的子树，替代z的位置。 若结点z有左、右两棵子树，则令z的直接后继(或直接前驱)替代z，然后从二叉排序树中删去这个直接后继(或直接前驱)，这样就转换成了第一或第二种情况。 查找效率分析 平衡二叉树 插入操作 调整最小不平衡树 LL RR LR RL 查找效率分析 哈夫曼树相关概念 构造哈夫曼树 哈夫曼编码","path":"page/datastructure05.html","date":"02-17","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://xiaoliblog.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构💰串","text":"串串的定义 串是一种特殊的线性表，数据元素之间呈线性关系 串的数据对象限定为字符集(如中文字符、英文字符、数字字符、标点字符等) 串的基本操作，如增删改查等通常以子串为操作对象 串的基本操作 字符集编码 串的存储结构顺序存储 链式存储 顺序存储基本操作 求子串 比较操作 定位操作 串的朴素模式匹配算法 模式匹配算法 算法性能分析 很多应用场景中（比如百度搜索关键字），主串比模式串长很多，即n&gt;&gt;m，O(n-m)可以约等于O(n) KMP算法 由D.E.Knuth，J.H.Morris和V.R.Pratt提 出，因此称为KMP算法 视频讲解王道考研 KMP算法","path":"page/datastructure04.html","date":"02-15","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://xiaoliblog.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构💰栈和队列","text":"栈栈的定义 栈(stack)是只允许在一端进行插入或删除操作的线性表 栈的特点：先进后出 线性表是具有相同数据类型的n( n&gt;=0)个数据元素的有限序列，其中n为表长，当n=0时线性表是一个空表 重要术语：栈顶、栈底、空栈 栈的基本操作 顺序栈顺序栈的定义 栈顶指针top指向栈顶元素，记录的是数组下标，从0开始 使用typedef重命名结构体，简化代码 初始化操作 栈顶指针需要指向此时元素的位置，刚开始不能让它指向0，因为还没有元素进入，所以需要指向-1，当top=-1，表示栈为空 进栈操作 S.data[++S.top]=x; 表示先将top+1，再使用所得的值 出栈操作 x=S.data[S.top–]; 表示先使用top的值，再减1 读取栈顶元素 另一种方式 另一种方式是使top指针指向0，让top指针指向下一个可以插入元素的位置，栈满条件为top==MaxSize 顺序栈的缺点：栈的大小不可改变，可以使用链式存储或者共享栈的方式 共享栈 共享栈：两个栈共享一片存储空间，逻辑上是两个栈但物理上是一个栈，因为共享同一片空间 栈满条件：top0+1==top1; 回收内存资源：未使用malloc函数，函数运行结束后系统自动回收内存 链式栈链式栈的定义 队列队列的定义 队列(Queue)是只允许在一端进行插入(入队)，在另一端删除(出队)的线性表 队列的特点：先进先出 重要术语：队头、队尾、空队列 队列的基本操作 队列顺序实现顺序队列定义 顺序队列初始化 通过队头、队尾指针指向0来判断是否为空 入栈队列 当队尾指针rear指向最后一个元素，即指向MaxSize时，不能通过rear==MaxSize判断队列已满，因为队头有元素出队时，队尾指针还是指向MaxSize 解决方法：可以通过取余运算让队尾指针指向初始位置 (Q.rear+1)%MaxSize; 循环队列 循环队列：用模运算将存储空间在逻辑上变成环状 队列已满的条件：队尾指针的在下一个位置是队头，即(Q.rear+1)%MaxSize==Q.front 入队操作 出队操作 判断已满/已空 方案一：牺牲了一片存储空间 方案二：定义一个变量size，记录队列此时存放了几个元素 方案三：定义一个变量tag，当最近进行的是删除操作时值为0，插入操作时值为1 当队头和队尾指针指向同一个位置(front==rear)是由插入操作(tag==1)导致，为队列已满的情况 当队头和队尾指针指向同一个位置(front==rear)是由删除操作(tag==0)导致，为队列为空的情况 其他出题方法 以上都是队尾指针指向队尾元素的下一个位置，当队尾指针指向队尾元素时，代码实现有不同之处 队列链式实现链式队列定义 链式队列：一般不会队满，除非内存不足 链式队列初始化 入队 出队 双端队列双端队列概念 输出序列合法性判断 在栈中合法的输出序列，在双端队列中必定合法，所以只需要验证不合法的序列 注释：红色字体表示不合法，下划线字体表示在双端队列合法，在栈中不合法 栈的应用括号匹配 人和计算机匹配方法是不一样的，计算机是从左到右扫描 实现思路：依次扫描所有字符，遇到左括号入栈，遇到右括号则弹出栈顶元素检查是否匹配 匹配失败情况： ①左括号单身②右括号单身③左右括号不匹配 算法演示 具体动画演示请戳括号匹配算法演示 算法实现 表达式求值 算数表达式由三个部分组成：操作数、运算符、界限符，界限符是必不可少的，反映了计算的先后顺序 一个波兰数学家提出：可以不用界限符也能无歧义地表达运算顺序 Reverse Polish notation (逆波兰表达式=后缀表达式) Polish notation (波兰表达式=前缀表达式) 后缀表达式中缀转后缀表达式 后缀表达式求值 后缀表达式适用于基于栈的编程语言( stack-orientedprogramming language )，如：Forth、PostScript 前缀表达式中缀转前缀表达式 前缀表达式计算 中缀表达式中缀转后缀表达式 中缀表达式计算 递归的应用 队列的应用 树的层次遍历 图的广度优先遍历 队列在操作系统中的应用 多个进程争抢着使用有限的系统资源时，FCFS(FirstComeFirstService,先来先服务)是一种常用策略。可用队列实现 代码实现顺序栈数据结构-顺序栈的基本操作的实现（含全部代码） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/* Project: sequence_stack (数据结构-顺序栈) Date: 2018/09/14 Author: Frank Yu InitStack(SqStack &amp;s) 参数：顺序栈s 功能：初始化 时间复杂度O(1) Push(SqStack &amp;s,SElemType e) 参数：顺序栈s,元素e 功能：将e入栈 时间复杂度:O(1) Pop(SqStack &amp;s,SElemType &amp;e) 参数：顺序栈s,元素e 功能：出栈,e接收出栈元素值 时间复杂度O(1) GetTop(SqStack s,SElemType &amp;e) 参数：顺序栈s,元素e 功能：得到栈顶元素 时间复杂度O(1) 注意：严蔚敏版没有判断栈空函数，在入栈、出栈函数里面判断栈是否空，与王道的不同 尤其是top指针在base之上(有元素时) 另外，严蔚敏版 59页取栈顶有误 */#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;using namespace std;#define Status int#define SElemType int#define MaxSize 100//栈数据结构typedef struct Stack&#123; SElemType *base;//栈底指针 不变 SElemType *top;//栈顶指针 一直在栈顶元素上一个位置 int stacksize;//栈可用的最大容量&#125;SqStack;//**************************************基本操作函数************************************////初始化函数Status InitStack(SqStack &amp;s)&#123; s.base=new SElemType[MaxSize];//动态分配最大容量 if(!s.base) &#123; printf(&quot;分配失败\\n&quot;); return 0; &#125; s.top=s.base;//栈顶指针与栈底相同 王道上top起初在base下面，感觉很别扭，top应该高于或等于base s.stacksize=MaxSize; return 1;&#125;//入栈Status Push(SqStack &amp;s,SElemType e)&#123; if(s.top-s.base==s.stacksize) return 0;//栈满 *(s.top++)=e;//先入栈，栈顶指针再上移 注意与王道上的不同，具体问题具体分析 return 1; &#125;//出栈 用e返回值Status Pop(SqStack &amp;s,SElemType &amp;e)&#123; if(s.top==s.base) return 0;//栈空 e=*--s.top;//先减减 指向栈顶元素，再给e return 1; &#125;//得到栈顶元素，不修改指针bool GetTop(SqStack s,SElemType &amp;e) //严蔚敏版59页有问题，应该用e去获得，函数返回bool类型去判断&#123; if(s.top==s.base) return false;//栈空 else e=*--s.top; return true; &#125;//********************************功能实现函数**************************************////菜单void menu()&#123; printf(&quot;********1.入栈 2.出栈*********\\n&quot;); printf(&quot;********3.取栈顶 4.退出*********\\n&quot;);&#125;//入栈功能函数 调用Push函数void PushToStack(SqStack &amp;s)&#123; int n;SElemType e;int flag; printf(&quot;请输入入栈元素个数(&gt;=1)：\\n&quot;); scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) &#123; printf(&quot;请输入第%d个元素的值:&quot;,i+1); scanf(&quot;%d&quot;,&amp;e); flag=Push(s,e); if(flag)printf(&quot;%d已入栈\\n&quot;,e); else &#123;printf(&quot;栈已满！！！\\n&quot;);break;&#125; &#125;&#125;//出栈功能函数 调用Pop函数void PopFromStack(SqStack &amp;s)&#123; int n;SElemType e;int flag; printf(&quot;请输入出栈元素个数(&gt;=1)：\\n&quot;); scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) &#123; flag=Pop(s,e); if(flag)printf(&quot;%d已出栈\\n&quot;,e); else &#123;printf(&quot;栈已空！！！\\n&quot;);break;&#125; &#125;&#125;//取栈顶功能函数 调用GetTopvoid GetTopOfStack(SqStack &amp;s)&#123; SElemType e;bool flag; flag=GetTop(s,e); if(flag)printf(&quot;栈顶元素为:%d\\n&quot;,e); else printf(&quot;栈已空！！！\\n&quot;);&#125;//主函数int main()&#123; SqStack s;int choice; InitStack(s); while(1) &#123; menu(); printf(&quot;请输入菜单序号：\\n&quot;); scanf(&quot;%d&quot;,&amp;choice); if(choice==4) break; switch(choice) &#123; case 1:PushToStack(s);break; case 2:PopFromStack(s);break; case 3:GetTopOfStack(s);break; default:printf(&quot;输入错误！！！\\n&quot;); &#125; &#125; return 0;&#125; 链栈数据结构-链栈的基本操作函数的实现（含全部代码） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/* Project: single_linked_stack (数据结构 链栈) Date: 2018/09/16 Author: Frank Yu InitStack(LinkStack &amp;S) 参数：链栈S 功能：初始化 时间复杂度O(1) Push(LinkStack &amp;S,SElemType e) 参数：链栈S,元素e 功能：将e入栈 时间复杂度:O(1) Pop(LinkStack &amp;S,SElemType &amp;e) 参数：链栈S,元素e 功能：栈顶出栈,e接收出栈元素值 时间复杂度O(1) GetTop(LinkStack &amp;S,SElemType &amp;e) 参数：链栈S,元素e 功能：得到栈顶元素 时间复杂度O(1)*/#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;using namespace std;#define Status int#define SElemType int//链栈结点数据结构typedef struct StackNode&#123; SElemType data;//数据域 struct StackNode *next;//指针域&#125;StackNode,*LinkStack;//**************************基本操作函数***************************////初始化函数Status InitStack(LinkStack &amp;S)&#123; S = NULL;//生成空栈 以单链表表头为栈顶 注意，链栈没有像链表似的头结点 return 1;&#125;//入栈函数 将e压入栈Status Push(LinkStack &amp;S,SElemType e)&#123; StackNode *p; p=new StackNode;//生成新节点 p-&gt;data=e; //赋值 p-&gt;next=S; //压入栈顶 S=p; return 1;&#125;//出栈函数 栈顶出栈用e返回 注意释放空间bool Pop(LinkStack &amp;S,SElemType &amp;e)&#123; LinkStack p; if(S==NULL)return false;//栈空 e=S-&gt;data; p=S; S=S-&gt;next; free(p); return true;&#125;//取栈顶函数 用e返回bool GetTop(LinkStack &amp;S,SElemType &amp;e) //严蔚敏版（人民邮电出版社） 61页有误&#123; if(S==NULL) return false;//栈顶为空 e=S-&gt;data; return true;&#125;//**************************功能实现函数***************************////菜单void menu()&#123; printf(&quot;********1.入栈 2.出栈*********\\n&quot;); printf(&quot;********3.取栈顶元素 4.退出*********\\n&quot;);&#125;//入栈功能函数 调用Push函数 void PushToStack(LinkStack &amp;S)&#123; int n;SElemType e;int flag; printf(&quot;请输入入栈元素个数(&gt;=1)：\\n&quot;); scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) &#123; printf(&quot;请输入第%d个元素的值:&quot;,i+1); scanf(&quot;%d&quot;,&amp;e); flag=Push(S,e); if(flag)printf(&quot;%d已入栈\\n&quot;,e); &#125;&#125;//出栈功能函数 调用Pop函数void PopFromStack(LinkStack &amp;S)&#123; int n;SElemType e;int flag; printf(&quot;请输入出栈元素个数(&gt;=1)：\\n&quot;); scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) &#123; flag=Pop(S,e); if(flag)printf(&quot;%d已出栈\\n&quot;,e); else &#123;printf(&quot;栈已空！！！\\n&quot;);break;&#125; &#125;&#125;//取栈顶功能函数 调用GetTop函数void GetTopOfStack(LinkStack S)&#123; SElemType e;bool flag; flag=GetTop(S,e); if(flag)printf(&quot;栈顶元素为:%d\\n&quot;,e); else printf(&quot;栈已空！！！\\n&quot;);&#125;//主函数int main()&#123; LinkStack S;int choice; InitStack(S); while(1) &#123; menu(); printf(&quot;请输入菜单序号：\\n&quot;); scanf(&quot;%d&quot;,&amp;choice); if(choice==4) break; switch(choice) &#123; case 1:PushToStack(S);break; case 2:PopFromStack(S);break; case 3:GetTopOfStack(S);break; default:printf(&quot;输入错误！！！\\n&quot;); &#125; &#125; return 0;&#125; 循环队列数据结构-循环队列的基本操作函数的实现（含全部代码） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127/* Project: sequentially_cyclic_queue （顺序结构循环队列） Date: 2018/09/16 Author: Frank Yu InitQueue(SqQueue &amp;Q) 参数：循环队列Q 功能：初始化循环队列Q 时间复杂度：O(1) QueueEmpty(SqQueue Q) 参数：循环队列Q 功能：判断队空与否 时间复杂度：O(1) EnQueue(SqQueue &amp;Q,QElemType e) 参数：循环队列Q，元素e 功能：使元素e入队 时间复杂度：O(1) DeQueue(SqQueue &amp;Q,QElemType &amp;e) 参数：循环队列Q，元素e 功能：队头出队,用e返回值 时间复杂度：O(1) GetHead(SqQueue &amp;Q,QElemType &amp;e) 参数：循环队列Q，元素e 功能：获取队头元素e 时间复杂度：O(1)*/#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;using namespace std;#define Status int#define QElemType int#define MaxQSize 100//循环队列数据结构typedef struct&#123; QElemType data[MaxQSize];//数据域 int front,rear; //队头队尾指针&#125;SqQueue;//***************************基本操作函数**************************////初始化函数Status InitQueue(SqQueue &amp;Q)&#123; Q.front=Q.rear=0; return 1;&#125;//判断队空函数bool QueueEmpty(SqQueue Q)&#123; if(Q.front!=Q.rear)return false; else return true;&#125;//入队函数bool EnQueue(SqQueue &amp;Q,QElemType e)&#123; if((Q.rear+1)%MaxQSize==Q.front)return false; //队列满 牺牲一个以判断 Q.data[Q.rear]=e; Q.rear=(Q.rear+1)%MaxQSize;//指针加1 取模 return true;&#125;//出队函数bool DeQueue(SqQueue &amp;Q,QElemType &amp;e)&#123; if(Q.front==Q.rear)return false;//队空 其实可以调用QueueEmpty 不然要它干啥呢 //严蔚敏版 给了判空函数，但在其他基本操作函数中也没用 e=Q.data[Q.front]; Q.front=(Q.front+1)%MaxQSize;指针加1 取模 return true;&#125;//取队头bool GetHead(SqQueue &amp;Q,QElemType &amp;e)&#123; if(Q.front==Q.rear)return false;//队空 其实可以调用QueueEmpty 不然要它干啥呢 //严蔚敏版 给了判空函数，但在其他基本操作函数中也没用 e=Q.data[Q.front]; return true;&#125;//**************************功能实现函数****************************////入队功能函数 调用EnQueue函数void EnterToQueue(SqQueue &amp;Q)&#123; int n;QElemType e;int flag; printf(&quot;请输入入队元素个数(&gt;=1)：\\n&quot;); scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) &#123; printf(&quot;请输入第%d个元素的值:&quot;,i+1); scanf(&quot;%d&quot;,&amp;e); flag=EnQueue(Q,e); if(flag)printf(&quot;%d已入队\\n&quot;,e); else &#123;printf(&quot;队已满！！！\\n&quot;);break;&#125; &#125;&#125;//出队函数 调用DeQueue函数void DeleteFromQueue(SqQueue &amp;Q)&#123; int n;QElemType e;int flag; printf(&quot;请输入出队元素个数(&gt;=1)：\\n&quot;); scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) &#123; flag=DeQueue(Q,e); if(flag)printf(&quot;%d已出队\\n&quot;,e); else &#123;printf(&quot;队已空！！！\\n&quot;);break;&#125; &#125;&#125;//获得队头元素 调用GetHead函数void GetHeadOfQueue(SqQueue Q)&#123; QElemType e;bool flag; flag=GetHead(Q,e); if(flag)printf(&quot;队头元素为:%d\\n&quot;,e); else printf(&quot;队已空！！！\\n&quot;);&#125;//菜单void menu()&#123; printf(&quot;********1.入队 2.出队*********\\n&quot;); printf(&quot;********3.取队头元素 4.退出*********\\n&quot;);&#125;//主函数int main()&#123; SqQueue Q;int choice; InitQueue(Q); while(1) &#123; menu(); printf(&quot;请输入菜单序号：\\n&quot;); scanf(&quot;%d&quot;,&amp;choice); if(choice==4) break; switch(choice) &#123; case 1:EnterToQueue(Q);break; case 2:DeleteFromQueue(Q);break; case 3:GetHeadOfQueue(Q);break; default:printf(&quot;输入错误！！！\\n&quot;); &#125; &#125; return 0;&#125; 链队数据结构-链队的基本操作函数的实现（含全部代码） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130/* Project: single_linked_queue (链队列) Date: 2018/09/17 Author: Frank Yu InitQueue(LinkQueue &amp;Q) 参数：链队Q 功能：初始化 时间复杂度O(1) EnQueue(LinkQueue &amp;Q,QElemType e) 参数：链队Q,元素e 功能：将e入队 时间复杂度:O(1) DeQueue(LinkQueue &amp;Q,QElemType &amp;e) 参数：链队Q,元素e 功能：队头出队,e接收出队元素值 时间复杂度O(1) GetHead(LinkQueue &amp;Q,QElemType &amp;e) 参数：链队Q,元素e 功能：得到队顶元素 时间复杂度O(1) 注意：有头结点*/#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;using namespace std;#define Status int#define QElemType int//链队结点数据结构typedef struct QNode&#123; QElemType data;//数据域 struct QNode *next;//指针域 &#125;QNode,*QueuePtr;typedef struct&#123; struct QNode *front,*rear;//rear指针指向队尾 用于入队 front指针指向队头 用于出队&#125;LinkQueue;//**************************基本操作函数***************************////初始化函数Status InitQueue(LinkQueue &amp;Q)&#123; Q.front=Q.rear=new QNode;//生成新节点作为头结点，队头队尾指针均指向它 Q.front-&gt;next=NULL; return 1;&#125;//入队函数 Status EnQueue(LinkQueue &amp;Q,QElemType e)&#123; QNode *p; p=new QNode;//生成新节点 p-&gt;data=e; //赋值 p-&gt;next=NULL; Q.rear-&gt;next=p;//加入队尾 Q.rear=p; //尾指针后移 return 1;&#125;//出队函数 队头出队用e返回 注意释放空间bool DeQueue(LinkQueue &amp;Q,QElemType &amp;e)&#123; QueuePtr p; if(Q.front==Q.rear)return false;//队空 e=Q.front-&gt;next-&gt;data; //e返回值 之前写的Q.front-&gt;data 炸了，头结点没数据的，一定要注意头结点 p=Q.front-&gt;next; //保留，一会儿释放空间 Q.front-&gt;next=p-&gt;next; //出队,注意Q.front-&gt;next 不是Q.front 还有头结点 if(Q.rear==p)Q.rear=Q.front; //最后一个元素出队，rear指向头结点 free(p); return true;&#125;//取队顶函数 用e返回bool GetHead(LinkQueue &amp;Q,QElemType &amp;e) &#123; if(Q.front==Q.rear) return false;//队列为空 e=Q.front-&gt;next-&gt;data; return true;&#125;//**************************功能实现函数***************************////菜单void menu()&#123; printf(&quot;********1.入队 2.出队*********\\n&quot;); printf(&quot;********3.取队顶元素 4.退出*********\\n&quot;);&#125;//入队功能函数 调用EnQueue函数 void EnterToQueue(LinkQueue &amp;Q)&#123; int n;QElemType e;int flag; printf(&quot;请输入入队元素个数(&gt;=1)：\\n&quot;); scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) &#123; printf(&quot;请输入第%d个元素的值:&quot;,i+1); scanf(&quot;%d&quot;,&amp;e); flag=EnQueue(Q,e); if(flag)printf(&quot;%d已入队\\n&quot;,e); &#125;&#125;//出队功能函数 调用DeQueue函数void DeleteFromQueue(LinkQueue &amp;Q)&#123; int n;QElemType e;int flag; printf(&quot;请输入出队元素个数(&gt;=1)：\\n&quot;); scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) &#123; flag=DeQueue(Q,e); if(flag)printf(&quot;%d已出队\\n&quot;,e); else &#123;printf(&quot;队已空！！！\\n&quot;);break;&#125; &#125;&#125;//取队顶功能函数 调用GetHead函数void GetHeadOfStack(LinkQueue Q)&#123; QElemType e;bool flag; flag=GetHead(Q,e); if(flag)printf(&quot;队头元素为:%d\\n&quot;,e); else printf(&quot;队已空！！！\\n&quot;);&#125;//主函数int main()&#123; LinkQueue Q;int choice; InitQueue(Q); while(1) &#123; menu(); printf(&quot;请输入菜单序号：\\n&quot;); scanf(&quot;%d&quot;,&amp;choice); if(4==choice) break; switch(choice) &#123; case 1:EnterToQueue(Q);break; case 2:DeleteFromQueue(Q);break; case 3:GetHeadOfStack(Q);break; default:printf(&quot;输入错误！！！\\n&quot;); &#125; &#125; return 0;&#125;","path":"page/datastructure03.html","date":"02-12","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://xiaoliblog.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构💰线性表","text":"线性表线性表的定义 线性表的基本操作 顺序表顺序表的定义 顺序表的实现静态分配 动态分配 由于静态分配的顺序表表长确定后无法更改，所以引出动态分配 实现思路：定义一个int类型指针p，指向data[0]首地址，并动态申请一个新空间（比原空间大len），使data指针指向新空间，将原数据复制到新空间，顺序表最大长度增加len并释放原空间 顺序表的特点 顺序表基本操作顺序表插入 ListInsert(&amp;L,e)：插入操作。在表L中的第i个位置（位序）上插入指定元素e，注意位序与数组下标的关系 实现思路：静态分配实现，当插入c时，需要c后面的数即d，e，f后移一位，即data[i+1]=data[i] 以上代码有缺陷，当执行ListInsert(L,9,3);时，由于原数据不够会导致插入数据位置和原数据之间有空位，这违背了顺序存储的原理，所以为了提高代码健壮性，需要对插入数据指定位置进行判断 1234567891011bool ListInsert(SqList &amp;L,int i,int e)&#123; . if(i&lt;1||i&gt;L.length+1) //判断i的范围是否有效 return false; if(L.length&gt;=MaxSize)//当前存储空间已满，不能插入 return false; for(int j=L.length;j&gt;=i;j--) //将第i个元素及之后的元素后移 L.data[j]=L.data[j-1]; L.data[i-1]=e; //在位置i处放入e . L.length++; //长度加1 return true;&#125; 顺序表删除 ListDelete(&amp;L,i,&amp;e)：删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值 思想思路：删除数据后面的值往前移一位，即data[i-1]=data[i]，同时length-1 如果参数没有加引用符号&amp;，那么删除的值其实是赋给了e的复制品，虽然变量名相同，但内存地址不同值也不同，运行结果将会不变，为main函数里的-1 顺序表查找按位查找 GetElem(L,i)：按位查找操作。获取表L中第i个位置的元素的值 123456789#define MaxSize 10 //定义最大长度typedef struct&#123; ElemType data [MaxSize];//用静态的“数组”存放数据元素-静态分配 int length; //顺序表的当前长度&#125;SqList; //顺序表的类型定义(静态分配方式)ElemType GetElem(SqList L,int i)&#123; return L.data[i-1];&#125; 12345678910#define InitSize 10 //顺序表的初始长度typedef struct&#123; ElemType *data; //指示动态分配数组的指针动态分配，指向了第一个元素，空间用malloc分配 int MaxSize; //顺序表的最大容量 int length; //顺序表的当前长度.&#125;SeqList; //顺序表的类型定义(动态分配方式)ElemType GetElem(SeqList L,int i)&#123; //和访问普通数组的方法一样 return L.data[i-1];&#125; 如果按指针+数组下标方式会根据指针所使用的数据类型空间大小标识下一个数据 所以再次理解下列代码中 为何malloc函数返回的存储空间起始地址要转换为与数据元素的数据类型相对应的指针(int *) 1L.data=(int *)malloc (InitSize*sizeof(int)); 按值查找 LocateElem(L,e)：按值查找操作。在表L中查找具有给定关键字值的元素。 1234567891011121314#define InitSize 10 //顺序表的初始长度typedef struct&#123; ElemType *data; //指示动态分配数组的指针 int MaxSize; //顺序表的最大容量 int length; //顺序表的当前长度&#125;SeqList; //顺序表的类型定义(动态分配方式)//在顺序表L中查找第一个元素值等于e的元素，并返回其位序int LocateElem(SeqList L, ElemType e)&#123; for(int i=0; i&lt;L.length;i++) if(L.data[i]==e) return i+1; //数组 下标为i的元素值等于e，返回其位序i+1 return 0; //退出循环，说明查找失败&#125; 注意：C语言中，结构体的比较不能直接用”==”判断，需要依次对比各个分量，来判断两个结构体是否相等 单链表单链表的定义 123456struct LNode&#123; //定义单链表结点类型 ElemType data; //每个节点存放一个数据元素(数据域) struct LNode *next ; //指针指向下一个节点(指针域)&#125;;//增加一个新的结点：在内存中申请一个结点所需的空间，并用p指针指向这个结点struct LNode* p=(struct LNode *) malloc(sizeof(struct LNode)); typedef &lt;数据类型&gt; &lt;别名&gt;：可以为数据类型重命名 123456789//使用typedef可以简化代码，下列代码和上例代码一样typedef struct LNode&#123; //定义单链表结点类型. ElemType data; //每个节点存放一个数据元素 struct LNode *next ; //指针指向下一个节点&#125;LNode,*LinkList;//要表示一个单链表时，只需要声明一个头指针L，指向单链表的第一个结点LNode *L; //声明一个指向单链表第一个结点的指针//或者LinkList L; //这种表示方法语义更加明确 LNode * 强调返回的是一个结点，而LinkList L 强调的是一个单链表 单链表插入按位序插入带头结点 ListInsert(&amp;L,i,e)：插入操作。在表L中的第i个位置（位序从1开始）上插入指定元素e 实现思路：找到第i-1个结点，将新结点插入其后 头结点是第0个结点，不存放数据，用来标识单链表 不带头结点 ListInsert(&amp;L,i,e)：插入操作。在表L中的第i个位置上插入指定元素e 实现思路：找到第i-1个结点，将新结点插入其后；但是不存在“ 第0个”结点，因此i=1时需要特殊处理 指定结点的后插操作 指定结点的前插操作 单链表删除按位序删除 ListDelete(&amp;L,i,&amp;e)：删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值 实现思路：找到第i-1个结点，将其指针指向第i+1个结点，并释放第i个结点 指定结点的删除 删除结点p，需要修改其前驱结点的next指针 方法1：传入头指针，循环寻找p的前驱结点 方法2：偷天换日(类似于结点前插的实现 由于单链表的局限性无法逆向检索，当删除的p是最后一个结点时，只能从表头开始依次寻找p的前驱，时间复杂度O(n) 单链表查找按位查找 GetElem(L,i)：按位查找操作。获取表L中第i个位置的元素的值。 按值查找 LocateElem(L,e)：按值查找操作。在表L中查找具有给定关键字值的元素。 单链表的长度12345678910//求表的长度int Length(LinkList L)&#123; int Len = 0; //统计表长 LNode *p = L; while (p-&gt;next != NULL)&#123; p = p-&gt;next; len++; &#125; return len;&#125; 单链表的建立 如果给你很多个数据元素( ElemType)，要把它们存到一个单链表里边，咋弄呢? Step1：初始化一个单链表 Step 2：每次取一个数据元素，插入到表尾/表头 尾插法 头插法 双链表 单链表：无法逆向检索，有时候不太方便 双链表：可进可退，存储密度更低一丢丢 1234typedef struct DNode&#123; //定义双链表结点类型 ElemType data; //数据域 struct DNode *prior,*next; //前驱和后继指针&#125;DNode,*DLinkList; 双链表初始化 双链表插入 双链表删除 双链表遍历 循环链表循环单链表 单链表：表尾结点的next指针指向NULL，从一个结点触发只能找到后续的各个结点 循环单链表：表尾结点的next指针指向头结点，从一个结点触发可以找到其他任何一个结点 循环双链表 双链表 表头结点的prior指向NULL 表尾结点的next指向NULL 循环双链表 表头结点的prior指向表尾结点; 表尾结点的next指向头结点 静态链表静态链表的定义 静态链表基本操作 代码实现顺序表👉数据结构-顺序表基本操作的实现（含全部代码） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250/*Project: sequence_list(数据结构-顺序表)Date: 2018/09/12 20191012修改 添加Reverse 20200819修改 添加ClearListAuthor: Frank YuCreateList(SqList &amp;L,int n) 参数：顺序表L，顺序表长度n 功能：创建长度为的顺序表 时间复杂度：O(n)InitList(SqList &amp;L) 参数：顺序表L 功能：初始化 时间复杂度:O(1)InsertList(SqList &amp;L,int i,ElemType e) 参数:顺序表L,位置i,元素e 功能：位置i处插入元素e 时间复杂度:O(n)ListDelete(SqList &amp;L,int i) 参数:顺序表L,位置i 功能：删除位置i处元素 时间复杂度:O(n)LocateElem(SqList L,ElemType e) 参数:顺序表L,元素e 功能：返回第一个等于e的元素的位置 时间复杂度:O(n)Reverse(SqList &amp;L) 参数：顺序表L 倒置函数 将原顺序表直接倒置PrintList(SqList L) 参数:顺序表L 功能：遍历L，并输出SplitSort(SqList &amp;L) 参数：顺序表L 功能：分开奇偶，并分开排序ClearList(SqList &amp;L) 参数：顺序表L 功能：清空顺序表*/#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#define MaxSize 100#define ElemType int#define Status intusing namespace std;//顺序表数据结构typedef struct&#123; ElemType data[MaxSize];//顺序表元素 int length; //顺序表当前长度&#125;SqList;//***************************基本操作函数*******************************////初始化顺序表函数，构造一个空的顺序表 Status InitList(SqList &amp;L)&#123; memset(L.data, 0, sizeof(L));//初始化数据为0 L.length = 0; //初始化长度为0 return 0;&#125;//创建顺序表函数 初始化前n个数据bool CreateList(SqList &amp;L, int n)&#123; if (n&lt;0 || n&gt;MaxSize)false;//n非法 for (int i = 0; i&lt;n; i++) &#123; scanf(&quot;%d&quot;, &amp;L.data[i]); L.length++; &#125; return true;&#125;//插入函数 位置i插入数据 i及之后元素后移 1=&lt;i&lt;=length+1 bool InsertList(SqList &amp;L, int i, ElemType e)&#123; if (i&lt;1 || i&gt;L.length + 1) //判断位置是否有效 &#123; printf(&quot;位置无效！！！\\n&quot;); return false; &#125; if (L.length &gt;= MaxSize)//判断存储空间是否已满 &#123; printf(&quot;当前存储空间已满！！！\\n&quot;); return false; &#125; for (int j = L.length; j &gt;= i; j--)//位置i及之后元素后移 &#123; L.data[j] = L.data[j - 1]; &#125; L.data[i - 1] = e; L.length++; return true;&#125;//删除函数 删除位置i的元素 i之后的元素依次前移bool ListDelete(SqList &amp;L, int i)&#123; if (i&lt;1 || i&gt;L.length) &#123; printf(&quot;位置无效！！！\\n&quot;); return false; &#125; for (int j = i; j &lt;= L.length - 1; j++)//位置i之后元素依次前移覆盖 &#123; L.data[j - 1] = L.data[j]; &#125; L.length--; return true;&#125;//查找函数 按位置从小到大查找第一个值等于e的元素 并返回位置int LocateElem(SqList L, ElemType e)&#123; for (int i = 0; i&lt;L.length; i++)//从低位置查找 &#123; if (L.data[i] == e) return i + 1; &#125; return 0;&#125;//倒置函数 将原顺序表直接倒置void Reverse(SqList &amp;L)&#123; if (L.length) for (int i = 0; i&lt;L.length - 1 - i; i++) &#123; int t = L.data[i]; L.data[i] = L.data[L.length - 1 - i]; L.data[L.length - 1 - i] = t; &#125;&#125;//奇偶分开并排序void SplitSort(SqList &amp;L)&#123; int Even = 0; int Odd = L.length - 1; int i = 0; int j = L.length - 1; bool flag = false; if (L.length) for (; i &lt; j; i++, j--) &#123; while (L.data[i] % 2 != 0)i++; while (L.data[j] % 2 == 0)j--; if (L.data[i] % 2 == 0 &amp;&amp; L.data[j] % 2 != 0&amp;&amp;i&lt;j) &#123; int temp = L.data[i]; L.data[i] = L.data[j]; L.data[j] = temp; flag = true; &#125; if(!flag) //没有交换 &#123; Even = L.length - 1;//全奇数 Odd = 0; //全偶数 &#125; &#125; if (flag) &#123; for(int i=0;i&lt;L.length;i++) if (L.data[i] % 2 == 0) &#123; Odd = i; Even = i - 1; break; &#125; &#125; sort(L.data, L.data + Even + 1); sort(L.data + Odd, L.data + L.length);&#125;//清空顺序表void ClearList(SqList &amp;L) &#123; L.length = 0;&#125;//********************************功能函数*****************************************////输出功能函数 按位置从小到大输出顺序表所有元素void PrintList(SqList L)&#123; printf(&quot;当前顺序表所有元素:&quot;); for (int i = 0; i&lt;L.length; i++) &#123; printf(&quot;%d &quot;, L.data[i]); &#125; printf(&quot;\\n&quot;);&#125;//创建顺序表函数void Create(SqList &amp;L)&#123; int n; bool flag; L.length = 0; printf(&quot;请输入要创建的顺序表长度(&gt;1):&quot;); scanf(&quot;%d&quot;, &amp;n); printf(&quot;请输入%d个数（空格隔开）:&quot;, n); flag = CreateList(L, n); if (flag) &#123; printf(&quot;创建成功！\\n&quot;); PrintList(L); &#125; else printf(&quot;输入长度非法！\\n&quot;); &#125;//插入功能函数 调用InsertList完成顺序表元素插入 调用PrintList函数显示插入成功后的结果void Insert(SqList &amp;L)&#123; int place; ElemType e; bool flag; printf(&quot;请输入要插入的位置(从1开始)及元素:\\n&quot;); scanf(&quot;%d%d&quot;, &amp;place, &amp;e); flag = InsertList(L, place, e); if (flag) &#123; printf(&quot;插入成功！！！\\n&quot;); PrintList(L); &#125;&#125;//删除功能函数 调用ListDelete函数完成顺序表的删除 调用PrintList函数显示插入成功后的结果void Delete(SqList &amp;L)&#123; int place; bool flag; printf(&quot;请输入要删除的位置(从1开始):\\n&quot;); scanf(&quot;%d&quot;, &amp;place); flag = ListDelete(L, place); if (flag) &#123; printf(&quot;删除成功！！！\\n&quot;); PrintList(L); &#125;&#125;//查找功能函数 调用LocateElem查找元素void Search(SqList L)&#123; ElemType e; int flag; printf(&quot;请输入要查找的值:\\n&quot;); scanf(&quot;%d&quot;, &amp;e); flag = LocateElem(L, e); if (flag) &#123; printf(&quot;该元素位置为:%d\\n&quot;, flag); &#125; else printf(&quot;未找到该元素！\\n&quot;);&#125;//菜单void menu()&#123; printf(&quot;********1.创建 2.插入*********\\n&quot;); printf(&quot;********3.删除 4.查找*********\\n&quot;); printf(&quot;********5.倒置 6.分奇偶排序***\\n&quot;); printf(&quot;********7.输出 8.清空*********\\n&quot;); printf(&quot;********9.退出 *********\\n&quot;);&#125;int main()&#123; SqList L; int choice; InitList(L); while (1) &#123; menu(); printf(&quot;请输入菜单序号：\\n&quot;); scanf(&quot;%d&quot;, &amp;choice); if (9 == choice) break; switch (choice) &#123; case 1:Create(L); break; case 2:Insert(L); break; case 3:Delete(L); break; case 4:Search(L); break; case 5:Reverse(L); break; case 6:SplitSort(L); break; case 7:PrintList(L); break; case 8:ClearList(L); break; default:printf(&quot;输入错误！！！\\n&quot;); &#125; &#125; return 0;&#125; 单链表👉数据结构-单链表基本操作实现（含全部代码） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185/* Project: single linkeed list (数据结构 单链表) Date: 2018/09/14 Author: Frank Yu InitList(LinkList &amp;L) 参数：单链表L 功能：初始化 时间复杂度 O(1) ListLength(LinkList L) 参数：单链表L 功能：获得单链表长度 时间复杂度O(n) ListInsert(LinkList &amp;L,int i,ElemType e) 参数：单链表L,位置i，元素e 功能：位置i后插 时间复杂度O(n)[加入了查找] 若已知指针p指向的后插 O(1) ListDelete(LinkList &amp;L,int i) 参数：单链表L，位置i 功能：删除位置i元素 时间复杂度O(n)[加入了查找] 若已知p指针指向的删除 最好是O(1),因为可以与后继结点交换数据域，然后删除后继结点。 最坏是O(n),即从头查找p之前的结点,然后删除p所指结点 LocateElem(LinkList L,ElemType e) 参数：单链表L，元素e 功能：查找第一个等于e的元素，返回指针 时间复杂度O(n) */#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;using namespace std;#define Status int#define ElemType int//单链表结点数据结构typedef struct LNode&#123; ElemType data;//数据域 struct LNode *next;//指针域&#125;LNode,*LinkList;//**************************基本操作函数***************************////初始化函数Status InitList(LinkList &amp;L)&#123; L = new LNode;//生成头结点 这样删除等操作就不必分第一个结点和其他了 L-&gt;next = NULL; return 1;&#125;//获取单链表长度 头结点无数据，不算int ListLength(LinkList L)&#123; LinkList p=L;int sum=0; while(p) &#123; sum++; p=p-&gt;next; &#125; return sum-1;//去除头结点&#125;//插入函数--后插法 插入到第i(1&lt;=i&lt;=length+1)个位置 即i-1之后 不必区分i的位置bool ListInsert(LinkList &amp;L,int i,ElemType e)&#123; LNode* s;LinkList p=L;int j=0; while(p&amp;&amp;(j&lt;i-1))//j指到i-1位置或者p已经到最后时跳出 &#123; p=p-&gt;next; ++j; &#125; if(!p||j&gt;i-1)//i&lt;1或者i&gt;ListLength(L)+1时,插入位置无效 不调用ListLength,提高效率 &#123; printf(&quot;插入位置无效！！！\\n&quot;); return false; &#125; s=new LNode; s-&gt;data=e; s-&gt;next=p-&gt;next; p-&gt;next=s; return true;&#125;//删除函数 删除位置i的结点 即删除i-1之后的结点bool ListDelete(LinkList &amp;L,int i)&#123; LNode* s;LinkList p=L;int j=0; LinkList q; while(p&amp;&amp;(j&lt;i-1))//j指到i-1位置 &#123; p=p-&gt;next; ++j; &#125; if(!(p-&gt;next)||j&gt;i-1)//i&lt;1或者i&gt;ListLength(L)时,删除位置无效 &#123; printf(&quot;删除位置无效！！！\\n&quot;); return false; &#125; q=p-&gt;next; p-&gt;next=q-&gt;next; free(q);//释放空间 return true;&#125;//查找函数 按值查找 查找第一个等于e的结点 成功返回该结点指针，否则返回NULLLNode *LocateElem(LinkList L,ElemType e)&#123; LNode *p=L; while(p&amp;&amp;(p-&gt;data!=e)) &#123; p=p-&gt;next; &#125; return p;&#125;//**************************功能实现函数**************************////遍历输出函数void PrintList(LinkList L)&#123; LinkList p=L-&gt;next;//跳过头结点 if(ListLength(L)) &#123; printf(&quot;当前单链表所有元素:&quot;); while(p) &#123; printf(&quot;%d &quot;,p-&gt;data); p=p-&gt;next; &#125; printf(&quot;\\n&quot;); &#125; else &#123; printf(&quot;当前单链表已空！\\n&quot;); &#125;&#125;//插入功能函数 调用ListInsert后插void Insert(LinkList &amp;L)&#123; int place;ElemType e;bool flag; printf(&quot;请输入要插入的位置(从1开始)及元素:\\n&quot;); scanf(&quot;%d%d&quot;,&amp;place,&amp;e); flag=ListInsert(L,place,e); if(flag) &#123; printf(&quot;插入成功！！！\\n&quot;); PrintList(L); &#125;&#125;//删除功能函数 调用ListDelete删除void Delete(LinkList L)&#123; int place;bool flag; printf(&quot;请输入要删除的位置(从1开始):\\n&quot;); scanf(&quot;%d&quot;,&amp;place); flag=ListDelete(L,place); if(flag) &#123; printf(&quot;删除成功！！！\\n&quot;); PrintList(L); &#125;&#125;//查找功能函数 调用LocateElem查找void Search(LinkList L)&#123; ElemType e;LNode *q; printf(&quot;请输入要查找的值:\\n&quot;); scanf(&quot;%d&quot;,&amp;e); q=LocateElem(L,e); if(q) &#123; printf(&quot;找到该元素！\\n&quot;); &#125; else printf(&quot;未找到该元素！\\n&quot;);&#125;//菜单void menu()&#123; printf(&quot;********1.后插 2.删除*********\\n&quot;); printf(&quot;********3.查找 4.输出*********\\n&quot;); printf(&quot;********5.退出 *********\\n&quot;);&#125;//主函数int main()&#123; LinkList L;int choice; InitList(L); while(1) &#123; menu(); printf(&quot;请输入菜单序号：\\n&quot;); scanf(&quot;%d&quot;,&amp;choice); if(choice==5) break; switch(choice) &#123; case 1:Insert(L);break; case 2:Delete(L);break; case 3:Search(L);break; case 4:PrintList(L);break; default:printf(&quot;输入错误！！！\\n&quot;); &#125; &#125; return 0;&#125;","path":"page/datastructure02.html","date":"02-10","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://xiaoliblog.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"数据结构💰数据结构绪论","text":"数据结构绪论 数据结构在学什么? 如何用程序代码把现实世界的问题信息化 如何用计算机高效地处理这些信息从而创造价值 数据结构基本概念 数据 数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料 数据元素、数据项 数据元素是数据的基本单位，通常作为一一个整体进行考虑和处理。一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位 结构 各个元素之间的关系 数据结构、数据对象 数据结构是相互之间存在一种或多种特定关系的数据元素的集合 数据对象是具有相同性质的数据元素的集合，是数据的一个子集 数据类型、抽象数据类型 数据类型是一个值的集合和定义在此集合上的一组操作的总称 原子类型。其值不可再分的数据类型 结构类型。其值可以再分解为若干成分(分量)的数据类型 抽象数据类型(Abstract Data Type，ADT) 是抽象数据组织及与之相关的操作 数据结构三要素逻辑结构 集合 各个元素同属一个集合，别无其他关系 线性结构 数据元素之间是一对一的关系。除了第一个元素，所有元素都有唯一前驱;除了最后一个元素，所有元素都有唯一后继 树形结构 数据元素之间是一对多的关系 图结构 数据元素之间是多对多的关系 存储结构 存储结构也叫物理结构 顺序存储 把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现 链式存储 逻辑上相邻的元素在物理位置上可以不相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系 索引存储 在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是(关键字，地址) 散列存储 根据元素的关键字直接计算出该元素的存储地址，又称哈希(Hash)存储 数据的运算 数据的运算 施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的，指出运算的功能;运算的实现是针对存储结构的，指出运算的具体操作步骤。 算法算法的基本概念程序=数据结构+算法 数据结构 如何把现实世界的问题信息化，将信息存进计算机。同时还要如何处理这些信息，以实现对数据结构的基本操作 算法 如何处理这些信息，以解决实际问题 算法的特性 有穷性 一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成 算法必须是有穷的，而程序可以是无穷的 确定性 算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出 可行性 算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现 输入 一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合 输出 一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量 “好”算法的特性 正确性：算法应能够正确地解决求解问题 可读性：算法应具有良好的可读性，以帮助人们理解 健壮性：输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果 高效率与低存储量需求 高效率：执行速度快。时间复杂度低 低存储量需求：不费内存。空间复杂度低 算法效率的度量 算法时间复杂度 算法时间复杂度 事前预估算法时间开销T(n)与问题规模n的关系(T表示“time”,算法时间开销和问题规模呈现一定的函数关系 ) 算法时间复杂度表示 常用公式 加法规则举例：T3(n)=O(n3)+O(n2)+9999999，取最高阶为O(n3) 由于n3阶数更高，所以根据加法规则，T3(n)=O(n3) 只考虑阶数，用大O记法表示，忽略常数部分 当有好几千行代码时 顺序执行的代码只会影响常数项，可以忽略 只需挑循环中的一个基本操作分析它的执行次数写n的关系即可 如果出现嵌套循环 只需关注最深层循环循环了几次 三种时间复杂度 最坏时间复杂度：最坏情况下算法的时间复杂度 平均时间复杂度：所有输入示例等概率出现的情况下，算法的期望运行时间 最好时间复杂度：最好情况下算法的时间复杂度 小练习 算法空间复杂度 空间复杂度 空间开销(内存开销)与问题规模n之间的关系 函数调用内存开销 参考👉👉👉2020 王道考研 数据结构||数据结构（严蔚敏版）与算法的实现（含全部代码）","path":"page/datastructure01.html","date":"02-10","excerpt":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://xiaoliblog.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"计算机网络🌈应用层","text":"应用层概述 两种常用的网络应用模型客户/服务器模型（Client/Server） P2P模型（Peer-to-Peer） 网络健壮性指的是P2P模型不容易坏掉，即使一个节点坏了也没问题，可以有其他节点代替 域名系统协议（DNS） DNS就是将打在地址栏的域名转化为IP地址的东西 域名 域名服务器（DNS服务器） DNS服务器有很多台，根据层次结构分为三层，根域名服务器，顶级域名服务器，权限域名服务器 本地域名服务器不算层次结构，特点是里主机比较近，当主机和另一台比较近的主机通信时，就不用走哪些更高级的服务器了 根域名服务器并不是一个域名只有一台，而是一个域名对应多台域名服务器，全世界一共有13个这样的域名，分别是a.rootservers.net，b.rootservers.net，c.rootservers.net，~m.rootservers.net 在权限域名服务器中，虽然看似abc.com比y.abc.com少了一位，但是他们的地位仍是对等的，对应的两台权限域名服务器 域名解析过程 递归查询 在上图中，主机先是想本地域名服务器发送请求，如果查不到的话， 本地域名服务器向根域名服务器发送请求（找别人），如果还是查不到的话， 根域名域名服务器向顶级域名服务器发送请求（找别人），如果还是查不到的话， 顶级域名服务器向权限域名服务器发送请求（找别人） 可以看到每一次向下一个查询的服务器都变了，不是主机一个个去问，而是服务器自己一个个问下去，靠别人 迭代查询 在上图中，主机先是想本地域名服务器发送请求，如果查不到的话， 本地域名服务器就让主机去向根域名服务器发送请求（主机去找，本地域名给目标根域名服务器的IP地址），如果还是查不到的话， 根域名域名服务器让主机去向对应的顶级域名服务器发送请求（主机去找，根域名给目标顶级域名服务器的IP地址），如果还是查不到的话， 顶级域名服务器让主机去向权限域名服务器发送请求（主机去找，顶级域名给目标权限域名服务器的IP地址） 可以看到这里是主机一个个挨个问的地址，靠自己 高速缓存 为了减少多次查询同一个域名的资源浪费，本地域名服务器会存储最近使用的ip地址解析，下次再访问同一个域名就不需要这么多查询步骤了。同时这个高速缓存主机本身也有存储 同时本地域名服务器还可以对顶级域名服务器，权限域名服务器的地址进行缓存，下一次即使是不知道的ip地址，查询也可以更快 高速缓存为了保持正确性，需要定时更新 文件传输协议 文件传送协议FTP ( File Transfer Protocol)：提供不同种类主机系统(硬、软件体系等都可以不同)之间的文件传输能力 简单文件传送协议TFTP (Trivial File Transfer Protocol)是一个轻量的，比较容易实现的，面对小文件的，UDP的文件传输协议 FTP的服务端和客户端 FTP的工作原理 为什么有匿名登陆? 对于一些公共服务器来说，增加验证阶段就是增加资源开销，减少验证阶段就可以节省资源来更好地服务 主进程和从属进程的区别 主进程是打开端口，让外部发送的数据可以进来，并且将这些数据逐个分配各从属进程。从属进程则是单独为这些数据服务 先注释一下这里的主进程被忽略掉了，只是没标在上面，不是没有啊 这里客户端和服务器端先建立TCP连接，端口是21，称为控制连接 然后看情况是主动建立连接还是被动建立连接 主动建立连接是指服务器端主动发送请求和客户端进行连接，此时端口号固定是20 被动连接是指客户端发送请求和服务器端建立数据传送连接，此时端口号是不确定，有两者协商得到 数据传输完成之后，数据连接断开，控制连接继续保持，直至两边发送断开请求 FTP传输模式 文本模式: ASCII模式，以文本序列传输数据 二进制模式: Binary模式，以二进制序列传输数据 电子邮件概述电子邮件的格式 电子邮件系统的组成结构 用户代理的四个功能解释： 撰写就是给用户编辑信件的环境 显示就是可以看到自己写的和自己收的信件内容 处理就是对信件进行操作，包括删除，打印，转发等等 通信就是可以将邮件发送到邮件服务器当中，同时可以从邮件服务器当中读取邮件 邮件服务器的功能注释 邮件服务器端的发送和接受是指从自己的用户代理处接收邮件，之后向对面的邮件服务器发送邮件 邮件服务器的报告邮件发送结果就是投递是否成功这种情况 邮件服务器既可以作为客户端又可以作为服务器端，使用的是C/S方式 协议的功能注释 发邮件用的是SMTP 收邮件的是POP3或者IMAP 邮件协议简单邮件传送协议SMTP 注意一下，这里STMP客户和服务器不是固定死的，可以也可以成为服务器，服务器也可以成为用户，由发送方和接收方决定，发送方就是客户，接收方就是服务器 可以看见这里比如 12345220 service ready250 OK421 service not available550 xxx354 xxx 都是应答信息 这里RCPT能有多条命令的原因是，电子邮件可以有多个收件人，就是群发，所以允许多个RCPT 再强调一下，这里服务器和客户端可以互换，视具体情况而定，发送方是客户端，接收方是服务器端 改进SMTP缺点的MIME协议 MIME改善SMTP发送数据的缺点，是SMTP的功能性扩展 MIME协议已经逐渐开始应用到浏览器当中，通过对不同文件类型用不同的标识符标识，来让浏览器读取通过MIME的相关文件 邮局协议POP3 这里接收方是客户端，邮件服务器是服务器端 POP3确实很简单，但是有不少缺点，比较难受的就是邮件一旦下载就自动删除了 比较复杂的读取邮件的IMAP协议 基于万维网的电子邮件 与之前的不同的地方就是，基于万维网的电子邮件的邮件服务器端可以不同 同时，发送邮件使用的SMTP/MIME和收邮件时的POP3/IMAP协议都换成了HTTP协议 万维网和HTTP协议万维网概述 URL用来标识整个互联网当中的某一个资源（文字，视屏，音频等）的位置 HTTP用来将这些资源传送给用户 HTML帮助设计者来设计页面，让不同设计者设计的页面都可以在界面上显示 HTTP协议HTTP协议的过程下面这张图里讲了HTTP的具体过程 服务器通过TCP 80端口来监听HTTP请求 注意HTTP可以不一次性下载完页面的所有资源，可以只下载文本部分，其他音频视频等待用户下一步请求之后再传输 HTTP协议的特点 HTTP的连接方式 非持久连接在TCP三次握手的第三次握手时发生，将HTTP请求作为第三次握手的数据部分发给服务器，服务器收到请求之后将HTTP相应报文传输给客户。耗时就是RTT*2+文档传输时间。 缺点就是这样如果再想传输，那么就需要重新建立TCP连接从头开始 持久连接和非持久连接类似，都是在第三次握手时发生，将HTTP请求作为第三次握手的数据部分发给服务器，服务器收到请求之后将HTTP相应报文传输给客户。但是持久连接再需要请资源的时候就不需要建立新的TCP连接了 持久连接的两种方式——非流水线和流水线 非流水线就是发一个，确认一个，才能再发下一个 流水线就是一个个连着发，然后多个确认 HTTP的报文结构 开始行用于区别请求报文和响应报文。可以明显的看到两者第一行的东西都不一样 请求报文的方法是指命令，就是对所请求的对象进行什么操作，如获取/删除等等 URL就是之间说的资源标识符 版本是指使用的是什么版本的HTTP协议 CRLF相当于我们程序里面的；标识一行的结束。同时，在整个首部行结束时，为了区别首部行和实体主体还会有一行单独的CRLF 这里举了请求报文的例子，和一些常用的状态码","path":"page/net06.html","date":"02-08","excerpt":"","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://xiaoliblog.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机网络🌈传输层","text":"传输层概述传输层的意义 网络层可以把数据从一个主机传送到另一个主机，但是没有和进程建立联系 传输层就是讲进程和收到的数据联系到一起，使数据能够为应用层服务，所以说传输层是主机才有的层次 传输层的功能 传输层提供进程和进程之间的逻辑通信 复用和分用 传输层对收到的报文进行差错检测 传输层的两种协议 传输层的两个协议 传输层协议 说明 特点 面向连接的传输控制协议TCP 传送数据之前必须建立连接，数据传送结束后要释放连接。不提供广播或多播服务。由于TCP要提供可靠的面向连接的传输服务，因此不可避免增加了许多开销:确认、流量控制、计时器及连接管理等。 可靠，面向连接，时延大，适用于大文件。 无连接的用户数据报协议UDP 传送数据之前不需要建立连接，收到UDP报文后也不需要给出任何确认。 不可靠，无连接, 时延小，适用于小文件 传输层的寻址和端口 端口号只用于计算机分辨本地进程，总共有216=65536种端口号，端口号有很多种，不能随便使用 常见的应用程序端口号 UDP协议UDP概述 UDP只在IP数据报服务之上增加了很少功能，即复用分用和差错检测功能。 UDP的主要特点: UDP是无连接的，减少开销和发送数据之前的时延。 UDP使用最大努力交付，即不保证可靠交付。 UDP是面向报文的，适合一次性 传输少量数据的网络应用。 UDP无拥塞控制， 适合很多实时应 UDP首部开销小，8B， TCP20B。 UDP首部格式 UDP的校验位构成 这里的伪首部只是用来计算检验和的，计算完了就丢弃，可以见下UDP的校验方式 UDP校验方式 在发送端的时候 就是将每一行（4字节）拆成两部分，左右平均2字节大小，将这两字节数据写成二进制，那么2字节一共就需要2*8=16位。此时检验和没有计算，默认填充0，同时如果数据字段不整齐，则用0补齐，这样就可以写出几十行二进制数，如图中方所示 计算着几十行二进制数按二进制反码运算求和，二进制反码运算可以参考二进制反码求和运算，得到的最后简介再反码，之后将反码之后的放入原来的检验和字段 在接收端的时候 与发送端的时候不同的是，此时检验和字段不是0了 按照发送端的步骤再将所有数据写成二进制进行二进制反码运算求和 如果最后得到结果全1就是没问题，否则丢弃 TCP协议TCP协议的特点 TCP必须要建立连接之后才可以进行数据交换，所以TCP是面向连接的 TCP传输数据是随机切割数据的 TCP报文段的首部 见上图，可以看到TCP是将数据随机分割后加上TCP头传输的 所以序号就是为了标记这些随机分割之后的数据，这里把第一个字节的编号当成序号 确认号就是收到之后做一下标记，代表这之前的都收到了，希望收到的下一个编号的数据就是确认号打头的那个数据 偏移量就是为了标记一下距离TCP开始多少字节是数据，这里的单位是4B，这个偏移量就是TCP首部长度 窗口就是接收方告诉发送方，还有多少地方（缓存）可以放数据 紧急指针就是告诉TCP从哪里到哪里是紧急数据 TCP的六个控制位 TCP连接管理 TCP连接传输三个阶段: 连接建立 数据传送 连接释放 TCP连接的建立采用客户服务器方式，主动发起连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫服务器 TCP三次握手（建立连接） 第一段的意思是 SYN=1：(A)要建立连接了！ seq=x（随机）：因为还没有数据，所以写什么都无所谓 第二段的意思是 SYN=1：我(B)同意你(A)建立连接！ ACK=1：连接建立了，之后的ACK必须都置为1 seq=y（随机）：因为还没有数据，所以写什么都无所谓 ack=x+1：之前发送方(A)说发送的是第x位数据（虽然发送方是瞎说的），所以我(B)要的是x+1位数据 第三段的意思是 SYN=0：SYN只有在建立连接时才为1，其他时候均设为0 ACK=1：连接建立了，之后的ACK必须都置为1 seq=x+1：我(A)发送的报文段的第一个字节就是x+1 ack=y+1：之前接收方(B)说发送的是第y位数据（虽然接收方是瞎说的），所以我(A)要的是y+1位数据 注意一下，TCP是双向的，所以不存在绝对不变的发送方接收方，这里的两台主机都同时是发送方和接收方 TCP三次握手特定导致的SYN洪泛攻击 TCP四次挥手（连接释放） 第一段的意思是 FIN=1：(A)要释放连接了！ seq=u：发了好多数据，这里只是用u指代一下，这里u是有确定值的 第二段的意思是 ACK=1：连接建立了，之后的ACK必须都置为1 seq=v：发了好多数据，这里只是用v指代一下，这里v是有确定值的 ack=u+1：之前发送方(A)说发送的是第u位数据，所以我(B)要的是u+1位数据（尽管此时A已经决定释放连接了） 第三段的意思是 FIN=1：(B)要释放连接了！ ACK=1：连接建立了，之后的ACK必须都置为1 seq=w：发了好多数据，这里只是用w指代一下，这里w是有确定值的 ack=u+1：之前发送方(A)说发送的是第u位数据，所以我(B)要的是u+1位数据（因为A直接不发数据了，所以第二段第三段的ack都是u+1） 第四段的意思是 ACK=1：连接建立了，之后的ACK必须都置为1 seq=u+1：之前发的数据时第u位数据，B也要第u+1位数据，所以我发第u+1位数据 ack=w+1：之前发送方(B)说发送的是第w位数据，所以我(A)要的是w+1位数据 为什么需要等待计时2MSL？ 因为这样可以保证B可以收到A的终止报文段进而进入关闭状态 比如说如果A的第四段报文丢失，那么等待一个MSL之后B就会重传第三段报文，花费小于1MSL之后A就会再收到第三段报文，之后就可以再次向B发送第四段报文提示B关闭连接 TCP可靠传输 TCP是提供可靠传输，UDP这种本身还是不可靠传输的就再靠应用层解决了 序号 就是TCP根据下方数据链路层的MTU（最大传输单元）来随即将数据切割成好几端并且进行编号 确认 发送方每一次发送数据之后都需要接收方进行确认。T- CP使用的是累计确认机制，就是从第一个丢失的字节开始请求丢失的报文段。如图中456丢失，78到达，但仍然请求发送的数据序号是4 重传 为什么要使用自适应算法？ 网络环境太复杂，路径又长又短，RTT设置短了照顾不了距离远的，RTT设置长了又导致网络利用率降低，所以使用RTTs TCP流量控制 简单来说就是接收方可以动态的发送信息告诉发送方发送窗口的大小。 接收方接受不过来了就让发送方发送窗口小点，这样发送方发送的速率就慢下来了，接收方就有时间处理它的数据了 接受方处理完了也可以发送请求让发送方发送窗口大点，这样发送方发送的速率就快起来了，接收方就可以处理更多数据而不是空闲等着收数据了 计时器 在本例子中，使用的累计确认机制（一次回复收到ack=201）和三次流量控制机制。 但是有一个情况就是，如果最后B不允许A再发送数据了，B在处理完数据之后想要恢复窗口大小时发送的有rwnd大小的数据报丢了怎么办？此时A有B的指令在前，发送窗口为0无法发送数据，B也在等待A回复，造成了类似死锁的现象 解决方法：使用计时器 TCP拥塞控制流量控制是对单独一个来说的，拥塞控制是一群 拥塞控制四种算法这里虽然是四种算法，但是通常是两两结合进行使用 慢开始和拥塞避免 这里开始时以指数形式增长，ssthresh的意思是慢开始门限，代表从这个地方注入的报文段就比较多了，需要开始慢速增加了。 之后一段都是线性增长，每次增加1，直至达到网络拥塞状态 瞬间将cwnd设置为1，同时调整原来的ssthresh的值到之前达到网络拥塞状态的1/2,（这里是24降到12） 重复以上步骤，但是注意此时ssthresh变了之后线性增长的转折点也变了 快重传和快恢复 这里和上面的慢开始和拥塞避免的一开始步骤差不多，都是先指数增长再转变为线性增长。 不同的点是快重传和快恢复算法是在收到连续的ack确认之后执行，这里的ack就是冗余ack，冗余ack的特点是如果多次对某一段请求的数据没有被收到，达到一定数目之后就会立即执行重传。但是此时只是降到现在cwnd的一半，再重新线性增长。而不是像慢开始和拥塞避免的从头开始","path":"page/net05.html","date":"02-08","excerpt":"","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://xiaoliblog.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机网络🌈网络层","text":"网络层概述 主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务 网络层传输单位是数据报 数据报和分组的关系：分组是一段比较长的数据，将它进行切割成一段段之后就得到数据报 网络层功能 路由选择与分组转发最佳路径：就是让数据在路由器之间走最佳的路径 异构网络互联：就是让不同的设备（手机，电脑，平板等）都能正常连接 拥塞控制：若所有结点都来不及接受分组，而要丢弃大量分组的话，网络就处于拥塞状态。因此要采取一定措施,缓解这种拥塞。 开环控制就是在拥塞之前就提前设计解决 闭环控制就是在拥塞时自动调整解决问题 OSI参考模型 各层次的传输单元 应用层 报文 传输层 报文段 网络层 IP数据报，分组（如果IP数据报太大就切割成分组） 数据链路层 帧 物理层 比特流 数据交换方式 为什么要进行数据交换？因为每个节点之间都拉网线太麻烦了也不实际，所以通过大量交换设备互联进行数据交换 电路交换 常见的例子：打电话 链路支持多路复用（可参考数据链路层的TDM等） 特点是独占资源，因为两者建立了连接 报文交换 报文发送的过程 源先根据报文加上ip地址，物理地址等，通过物理层发送 交换机收到报文之后，先进行存储，等待链路空闲之后进行转发，但是转发的路径不是固定的，是比较随机的 最后通过许多交换机最终到达目的地 分组交换 分组交换和报文交换基本相同，就是将报文切割之后再进行发送 方式的选择 数据报与虚电路 数据报与虚电路方式是分组交换的两种形式 数据报方式为网络层提供无连接服务 无连接服务:不事先为分组的传输确定传输路径，每个分组独立确定传输路径，不同分组传输路径可能不同 虚电路方式为网络层提供连接服务 连接服务:首先为分组的传输确定传输路径(建立连接)，然后沿该路径(连接)传输系列分组，系列分组传输路径相同，传输结束后拆除连接 路由算法和路由协议 路由算法就是让路由知道收到报文之后下一步怎么走 AS就是多个路由器之间构成的单独的小圈子，圈子内使用自己的协议，圈子和圈子之间用的是BGP协议 RIP协议和距离向量算法RIP协议概述通过交换信息构建路由表 如何建立路由表 距离向量算法 为什么改地址？ 因为图中是从x得到的信息 为什么距离固定+1？ 因为路由器只从相邻路由器之间获取RIP报文，举例只会是1 为什么下一跳是x就要替换？ 因为网络环境不断变化，可能这次某个节点挂掉，所以保持最新的 为什么下一跳不是x时有更新和不处理两种手段？ 因为这样可以提高效率，比原来快就换，比原来慢就保留原来的，也可以理解 RIP协议报文格式 RIP协议特点 RIP协议来回更新路由表，错误信息被覆盖，导致直至达到距离上限强制错误时才可以得知出错 OSPF协议和链路状态算法OSPF协议概述 链路状态路由算法 OSPF区域 OSPF分组 OSPF其他特点 BGP协议BGP协议概述 BGP协议交换信息的过程 BGP所交换的网络可达性的信息就是要到达某个网络所要经过的一系列AS。当BGP发言人互相交换了网络可达性的信息后，各BGP发言人就根据所采用的策略从收到的路由信息中找出到达各AS的较好路由。 BGP协议报文格式 BGP是应用层协议 BGP协议特点 BGP四种报文 三种路由协议的笔记 RIP是一种分布式的基于距离向量的内部网关路由选择协议，通过广播UDP报文来交换路由信息。 OSPF是一个内部网关协议，要交换的信息量较大，应使报文的长度尽量短，所以不使用传输层协议(如UDP或TCP)，而是直接采用IP BGP是一个外部网关协议，在不同的自治系统之间交换路由信息，由于网络环境复杂，需要保证可靠传输，所以采用TCP IP数据报IP数据报格式 名称 注释 大小 版本 Version ipv4或者ipv6 4位 首部长度 IHL 此处数值再乘以4才是真正大小，同时因为IP数据报固定长度为20字节，所以此处最小值为5，即二进制的0101 4位 区分服务 DSCP + ECN 希望获得哪种服务，用的比较少 8位 总长度 Total Length 首部+数据的长度，最大为2^16-1=65535 16位 标识 Identification 用来表示是哪一个数据报的分片，不同的分片标识各不相同 8位 标志 Flags 用来表示是否分片和分片是否结束 3位，但实际有用的只有后两位 片偏移 Fragment Offset 用来标记分片之后，该分片在原来的数据报的位置，以8字节为单位 13位 生存时间 Time To Live 即TTL，没经过一个路由器TTL-1,0时自动放弃，根据系统不同默认的TTL不同 8位 协议 Protocol 用来标记协议名的字段值，如TCP,UDP,ICMP等等 8位 首部检验和 Header Checksum 检验首部的字段是否出错，出错就丢弃此数据报 源地址 Source IP Address 发送方ip地址 32位 目的地址 Destination IP Address 接收方ip地址 32位 可选字段 Options 用来排错等安全检测 未知，可在0-40位之间 填充 将数据报对齐成4字节的整数倍，数值全部为0 未知，根据可选字段来定 IP数据报分片 最大传送单元MTU：链路层数据帧可封装数据的上限。例如以太网的MTU是1500字节。 如果所传送的数据报长度超过某链路的MTU值，就需要引入分片 IP概述IPv4 全球唯一的表示某一个主机或者路由器接口的编码 IP编制的方法 分类的IP地址 子网的划分 构成超网(无分类编址方法)、 IP地址分类 特殊IP地址 私有IP地址 私有IP地址也叫本地IP地址， 为什么A类最大是126.xxx.xxx.xxx？ 因为网络号最开始第一位是0，一共八位，所以二进制表示位0xxxxxxx，最大就是27-1=127，但是因为127.xxx.xxx.xxx是特殊ip地址，所以将其去掉 为什么B类最大是191.255.xxx.xxx？ 因为网络号最开始第一位是10，一共八位，所以二进制表示位10xxxxxx，最大就是10111111=191，最小就是10000000=128，无特殊ip地址 为什么C类最大是223.255.xxx.xxx？ 因为网络号最开始第一位是110，一共八位，所以二进制表示位110xxxxx，最大就是11011111=223，最小就是10000000=192，无特殊ip地址 网络地址转换NAT 路由器对目的地址是私有IP地址的数据报一律不进行转发 连接内网和外网，就是找个代理的用它的ip地址与外面收发数据 NAT需要构建NAT转换表，既要存广域网（WAN，外网）也要存局域网（LAN，内网）的ip地址和端口号 子网划分和子网掩码子网划分 分类的IP地址的弱点 IP地址空间的利用率有时很低 两级IP地址不够灵活。 总结：就是IP不够用，需要额外整个子网扩展IP，所以引出子网划分 子网掩码 子网掩码就是用来和IP地址一起计算子网的地址的 子网掩码逐位写成二进制然后而原来IP地址进行与运算，就可以得到子网IP地址 因为255是11111111，所以如果写着255的话，IP地址和子网IP地址对应的地方的数值就相同 子网掩码习题1 IP地址与子网掩码相与，72对应二进制：0100 1000 ，192对应二进制： 1100 0000，相与得到： 0100 0000（64），网络地址为：141.14.64.0 如果子网掩码为255.255.224.0，所求的网络地址也是141.14.64.0 可以看出来，即使子网掩码不同，相同IP地址对应的子网IP地址也可能相同，但是子网掩码不同，划分的子网数目不同 为什么划分的子网数目不同？或者说怎么算划分的子网位数目？ 以255.255.192.0为例，255是11111111即八个1,192是11000000即2个1，一共是82+2=18个1，一共有32位地址，所以剩余有32-18=14位 以255.255.224.0为例，255是11111111即八个1,224是11100000即3个1，一共是82+3=19个1，一共有32位地址，所以剩余有32-19=13位 子网掩码习题2 这道题先将255.255.252.0计算出一共有8+8+6=22位网络号位，所以就有32-22=10位主机号位 将180.80.77.55解析，可以知道在77部分某部分开始会用来表示主机号位 77的二进制是0100 1101，因为一共有22位网络号位，所以010011 （此处分开） 01，从这个01开始是主机号位。 所以用来表示子网ip地址的应该是180.80.76（010011 00）.xxx PS注意76括号内后两位二进制00 但是本体是发布广播地址，所以主机号全部都要是1，所以应该是180.80.79（010011 11）.255（11111111）注意79括号内后两位二进制11 这里特定主机路由就是指找特定的处理这里这个ip地址的路由 默认路由会将这个数据报发给另一个路由，直至找到对应的路由，或者TTL耗尽被丢弃 无分类编制CIDR 使用CIDR可以聚合网络 如图，通过缩短前缀，R1和R2就可以合并在206.1.0.0/16的子网下 但是这样转发表之中就会有多个匹配结果，所以我们使用最长前缀匹配 最长前缀匹配就是在计算后符合同一子网的时候，选前缀越长的，这道题选B 因为本网络是192.168.5.0/24，就是192.168.5.（0000 0000）/24，将248写成二进制是11111 000，有五个1，所以前五位都可以作为子网的编号，剩下的三位就是用来分配子网内剩余的地址了，因为不能全0或者全1，所以还要减2 ARP协议 DHCP协议 ICMP协议ICMP协议概述 ICMP，IGMP处于网络层和传输层之间，就是为了更好地转发IP数据报和提高交互成功的几率 ICMP差错报告报文ICMP差错报告报文如何与IP数据报结合 五种ICMP差错报告报文 终点不可达:当路由器或主机不能交付数据报时就向源点发送终点不可达报文。（无法交付） 源点抑制（已取消）:当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢。（拥塞丢数据） 时间超过：当路由器收到生存时间TTL=0的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。（TTL=0） 参数问题：当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。（首部字段有问题） 改变路由(重定向) ：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器(可通过更好的路由)。（值得更好的路由） 四种不发送ICMP差错报文的情况 对ICMP差错报告报文不再发送ICMP差错报告报文。 对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文。 对具有组播地址的数据报都不发送ICMP差错报告报文。 对具有特殊地址(如127.0.0.0或0.0.0.0)的数据报不发送ICMP差错报告报文。 ICMP询问报文 四种ICMP询问报文 回送请求和回答报文主机或路由器向特定目的主机发出的询问，收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。测试目的站是否可达以及了解其相关状态。 时间戳请求和回答报文请某个主机或路 由器回答当前的日期和时间。用来进行时钟同步和测量时间。 掩码地址请求和回答报文 路由器询问和通告报文 后两种是掩码地址请求和回答报文，路由器询问和通告报文，这两个已经废弃不再使用 ICMP的应用 ping命令：测试两个主机之间连通性，使用了ICMP回送请求和回答报文 traceroute命令：跟踪一个分组从原点到终点的路径，使用了ICMP时间超过差错报告报文 traceroute命令讲解 IPV6 IPv6的出现：IPV4地址用完了，从根本上增加IP地址数目，之前讲的NAT和CIDR也只是在IPV4的基础上扩展了IPV4地址数目，治标不治本 IPV6地址表示形式 IPV6数据报格式 名称 作用 位数 版本 Version 知名协议版本，此处因为是ipv6所以总是6 4位 优先级 Traffic Class 又来区分数据报的类型和优先级 8位 流标签 Flow Label 和ipv4标识某个数据报分片不同，这是对于一整个数据报流的标记 19位 有效载荷长度 Payload Length 指的是扩展首部+数据部分的大小，和ipv4的总长度和首部长度都不同，ipv6的首部长度是固定的40字节 16位 下一个首部 Next Header 基本首部的下一个首部指的是有效载荷里标记的的扩展首部，有效载荷里的扩展首部再指向有效载荷里标记的的扩展首部，直至最后指向数据 8位 跳数限制 Hop Limit 基本相当于ipv4当中的TTL，每到一个路由器-1.减到0时丢弃 7位 源地址 Source Address 发送方ipv6地址 128位 目标地址 Destination Address 接收方ipv6地址 128位 IPV4和IPV6的区别 IPV6基本地址类型 名称 作用 要求 单播 一对一通信 可做源地址，目的地址 多播 一对多通信，以前的广播地址当做覆盖所有主机的多播 可做目的地址 任播 一对多当中的一个通信，看似一对多，实则一对一 可做目的地址 IPV4和IPV6之间的过渡如果是IPV6的数据报到了IPV4，就用IPV4重新封装，把IPV6数据报前面加上IPV4伪装成IPV4数据报继续传输，直至到了IPV路由再解开IPV4伪装 IP组播（多播）IP组播概述IP数据报的三种传输方式 单播用于发送数据包到单个目的地，且每发送一份单播报文都使用一个单播IP地址，作为目的地址。是一种点对点传输方式 广播是指发送数据包到同一广播域或子网内的所有设备的一-种数据传输方式，是一种点对多点传输方式 组播（多播）：当网络中的某些用户需要特定数据时,组播数据发送者仅发送一-次数据，借助组播路由协议为组播数据包建立组播分发树，被传递的数据到达距离用户端尽可能近的节点后才开始复制和分发，是一种点对多点传输方式 单播所占资源多 组播明显减轻了压力 IP组播地址 硬件组播 就像全F的mac地址代表广播一样，00-10-5E打头的MAC地址就代表组播 7为什么最大是00-10-5E-7F-FF-FF？ 因为只有最后23位决定 IGMP协议 IGMP只能知道有没有组播组成员，对有几个组播组成员，成员在哪个地方都不知道 组播路由选择协议 有了这个，成员可以自行找到转发组，自行决定参加哪个组播（就像电视机选台一样） 组播路由选择协议常使用的三种算法: 基于链路状态的路由选择 基于距离-向量的路由选择 协议无关的组播(稀疏/密集) 移动IP移动IP不等于动态IP（DHCP获得的）移动IP的可以让用户因为地理原因等等，即使不在内网也可以访问内网的东西 移动IP的相关术语 移动IP通信过程 网络层设备路由器路由器的构造 路由器输入输出端口构造 集线器，网桥，路由表几层设备比较 路由器的路由表和转发表","path":"page/net04.html","date":"02-07","excerpt":"","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://xiaoliblog.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机网络🌈数据链路层","text":"数据链路层概述基本概念 结点：主机、路由器 链路：网络中两个结点之间的物理通道，链路的传输介质主要有双绞线、光纤和微波。分为有线链路、无线链路 数据链路：网络中两个结点之间的逻辑通道，把实现控制数据传输协议的硬件和软件加到链路上就构成数据链路 帧：链路层的协议数据单元， 封装网络层数据报 数据链路层负责通过一条链路从一个结点向另一个物理链路直接相连的相邻结点传送数据报 基本功能概述 数据链路层在物理层提供服务的基础，上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。其主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造成为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。 功能一：为网络层提供服务。无确认无连接服务，有确认无连接服务，有确认面向连接服务。有连接一定有确认! 功能二：链路管理，即连接的建立、维持、释放(用于面向连接的服务)。 功能三：组帧。 功能四：流量控制。限制发送方哦~ 功能五：差错控制(帧错/位错)。 封装成帧与透明传输 封装成帧就是加将数据加头加尾，相当于将数据打包 透明传输就是为了防止特殊的数据无法正常传输的的情况的发生，比如说在封装成帧的过程中出现数据中的某些标记符与开始/结束标记符恰巧重复等等情况 透明传输的应用字符计数法 就是在帧的首部做计数，看看数据是否错误 缺点：如果在某一个帧内，标记位后面的某个字节的数据丢失，那么会影响后面的帧 比如3 1 1 和 4 2 2 2，如果前面的帧丢失变成 3 1，那么后面的4就会被补到前面变成 3 1 4导致错误 字符填充法 就是加头加尾分别标记开始结束，和零比特填充法（见下）对比，开始和结束的对应的字符不一样 但有可能出现数据内某段比特流数据正好与标记字段重复，从而导致误判断的情况 解决方法：添加转义字符，接收端删掉转义字符 零比特填充法 违规编码法 因为曼彻斯特编码不使用高-高，低-低来表示，所以如果使用高-高，低-低来表示帧起始和终止就不会与数据冲突 差错控制差错的出现 数据链路层的差错检测的是比特的错误 检错编码奇偶校验 缺点：只能检测出1，3，5，7…等等奇位数错误，检测成功率位50% 循环冗余码CRC 就是用传输数据除以生成多项式得到冗余码 阶数就是最高位是哪位，然后位数-1，如10011就是5-1=4,1011就是4-1=3 异或运算就是相同得0，不同得1，比如100和101做异或，结果就是001 除数和最后的余数添加到要发送的数据后面，称为帧检验序列FCS 接收方收到数据后进行检测 在数据链路层仅仅使用循环冗余检验CRC差错检测技术，只能做到对帧的无差错接收，即“凡是接收端数据链路层接受的帧，我们都能以非常接近于1的概率认为这些帧在传输过程中没有产生差错”。接收端丢弃的帧虽然曾收到了，但是最终还是因为有差错被丢弃。“ 凡是接收端数据链路层接收的帧均无差错”。 “可靠传输”：数据链路层发送端发送什么，接收端就收到什么。链路层使用CRC检验，能够实现无比特差错的传输，但这还不是可靠传输。 纠错编码-海明码 海明码:发现双比特错，纠正单比特错 第一步 确认校验码位数r 第二步 确定校验码和数据的位置 为什么是10为数据位？因为4位校验码+6位信息位=10位 校验码放到2的几次方的位置(1,2,4,8)，其他的地方按顺序放已知的信息位 第三步 求出校验码的值 先是通过二进制位确定有几位。本题中因为最大位10的二进制是1010，所以是4位，将其标注 然后从p1开始看，看p1的二进制位的数值和所有信息位的对应位置的数值是否相同，然后找出来这些位。这里有点难理解，这里以p1为例辅助理解,p1第四位为1，这里找出最后第四位为1来的就是P1,D1,D2,D4,D5 然后计算异或值，比如说这里D1=1,D2=0,D4=1,D5=0,就是p1要同时和0,1，0,1进行异或之后得到0 举例：0和1异或得1，1和0异或得1，1和1异或得0，那么p1和0异或得0，p1就是0了 其他同理，按顺序计算出P2，P3，P4，然后填入表格 第四步 检测并纠错 就是和上面一样，将所有校验位进行运算，得出的结果的值就是错误的位 流量控制和可靠传输 流量控制是为了让传输过程中的发送速度和接受速度匹配，减少传输出错与资源浪费 可靠传输是发送端发送什么，接收端就要受到什么 流量控制的方法 停止-等待协议 滑动窗口协议 后退N帧协议（GBN） 选择重传协议（SR） 停止等待协议（Stop-and-Wait）丢包：物理线路故障、设备故障、病毒攻击、路由信息错误等原因，会导致数据包的丢失。 为什么要有停止等待协议? 除了比特出差错，底层信道还会出现丢包问题，为了实现流量控制 研究停等协议的前提？ 虽然现在常用全双工通信方式，但为了讨论问题方便，仅考虑一方发送数据 (发送方)，一方接收数据(接收方)。 因为是在讨论可靠传输的原理，所以并不考虑数据是在哪一个层次上传送的。 “停止-等待” 就是每发送完-一个分组就停止发送，等待对方确认，在收到确认后再发送下一个分组。 停等协议有几种应用情况? 无差错情况&amp;有差错情况 停止等待协议的无差错情况 注释：因为一次就一个，所以用0和1标记ACK就行 停止等待协议的有差错情况 停止等待协议的特点 简单 信道利用率低。大部分时间数据都在路上，发送方很长时间闲置，资源浪费 后退N帧协议（GBN） 因为停止等待协议太浪费时间了，所以尝试采用GBN，发送连续多个数据帧，以增大信道利用率 累计确认：就是收到一个确认帧，那么它和它之前的所有帧都默认已收到，反之，如果某个确认帧没收到，那么它和它之后的所有帧都默认丢失（即使收到了也丢掉），进行重传 后退N帧协议（GBN）中的滑动窗口基本理解 GBN发送方必须响应的三件事 上层的调用上层要发送数据时，发送方先检查发送窗口是否已满，如果未满，则产生一个帧并将其发送;如果窗口已满，发送方只需将数据返回给上层，暗示上层窗口已满。上层等一会再发送。(实际实现中， 发送方可以缓存这些数据，窗口不满时再发送帧) 收到了一个ACKGBN协议中，对n号帧的确认采用累积确认的方式，标明接收方 已经收到n号帧和它之前的全部帧。 超时事件协议的名字为后退N帧/回退N帧，来源于出现丢失和时延过长帧时发送方的行为。就像在停等协议中一样，定时器将再次用于恢复数据帧或确认帧的丢失。如果出现超时，发送方重传所有已发送但未被确认的帧。 GBN接收方要做的事 如果正确收到n号帧，并且按序，那么接收方为n帧发送-个ACK，并将该帧中的数据部分交付给.上层。 其余情况都丢弃帧，并为最近按序接收的帧重新发送ACK。接收方无需缓存任何失序帧，只需要维护一个信息: expectedseqnum (下一个按序接收的帧序号)。 下图是一个实例 注释：此图发送2帧时丢失，所以接收方收到后面的帧也是直接丢弃并且发送最晚收到的有效帧1的ACK，直至2帧的超时重传机制被触发进行重传并得到ACK之后，接收方才会接受2帧以及后面的帧 发送窗口不能无限大，与使用的编号的比特数有关 比如2个比特，编号z为0，1，2，3，发送窗口尺寸应满足1&lt;=Wt&lt;=3 GBN的优缺点也显而易见，优点是提高了信道利用率，缺点是因为重传机制的原因导致已经收到数据却需要强行丢弃而造成浪费 GBN协议重点总结 累积确认(偶尔捎带确认) 接收方只按顺序接收帧。不按序无情丢弃 确认序列号最大的、按序到达的帧 发送窗口最大为2n-1。接收窗口大小为1 选择重传协议（SR） 为了解决GBN的缺点，我们打算尝试只重传错误的帧，这样的话就不用浪费资源吧已经收到的帧再重传一次了，解决办法：设置单个确认，同时加大接收窗口，设置接收缓存，缓存乱序到达的帧。 SR和GBN相比，两者都有窗口了，和GBN的区别其实就是做了一个数据缓存，已经收到的帧不用扔了，等待之前因意外丢失的帧收到的时候确认即可，但是只能缓存窗口尺寸内的包含的帧（PS，缓存咋可能无限大） 选择重传协议中的滑动窗口 SR运行过程 注释：2帧丢失之后仍然在发送，但是2帧丢失之后只是缓存，并没有移动窗口，直至最后2帧收到后一次性确认2-5帧 发送窗口最好等于接收窗口，WTmax=WRmax=2(2n-1) SR协议重点总结 对数据帧逐一确认。收一个确认一个 只重传出错帧 接收方有缓存 WTmax=WRmax=2(2n-1) 介质访问控制技术 传输数据使用的两种链路 点对点链路两个相邻节点通过一个链路相连，没有第三者。应用: PPP协议，常用于广域网。 广播式链路所有主机共享通信介质。应用：早期的总线以太网、无线局域网，常用于局域网。典型拓扑结构：总线型、星型(逻辑总线型) 介质访问控制的内容就是，采取一定的措施，使得两对节点之间的通信不会发生互相干扰的情况。 信道划分介质访问控制 频分多路复用FDM 时分多路复用TDM TDM的缺点就是利用率低，所以又衍生出了STDM 统计时分复用STDM STDM的原则是先到先走，满了就发，相对于TDM提高了利用率 波分多路复用WDM 码分多路复用CDM 假设A向C发送信号，B也向C发送信号 A的芯片序列是：00011011 ，A想发送1时，向量序列是：(-1,-1,-1,+1,+1,-1,+1,+1)，A想发送0时，取反为(+1,+1,+1,-1,-1,+1,-1,-1) B的芯片序列是：00101101 ，发送1时为(-1,-1,+1,-1,+1,+1,-1,+1)，发送0时为(+1,+1,-1,+1,-1,-1,+1,-1) 如何不打架：先看AB内积是否为0（相互正交），如果为0说明可以同时发送，AB={(-1,-1,-1,+1,+1,-1,+1,+1)*(-1,-1,-1,+1,+1,-1,+1,+1)}/8=0 如何合并：对应位相加就可以，比如A发送1，B发送0，则A+B=(0,0,-2,+2,0,-2,+2,0) 如何分离：比如C收到的芯片序列是：(0,0,-2,+2,0,-2,+2,0)，与原来A源序列(-1,-1,-1,+1,+1,-1,+1,+1)正交，{(0,0,-2,+2,0,-2,+2,0)*(-1,-1,-1,+1,+1,-1,+1,+1)}/8=0，0表示A发送给C的是1，如果为-1表示发送给C的是0 随机访问介质访问控制 所有用户都可以随机发送信息，发送时可以占用全部带宽，理论上个人使用时比静态分配信道的速度更快 ALOHA协议 纯ALOHA协议缺点：太随性，导致效率低 时隙ALOHA协议 相对于纯ALOHA协议就是固定了发送的时间（只能在一个时间片的开始），提高了效率 CSMA协议 名称 描述 优点 缺点 1-坚持CSMA 发送信息时监听信道，一空闲下来就立即传输，信道忙也一直监听，如果发送时冲突就等待随机时长之后再监听 立即发送，利用率高 如果多台设备同时监听，那么会发生冲突 非坚持CSMA 发送信息时监听信道，如果空闲就立即传输，信道忙就随机等待一段时间后再监听 冲突发生的几率减少 因为需要等待，所以利用率不高 p-坚持CSMA 发送信息时监听信道，空闲时以概率p进行传输，概率1-p不传输。信道忙就随机等待一段时间后再监听 冲突减少的同时效率也比较高 即使发生冲突也要坚持发送数据，资源被浪费 CSMA/CD协议 就是因为链路实际有长短，发送数据需要时间，这个时间内可能就被其他节点当成空闲状态导致发生碰撞 知道自己发生碰撞的最长时间是2τ（两倍的传播时延），就是一去一回 CSMA/CA协议 轮询访问介质访问控制 主要包括两大类，一个是轮询协议，另一个是令牌传递协议 轮询协议 就是选出一个代表，让他控制所有的传输 注释： 轮询开销在随着服务的节点越多，需要用于查询是否发送数据发送的数据帧也就越多，会造成一定开销 等待延迟就是因为这是轮流“邀请”，所以难免某个节点需要发送数据，但是主节点还在较远的需要里有需求的节点那边，导致需求得不到立即响应 单点故障很好理解，就是代表挂了 令牌传递协议 在节点之间没有收发数据的需求时，令牌在节点之间循环 发送数据的流程 当一个节点需要时就可以获得这个令牌。然后修改这个令牌的状态（空闲-&gt;占用） 再将令牌与数据帧结合，让其在节点构成的环之间流动 不是目的地的节点收到令牌也不接受，直接略过，目标节点收到信息并复制一份到本地（传输完成），因为是个闭环，所以发送节点最后得到令牌 最后，发送令牌的节点对令牌的内容进行检查，如果发现数据出错还要重新发一遍问题基本和轮询协议相同 局域网 局域网(Local Area Network) : 简称LAN,是指在某一区域内由多台计算机互联成的计算机组，使用广播信道 特点 覆盖的地理范围较小，只在一个相对独立的局部范围内联，如一座或集中的建筑群内 使用专门铺设的传输介质(双绞线、同轴电缆)进行联网，数据传输速率高(10Mb/s~10Gb/s) 通信延迟时间短，误码率低，可 靠性较高 各站为平等关系，共享传输信道 多采用分布式控制和广播式通信，能进行广播和组播 决定局域网的主要要素为：网络拓扑，传输介质与介质访问控制方法 局域网主要因素 网络拓扑结构 常用的是总线型拓扑结构 传输介质 局域网 常用介质 有线局域网 双绞线，同轴电缆，光纤 无线局域网 电磁波 介质访问控制方法 方法 说明 CSMA/CD 常用于总线型局域网，也用于树型网络 令牌总线 常用于总线型局域网，也用于树型网络，它是把总线型或树型网络中的各个工作站按一定顺序如按接口地址大小排列形成一个逻辑环。只有令牌持有者才能控制总线，才有发送信息的权力 令牌环 用于环形局域网，如令牌环网 局域网的分类 IEEE802标准 IEEE 802系列标准是IEEE 802 LAN/MAN标准委员会制定的局域网、城域网技术标准(1980年2月成立)。其中最广泛使用的有以太网、令牌环、无线局域网等。这一系列标准中的每-一个子标准都由委员会中的一个专门工作组负责。 IEEE802描述的局域网参考模型 以太网以太网概念 以太网(Ethernet)指的是由Xerox公司创建并由Xerox、Intel和DEC公 司联合开发的基带总线局域网规范，是当今现有局域网采用的最通用的通信协议标准。以太网络使用CSMA/CD (载波 监听多路访问及冲突检测)技术。 以太网在局域网各种技术中占统治性地位: 造价低廉(以太网网卡不到100块) ; 是应用最广泛的局域网技术; 比令牌环网、ATM网便宜，简单; 满足网络速率要求: 10Mb/s~ 10Gb/s. 以太网两个标准 DIX Ethernet V2:第一个局域网产品(以太网)规约。 IEEE 802.3 : IEEE 802委员会802.3工作组制定的第-个IEEE的以太网标准。(帧格式有一丢丢改动) 以太网提供无连接、不可靠的服务 无连接:发送方和接收方之间无“握手过程” 不可靠:不对发送方的数据帧编号，接收方不向发送方进行确认，差错帧直接丢弃，差错纠正由高层负责 以太网只实现无差错接收，不实现可靠传输 以太网的发展 10BASE-T以太网 适配器和MAC地址 以太网MAC帧 这里的mac层指的是数据链路层 之前说过数据链路层将上一层ip数据包加头加尾头就是目标地址（6字节），源地址（6字节），类型（2字节）尾就是FCS（帧检验序列），（4字节） 前导码不是MAC帧的一部分，目的是使时钟同步 为什么数据长度时46~1500？ 因为有最小传输字节64字节，mac占用6+6+2+4=18，所以数据最小为64-18=46，1500则是规定的默认最大字节，没有理由 高速以太网 无线局域网 IEEE 802.11是无线局域网通用的标准，它是由IEEE所定义的无线网络通信的标准 无线局域网分类 有固定基础设施无线局城网 无固定基础设施无线局城网的自组织网络 广域网广域网概念 广域网(WAN, Wide Area Network)，通 常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个城市或国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络 广域网的通信子网主要使用分组交换技术。广域网的通信子网可以利用公用分组交换网、卫星通信网和无线分组交换网，它将分布在不同地区的局域网或计算机系统互连起来，达到资源共享的目的。如因特网(Internet)是世界范围内最大的广域网 PPP协议 PPP协议（Point-to-Point Protocol）是目前使用最广泛的数据链路层协议，拨号基本都是PPP协议 PPP协议仅支持全双工链路 PPP协议的要求 PPP协议需要满足的要求 说明 简单 对于链路层的帧， 无需纠错，无需序号，无需流量控制 封装成帧 帧定界符 透明传输 与帧定界符一样比特组合的数据应该如何处理:异步线路用字节填充，同步线路用比特填充 多种网络层协议 封装的IP数据报可以采用多种协议 多种类型链路 串行/并行， 同步/异步，电/光… 差错检测 错就丢弃 检测连接状态 链路是否正常工作 最大传送单元 数据部分最大长度MTU 网络层地址协商 知道通信双方的网络层地址 数据压缩协商 PPP协议无需满足的要求 纠错 流量控制 序号 不支持多点线路 PPP协议的组成部分 一个将IP数据报封装到串行链路(同步串行/异步串行)的方法。 链路控制协议LCP ：建立并维护数据链路连接。（身份验证） 网络控制协议NCP :：PPP可支持多种网络层协议，每个不同的网络层协议都要一个相应的NCP来配置，为网络层协议建立和配置逻辑连接。 PPP协议的状态图 PPP协议的帧格式 HDLC协议 高级数据链路控制(High-Level Data Link Control或简称HDLC)，是一个在同步网上传输数据、面向比特的数据铁路层协议，它是由国际标准化组织(ISO)根据IBM公司的SDLC(SynchronousData Link Control)协议扩展开发而成的. 数据报文可透明传输，用于实现透明传输的“0比特插入法”易于硬件实现 采用全双工通信 所有帧采用CRC检验，对信息帧进行顺序编号，可防止漏收或重份，传输可靠性高。 HDLC的三种站 HDLC的帧格式 PPP&amp;HDLC对比 链路层设备集线器（Hub） 可以扩展以太网，但是集线器会无脑将一个设备的所有消息转发到集线器所连的所有设备，故会将所连接的所有设备变成一个大的冲突域，同时只能有两台设备进行通信，且设备越多，冲突越多。由此诞生了网桥 网桥（Bridge） 使用网桥时，由于网桥会根据mac地址进行过滤，所以不会形成冲突域 两种网桥 透明网桥：”透明”指以太网上的站点并不知道所发送的帧将经过哪几个网桥，是-种即插即用设备自学习 源路由网桥：在发送帧时，把详细的最佳路由信息(路由最少/时间最短)放在帧的首部中。方法:源站以广播方式向欲通信的目的站发送一个发现帧 交换机 网桥接口越来越多，网桥就变成了交换机 冲突域和广播域","path":"page/net02.html","date":"02-06","excerpt":"","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://xiaoliblog.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机网络🌈物理层","text":"物理层基本概念 物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。 物理层主要任务：确定与传输媒体接口有关的一些特性（定义标准） 机械特性：定义物理连接的特性，规定物理连接时所采用的规格、接口形状、引线数目、引脚数量和排列情况。 电气特性：规定传输二进制位时，线路上信号的电压范围、阻抗匹配、传输速率和距离限制等 功能特性：指明某条线上出现的某-电平表示何种意义，接口部件的信号线的用途。 规程特性：(过程特性)定义各条物理线路的工作规程和时序关系。 数据通信基础知识 相关术语 通信的目的是传送消息(消息:语音、文字、图像、视频等) 数据data ：传送信息的实体，通常是有意义的符号序列。 信号：数据的电气/电磁的表现，是数据在传输过程中的存在形式。 数字信号/离散信号：代表消息的参数的取值是离散的。 模拟信号/连续信号：代表消息的参数的取值是连续的。 信源：产生和发送数据的源头。 信宿：接收数据的终点。 信道：信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道。 通信方式 名称 英文 定义 需要信道条数 单工通信 Simplex 只能一个发一个收 一条 半双工通信 half-duplex 都可以发或者收，但是同一时间只能进行一个 两条 全双工通信 duplex 都可以同时收发数据 两条 数据传输方式 传输方式 特点 串行传输 速度慢，省钱，适合远距离 并行传输 速度快，耗钱，适合近距离 同步传输&amp;异步传输 同步传输：在同步传输的模式下，数据的传送是以一个数据区块为单位，因此同步传输又称为区块传输。在传送数据时，需先送出1个或多个同步字符，再送出整批的数据。 异步传输：异步传输将比特分成小组进行传送，小组可以是8位的1个字符或更长。发送方可以在任何时刻发送这些比特组，而接收方不知道它们会在什么时候到达。传送数据时，加一个字符起始位和一个字符终止位。 码元（Symbol） 码元是指用一个固定时长的信号波形(数字脉冲)，代表不同离散数值的基本波形，是数字通信中数字信号的计量单位，这个时长内的信号称为k进制码元，而该时长称为码元宽度。当码元的离散状态有M个时(M大于2)，此时码元为M进制码元。 1码元可以携带多个比特的信息量。例如，在使用二进制编码时，只有两种不同的码元，- 种代表0状态，另-种代表1状态。 速率 速率也叫数据率，是指数据的传输速率，表示单位时间内传输的数据量。可以用码元传输速率和信息传输速率表示 码元传输速率：别名码元速率、波形速率、调制速率、符号速率等，它表示单位时间内数字通信系统所传输的码元个数(也可称为脉冲个数或信号变化的次数)，单位是波特(Baud)。1波特表示数字通信系统每秒传输一个码元。这里的码元可以是多进制的，也可以是二进制的，但码元速率与进制数无关 信息传输速率：别名信息速率、比特率等，表示单位时间内数字通信系统传输的二进制码个数(即比特数)，单位是比特/秒(b/s) 关系：若一个码元携带nbit的信息量，则MBaud的码元传输速率所对应的信息传输速率为Mxnbit/s。 码元传输速率就是1s传输多少个码元，信息传输速率就是1s传输多少个比特 带宽（Band Width） 模拟信号系统中：当输入的信号频率高或低到一定程度，使得系统的输出功率成为输入功率的一半时(即-3dB)，最高频率和最低频率间的差值就代表了系统的通频带宽，其单位为赫兹(Hz) 数字设备中：表示在单位时间内从网络中的某一点到另 一点所能通过的“最高数据率”/单位时间内通过链路的数量，常用来表示网络的通信线路所能传输数据的能力。单位是比特每秒(bps) 拥有更宽的宽度，也就是有更大的信息运送能力 奈氏准则（Nyquist） 现实中的信道传输会出现失真现象，影响失真程度的因素: 码元传输速率 信号传输距离 噪声干扰 传输媒体质量 香农定理是在理想状态下得出的结论 香农定理（Shannon）是在有噪声的信道中得出的结论 信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高 对一定的传输带宽和一定的信噪比，信息传输速率的上限就确定了 只要信息的传输速率低于信道的极限传输速率，就一定能找到某种方法来实现无差错的传输 香农定理得出的为极限信息传输速率，实际信道能达到的传输速率要比它低不少 从香农定理可以看出，若信道带宽W或信噪比S/N没有上限(不可能)，那么 信道的极限信息传输速率也就没有上限 编码与调制基带信号与宽带信号计算机网络中用的基带信号是数字信号 编码 编码：将数据转化为数字信号 数字数据(digtal data)通过 数字发送器(digit emitter) 转化为 数字信号(digtal signal) 模拟数据(analog data)通过 PCM编码器(PCM coder) 转化为 数字信号 (digtal signal) 编码方法 非归零编码【NRZ】高1低0：编码容易实现，但没有检错功能，且无法判断一个码元的开始和结束，以至于收发双方难以保持同步 归零编码【RZ】：信号电平在一个码元之内都要恢到零的这种编码成编码方式 反向不归零编码【NRZI】：信号电平翻转表示0，信号电平不变表示1 曼彻斯特编码：将一个码元分成两个相等的间隔，前一个间隔为低电平后一个间隔为高电平表示码元1(前高后低为1);码元0则正好相反(前低后高为0)。也可以采用相反的规定。该编码的特点是在每一个码元的中间出现电平跳变，位中间的跳变既作时钟信号(可用于同步) ，又作数据信号，但它所占的频带宽度是原始的基带宽度的两倍。每一个码元都被调成两个电平，所以数据传输速率只有调制速率的1/2。 差分曼彻斯特编码(同1异0)：常用于局域网传输，其规则是：若码元为1，则前半个码元的电平与上一个码元的后半个码元的电平相同，若为0，则相反。该编码的特点是，在每个码元的中间，都有一次电平的跳转，可以实现自同步，且抗干扰性强于曼彻斯特编码。 调制 调制：将数据转化为模拟信号 模拟数据(analog data)通过 调制器(modulaotr) 转化为 模拟信号 (analog signal) 数字数据(digtal data)通过 调制器(modulaotr) 转化为 模拟信号 (analog signal) 调制方法 数字数据调制技术在发送端将数字信号转换为模拟信号，而在接收端将模拟信号还原为数字信号，分别对应于调制解调器的调制和解调过程。 常用的调制方法：调频(AM)，调频(FM)，调相(PM)，波形稀疏频率低0，波形密集频率高1 物理层传输介质 传输介质也称传输媒体/传输媒介，它就是数据传输系统中在发送设备和接收设备之间的物理通路 传输媒体并不是物理层。传输媒体在物理层的下面，因为物理层是体系结构的第一层，因此有时称传输媒体为0层。在传输媒体中传输的是信号，但传输媒体并不知道所传输的信号代表什么意思。但物理层规定了电气特性，因此能够识别所传送的比特流。 导向性传输介质双绞线 根据有无屏蔽层分为屏蔽双绞线（STP）和无屏蔽双绞线（UTP） 同轴电缆（Coaxial Cable） 光纤（Optical fiber） 根据入射角不同，又分为单模光纤和多模光纤 光纤的特点: 传输损耗小，中继距离长，对远距离传输特别经济。 抗雷电和电磁干扰性能好。 无串音干扰，保密性好，也不易被窃听或截取数据。 体积小，重量轻。 非导向性传输介质 包括无线电波，微波，红外线和激光等 物理层设备中继器（RP repeater） 5-4-3规则是为了限制中继器使用次数的，理由可见图 5是指不能超过5个网段 4是指在这些网段中的物理层网络设备（中继器，集线器）最多不超过4个 3是指这些网段中最多只有三个网段挂有计算机 集线器（Hub） 集线器是个大的冲突域，同时只能有两个设备进行通讯，只会传输信号，没有智能。","path":"page/net03.html","date":"02-05","excerpt":"","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://xiaoliblog.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机网络🌈计算机网络体系结构","text":"计算机网络基础计算机概述 计算机网络概念 计算机网络：是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统 计算机网络是互连（互联互通）的、自治（无主从关系）的计算机集合 计算机网络功能 数据通信（连通性） 资源共享（硬件，软件，数据） 分布式处理（多台计算机各自承担同一工作任务的不同部分） 提高可靠性 负载均衡 计算机网络组成 组成部分（硬件、软件、协议） 工作方式 边缘部分 用户直接使用（C/S方式，P2P方式） 核心部分 为边缘部分服务 功能组成 通信子网 实现数据通信 资源子网 实现资源共享/数据处理 计算机网络分类 按分布范围分：广域网WAN、城域网MAN、局域网WAN、个人区域网PAN 按使用者分：公用网（中国电信）、专用网（军队网） 按交换技术分：电路交换、报文交换、分组交换 按拓扑结构分：总线性、星型、环型、网状型 按传输技术分：广播式网络、点对点网络 标准化工作及相关组织 标准的分类 法定标准：由权威机构制定的正式的、合法的标准 OSI 事实标准：某些公司的产品在竞争中占据了主流，时间长了，这些产品中的协议和技术就成了标准 TCP/IP RFC (Request For Comments )——因特网标准的形式RFC要上升为因特网正式标准的四个阶段: 因特网草案(Internet Draft)这个阶段还不是RFC文档 建议标准( Proposed Standard)从这个阶段开始成为RFC文档 草案标准( Draft Standard ) 次阶段现已取消 因特网标准( Internet Standard ) 标准化工作的相关组织 国际标准化组织ISO OSI参 考模型、HDLC协议 国际电信联盟TTU 制定通信规则 国际电气电子工程师协会IEEE 学术机构、 IEEE802系列标准、5G Internet工程任务组IETF 负责因特网相关标准的制定RFC XxxXx 计算机网络性能指标速率 速率即数据率或称数据传输率或比特率比特 1/0 位连接在计算机网络上的主机在数字信道上传送数据位数的速率单位是b/s，kb/s， Mb/s， Gb/s， Tb/s 带宽 “带宽”原本指某个信号具有的频带宽度，即最高频率与最低频率之差，单位是赫兹(Hz) 计算机网络中，带宽用来表示网络的通信线路传送数据的能力，通常是指单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。单位是“比特每秒”，b/s， kb/s， Mb/s, Gb/s。网络设备所支持的最高速度 吞吐量 表示在单位时间内通过某个网络(或信道、接口)的数据量。单位b/s, kb/s， Mb/s等 。 吞吐量受网络的带宽或网络的额定速率的限制。 时延 指数据(报文/分组/比特流) 从网络(或链路)的一端传送到另一端所需的时间。也叫延迟或迟延。单位是s。 名称 描述 计算公式 发送时延 数据从主机到信道上所用的时间 发送的数据长度/发送速率 传播时延 数据在信道上传播所花费的时间 信道长度/电磁波在信道上传播的速率 排队时延 数据在路由器前等待前面数据处理的时间 无计算方式 处理时延 数据在路由器中处理需求的时间 无计算方式 使用高速链路(提高网速)，只能减小发送时延，无法减少其他三个时延 时延带宽积 公式：时延带宽积(bit)=传播时延(s)x带宽(b/s) 时延带宽积又称为以比特位为单位的链路长度，表示某链路上有多少比特的数据 往返时延RTT和利用率 从发送方发送数据开始，到发送方收到接收方的确认(接收方收到数据后立即发送确认)，总共经历的时延 RTT越大，在收到确认之前，可以发送的数据越多 RTT包括 往返传播时延=传播时延*2 末端处理时间 利用率 信道利用率=有数据通过时间/（有+无）数据通过时间 网络利用率=信道利用率加权平均值 利用率越高，延迟越大 分层结构相关概念 分层的原因及作用 发起通信的计算机必须将数据通信的通路进行激活。 要告诉网络如何识别目的主机。 发起通信的计算机要查明目的主机是否开机，并且与网络连接正常。 发起通信的计算机要弄清楚，对方计算机中文件管理程序是否已经做好准备工作。 确保差错和意外可以解决。 分层的基本原则 各层之间相互独立，每层只实现-种相对独立的功能。 每层之间界面自然清晰，易于理解，相互交流尽可能少。 结构上可分割开。每层都采用最合适的技术来实现。 保持下层对上层的独立性，上层单向使用下层提供的服务。 整个分层结构应该能促进标准化工作 实体:第n层中的活动元素称为n层实体。同一层的实体叫对等实体。 协议:为进行网络中的对等实体数据交换而建立的规则、标准或约定称为网络协议。[水平] 语法:规定传输数据的格式 语义:规定所要完成的功能 同步:规定各种操作的顺序 接口(访问服务点SAP) :上层使用下层服务的入口。 服务:下层为相邻上层提供的功能调用。【垂直】 SDU服务数据单元：为完成用户所要求的功能而应传送的数据。 PCI协议控制信息：控制协议操作的信息。 PDU协议数据单元：对等层次之间传送的数据单位。 OSI参考模型 国际标准化组织(ISO) 于1984年提出开放系统互连(OSI) 参考模型。但是！理论成功，市场失败 名称 英文 作用 应用层 Application Layer 直接为用户的应用进程（例如电子邮件、文件传输和终端仿真）提供服务。如HTTP、SMTP、FTP、DNS等 表示层 Presentation Layer 把数据转换为能与接收者的系统格式兼容并适合传输的格式，即让两个系统可以交换信息 会话层 Session Layer 负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接 传输层 Transport Layer 负责端到端通讯，可靠传输，不可靠传输 ，流量控制，复用分用 网络层 Network Layer 负责选择路由最佳路径，规划IP地址(ipv4和ipv6变化只会影响网络层)，拥塞控制 数据链路层 Data Link Layer 帧的开始和结束，还有透明传输，差错校验(纠错由传输层解决) 物理层 Physical Layer 定义网络设备接口标准，电气标准(电压)，如何在物理链路上传输的更快 OSI参考模型通信过程 网络层及以上，每一层都要对上一层发送的数据进行处理（加个头部） 数据链路层不仅需要加头部，还需要加尾部 物理层什么都不加，只管发送数据（比特流） TCP/IP模型 ISO/OSI参考模型 TCP/IP模型 网络层 无连接+面向连接 无连接 传输层 面向连接 无连接+面向连接 面向连接分为三个阶段，第一是建立连接，在此阶段，发出一一个建立连接的请求。只有在连接成功建立之后，才能开始数据传输，这是第二阶段。接着，当数据传输完毕，必须释放连接。而面向无连接没有这么多阶段，它直接进行数据传输。 五层参考模型 参考👉👉👉2019 王道考研 计算机网络||计算机网络笔记","path":"page/net01.html","date":"02-05","excerpt":"","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://xiaoliblog.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机组成原理👨‍💻输入输出系统","text":"I/O基本概念 I/O就是输入/输出(Input/Output) I/O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备 I/O接口又称I/O控制器(I/O Controller )、设备控制器，负责协调主机与外部设备之间的数据传输 I/O控制器多种多样，也会制定相应的标准，如:用于控制USB设备的IO接口、用于控制SATA 3.0硬盘的IO接口等(I/O控制器就是一块芯片，常被集成在主板上) I/O系统基本组成 I/O控制方式 程序查询方式 IO与CPU串行，CPU有”踏步等待“的现象 程序中断方式 IO准备数据时CPU继续工作，在指令结束时响应中断 DMA方式 主存与IO交换信息时，由DMA控制器控制，在存取周期结束时响应DMA请求 通道方式 通过I/O指令启动通道，通道程序放在主存中 前两种主要由程序控制，用于速度较低的外设 后两种主要由硬件控制，用于速度较高的外设 I/O外部设备 外部设备也称外围设备，是除了主机以外的、能直接或间接与计算机交换信息的装置 输入设备 用于向计算机系统输入命令和文本、数据等信息的部件。键盘和鼠标是最基本的输入设备 输出设备 用于将计算机系统中的信息输出到计算机外部进行显示、交换等的部件。显示器和打印机是最基本的输出设备 外存设备 是指除计算机内存及CPU缓存等以外的存储器。硬磁盘、光盘等是最基本的外存设备 输入设备 输出设备显示屏 显示器的性能指标 按显示设备所使用的显示器件分类 阴极射线管（CRT）显示器 三种阴极射线管显示器 液晶显示器（LCD） LED显示器 三种显示器的特点 打印机 外存储器 外存既可以作为输入设备，也可以作为输出设备 磁表面存储器 计算机的外存储器又称为辅助存储器，目前主要使用磁表面存储器 所谓“磁表面存储”，是指把某些磁性材料薄薄地涂在金属铝或塑料表面上作为载磁体来存储信息。磁盘存储器、磁带存储器和磁鼓存储器均属于磁表面存储器。 磁表面存储器的优点 存储容量大，位价格低 记录介质可以重复使用 记录信息可以长期保存而不丢失，甚至可以脱机存档 非破坏性读出，读出时不需要再生 磁表面存储器的缺点 存取速度慢 机械结构复杂 对工作环境要求较高 原理 当磁头和磁性记录介质有相对运动时，通过电磁转换完成读/写操作。 串行工作模式 编码方式 按某种方案（规律），把一连串的二进制信息变换为存储介质磁层中一个磁化翻转状态的序列，并使读/写控制电路容易、可靠地实现转换。 磁记录方式 通常采用调频制（FM）和改进型调频制（MFM）的记录方式 磁盘存储器 存储区域 一块硬盘含有若干个记录面，每个记录面划分为若干条磁道，而每条磁道分为若干个扇区，扇区（也称块）是磁盘读写的最小单位，也就是说磁盘按块存取。 记录面–&gt;磁道–&gt;扇区（块） 磁头数Heads 即记录面数，表示磁盘总共有多少个磁头，磁头用于读写盘片上记录面的信息，每一个记录面对应一个磁头。 柱面数Cylinders表示硬盘每一面盘片上有多少条磁道。在一个盘组中，不同记录面的相同编号（位置）的诸磁道构成一个圆柱面 扇区数Sectors表示一条磁道上有多少个扇区 硬盘存储器 硬盘存储器由磁盘驱动器、磁盘控制器和盘片组成 硬盘存储器=磁盘驱动器+磁盘控制器+盘片 磁盘驱动器 核心部件是磁头组件和盘片组件，温彻斯特盘是一种可移动头固定盘片的硬盘存储器。 磁盘控制器 是硬盘存储器和主机的接口，主流的标准有IDE、SCSI、SATA 磁盘的性能指标 磁盘的容量 一个磁盘所能存储的字节总数称为磁盘容量。磁盘容量有非格式化容量和格式化容量之分 非格式化容量：磁记录表面可以利用的磁化单元总数 格式化容量按照某种特定的记录格式所能存储信息的总量 记录密度 记录密度是指盘片单位面积上记录的二进制的信息量，通常以道密度、位密度和面密度表示 道密度：沿磁盘半径方向单位长度上的磁道数 位密度：磁道单位长度上能记录二进制代码位数 面密度：位密度和道密度的成绩注意：磁道所有磁道记录的信息量一定是相等的，并不是圆越大信息越大，故每个磁道上的位密度都是不同的 平均存取时间 平均存取时间=寻到时间+旋转延迟时间+传输时间 寻到时间：磁道移动到目的的磁道 旋转延迟时间：磁头定位到所在扇区 传输时间：传输数据花费的时间 数据传输率 磁盘存储器在单位时间内向主机传送数据的字节数，称为数据传输率。 数据传输率=磁盘每秒转数*每条磁道的容量 磁盘地址 磁盘的地址一般为：驱动器号|柱面（磁道）号|盘面号|扇区号 硬盘的工作过程 硬盘的主要操作是寻址、读盘、写盘。每个操作都对应一个控制字。 硬盘工作时，第一步是取控制字，第二步是执行控制字。 硬盘属于机械式部件，其读写操作是串行的，不可能在同一时刻既要读又要写，也不可能在同一时刻读两组数据或写两组数据。 磁盘阵列 RAID0：条带化，提高存取速度，没有容错能力 RAID1：镜像磁盘互为备份 RAID2~5：认为RAID1备份浪费，通过数据校验提高容错能力 光盘存储器 固态硬盘 I/O接口I/O接口的功能 I/O接口（I/O控制器）是主机与外设之间的交接界面，通过接口可以实现主机和外设之间的信息交换 I/O接口的工作原理 I/O接口的基本结构 接口和端口 I/O控制方式程序查询方式 程序中断方式中断 中断请求的优先级设置 硬件故障中断属于最高级、其次是软件中断； 非屏蔽中断优于可屏蔽中断； DMA请求优于I/O设备传送的中断请求； 高速设备优于低速设备； 输入设备优于输出设备； 实时设备优于普通设备。 多重中断 单重中断：执行中断服务程序时，不响应新的中断请求。 多重中断：又称中断嵌套，执行中断服务程序时可响应新的中断请求。 单重中断和多重中断的区别 程序中断方式 例题 DMA方式 DMA的结构 DMA的传送过程 DMA的传送方式 DMA方式的特点 DMA方式与中断方式比较 CPU占用情况","path":"page/composition03.html","date":"02-05","excerpt":"","tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"http://xiaoliblog.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}]},{"title":"计算机组成原理👨‍💻总线","text":"总线概述总线的定义 总线是一组能为多个部件分时共享的公共信息传送线路 共享是指总线上可以挂接多个部件，各个部件之间互相交换的信息都可以通过这组线路分时共享 分时是指同-一时刻只允许有一个部件向总线发送信息，如果系统中有多个部件，则它们只能分时地向总线发送信息。 为什么要用总线? 早期计算机外部设备少时大多采用分散连接方式，不易实现随时增减外部设备。为了更好地解决I/O设备和主机之间连接的灵活性问题，计算机的结构从分散连接发展为总线连接。 总线的特性 机械特性 尺寸、形状、管脚数、排列顺序 电气特性 传输方向和有效的电平范围 功能特性 每根传输线的功能（地址、数据、控制） 时间特性 信号的时序关系 总线的分类 区别数据通路与数据总线 数据通路表示的是数据流经的路径 数据总线是承载的媒介 按数据传输格式分类 串行总线 优点：只需要一条传输线，成本低廉，广泛应用于长距离传输；应用于计算机内部时，可以节省布线空间 缺点：在数据发送和接收的时候要进行拆卸和装配，要考虑串行、并行转换问题 并行总线 优点：中心概念的逻辑时序比较简单，电路实现起来比较容易 缺点：1.信号线数量多，占用更多的布线空间；远距离传输成本高昂；2.由于工作频率较高时，并行的信号线之间会产生严重干扰。每条线等长的要求越高，所以无法持续提升工作频率。 串行总线和并行总线之间的比较 工作频率相同时，串行总线传输速度比并行总线慢 并行总线的工作频率无法持续提高，而串行总线可以通过不断提高工作频率来提高传输速度，最终超过并行总线 按总线功能（连接的部件）分类 片内总线 片内总线是芯片内部的总线，它是CPU芯片内部寄存器与寄存器之间、寄存器与ALU之间的公共连接线 系统总线 系统总线是计算机系统内各功能部件（CPU、主存、I/O接口）之间相互连接的总线， 按系统总线传输信息内容的不同，可分为3类：数据总线、地址总线和控制总线 数据总线 1.传输各功能部件之间的数据信息，包括指令和操作数； 2.位数（数据总线的根数）与机器字长、存储字长有关； 3.双向 地址总线 1.传输地址信息，包括主存单元或I/O端口的地址； 2.位数（地址中心概念的根数）与主存地址空间大小和设备数量有关 3.单向（由CPU传向外部） 控制总线 1.传输控制信息 2.一根控制线传输一个信号，每一条线的方向是单向的，但是有入有出 有出：CPU送出的控制命令 有入：主存（或外设）返回CPU的反馈信号 按时序控制方法 同步总线 异步总线 系统总线的结构单总线 双总线 三总线 三总线： 每一个时刻只有一套总线能够单独的工作 四总线 四总线 桥接器：用于连接不同的总线，具有数据缓冲、转换和控制功能 靠近CPU的总线速度较快 总线性能指标 前六个关心总线的工作速度，第七个关心总线的利用率以及如何减小总线所占用的面积，第八个主要受总线复用的影响 注：总线带宽是指总线本身所能达到的最高传输速率，在计算实际的有效数据传输率时，要用实际传输的数据量除以耗时 总线仲裁总线仲裁基本概念 同一时刻只能有一个设备控制总线传输操作，可以有一个或多个设备从总线接收数据 将总线上所连接的各类设备按其对总线有无控制功能分为: 主设备：获得总线控制权的设备 从设备：被主设备访问的设备，只能响应从主设备发来的各种总线命令 为什么要仲裁? 总线作为一种共享设备，不可避免地会出现同一时刻有多个主设备竞争总线控制权的问题 总线仲裁的定义 多个主设备同时竞争主线控制权时，以某种方式选择一个主设备优先获得总线控制权称为总线仲裁。 总线仲裁分类 集中仲裁方式：链式查询方式、 计数器定时查询方式、独立请求方式 分布仲裁方式 集中仲裁方式 工作流程: 主设备发出请求信号; 若多个主设备同时要使用总线，则由总线控制器的判优、仲裁逻辑按一定的优先等级顺序确定哪个主设备能使用总线; 获得总线使用权的主设备开始传送数据。 链式查询方式 计数器定时查询方式 独立请求方式 集中仲裁方式小结 分布仲裁方式 特点：不需要中央仲裁器，每个潜在的主模块都有自己的仲裁器和仲裁号，多个仲裁器竞争使用总线。 当设备有总线请求时，它们就把各自唯的仲裁 号发送到共享的仲裁总线上; 每个仲裁器将从仲裁总线上得到的仲裁号与自己的仲裁号进行比较; 如果仲裁总线上的号优先级高，则它的总线请求不予响应，并撤销它的仲裁号; 最后，获胜者的仲裁号保留在仲裁总线上。 总线操作和定时总线传输四个阶段 同步定时方式 异步定时方式 在异步定时方式中，没有统一的时钟，也没有固定的时间间隔，完全依靠传送双方相互制约的“握手”信号来实现定时控制。 主设备提出交换信息的“请求”信号，经接口传送到从设备;从设备接到主设备的请求后，通过接口向主设备发出“回答”信号。 根据“请求”和“回答”信号的撤销是否互锁，分为以下3种类型 不互锁方式 半互锁方式 全互锁方式 优点：总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换，自动适应时间的配合。 缺点：比同步控制方式稍复杂一些，速度比同步定时方式慢。 半同步通信 结合同步和异步的优点 同步的优点：发送发用系统时钟前沿发信号，接收方用系统时钟后沿判断、识别 异步的优点：允许不同速度的模块和谐工作 半同步：统一时钟的基础上，增加一个“等待”响应信号 注意这里的波特率与计算机网络中的波特率不同 分离式通信 总线标准 总线标准是国际上公布或推荐的互连各个模块的标准，它是把各种不同的模块组成计算机系统时必须遵守的规范。按总线标准设计的接口可视为通用接口，在接口的两端，任何一-方只需根据总线标准的要求完成自身方面的功能要求，而无须了解对方接口的要求。 根据总线在计算机系统中的位置，可分为 系统总线标准：通常与CPU直接相连，用于连接CPU与北桥芯片、或CPU与主存等，例如ISA、EISA、VESA、PCI、PCI-Express等。 设备总线标准：通常由南桥芯片控制，用于连接计算机与计算机，或连接计算机与外部I/0设备，例如IDE、AGP、RS-232C、USB、SATA、SCSI、PCMCIA等. 局部总线标准：在ISA总线和CPU总线之间增加了一级总线或管理层。如PCI、PCI-E、VESA、AGP等，可以节省系统的总带宽。 详情请看总线标准","path":"page/composition07.html","date":"02-05","excerpt":"","tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"http://xiaoliblog.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}]},{"title":"计算机组成原理👨‍💻中央处理器","text":"CPU概述CPU的功能 指令控制：完成取指令、分析指令和执行指令的操作，即程序的顺序控制 操作控制：一条指令的功能往往是由若干操作信号的组合来实现的。CPU管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作 时间控制：对各种操作加上时间上的控制。时间控制要为指令按时间顺序提供相应的控制信号 数据加工：对数据进行算数和逻辑运算。 中断处理：对计算机运行过程中出现的异常情况和特殊请求进行处理 运算器和控制器 运算器的功能：对数据进行加工 控制器的功能：协调并控制计算机各种部件执行程序的指令序列，基本功能包括：取指令、分析指令、执行指令 取指令：自动形成指令地址；自动发出取指令的命令 分析指令：操作码译码（分析本条指令要完成什么操作）产生操作数的有效地址。 执行指令：根据分析指令得到的“操作命令”和“操作数地址”，形成操作信号控制序列，控制运算器、存储器以及I/O设备完成相应的操作。 中断处理：管理总线及输入输出：处理异常情况（如掉电）和特殊请求（如打印机请求打印一行字符） 运算器的基本结构 算术逻辑单元ALU：主要功能是进行算术/逻辑运算。 通用寄存器组：如AX，BX，CX，DX，SP等，用于存放操作数（包括源操作数、目的操作数及中间结果）和各种地址信息等。SP是堆栈指针，用来指示站定的地址 通用寄存器组与ALU如何相连？ 专用数据通路方式：根据指令执行过程中的数据和地址的流动方向安排线路。如果直接用导线相连，相当于多个寄存器同时并一直想ALU传输数据 解决办法1：使用多路选择器，根据控制信号选择一路输出 解决办法2：使用三态门可以控制每一条路是否输出特点：性能较高，基本不存在数据冲突现象，但结构复杂，硬件量大，不易实现。 CPU内部单总线方式：将所有寄存器的输入端和输出端都连在一条公共的通路上。要有一个暂存寄存器特点：结构简单，容易实现，但数据传输存在较多冲突现象，性能较低。 暂存寄存器：可以用于暂存从主存读来的数据，这个数据不能存放在通用寄存器中，否则会破坏原有内容。 累加寄存器ALU：它是一个通用寄存器，用于暂时存放ALU运算的结果信息 程序状态字寄存器PSW：保留由算数逻辑运算指令或测试指令的结果而建立的各种状态信息 如：溢出标志（OP）、符号标志（SF）、零标志（ZF）、进位标志（CF）、PSW中的这些位参与并决定微操作的形成。 移位器：对运算结果进行移位运算 计数器：控制乘除运算的操作步数 控制器的基本结构 CPU基本结构 指令执行过程指令周期 指令周期：CPU从主存中取出并执行一条指令所需要的的全部时间 指令周期常常用若干个机器周期来表示，机器周期又叫CPU周期 一个机器周期又包括若干个时钟周期（也称为节拍、T周期或CPU时钟周期），它是CPU操作的时间基本单位 .每个指令周期内机器数可以不等，每个机器周期内的节拍数也可以不等，因为每个指令的任务是不一样的 指令周期流程 四个工作周期都有CPU访存操作，只是访存的目的不同。 取指周期：取指令（读操作） 间址周期：取有效地址（读操作） 执行周期：取操作数（读操作） 中断周期：保护程序断点（写操作） 标志触发器FE、IND、EX、INT 取指周期 当前指令送至存储器地址寄存器，记作：（PC）-&gt;MAR CU发出控制信号，经控制总线传到主存，这里是读信号，记作：1-&gt;R 将MAR所指主存中的内容经数据总线送入MDR，记作：M（MAR）-&gt;MDR 将MDR中的内容（此时是指令）送入IR，记作：（MDR）-&gt;IR CU发出控制信号，形成吓一跳指令地址，记作：（PC）+1-&gt;PC 间址周期 将指令的地址码送入MAR，记作：Ad（IR）-&gt;MAR CU发出控制信号，启动主存做读操作，记作：1-&gt;R 将MDR所指主存中的内容经数据总线送入MDR，记作：M（MAR）-&gt;MDR 一种方式是：将有效地址送至指令的地址码字段，记作MDR-&gt;Ad（IR） 另一种方式是：之后直接取MDR中的内容作为有效地址就好 中断周期 执行周期 执行周期的任务是根据IR中的指令字的操作码和操作数通过ALU操作产生执行结果。 不同的执行周期操作不同，因此没有同意的数据流向。 中断周期 中断：暂停当前任务去完成其他任务，为了能够恢复当前任务，需要保存断点 一般使用堆栈来保存断点，这里用SP表示栈顶地址，假设SP指向栈顶元素，进栈操作是先修改指针，后存入数据 中断周期具体操作流程 CU控制将SP-1，修改后的地址送入MAR，记作：（SP）-1-&gt;SP，（SP）-&gt;MAR 本质上是：将断点存入某个存储单元，假设其地址为a，故可记作：a-&gt;MAR 为什么是SP-1？ 在主存中，选一片地方做堆栈的时候，是从高地址向低地址去扩增的，所以进栈是用减法，出栈是用加法 CU发出控制信号，启动主存做写操作，记作：1-&gt;W 将断点（PC内容）送入MDR，记作：（PC）-&gt;MDR CU控制将中断服务程序的入口地址（由向量地址形成部件产生）送入PC，记作：向量地址-&gt;PC 指令执行方案 方案1：单指令周期 对所有指令都选用相同的执行时间来完成 指令之间串行执行：指令周期取决于执行时间最长的指令的执行时间 设计起来比较简单，但对于本可以在更短时间内完成的指令，要使用这个较长的周期来完成，会降低整个系统的运行速度 方案2：多指令周期 对于不同类型的指令选用不同的执行步骤来完成 指令之间串行执行：可选用不同个数的时间周期来完成不同的执行过程 相比于方案1，需要更复杂的硬件设计 方案3：流水线方案 在每一个时钟周期启动一条指令，尽量让多条指令同时运行，但各自处于不同的执行步骤中 多条指令之间并行执行。 数据通路单总线结构 数据通路：数据在功能部件之间传送的路径 研究数据通路时需要关注的问题 信息从哪里开始？ 中间经过哪些部件？ 最后传到哪里？ 由控制部件产生的控制信号建立数据通路 数据通路的基本结构： CPU内部单总线方式 CPU内部多总线方式 专用数据通路方式 内部总线是指：同一部件，如CPU内部链接个寄存器和运算部件之间的总线 系统总线是指：同一台计算机系统的各个部件（如CPU、内存、通道和各类I/O接口）间相互连接的总线 CPU内部单总线方式 内部总线是指同一部件，如CPU内部连接各寄存器及运算部件之间的总线; 系统总线是指同一台计算机系统的各部件，如CPU、内存、通道和各类I/0接口间互相连接的总线。 专用数据通路方式 控制器硬布线控制器 微程序控制器 指令流水线指令流水线定义 定义：一条指令的执行过程可以分成多个阶段(或过程)；根据计算机的不同，具体的分法也不同 取指:根据PC内容访问主存储器，取出一条指令送到IR中。 分析:对指令操作码进行译码，按照给定的寻址方式和地址字段中的内容形成操作数的有效地址EA，并从有效地址EA中取出操作数。 执行:根据操作码字段，完成指令规定的功能，即把运算结果写到通用寄存器或主存中。 设取指、分析、执行3个阶段的时间都相等，用t表示，按以下几种执行方式分析n条指令的执行时间: 指令流水线表示方法 流水线性能指标 影响流水线的因素 流水线分类 按照流水线使用的级别来分类： 部件功能级流水线 将复杂的算数逻辑运算组成流水线工作方式。 例如：可将浮点加法操作分成求阶差、对阶、位数相加、结果规格化4个子过程 处理机级流水线 把一条指令解释过程分成多个子过程 如前面提到的取指、译码、执行、访存及写回5个子过程 处理机间流水线 是一种宏流水，其中每一个处理机完成某一专门任务，各个处理机所得到的的结果需要存放在与下一个处理机共享的存储器中。 按照流水线可以完成的功能分类 单功能流水线 指只能实现一种固定的专门功能的流水线 多功能流水线 指通过各段间的不同连接方式可以同时或不同时地实现多种功能的流水线 动态流水线和静态流水线 静态流水线 指在同一时间内，流水线的各段只能按同一种功能的连接方式工作。 动态流水线 指在同一时间内，当某些段正在实现某种运算时，另一些段却正在进行另一种运算。这样对提高流水线的效率很有好处，但会使流水线控制变得很复杂。 线性流水线和非线性流水线 按流水线的各个功能段之间是否有反馈信号，流水线可分为线性流水线与非线性流水线。 线性流水线中，从输入到输出，每个功能段只允许经过一次，不存在反馈回路。 非线性流水线存在反馈回路，从输入到输出过程中，某些功能段将数次通过流水线，这种流水线适合进行线性递归的运算。 流水线的多发技术 超标量技术 超流水技术 超长指令字","path":"page/composition06.html","date":"02-05","excerpt":"","tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"http://xiaoliblog.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}]},{"title":"计算机组成原理👨‍💻指令系统","text":"指令格式 指令(又称机器指令) :是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。一台计算机的所有指令的集合构成该机的指令系统，也称为指令集 注：一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令，Eg: x86 架构、ARM架构 一条指令就是机器语言的一个语句，它是一组有意义的二进制代码 一条指令通常要包括操作码字段和地址码字段两部分: 条指令可能包含0个、1个、2个、3个、4个地址码… 根据地址码数目不同，可以将指令分为零地址指令、一地址指令、二地址指令. 地址码数目分类 指令长度分类 操作码长度分类 操作类型分类 扩展操作码 基本思路 动态地把地址码用作操作码，而为了识别出这个变化上一层的操作码字段要留出一个状态，来表示现在进入下一层的操作码的编码 指令寻址指令寻址：如何确定下一条指令的存放地址? 数据寻址 数据寻址确定本条指令的地址码指明的真实地址 数据寻址指令格式 数据寻址1立即寻址 立即寻址：形式地址就是操作数本身，又称为立即数，一般使用补码表示 直接寻址 直接寻址：形式地址就是操作数的真实地址EA=A 间接寻址 间接寻址：形式地址不是操作数的真正地址，而是操作数真实地址 所在的存储单元的地址，也就是操作数地址的地址，即：EA=（A）；还有两次间址或多次间址 寄存器寻址 寄存器寻址 形式地址是寄存器编号，其操作数在由该编号所指的寄存器中 与直接寻址类似，直接访问寄存器中的内容，比较快，一次访存，比立即寻址还是慢一些 寄存器间接寻址 寄存器间接寻址 寄存器中给出的不是一个操作数，而是操作数所在主存单元的地址 比对应的一般间接寻址少一次访存 隐含寻址 隐含寻址 不是明显的给出操作数的地址，而是在指令中隐含着操作数的地址，比如另一个操作数隐含在ACC中 偏移寻址基址寻址 3种偏移寻址方式，三种偏移寻址不同主要体现在三种寄存器特点的不同之上 基址寻址 将CPU中基址寄存器（BR）的内容加上指令格式中的形式地址A，而形成操作数的有效地址（即真实地址）即：EA=(BR)+A 基址寻址可以使用专用寄存器BR作为基址寄存器，也可以使用通用寄存器作为基址寄存器，这时需要指出通用寄存器的编号 变址寻址 变址寻址 有效地址等于指令字中的形式地址与变址寄存器IX的内容相加之和，即EA=（(IX)+A，其中IX为变址寄存器（专用），也可用通用寄存器作为变址寄存器，这时指令格式需要加上一个字段表示通用寄存器的字段 相对寻址 相对寻址 把程序计数器PC的内容加上指令格式的形式地址A而形成操作数的有效地址，即：EA=(PC)+A，其中A是相当于当前指令地址的位移量，可正可负，补码表示 堆栈寻址 堆栈寻址：操作数存放在堆栈中，隐含使用堆栈指针（SP）作为操作数地址，不需要操作数 这里堆栈的基本逻辑与数据结构中栈的基本逻辑一样，但是这里是使用硬件实现 堆栈是存储器（或专用寄存器组）中一块特定的按“后进先出（LIFO）”原则 管理的存储区，该存储区中被读/写单元的地址是用一个特定的寄存器给出，该寄存器称为堆栈指针（SP） 硬堆栈和软堆栈 硬堆栈：数据放在寄存器组中；软堆栈：数据放在主存中 总结 CISC和RISC CISC（Complex Instruction Set Computer，复杂指令集） 设计思路：一条指令完成一个复杂的基本功能 代表：×86架构，主要用于笔记本、台式机 主要用于性能要求比较高、比较大的平台上 RISC（Reduced Instruction Set Computer，精简指令集） 80-20规律：典型程序中80%的语句仅仅使用处理机中的20%的指令 设计思路：一条指令完成一个基本“动作”，多条指令组合完成一个复杂的基本功能 代表：ARM架构、主要用于手机、平板 主要用于构造相对简单、相对轻便的平台上。","path":"page/composition05.html","date":"02-05","excerpt":"","tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"http://xiaoliblog.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}]},{"title":"计算机组成原理👨‍💻存储系统","text":"存储系统基本概念存储器层次结构 存储器的分类存储器的功能：存放二进制信息 按层次分类 按存储介质分类 半导体存储器（主存、Cache）：以半导体器件存储信息 磁表面存储器：磁盘、磁带，以磁性材料存储信息 光存储器（以光介质存储信息） 按存取方式分类 按信息的可更改性分类 读写存储器( Read/Write Memory)——即可读、也可写(如:磁盘、内存、Cache) 只读存储器(ReadOnlyMemory)——只能读，不能写(如:实体音乐专辑通常采用CD-ROM,.实体电影采用蓝光光碟，BIOS通常写在ROM中) 按信息的可保存性分类 断电后，存储信息消失的存储器——易失性存储器(主存、Cache) 断电后，存储信息依然保持的存储器——非易失性存储器(磁盘、光盘) 信息读出后，原存储信息被破坏——破坏性读出(如DRAM芯片，读出数据后要进行重写) 信息读出后，原存储信息不被破坏——非破坏性读出(如SRAM芯片、磁盘、光盘) 存储器的性能指标 主存储器的基本组成半导体元件的原理 红色的线用来并行地、同时地控制多个存储元 绿色的线用来将信号传入存储元、或者把信号从存储元中传出 一个存储单元由若干个存储元构成，所有的存储单元组成了一个矩阵就叫做存储体 三条横线接地表示0，根据电容是否保存了电荷两种状态的信息表示0和1 存储器芯片的基本原理 但是上图这样的存储体是有局限性的，每一次只能使一行存储单元有效 使用一个译码器，可以减少输入控制信息的位数 寻址 按字节寻址 按字寻址：直接取按字节寻址的地址高位即可 假设存储一个数据[高位字节 低位字节] 大端方式 以字地址作为该数据高位字节 小端方式 以字地址作为该数据的低位字节 按半字寻址 按双字寻址 SRAM和DRAM Dynamic Random Access Memory，即动态RAM 分两次送行列地址 电容实现 Static Random Access Memory,即静态RAM 需要同时送行列地址 触发器实现 DRAM用于主存、SRAM用于Cache 存储元件不同导致的特性差异 DRAM芯片：使用栅极电容存储信息. SRAM芯片：使用双稳态触发器存储信息 DRAM刷新 多久需要刷新一次 刷新周期：一般为2ms 每次刷新多少存储单元 以行为单位，每次刷新一行存储单元 为什么要用行列地址？ 当地址位数很大的时候，选通线的个数是无法忍受的 把存储单元排列成矩阵的形式，将一维排列变成二维排列 原来是一个号码选通一个单元，现在是一个坐标选通一个单元 存储单元排列成2(n/2)*2(n/2)的矩阵（行列地址位数相同） 把地址拆分为行列地址 把原来的译码器分成行地址译码器和列地址译码器 原来需要2^n根线，现在需要2^(n/2+1)根线，大大减少了线的数量 原来只能选中一个存储单元，现在可以选中一行存储单元 将简单模型拆分为行列地址排列，由原来的220根地址线转变为210根地址线，由一维变为二维，行地址译码器中，只有行和列同时选通才能进行读和写 如何刷新 有硬件支持，读出一行的信息后重新写入，占用1个读/写周期 在什么时候刷新（刷新就是重新写入）（重点） 不需要CPU控制 以行为单位 整个存储器的所有芯片的同一行同时进行刷新 多个芯片时，不要分开计算 刷新方式 分散刷新 一个存储周期之后，刷新一行 集中刷新 异步刷新（掌握异步刷新的时间间隔如何计算） DRAM的地址线复用技术 只读存储器ROM RAM芯片- – -易失性，断电后数据消失 ROM芯片一-非易失性，断电后数据不会丢失 了解各种ROM 计算机内的重要ROM 逻辑上，主存由RAM+ROM组成，且二者常统一编址 主存储器与CPU的连接单块存储芯片与CPU的连接 多块存储芯片与CPU的连接增加主存的存储字长-位扩展CS代表片选信号WE代表读写信号 增加主存的存储字数-字扩展 线选法 译码片选法 n条线→n个选片信号 n条线→2n个选片信号 电路简单 电路复杂 地址空间不连续 地址空间可连续 线选法 片选法的送入主存储器的片选地址只能有一位为1，代表选中该芯片 使用不连续 当使用字扩展的芯片很为n时，用于选择芯片的地址线也应该有n条，即片选地址为n位 当n很大时，地址线的数量也会大到难以忍受 并且这n位片选地址只有一位为1 译码片选法 主存容量扩展字位同时扩展先完成位的扩展，后完成字的扩展 双口RAM&amp;多模块存储器 解决问题 CPU运算速度呈指数型增长（摩尔定律） 主存储器的容量呈指数型增长（摩尔定律），数据传输速度呈线性增长 这样导致CPU和主存之间的速度差距越来越大 双口RAM和多模块存储器是提高存储器的工作速度两种方案 原理：使用特殊的存储器的管理结构 存取周期 衡量整个住存储器的工作速度 存取周期实际上是比存取时间长的 提高工作速度的主要思路是把存取周期中的恢复时间利用起来 双口RAM 双端口RAM 思路：RAM提供两套端口、两套接口，两个CPU同时对RAM进行访问 对提速效果不是很明显 并且需要提供两套线，在硬件上开销比较大 多体并行存储器 多体并行存储器 多个模块具有的性质： 每个模块都有相同的容量和存取速度 各个模块都有独立的读写控制电路、地址寄存器、数据寄存器 他们既能并行工作，又能交叉工作 多体并行存储器的工作模式依赖于地址的设置方式 高位交叉编址的多体存储器 地址高位决定访问的是哪一个存储体，地址低位决定体内访问的是哪一块单元 纵向编址，正常编址 连续访问时，仅有有扩容功能（跟译码片选法的意思类似），但没有提速 低位交叉编址的多体存储器 地址低位决定访问的是哪一个存储体，地址高位决定体内访问的是哪一块单元 横向编址 连续访问时，有提速的功能 补充：多体并行存储器可以并行工作，如果总线宽度足够宽的时候， 是可以同时读取长度为 存储体个数*字长 多模块存储器 高速缓冲存储器Cache 问题 使用多模块存储器可以提高存储器的速度，但是优化后的速度与CPU差距依然很大 可以使用更高速的存储元设计，但是这样之后存储器价格变高了，存储容量下降了 后来发现了程序访问的局部性原理： CPU实际访问到的存储器的地方实际上是很小的地方，如果把这个很小的一块地方 放在贵的存储器中，就可以提高整个系统的工作速度 基于局部性原理引入层次化设计理念：“Cache-主存”层次 Cache基本原理Cache工作原理 Cache局部性原理 局部性原理 空间局部性 在最近的未来要用到的信息（指令和数据）， 很可能与现在正在使用的信息在存储空间上是邻近的 时间局部性 在最近的未来要用到的信息，很可能是现在正在使用的信息 CPU与主存、Cache交流的方式和主存与Cache之间的交流方式不同 CPU与主存、Cache交流的基本单位是机器字长， 这是因为CPU取出这些数据或者输出一些数据都是通过CPU内部的寄存器 寄存器因为电路比较复杂，所以可以暂存的数据的位数也是有限的 CPU从主存中读取数据是一个元素一个元素取（一个元素是一个机器字长）， 而不是多个元素多个元素一起取 主存和Cache都是存储器，就不存在这个限制， 主存与Cache之间的数据交流可以以块为单位 一次性可以交流多个元素，通常个数是2n个， Cache从主存中读取数据的速度与CPU从主存中读取数据的速度相差不多 运用局部性原理提速的示例 这是粗略的分析：对数组每个元素做自增，实际上不会这么简单 Cache性能分析 Cache-主存映射方式 主存中的块放到Cache中的哪个位置？ 方式1：空位随意放：全相联映射 方式2：对号入座：直接映射 方式3：按号分组，组内随意放：组相联映射 对于方式1，Cache满了如何处理？对于方式2和3，对应位置被占用了如何处理？四种策略 随机（RAND）算法 先进先出（FIFO）算法 近期最少使用（LRU）算法 最不经常使用（LFU）算法 修改Cache中的内容后，如何保持主存中相应的内容的一致性？ 命中：全写法（write-through）和写回法（write-back） 不命中：写分配法（write-allocate）和非写分配法（not-write-allocate） 全相联映射方式 全相联映射 主存中的存储块传输到Cache中之后，Cache会有对这存储块在主存中的部分地址（主存地址高位）的记录，还有对Cache中的存储块是否被占用的记录，具体看图 对Cache空位的利用率高，但是要存储的额外信息多， 因为存放的信息多，识别起来更复杂，对应的电路也会更加复杂 直接映射方式 直接映射 主存的存储块数比Cache中的多，Cache中存储完一轮后，要对主存块高位地址取模运算 Cache对存储块在主存中的地址记录的位数比全相联映射要少几位 对Cache空位的利用率低，但是要存储的额外信息少，电路更简单 组相联映射方式 组相联映射 综合了全相联映射和直接映射的优势，直接把所有Cache行取成一组，就变成了全相联映射，常见有：2路组相联、4路组相联 Cache替换算法 随机算法（RAND）：随机确定替换的Cache块。 实现起来比较简单，但没有依据程序的局部性原理，故可能命中率低 先进先出算法（FIFO）：选择最早调入的行进行替换。 比较容易实现，但也没有根据程序的局部性原理，可能会把一些经常使用的程序块（如循环程序）也作为最早进入Cache的快替换掉。 近期最少使用算法（LRU）： 局部时间 依据程序访问的局部性原理，选择近期内长久未访问过的存储作为替换的行 平均命中率要比FIFO要高，是对堆栈算法 LRU算法对每行设置一个计数器，Cache每命中一次，命中行的计数器清0， 而其他各行计数器均加1，需要替换时比较各特定行的计数值，将计数值最大的行换出。 最不经常使用算法（LFU）：将一段时间内被访问次数最少的存储行换出。 全局时间 每行也设置一个计数器，新行建立后从0开始计数，每访问一次，被访问的行计数器加1，需要替换时比较特定行的计数值，将计数值小的行换出，操作系统会讲其他的做法，与操作系统相应章节对比着学习 随机算法(RAND) 先进先出算法(FIFO) 近期最少使用算法(LRU) 最不经常使用算法(LFU) Cache写策略 写命中 写不命中 多级Cache","path":"page/composition01.html","date":"02-05","excerpt":"","tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"http://xiaoliblog.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}]},{"title":"计算机组成原理👨‍💻数据的表示和运算","text":"进位计数制最古老的技术方法 古代技术通过画竖线符号的方法来计数，比如一个竖线代表一个苹果，当遇到数量过多时，采用一个横线代表五个苹果的方法 即符号反应权重的方法 如罗马数字：MDCCCLXXXVIII = 1888 基本字符 I V X L C D M 对应的阿拉伯数字 1 5 10 50 100 500 1000 符号反应权重 + 符号所在的位置也反应权重 古印度人发明的阿拉伯数字：0、1、2、3、4、5、6、7、8、9和如今的十进制 由位置确定的权重叫位权 r进制计数法和进制转换基数r：每个数码位所用到的不同符号的个数，r进制的基数为r，如二进制 0 1 其他进-&gt;十进制 二进制：逢二进一（101.1+11.1=1001.0，最符合计算机的计算方式） 八进制：逢八进一（5.4+1.4=7.0) 十进制：逢十进一（最符合人类习惯的计数方式） 十六进制：逢十六进一（5.8+0.9=6.1，因为17=16+1） 二进制&lt;- -&gt;八进制、十六进制 二进制&lt;–&gt;八进制：因为八进制基数r=8，二进制r=2，所有二进制每三位（421）可以表示一位八进制（2*2*2=8） 二进制&lt;–&gt;十六进制：同理，十六进制基数r=16，二进制r=2，所有二进制每四位（8421）可以表示一位十六进制（2*2*2*2=16） 各种进制的常见书写方式： B（binary）：二进制 8：八进制 D（decimalism）：十进制 H（hexadecimal）：十六进制（也有用0x作为前缀） 十进制-&gt;任意进制 方法如下图所示，整数和小数部分要分开考虑 整数：除基取余法，将整数部分不断除以基数r，得到从低位到高位的余数 小数：乘基取整法，将小数部分不断乘以基数r，得到从高位到低位的余数 对于数字不大，可以考虑使用拼凑法，对照每个二进制位所对应位权 比如十进制260.75，整数部分(256+4)为1000 0010 0，小数部分(0.75=0.5+0.25)为0.11，化为二进制结果为：1000 0010 0.11 真值和机器数 真值：符合人类习惯的数字 机器数：数字实际存到机器里的形式，正负号需要被“数字化” BCD码BCD：Binary-Coded Decimal，用二进制编码的十进制，以符合人类习惯 8421码 每四个二进制位对应一个十进制，每一位二进制权重为8 4 2 1的编码方式就是8421码 8421码的加法，在最开始时就是二进制的加法 如代表5 + 8 的8421码相加：0101 + 1000 = 1101 但是注意到1101并不在8421码映射表中，因此有这样一种方法用来补位，在1101的结果上再加十进制的6，也就是0110，例如：1101 + 0110 = 1 0011 在前面补0即可得到0001 0011代表十进制1 3的8421码 总结：若8421码相加结果在合法范围内（0000-1001），则无需修正，若不在，则进行加6(0110)的修正 余3码与2421码 与8421码类似的便是余3码和2421码： 余3码与8421码的区别就是有权码和无权码的区别，余3码在8421的基础上加了0011(3) 2421码与8421码的区别就是权值不同，比如2421码：权值为2421的编码 对于上图2421码，0-4的编码是唯一的，但5-9的编码是不唯一的 如5=0101=1001，为避免歧义，因此在2421码中有这样的规定，5-9的编码的首位一定是1，因此 5 = 1001 字符与字符串英文字符 英文在计算机里的表示方法就是ASCII码，键盘上的字母+数字+符号共128个字符只需要7个二进制（128个字符）编码即可。但为了存入计算机，通常在最高位补0，凑足1B（1Byte = 8 bit），也就是说英文8bit就可以表示 上表即为ASCII码表，0-127，在表中可以发现：可印刷字符：32~126，其余为控制、通信字符 可印刷字符就是我们平时能打出来的字符； 控制字符如127DEL，Delete删除字符，控制计算机执行某一种行为； **通信字符，如6ACK，当两台计算机进行网络通信的时候，其中一台计算机收到另一台计算机发来的报文，需要回复一条ACK讯号。 可印刷字符 起始 终止 数字 48（0011 0000） 57 （0011 1001） 大写字母 65（010 00001） 90（010 11010） 小写字母 97（011 00001） 122（011 11010） 对于可印刷字符，值得注意的是： 在数字中，二进制编码的前四位均为0011，后四位为0000-1001的与之对应的8421编码； 在大写字母中，前三位均为010，后五位为00001-11010的 1-26 的二进制码； 在小写字母中，前三位均为011，后五位为00001-11010的 1-26 的二进制码。 且所有的数字、大写字母、小写字母的ASCII码值都是连续的 汉字对于英文字符和一些所需的符号，128个字符就足够英文的使用了，所以在计算机里保存英文只需要8bit（其实7bit就可以）。但对于中文来说，若算上生僻字等快7万多个字符。若要保存几万个字符，8bit显然是不够的，8bit最多只能对应256个字符。 因此，在1980年，我国推出了一个汉字编码标准GB 2312−80： 汉 字 + 各 种 符 号 共 7445 个 为存储更多的字符，因此在最开始，使用了区位码的方式进行存储，即94行94列的区位表示，但用这种(0~93 )*( 0~93)的方法存储会与英文ASCII码中的控制、通信字符有冲突，因此+32（20H），即(32~125) * (32~125)的国标码；但为了避免和英文的ASCII码冲突，还需要在国标码基础上加上128（80H） ，从而得到汉字内码（汉字机内码）。一个汉字占两个字节，但汉字的任何一个字节都是大于128的。所以当计算机读入一个字节的数据是大于128的，就说明将读入的是由两个字节组成的汉字 输入：输入编码（如拼音，输入法）输出：汉字字形码 输入编码会先变成国标码，再变成汉字内码；输出的汉字字形码就是用二进制表示的“手写数字识别版”的用1表示显示用0表示不显示的二进制数组（图片）。 字符串 对于英文字符的存储，如下图，依次存储对应字母的ASCII编码，且在结尾处加\\0，即00H 对于中文字符的存储，如下图，因为存储中文字符需要两个字节，因此也就有了两种存储模式： 大端模式：将数据的最高有效字节存放在低地址单元中 小端模式：将数据的最高有效字节存放在高地址单元中 奇偶校验码在计算机内部进行存储、计算的数据都是以二进制形式传送，由于计算机元器件或环境噪音干扰有可能导致计算机内部二进制数据发生错误，所以我们必须考虑这种错误 校验原理 如上图，假设我们有两种对数据A、B、C、D的编码方式:1. 信息 A B C D 编码 00 01 10 11 2. 信息 A B C D 编码 100 001 010 111 这其中的编码就是码字：由若干位代码组成的一个字叫码字（码字包含了合法码字和不合法码字，如第二种ABCD的编码方式种101就是不合法的码字） 将两个码字逐位对比，具有不同的位的个数被称为两个码字间的距离，如00和11的距离为2 一种编码方案中可能有若干个合法的码字，各合法码字间的最小距离被称为“码距”，如第一种d=1，第二种d=2 当d=1时，无校验能力；当d=2时，有校验能力（奇偶校验码）；当d&gt;=3时，若设计合理，可能有校验甚至纠错能力（如海明码） 奇偶校验 若有n个有效信息位，可在首部或尾部加上1位的奇偶校验位 奇偶校验码的定义也很简单，整个校验码中1的个数为奇数还是偶数，例 求1001101的奇偶校验码 易知1001101有4个1，假设我们在首部加奇偶校验位 则奇校验码为11001101，偶校验码为01001101 同样最后数据传输校验时，也是以这种奇数或偶数个1进行校验。但值得注意的是，如果发生了2bit位的错误（偶数个位发生变化），奇偶校验码将没用了 但上述都是我们人类对于奇偶的计数统计，对于计算机只需要对所有信息位进行异或操作就可以实现求偶校验位和进行偶校验 如对于1001101的求偶校验位： 所有位的依次异或得到0，故1001101的偶校验位为0 对01001101进行偶校验，若结果为1说明出错 01001101的异或结果为0，故没错 海明校验码奇偶校验码：1位奇偶校验位 + n位有效信息位对于上篇的奇偶校验码有这样的问题：如偶校验码只能校验奇数位错误，但无法确定是哪一位出错 而海明码设计思路：将信息位分组进行偶校验 得到 多个校验位，多个校验位标注出出错位置 需要多少个校验位 海明码求解步骤对于信息位：1010，让我们来一下它的海明码该怎么求？ 根据不等式2k=n+k+1确定海明码的校验位个数k，并用D1,D2,D3,D4表示信息位，用P3,P2,P1表示校验位，其海明码应为H7,H6,H5,H4,H3,H2,H1 确定校验位的分布，根据校验位Pi放在海明码号为2i-1的位置上，信息位按顺序放到其他位置，就比如P2就会被放到22-1=2的H2位置上 求校验位的值，将信息位D1,D2,D3,D4所在位置用二进制数表示 D1=H3=3=011 D2=H5=5=101 D3=H6=6=110 D4=H7=7=111 则各个分组的Pii便是对应二进制位的i位为1的信息位的异或和 如P1=D1异或D2异或D4=0异或1异或1=0 纠错纠错的方法便是校验每一组的异或值是否为1，若为1则海明码出错，且出错位置为S1 , S2 , S3这三组表示的二进制数转成十进制的位置，如接收到的1010010计算得到的S1 , S2 , S3=010=2，代表第2个位置出错 注意！：要注意给出的信息位D4,D3,D2,D1还是D1,D2,D3,D4，上述例子是从大到小的信息位排列，但原理上是一样的补充：海明码的检错、纠错能力 检错能力——2位 纠错能力——1位 为了避免两位错误导致无法区分，因此一般海明码还会加上“全校验位”，对整体进行偶校验，方法如上图，根据分组校验的S3 , S2 , S1结果与全体偶校验来判断出错个数 循环冗余校验码基本思想循环冗余校验码的思想：数据发送、接收方约定一个“除数”（二进制的除数） K个信息码 + R位校验码作为“被除数”，在检验时，判断余数是否为0来判断是否出错。 让我们来看个例子，如下图，已知生成多项式G（x），信息码为101001，求对应的CRC码。二进制的除法规则，如上图所示，其相除过程为首先判断被除数当前最高位是否为1，若为1，则当前商为1，否则为0；然后对被除数和除数做“模2减”，即异或；之后，在“模2减”后若位数不足在最高位补0，重复首先的步骤，直至最后得到商和余数。对于余数，余数的位数 = 除数的位数-1 = 校验码的位数。 构造方法 解法步骤： 确定K、R以及生成多项式对应的二进制码K = 信息码长度 = 6，R = 生成多项式最高次幂 = 3 则校验码位数为 N = K+R = 9生成多项式G对应的二进制码为1101，对应x次幂的系数 移位信息码左移R位，低位补0（即在信息码后补R个校验位的0） 相除对移位后的信息码，用生成多项式进行模2除法，产生余数对应的CRC码：101001 001（相除过程见上图，其模2除法的余数 001 就是校验位） 检错和纠错发送方发送的数据为101001001记为C9、C8、C7、C6、C5、C4、C3、C2、C1 接收方对接收的数据用约定好的1101进行模2除，若余数为000，代表没有出错；若余数为010，代表 C2、C9出错，其余数和出错位对应关系如下图 纠错检错注意在上表中，出错位为1和8、2和9的余数两两相同，那么我们能推知循环冗余校验码只有检错的能力，而没有纠错的能力么？也不全对，因为在上述例子中，余数只有3位二进制码，只能表示8-1=7种（000表示没出错）出错位，但传输的位数为9位，故无法纠错。对于确定的生成多项式，出错位与余数是相对应的 即如果出错的位数并没超过余数所能表示的范围，则余数和出错位之间就是一一对应的关系 K个信息位，R个校验位，若生成多项式选择得当，且 2R&gt;=K+R+1则CRC码可以纠错 定点数的表示定点数：小数点的位置固定 ——常规技术浮点数：小数点的位置不固定 ——科学计数法 无符号数无符号数：整个机器字长的全部二进制位均为数值位，没有符号位，相当于数的绝对值。且通常只考虑无符号整数 有符号数原码原码的表示，分成定点整数和定点小数： 定点整数：符号位 + 数值部分（尾数），如 +5通常写为0,101(假设机器字长是4位) 定点小数：符号位 + 数值部分（尾数），如 -0.5通常写为1,100(假设机器字长是4位) 反码反码： 若符号位为0，则反码与原码相同 若符号位位为1，则数值位全部取反 反码只是求补码的一个过程，其表示和范围如上图，不再阐述 补码 移码 补码作用在计算机中，使用原码运算： 加法——用加法器完成 减法——用减法器完成这样不高效，能不能用加法来替代减法呢？当然可以比如时钟中，将10点调成7点，可以通过顺时针（加法）10 + 9 = 19 % 12 = 7，也可以通过逆时针（减法）10 - 3 = 7来实现 而在计算机中，假定字长为8bit，也就是00000000~11111111的范围，0到28−1，而计算机只能保存8位，天然地就相当于mod28，因此减法通过 加 （模 - 绝对值）的操作便可由加法替代了。 因此，补码的作用——让减法操作转变为加法操作，符号位一起参与运算，ALU中无需集成减法器，节省硬件成本 定点数的运算移位运算三种移位运算的方法：算数移位+逻辑移位+循环移位 算数移位 原码的算数移位 反码的算数移位 补码的算数移位 总结 正数的原码 = 补码 = 反码，补位都用0补 负数的反码 = 原码数值位取反，补码 = 原码数值位取反+1 负数反码，补位补1 负数补码，左移补0，右移补1 逻辑移位 循环移位循环移位，二进制数在移位过程中不丢弃，像是一个队列一样头变尾或尾变头，循环移位很适合把一个数据的高低字节调换（中文字节的大端存储：高字节+低字节，小端存储：低字节+高字节） 加减运算原码加减运算 补码加减运算 溢出判断在补码加法运算中，会出现溢出这种问题，可以将溢出理解为“循环补码” 比如三位机器数的加法，3+3 = 011 + 011 = 110 = -2因此，我们可以得到这样的规律： 只有“正数+正数”才会上溢——正+正=负 只有“负数+负数”才会下溢——负+负=正 在此，计算机判断溢出的方式有三种： 采用一位符号位，离散数学方式进行逻辑表达式计算，而在硬件实现上也只需与门、或门、非门就可以实现逻辑表达式的计算，比如上图A+C，一位符号位为0，0，1，则V=000+111=1，表示有溢出 采用一位符号位，根据数据位进位情况判断溢出比如上图的A+C，得出Cs为0，C1为1，表示发生上溢 采用双符号位，正数的符号位为00，负数的符号位为11；在相加得到结果后，如符号位变成01则表示正确的符号位为0，实际的符号位为1，发生了上溢双符号位：实际存储时只存储1个符号位，运算时会复制一个符号位，并不会增加存储空间双符号位补码又称：模4补码单符号位补码又称：模2补码 符号扩展避免溢出可以使用符号扩展的方法：将短数据扩展为长数据 乘法运算乘法实现思想 原码一位乘法原码的乘法实现原理如上图所示，在运算器中，MQ（乘商寄存器）存储乘数、X（通用寄存器）存储被乘数、ACC存储乘积高位，符号位单独处理，对于数值位计算如下： 初始时，ACC全0，MQ乘数，X被乘数 接下来，乘数最低位若为1，则ACC加上被乘数；若为0，则ACC加0 然后，ACC和MQ进行逻辑右移，高位补0，ACC的低位移到MQ。注：每次加法后都要进行逻辑右移，重复n次 上述机器乘法原理类似于人工乘法，注意理解 让我们来看一下手动模拟的方法 补码一位乘法补码的乘法运算与原码区别如下与原码运算的硬件方式不同，在ACC\\MQ\\X中直接存储带有符号位的乘数，且MQ中多存储一位辅助位，初始为0；X和ACC也都使用用双符号位代表正负 除法运算除法运算思想 原码除法: 恢复余数法符号位单独处理：符号位的异或运算数值位：取绝对值进行除法计算 对于计算机而言，会在MQ中存储商，ACC中存储被除数，X中存储除数； 初始时，MQ全0，ACC存被除数的绝对值，X存除数的绝对值 接下来，计算机会默认商1即MQ末位填1，用ACC-X中的除数 = ACC + X中负除数的补码，若结果为负数，说明应该商0，便再改上商0，并“恢复余数” 之后，对ACC、MQ整体 逻辑左移，ACC高位丢弃、MQ低位补0 原码除法：加减交替法恢复余数法：当余数为负时商0，并+|除数|，再左移，再-|除数| 加减交替法：当余数为负时商0，并左移，再+|除数| 注意，余数的正负性与商相同 浮点数的表示基本格式 规则化表示 IEEE754标准 浮点数的运算加减运算 算数逻辑单元设计ALU ALU（Arithmetic and Logic Unit，算术逻辑单元） 运算器=PSW+X+ALU+ACC+MQ（运算器五大部件，ALU是核心部件） 功能 算数运算：加、减、乘、除等 逻辑运算：与、或、非、异或等 辅助功能：移位、求补等 ALU基本结构逻辑结构示意图和实例结构示意图如下 逻辑符号 基本逻辑符号：与、或、非 复合逻辑符号：与非、或非、异或、同或 加法器一位全加器 串行加法器 运行速度很慢 并行加法器 串行进位（串行进位的并行加法器） 速度没有比串行加法器高多少 也叫行波进位加法器 并行进位 单级先行进位方式，又称为组内进位、组间串行进位方式 多级先行进位方式，又称为组内并行、组间并行进位方式（层次化设计） ALU芯片的优化","path":"page/composition04.html","date":"02-03","excerpt":"","tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"http://xiaoliblog.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}]},{"title":"计算机组成原理👨‍💻计算机基础","text":"导论 计算机的最底层由硬件组成，在硬件之上加设操作系统，在操作系统之上再安装应用软件。另外通过计算机网络使得所有的计算机彼此可以交互信息。 而计算机原理就是研究计算机的硬件在底层是如何协调工作的，如CPU型号、运行内存、机身存储、显卡等 就数据而言，如图片、声音、文字、数字等等，其实对于计算机硬件唯一能识别的数据就是二进制0/1，那硬件是怎么区分0和1呢？ 用低/高电平分别表示0/1（高低电平就是指电压高低） 所以本质上在计算机内部就是通过这种电信号传递数据的，通过电信号的高低表示0和1 每一个二进制数位被称为1bit（比特）的信息 计算机的发展计算机系统 计算机系统 = 硬件 + 软件 硬件就是物理的实体，我们看得见摸得着的东西，如主机、外设（鼠标、键盘、显示器等）。 软件就是我们看得见但摸不着的东西，如操作系统、微信、QQ等 软件又可以划分为： 系统软件：用来管理整个计算机系统 如操作系统、数据库管理系统（DBMS）、标准程序库、网络软件（TCP/IC协议）、语言处理程序（编译程序、汇编程序）、服务程序（调试程序）。 应用软件：按任务需要编制成的各种程序 如微信、QQ等应用类软件。 硬件的发展历程 电子管时代，1946年，冯诺依曼发明了第一台电子数字计算机：ENIAC 。它采用了电子管作为逻辑元件（用来处理电信号的最小单元），也开启了第一代电子管计算机时代。当时所使用的编程语言是机器语言编程即纸带机，也因此一个小虫子就可能导致整个程序的错误，bug也因此产生了，这个说法也一直沿用至今（自计算机诞生起，bug就诞生了）。 晶体管时代，后来，贝尔实验室发明了以晶体管替代电子管的计算机，减小了体积和所需功耗。也因为晶体管可以实现更为复杂的电路逻辑，因此产生了面向过程的程序设计语言FORTRAN，也有了操作系统的雏形。 中小规模集成电路时代，将逻辑元件集成在一个基片上，各种高级语言迅速发展，同时有了分时操作系统。 大规模、超大规模集成电路时代，此时开始出现“微处理器”（CPU）和微型计算机，个人计算机（PC）萌芽，操作系统如Windows、MacOS、Linux等诞生。 机器字长：计算机一次整数运算所能处理的二进制位数。对于不同的微处理器，有着不同的机器字长，如Intel公司不断演化的微处理器，其机器字长也不断增长。 在此，让我们了解一个定律，摩尔定律，该定律揭示了信息技术进步的速度。集成电路上可容纳的晶体管数目，约每隔18个月便会增加一倍，整体性能也将提升一倍。而且，除了微处理器的发展符合，存储器（主存）的发展也是这样的。 软件的发展 编程语言的发展。其实软件发展的本质还是编程语言的发展，因为软件本身就是通过各种编程语言实现的。 机器语言、汇编语言——高级语言（FORTRAN、PASCAL、C++）——Java、Python 操作系统的发展，除了应用软件的发展，还有系统软件操作系统的发展。 DOC——Windows——Android、IOS 发展趋势： “两极”分化：一极是微型计算机向更微型化、网络化、高性能、多用途方向发展；另一极是巨型机向更巨型化、超高速、并行处理、智能化方向发展。（如我们的神威·太湖之光，每秒9.3亿亿次浮点运算）超级计算机排行榜 计算机硬件的基本组成冯诺依曼机 世界上第一台计算机ENIAC，是要通过手工接线来控制计算的，大大增加了人工的“时间复杂度”。 因此，冯诺依曼提出了”存储程序”：将指令以二进制代码的形式事先输入计算机的主储存器，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。 基于这种思想，第一台采用冯诺依曼结构的计算机EDVAC诞生了。 通过输入设备输入数据，这里的数据包含了要处理的数据，也包含了数据的计算步骤即程序。在此，数据先流向了运算器，然后通过运算器的中转放到存储器中。经过运算后，会通过输出设备输出计算结果。另外还有一个很重要的部件，控制器，它会电信号来协调其余部件相互工作，也会负责解析存储器里的程序指令 冯诺依曼计算机有以下特点： 计算机由五大部件组成：输入设备、运算器、储存器、控制器、输出设备，其中输入输出设备被统称为I/O设备(input、output) 指令和数据以同等地位存于存储器，可按地址寻访 指令和数据都是用二进制表示的 指令由操作码和地址码组成：操作码指明了操作过程，如加减乘除；而地址码指明了要操作的数据被存放在了内存的什么位置 存储程序：会提前把指令和数据提前存储到存储器中 以运算器为中心：输入/输出设备与储存器之间的数据传送通过运算器完成 在此，我们会发现这样的一个问题，冯诺依曼机的各种数据和指令都要通过运算器中转，还要最终通过运算器来实现运算，这种设计是存在一定的缺陷的。在此基础上，便有了现代计算机的结构 现代计算机结构 与冯诺依曼机以运算器为中心不同的是，现代计算机以存储器为中心。数据和程序经过输入设备是直接放到存储器中，通过运算器的运算再返还结果给存储器，再交给输出设备输出。这样运算器将只负责数据的运算过程，可以让运算器进行更多更快的运算。 也因为运算器和控制器的逻辑关系十分紧密，因此在大规模集成电路出现后，运算器和控制器通常是被集成到同一芯片上的，也就是我们今天的CPU。 CPU = 运算器 + 控制器 正因为CPU的出现，现代计算机的结构可简化为上图。由控制器+运算器组成的CPU和主存储器合称为计组的主机。 以及，主存和辅存都可以被统称为存储器。主存就是主存储器，也就是我们熟悉的内存；而辅存就是辅助存储器，在电脑中就是我们的机械硬盘、固态硬盘。在此要注意的是，主机仅包含了主存，辅存应被归为I/O设备。 计算机硬件部件主存储器主存储器中用于存放数据的叫做存储体，还有两个寄存器MAR（存储地址寄存器）和 MDR（存储数据寄存器） 现在的计算机通常把MAR、MDR也集成在CPU内 注意，1个字节（Byte）= 8 bit，而一个字到底有多少bit要看主存储器中MDR的位数。在描述时，通常以1B代表一个字节，1b表示1bit。 运算器 控制器 控制器，指挥程序运行。 控制器中有三个必不可少的部件： CU：控制单元，分析指令，给出控制信号 IR：指令寄存器，存放当前执行的指令 PC：程序计数器，存放下一条指令地址，有自动加1功能 对于计算机而言，最主要的就是执行代码，代码也就是一条一条的指令，完成一条指令需要： 取指令 ，根据PC的指令地址取出指令 分析指令 ， 从PC取出的指令会放到IR中 执行指令 ， CU分析这条指令要做什么 计算机工作流程 用C语言写这样一段程序 1234int a=2,b=3,c=1,y=0; void main()&#123; y = a * b + c; &#125; 编译装入主存的形式如下图，主存地址0-4存放了指令，5-8存放了数据、 计算机系统的层次结构层次结构 三种级别的语言 我们编写的高级语言需要被编译程序或解释程序翻译成汇编语言或机器语言 编译程序：一次性将高级语言翻译成机器语言程序，如整体翻译（编译语言：C、C++） 解释程序：一句一句将高级语言翻译成机器语言程序，如同声传译（解释语言：JavaScript、Python、Shell） 注：编译、汇编、解释程序，可统称为“翻译程序”； 计算机体系结构——机器语言程序员所见到的计算机系统的属性概念性的结构与功能特性；探讨的是如何设计硬件与软件之间的接口（指令系统、数据类型、寻址技术、I/O机理） 计算机组成原理——实现计算机体系结构所体现的属性，对程序员“透明”（看不见的）；探讨的是如何用硬件实现所定义的接口（具体指令的实现） 计算机性能指标存储器的性能指标 评估存储器的性能指标有 MAR位数：存储单元的个数（最多支持） MDR位数：储存字长=每个存储单元的大小 注：描述文件大小的K:2^10: 、 M:2^20 、 G:2^30 、 T:2^40 CPU的性能指标 系统整体的性能指标 对于系统整体的静态性能指标有： 数据通路带宽：数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据） 吞吐量：系统在单位时间内处理请求（请求：广义上的任务）的数量 响应时间：从用户向计算机发送一个请求，到系统对该请求做出响应并获得它所需要的结果的等待时间 对于系统整体的动态性能指标有： 基准程序：用来测量计算机处理速度的一种实用程序，以便于被测量的计算机性能可以与运行相同程序的其它计算机性能相比较（跑分软件，如鲁大师等的电脑性能评估），基准程序内置一段程序代码，包含各种指令，根据电脑设备运行这段程序代码的耗时来评判 思考 主频高的CPU一定比主频低的CPU快吗？ 答：不一定，如两个CPU，A主频为2GHz，平均CPI=10，A一秒可以执行0.2G条指令； B主频为1GHz，平均CPI=1，B一秒可以执行1G条指令。 那若A、B两个CPU的平均CPI相同，那么A一定更快吗？ 答：不一定，还要看指令系统，如A不支持乘法指令，只能用多次加法实现乘法；而B支持乘法指令。 基准程序执行得越快说明机器性能越好吗？ 答：基准程序中的语句存在频度差异，运行结果也不能完全说明问题（如基准程序中可能图像处理部分的语句占比很多，则会影响到其他性能的测试权重占比） 参考👉👉👉2019 王道考研 计算机组成原理|课程笔记","path":"page/composition02.html","date":"02-02","excerpt":"","tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"http://xiaoliblog.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}]},{"title":"Music Theory","text":"基本乐理节拍 拍号（节奏与节拍的表示） 4/4（四四拍）：以四分音符为一拍，每小节四拍，强→弱→次强→弱 4/3（四三拍）：以四分音符为一拍，每小节三拍，强→弱→弱 4/2（四二拍）：以四分音符为一拍，每小节两拍，强→弱→弱 8/6（八六拍）：以八分音符为一拍，每小节六拍，强→弱→弱→次强→弱→弱 十二平均律从任何一个音到高八度的那个音之间会经过十二个音（半音），这样的规律称为十二平均律 基本音级CDEFGAB，变化音级 #C #D #E #F #G #A 半音：相邻两个音为半音关系，对照吉他上的相邻品位（空弦到1品也为半音关系） 全音：中间隔一个音为全音关系，即两个半音为一个全音（比如1和2） 但是EF、BC已经是最小距离，即半音关系 升记号#：基本音级升高半音 降记号b：基本音级降低半音 C大调C大调（C Major）是一个于C音开始的音乐的自然大调，组成的音有CDEFGAB，是一个没有升号和降号的调，并按全全半全全全半排列 C大调音阶：C D E F G A B C大调旋律：打乱音阶的顺序 C C G G | A A G - | F F Ｅ E | D D C - | C大调和弦：多个音按照特定关系同时弹响 C大调曲子：C大调和弦+C大调旋律 大调：按照全全半全全全半排列，这样排列听起来很阳光快乐，故取名为大调 可以把任何一个音（X）作为第一个音，称为X大调，故有12个大调，比如D大调 想得到X大调的音阶就从X音开始按照：全全半全全全半，这样的距离间隔排列出一串音，那这串音就是X大调音阶 音乐名词 音名 音的名字叫音名，用7个英文字母表示: CDEFGAB，升降音用升降符号写在那个音的前面如:#C，bC 唱名 唱名是我们用来描述一段旋律的时候或 唱某段旋律的时候，这些音的另外一种比较适合经常读出来的读音。唱作do re mi fa sol la si 由于调性，音名不变，唱名可以改变 固定调（认音不认调） 把CDEFGAB这7个音永远唱做Do Re Mi Fa Sol La Si，升C就唱作:升do ，降B就唱做:降si，以此类推。不管什么调都是如此,固定不变。 首调（认调不认音） 永远把这个调里的第一级音唱作是Do，第二级音唱做是Re以此类推（小调的第一级音唱La)，每个音都可以为do，do re mi..是一种固定关系，以哪个音为do，即为什么调，比如A大调音阶 吉他指板结构 记忆口诀(1-6弦)：二(er)表(biao)哥(ge)都(dou)挨(ai)饿(e) 吉他相邻品格为半音关系，这样就可以推出指板上的音名，例如1弦的音名排列，其他类推 吉他指板基本音级图 音阶型 X型音阶 以吉他6弦上X音为最低音的音阶，比如Mi型音阶、Sol型音阶，这是只有吉他上才有的叫法，因为吉他音阶排列的特殊性，一个相同的音可能会排列在不同的地方，即同音不同弦的情况，需要安排一种适合吉他的音阶演奏路线，这个路线既要符合手指的分工又要避免大跨度，所以划分为一个个块状区域 Mi型音阶 Sol型音阶 La型音阶 Si型音阶 Re型音阶 主音概念 主音 调式中第一级音叫做主音，比如C大调音阶，C就是主音。主音起到支撑整个音乐色彩的作用，可以认为音阶中所以音都是为主音服务 练习音阶的时候要养成从主音开始，到主音结束的习惯 平行大小调 小调 从X音开始按照:全半全全半全全的间隔排列一串音叫X小调，比如C小调，小调色彩较悲伤 也可以理解为把C大调的3级、6级和7级降低半音得到C小调 平行大小调(关系大小调) 大调跟小调的调号一样的 叫平行大小调或关系大小调 （大调里的音跟小调里的音相同但是排列顺序不一样的关系叫做平行大小调），比如C大调和A小调 音程 音程 音与音之间的距离（高度关系），计量单位是度 二度音程 由两个相邻音组成的音程叫做“二度”音程 大二度：两音音高距离为一个全音 小二度：两音音高距离为一个半音 求X-Y两音之间的度数 从X音开始，按照基本音级数到Y，包含几个音即为度数 在一个大调里面，主音和其他音之间的关系如下 可知主音和其他音之间只有两种情况：纯和大，那只有考虑一个音到另外一个音的距离是比这些音程宽还是窄就可以了 比纯音程窄一点的为减音程 比纯音程宽一点的为增音程 比大音程小一点的为小音程 比大音程大一点的为增音程 任何大调里，主音到其他音级的关系是: 1458度是纯音程，2367度是大音程 实例 比如C-A，即1-6为大六度，因为C大调6级音为A 如果C-bA，即do到降la，这时由于la降低了，使原来的大六度小了一点，而比大音程还小的音程是小音程，故为小6度 如果C-#A，la升高了，使原来的大六度升高了，而比大音程还大的音程是增音程，故为增6度 如果#C-A，do升高了，使原来的大六度变窄了，比大音程还小的音程是小音程，故为小6度 如果#C-bA，do升高，la也降低，这使得它们之间的距离变得更窄了，比小音程还小的音程是减音程，故为减6度 如果#C-#A，do和la同时升高了，即两音之间距离不变为大6度 求#D-bA为几度 首先#D-bA经过了D E F G A五个音，可以肯定为5度 然后列出D大调音阶，然后看D-A为纯五度，因为任何大调主音到5级音都为纯音程 然后看题目，D升高了，A降低了，这使得它们之间的纯音程变得更窄了，故答案为倍减5度 求bE-#C为几度 首先bE-#C经过了E F G A B C六个音，可以肯定为6度 然后列出E大调音阶，然后看E-#C为大六度，因为2367为大音程 然后看题目，E降低了，这使得它们之间的大六度程变宽了 音程构建 任何大调里，主音到其他音级的关系是: 1458度是纯音程，2367度是大音程 音程构建 求C大调的音程构建，首先列出C大调音阶，C的大三度音是E，C的纯五度是G 求G的大三度和纯五度，首先列出G大调音阶，很容易得出G的大三度为B，G的纯五度为D 求F的大三度，纯五度和大七度，首先列出F大调音阶 求A的小三度，首先列出A大调音阶，A的大三度是#C，降低半音就是小三度，即C 音级 G大调音阶里，七级音是#F还是bG呢？ 再比如E大三和弦里，三弦音是#G还是bA呢？ 以上遇到升降音的问题时，记住任何大调或自然小调里的音级，必须是不同的7个音级 不管是#G还是bG都是属于G音级 比如升G调 太多的升号可以考虑转为bA调 五度圈 五度圈如下，例举几个实用的用法 快速确定一个大调的6个级数和弦 比如D大调，在五度圈中找到D这个音，围绕D的6个和弦即所找和弦 快速确定一个大三和弦的组成音 只需要找到三音和五音即可，五度圈根音下一个便是五音，五音的对面是三音 比如找A和弦的组成音：A #C E 快速确定145弹布鲁斯和弦 比如想弹C调的145布鲁斯，只需要找到C旁边的和弦便是4级和5级和弦，然后转为属和弦 如果想弹小调布鲁斯，只需要把1级和4级变为小三和弦或者小七即可 布鲁斯和弦一般都是一个调式里的145级和弦的属和弦 快速找到251弹爵士和弦进行 比如想弹G调的251进行，找到G，旁边的是5，然后5旁边的就是2，然后转为爵士的七和弦 和弦 和弦 三个音或三个以上的音按照一定的音程关系叠加的综合叫做和弦 三和弦 三和弦 三个音按照大小三度的关系叠加而成的一组音 例如C和弦（1，3，5）1为根音，3为三音，5为五音（冠音） 大三和弦 由根音到三音为大三度，三音到五音为小三度，即大三度+小三度 大三和弦色彩明亮，积极愉快 例如：C大三和弦（CMajor）：1，3，5 小三和弦 由根音到三音为小三度，三音到五音为大三度，即小三度+大三度 小三和弦色彩暗淡，伤感 例如：C小三和弦（Cminor，即Cm）：1，b3，5 增三和弦 由两个大三度叠加而成 不和谐，有扩张感 比如，C增三和弦（Caug）：1，3，#5 减三和弦 由两个小三度叠加而成 不和谐，有收缩感 比如，B减三和弦（Bdim）：低音7，2，4 C大调和弦 C大调和弦 C大调里面的音阶组成和弦。也叫调性和弦或顺接和弦。145为大三和弦，2367为小三和弦 和弦不是只有一种按法，和弦的按法是只要满足和弦的构成音即可 编排生日快乐歌 首先是单音旋律部分 如果想把这些旋律弹的更有音乐性，更加丰富，可以加入和声，一种简单的方法就是加入和弦音，比如根音 最后就是一个简单的独奏曲了 还可以把和声部分编的更加丰富，不断加和弦根音和三音 如果改编为弹唱谱，只需要把旋律部分改为唱，吉他只需要弹和声部分 根音+柱式和弦的弹法 七和弦 七和弦 由四个音组成，在根音、三音和五音的基础上再加一个七音组成 例如：Cmaj7由1，3，5，7构成 大小七和弦（属七和弦） 在大三和弦的基础上再加一个小三度，或者理解为根音上方加一个小七度音，即大三度+小三度+小三度 例如：G7由5、7、2、4构成 非常不和谐，三音和七音为减五度关系，所以一般接到主和弦（G7-C) 一般一个调式中，一级和弦为主和弦，七级和弦为属和弦，属和弦接主和弦是非常通顺的，比如（G-C），这样处理给人一种结束的感受，大多数流行曲都属于这种套路 反向思维，比如B7和弦非常不协和，需要接到哪里呢？这个来个上行纯4度音E就可以了，同理可得，E7接A和弦 大七和弦 大三和弦的基础上叠加一个大三度的音程，或者叠加根音的大七度音，即大三度+小三度+大三度 大七和弦接近大三和弦 例如：Cmaj7由1，3，5，7构成 小七和弦 大三和弦的基础上叠加一个小三度的音程，或者叠加根音的小七度音，即小三度+大三度+小三度 小七和弦色彩介于小三和弦和大三和弦之间，很多流行歌都有用小七和弦代替小三和弦的情况 例如：Am7由低音6，1，3，5构成 ，Dm7由2，4，6，高音1构成 减七和弦 由减三和弦叠加一个小三度构成，即小三度+小三度+小三度 例如：Edim7由3，5，b7，b高音2构成 半减七和弦 由减三和弦叠加一个大三度构成，即小三度+小三度+大三度 具有浓厚的爵士风味 例如：Cm7-5：构成音为1，b3，b5，b7，相当于把Cm7中（1，b3，5，b7）纯五度音减半音 小大七和弦 由小三和弦叠加一个大三度构成，即小三度+大三度+大三度 例如：M7由6，高音1，高音3，高音5构成 转调 只需要一个属和弦过渡到另一个调 比如弹奏的是C调，想要转入#C调，只需要找到#C的属和弦#G（反推下行纯4度音），即C→#G→#C完成转调 复合和弦 复合和弦 和弦根音不是落在其主音上，称为复合和弦，复合和弦又分转位、分割和加和弦 转位和弦 根音不是主音而是和弦之内的音 例如：C/E和弦，原来C和弦根音为5弦三品，C/E和弦根音变为6弦空弦E 分割和弦 根音不是主音而是和弦之外的音 例如：Am/G和弦，Am组成音为6，1，3，Am/G和弦根音为6弦三品，即G音 添加和弦 add+音程数 例如：Cadd9，添加根音的九度音程 万能和弦进行 卡农和弦进行，万能和弦的套路是尽量让两个和弦连接时，根音更加接近，即低音下行 和弦推算 首调概念推组成音 无论是哪个当那个调，例如B调，1=B 例如：Bm7和弦构成音1，b3,5,b7 A指型 A指型和弦根音都在5弦上，通过移动把位根据十二平均律可以推算出其他和弦，分别为大三和弦、小三和弦、属七和弦、大七和弦和小七和弦 五弦上第三品以C为根音的和弦 E指型 E指型和弦根音都在6弦上，通过移动把位根据十二平均律可以推算出其他和弦 六弦上以F为根音的和弦 也就是说，在5、6弦上随便找一个音作为根音，都可以按出其对应的和弦，5弦用A指型，6弦用E指型，加大横按类推 变调夹 经常会在吉他谱上看到以上说明 原调=bE，也就是用的是bE调的和弦和音阶 选调=C，也就是用C调编排，编排思路就是根据和弦级数对换相应的C大调和弦 CAPO=3，也就是变调夹夹3品，#D调也就是bE调，即用C调指法弹原调bE 原调=bB，也就是用的是bB调的和弦和音阶 选调=G，也就是用G调编排，编排思路就是根据和弦级数对换相应的G大调和弦 CAPO=3，也就是变调夹夹3品，G+3半音=bB 如果只喜欢玩弹唱，基本只要掌握C和G调的和弦系统，配合变调夹就可以弹奏大部分的歌曲 比如原调A，选调G，变调夹夹二品 原调#C，选调C，变调夹夹一品 原调B，选调G，变调夹夹四品 指板音阶记忆记音名，不记唱名；音名不变，唱名会变 五和弦记忆法 5弦上五和弦记忆法 五和弦：三和弦去掉三音，只剩根音和五音 记住五和弦的指法 C大调：1，5，1（把1=C） C小调：6，3，6（把6=C），找到主音是什么即为什么调，然后按五和弦指型推音阶即可 6弦上五和弦记忆法，和5弦类似 当碰到1、2弦时，五和弦指法多移一品，大小调音名不变 练习：随便找一个音，知道它的音名，并且可以根据A指型或者E指型找出其大小三和弦、属七大七小七和弦，知道和弦构成音，能通过五和弦指型找出大小调音阶 二弦Mi型音阶平移法 熟练二弦的音名，通过偏移C调的Mi型音阶可以找出二弦上所有主音的音阶 比如E大调音阶 找调 通过二弦音阶的偏移法，可以在二弦上或者五弦试着找歌曲的调 歌曲一般都以主音结尾 具体看视频讲解 二五一进行 二五一进行 是一个调式中的二级、五级和一级的和弦进行，一种终止式 传统终止法：F→G→C，因为这三个和弦包含了C大调里面所有的音级，呈现了一个调式的色彩 现代终止法： Dm7→G→C，Dm7组成音2，4，6，1； Dm7包含了F和弦组成音，代替F是没有问题的 Dm7根音→G→C，构成了五度音程连接，五度音程连接是非常有力量感，非常顺畅的 如果全上升为七和弦，就构成了爵士音乐基础进行：Dm7→G7→Cmaj7 不仅大调有，小调也有二五一进行，比如C大调的平行小调A小调 二五一为：B- → Em → Am，但五级是小三和弦，这会缺少力量感，可以替换为属七和弦，产生矛盾让一级解决，那么二五一就变为：B- → E7 → Am 全部上升为七和弦：B7-5 → E7 → Am7 如果C大调251+A小调251配合，就会有一种大小调转换的感觉，一般会在中间加一个Fmaj7和弦构成一个五度关系，比如爵士曲秋叶 流行伴奏律动 十六音符分解和弦 掌握律动 前八后十六 掌握律动，很适合民谣 拍弦节奏型 掌握律动 复杂节奏型 bossa nova风格律动 扫弦节奏型1 掌握律动 扫弦节奏型2 参考👉👉👉具体教程请戳B站UP主来玩吉他","path":"page/MusicTheory.html","date":"02-01","excerpt":"","tags":[{"name":"乐理","slug":"乐理","permalink":"http://xiaoliblog.cn/tags/%E4%B9%90%E7%90%86/"}]},{"title":"Git🧰GitHub相关操作","text":"下载Git 首先你需要一个github账号，所有还没有的话先去注册吧！ 我们使用git需要先安装git工具，这里给出下载地址，下载后一路直接安装即可：https://gitforwindows.org/ 仓库管理创建仓库 进入Github首页，点击New repository新建一个项目 填写相应信息后点击create即可 Repository name: 仓库名称 Description(可选): 仓库描述介绍 Public, Private : 仓库权限（公开共享，私有或指定合作者） Initialize this repository with a README: 添加一个README.md gitignore: 不需要进行版本管理的仓库类型，对应生成文件.gitignore license: 证书类型，对应生成文件LICENSE 点击Clone or dowload会出现一个地址，copy这个地址备用。 仓库初始化 新建一个文件夹，在这里打开命令行，先用Git初始化这个文件夹，并在里面放入一个README.md文件 12345$ git init # 初始化文件夹（在文件夹内创建一个.git文件夹用于存储git信息）$ git add . # 添加所有更改，当然你也可以添加特定的更改，把.换成文件路径即可$ git commit -m &quot;init&quot; # 提交更改，并留下信息为&quot;init&quot;$ git remote add origin git@github.com:xiaoliblog/MyCode.git # 添加仓库地址到名为origin的git目标$ git push -u origin master # Git推送到仓库，仅第一次加入git远程目标时需要，后续直接git push 添加SSH秘钥 输入以下命令，并一路回车 1$ ssh-keygen -t rsa 然后Windows会在C:\\Users\\:user\\.ssh下创建两个文件，linux则会在/.ssh创建两个文件，两个系统创建的文件是一样的，都是id_rsa和id_rsa.pub。 将id_rsa.pub内容复制，然后点开Github设置，点击左边的SSH and GPG Keys，点击右上角的NEW SSH KEY，粘贴到相应位置，即完成SSH设置 克隆及上传克隆项目 首先创建一个文件夹存放项目，然后右键你的项目选择Git Bash Here，进入如下界面，MyCode即为我的项目文件名。 接下来输入如下代码（关键步骤），把github上面的仓库克隆到本地，后面URL为以上copy的地址 1$ git clone https://github.com/lzyblog/MyCode.git 进入克隆到本地的文件中，可以看到GitHub仓库里的文件 1$ cd MyCode 本地上传 将想要提交（上传）到GitHub的代码拷贝到本地计算机中的MyCode文件夹，然后执行“git add .”命令。这里的”.”表示将当前目录下所有改动的文件夹及文件添加到版本管理器。 1$ git add . #把该目录下的所有文件添加到仓库 执行git commit -m “First commit”命令，提交到本地的版本控制库里，引号里面是你对本次提交的说明信息 1git commit -m &quot;First commit&quot; #添加-m参数，提交的注释内容 最后，执行” git push origin master“命令将本地仓库提交到远程的GitHub中，这里会用到注册的用户名和密码。输入密码的时候默认是没有任何提示符。 1$ git push origin main #main也可以是master，具体看仓库 这样，刷新GitHub仓库，你的代码就上传了！ 删除文件 本地仓库的文件和远程仓库的文件同时删除先打开本地仓库的文件夹，选择要删除的文件或者文件夹点击删除，注意github仓库不要删除然后执行下面的命令行即可，刷新页面后远程仓库的文件或者文件夹就已经被删除了 123$ git add * #把本地仓库的文件上传到缓存$ git commit -m &#x27;del&#x27; #把第一步上传到缓存的东西上传到本地仓库，其中‘del’是操作标识，内容随便填$ git push origin main #把本地仓库的文件上传到远程仓库 main可以是master 只删除远程仓库，不删除本地仓库进入到Git Bash窗口，执行以下命令 12345$ git pull origin main #将远程仓库里面的项目拉下来 main/master$ dir #查看有哪些文件夹$ git rm -r --cached JavaMailProject #删除你要删除的文件每次，这里是删除JavaMailProject文件（cached不会把本地的flashview文件夹删除）$ git commit -m &#x27;删除了JavaMailProject&#x27; #提交，添加操作说明$ git push -u origin main #重新提交 main也可以是master分支","path":"page/git02.html","date":"01-31","excerpt":"","tags":[{"name":"Git","slug":"Git","permalink":"http://xiaoliblog.cn/tags/Git/"}]},{"title":"Git🧰Git安装及基本使用","text":"版本控制 版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术 实现跨区域多人协同开发 追踪和记载一个或者多个文件的历史记录 组织和保护你的源代码和文档 统计工作量 并行开发、提高开发效率 跟踪记录整个软件的开发过程 减轻开发人员的负担，节省时间，同时降低人为错误 常见的版本控制工具 Git SVN（Subversion） CVS（Concurrent Versions System） VSS（Micorosoft Visual SourceSafe） TFS（Team Foundation Server） Visual Studio Online 版本控制分类 本地版本控制 记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS 集中版本控制 SVN 所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改 所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS 分布式版本控制 Git每个人都拥有全部的代码！安全隐患！所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。不会因为服务器损坏或者网络问题，造成不能工作的情况！ Git与SVN区别 SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高 Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！ Git是目前世界上最先进的分布式版本控制系统 Git环境配置Git安装与启动 打开 [git官网] https://git-scm.com/，下载git对应操作系统的版本。 官网下载太慢，我们可以使用淘宝镜像下载：http://npm.taobao.org/mirrors/git-for-windows/ 安装：无脑下一步即可！安装完毕就可以使用了！ 所有东西下载慢的话就可以去找镜像！ 启动Git 安装成功后在开始菜单中会有Git项，菜单下有3个程序：任意文件夹下右键也可以看到对应的程序！ Git Bash：Unix与Linux风格的命令行，使用最多，推荐最多 Git CMD：Windows风格的命令行 Git GUI：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令 常用的Linux命令 cd : 改变目录。 cd . . 回退到上一个目录，直接cd进入默认目录 pwd : 显示当前所在的目录路径。 ls(ll): 都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。 touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。 rm: 删除一个文件, rm index.js 就会把index.js文件删除。 mkdir: 新建一个目录,就是新建一个文件夹。 rm -r : 删除一个文件夹, rm -r src 删除src目录 rm -rf / 切勿在Linux中尝试！删除电脑中全部文件！ mv 移动文件, mv index.html src， index.html 是我们要移动的文件, src 是目标文件夹,当然, 这样写,必须保证文件和目标文件夹在同一目录下。 reset 重新初始化终端/清屏。 clear 清屏。 history 查看命令历史。 help 帮助。 exit 退出。 #表示注释 Git配置 Git相关的配置文件： Git\\etc\\gitconfig Git 安装目录下的 gitconfig ——system 系统级 C:\\Users\\Administrator\\ .gitconfig 只适用于当前登录用户(用户名和邮箱修改)的配置 ——global 全局 由上可知所有的配置文件，其实都保存在本地！查看配置使用以下命令 1$ git config -l 查看不同级别的配置文件 12345#查看系统config$ git config --system --list#查看当前用户（global）配置$ git config --global --list 设置用户名与邮箱当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中： 12$ git config --global user.name &quot;xiaoliblog&quot; #名称$ git config --global user.email &quot;2312057536@qq.com&quot; #邮箱 环境变量配置的目的是任何地方都使用该命令，但Git只需点击右键就可以在任何地方使用，所以可以不用配置环境变量！ Git基本理论工作区域Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下： Workspace：工作区，就是你平时存放项目代码的地方 Index / Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息 Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本 Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换 本地的三个区域确切的说应该是git仓库中HEAD指向的版本，.git为一个隐藏文件夹： Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。 WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。 .git：存放Git管理信息的目录，初始化仓库的时候自动创建。 Index/Stage：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。 Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。 Stash：隐藏，是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。 工作流程Git的工作流程一般是这样的： 在工作目录中添加、修改文件； 将需要进行版本管理的文件放入暂存区域；(git add .) 将暂存区域的文件提交到git仓库。(git commit) 因此，Git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed) Git项目搭建创建工作目录与常用指令工作目录（WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。 日常使用只要记住下图6个命令： 本地仓库搭建创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。 创建全新仓库 创建全新的仓库，需要用GIT管理的项目的根目录执行：12#在当前目录新建一个Git代码库$ git init 执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。 克隆远程仓库 另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！12#克隆一个项目和它的整个代码历史(版本信息)$ git clone [url] # https://gitee.com/kuangstudy/openclass.git 去 gitee 或者 github 上克隆一个测试！ Git文件操作文件的四种状态版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。 Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged. Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件 Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 ! Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified 查看文件状态上面说文件有4种状态，通过如下命令可以查看到文件的状态： 1234567891011#查看指定文件状态$ git status [filename]#查看所有文件状态$ git status#添加所有文件到暂存区$ git add . # 交暂存区中的内容到本地仓库 -m 提交信息$ git commit -m &quot;消息内容&quot; 忽略文件有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等 在主目录下建立.gitignore文件，此文件有如下规则： 忽略文件中的空行或以井号（#）开始的行将会被忽略。 可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（&#123;string1,string2,...&#125;）代表可选的字符串等。 如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。 如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。 如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。 123456#为注释*.txt #忽略所有 .txt结尾的文件,这样的话上传就不会被选中！!lib.txt #但lib.txt除外/temp #仅忽略项目根目录下的TODO文件,不包括其它目录tempbuild/ #忽略build/目录下的所有文件doc/*.txt #会忽略 doc/notes.txt 但不包括 doc/server/arch.txt 使用码云Github 是有墙的，比较慢，在国内的话，我们一般使用 Gitee ，公司中有时候会搭建自己的Gitlab服务器 官网注册登录码云：https://gitee.com/，完善个人信息 设置本机绑定SSH公钥，实现免密码登录！（免密码登录，这一步挺重要的，码云是远程仓库，我们是平时工作在本地仓库！)123# 进入 C:\\Users\\Administrator\\.ssh 目录# 输入命令后，一路空格，生成公钥$ ssh-keygen -t rsa 将公钥信息public key 添加到码云账户中即可！【设置】-&gt;【SSh公钥】 使用码云创建一个自己的仓库！选择一个本地文件夹克隆到本地！1$ git clone https://gitee.com/username/仓库名.git Git分支master主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作，工作完后，比如要发布，或者说dev分支代码稳定后可以合并到主分支master上来。 123456789101112131415161718192021# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 合并指定分支到当前分支$ git merge [branch]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 参考👉👉Git教程|Git最新教程通俗易懂|尚硅谷GitHub教程","path":"page/git01.html","date":"01-31","excerpt":"","tags":[{"name":"Git","slug":"Git","permalink":"http://xiaoliblog.cn/tags/Git/"}]},{"title":"Web移动开发📲Bootstrap响应式布局","text":"响应式开发就是使用媒体查询针对不同宽度的设备进行布局和样式的设置,从而适配不同设备的目的 设备划分 尺寸区间 超小屏幕(手机) &lt; 768px 小屏设备(平板) &gt;=768px~&lt;992px 中等屏幕(桌面显示器) &gt;= 992px ~ &lt;1200px 宽屏设备(大桌面显示器) &gt;= 1200px 响应式布局容器响应式需要一个父级做为布局容器，来配合子级元素来实现变化效果。原理就是在不同屏幕下，通过媒体查询来改变这个布局容器的大小，再改变里面子元素的排列方式和大小，从而实现不同屏幕下，看到不同的页面布局和样式变化。 平时我们的响应式尺寸划分 超小屏幕(手机, 小于768px) :设置宽度为100% 小屏幕( 平板，大于等于768px) :设置宽度为750px 中等屏幕( 桌面显示器,大于等于992px) : 宽度设置为970px 大屏幕(大桌面显示器 ,大于等于1200px) :宽度设置为1170px 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container &#123; height: 150px; background-color: pink; margin: 0 auto; &#125; /* 1. 超小屏幕下 小于 768 布局容器的宽度为 100% */ @media screen and (max-width: 767px) &#123; .container &#123; width: 100%; &#125; &#125; /* 2. 小屏幕下 大于等于768 布局容器改为 750px */ @media screen and (min-width: 768px) &#123; .container &#123; width: 750px; &#125; &#125; /* 3. 中等屏幕下 大于等于 992px 布局容器修改为 970px */ @media screen and (min-width: 992px) &#123; .container &#123; width: 970px; &#125; &#125; /* 4. 大屏幕下 大于等于1200 布局容器修改为 1170 */ @media screen and (min-width: 1200px) &#123; .container &#123; width: 1170px; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 响应式开发里面，首先需要一个布局容器 --&gt; &lt;div class=&quot;container&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 响应式导航案例 当我们屏幕大于等于768像素，我们给布局容器container宽度为750px container里面包含8个小li盒子,每个盒子的宽度定为93.75px( 750/8)，高度为30px ,浮动一行显示 当我们屏幕缩放，宽度小于768像素的时候，container盒子宽度修改为100%宽度 此时里面的8个小li , 宽度修改为33.33% ,这样一行就只能显示3个小i ,剩余下行显示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; ul &#123; list-style: none; &#125; .container &#123; width: 750px; margin: 0 auto; &#125; .container ul li &#123; float: left; width: 93.75px; height: 30px; background-color: green; &#125; /*屏幕小于767px时，修改为100%*/ @media screen and (max-width: 767px) &#123; .container &#123; width: 100%; &#125; .container ul li &#123; width: 33.33%; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;ul&gt; &lt;li&gt;导航栏&lt;/li&gt; &lt;li&gt;导航栏&lt;/li&gt; &lt;li&gt;导航栏&lt;/li&gt; &lt;li&gt;导航栏&lt;/li&gt; &lt;li&gt;导航栏&lt;/li&gt; &lt;li&gt;导航栏&lt;/li&gt; &lt;li&gt;导航栏&lt;/li&gt; &lt;li&gt;导航栏&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Bootstrap Bootstrap来自Twitter (推特) , 是目前最受欢迎的前端框架。Bootstrap 是基于HTML、CSS和JAVASCRIPT的，它简洁灵活，使得Web开发更加快捷。 中文官网: http://www.bootcss.com/ 官网: http://getbootstrap.com/ 推荐使用: http://bootstrap.css88.com/ 框架:顾名思义就是一套架构，它有一套比较完整的网页功能解决方案，而且控制权在框架本身，有预制样式库、组件和插件。使用者要按照框架所规定的某种规范进行开发。 优点 标准化的html+css编码规范 提供了一 套简洁、直观、强悍的组件 有自己的生态圈，不断的更新迭代 让开发更简单，提高了开发的效率 版本 2.x.x :停止维护，兼容性好，代码不够简洁，功能不够完善。 3.x.x :目前使用最多，稳定,但是放弃了IE6-IE7。 对IE8支持但是界面效果不好偏向用于开发响应式布局、移动设备优先的WEB项目 4.x.x :最新版，目前还不是很流行 Bootstrap使用 控制权在框架本身，使用者要按照框架所规定的某种规范进行开发 Bootstrap使用四步曲: 创建文件夹结构 创建html骨架结构 引入相关样式文件 书写内容 创建文件夹结构，多了一个存放Bootstrap的文件夹，内容需要从官网下载 创建html骨架结构 1234567891011&lt;!--要求当前网页使用IE浏览器最高版本的内核来渲染--&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;&lt;!--视口的设置:视口的宽度和设备一致，默认的缩放比例和PC端一致，用户不能自行缩放--&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1,user-scalable=0&quot;&gt;&lt;!-- HTML5 shim 和 Respond.js 是为了让 IE8 支持 HTML5 元素和媒体查询（media queries）功能 --&gt;&lt;!-- 警告：通过 file:// 协议（就是直接将 html 页面拖拽到浏览器中）访问页面时 Respond.js 不起作用 --&gt;&lt;!--[if lt IE 9]&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt; 引入相关样式文件 12&lt;!-- Bootstrap核心样式 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap/css/bootstrap.min.css&quot;&gt; 书写内容 直接拿Bootstrap预先定义好的样式来使用 修改Bootstrap原来的样式,注意权重问题人 学好Bootstrap的关键在于知道它定义了哪些样式,以及这些样式能实现什么样的效果 具体样式示例，可以到官网查看：https://v3.bootcss.com/css/ 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap-3.3.7-dist/css/bootstrap.min.css&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /*利用自己写的样式覆盖原先的样式，注重权重问题*/ .login&#123; width: 100px; height: 40px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-success&quot;&gt;（成功）Success&lt;/button&gt; &lt;!--通过class类控制，div等其他标签页可以使用--&gt; &lt;div class=&quot;btn btn-success login&quot;&gt;登录成功&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Bootstrap布局容器Bootstrap需要为页面内容和栅格系统包裹一个.container容器,，Bootstarp预先定义好了这个类，叫.container，不能起其他名字 它提供了两个作此用处的类 container类 响应式布局的容器固定宽度 大屏(&gt;= 1200px)宽度定为1170px 中屏(&gt;=992px) 宽度定为970px 小屏(&gt;=768px) 宽度定为750px 超小屏(100%) container-fluid类 流式布局容器 百分百宽度 占据全部视口 ( viewport )的容器。 适合于单独做移动端开发 12&lt;div class=&quot;container&quot;&gt;123&lt;/div&gt;&lt;div class=&quot;container-fluid&quot;&gt;456&lt;/div&gt; Bootstrap栅格系统 栅格系统英文为grid systems，也有人翻译为”网格系统“，它是指将页面布局划分为等宽的列，然后通过列数的定义来模块化页面布局 Bootstrap提供了一套响应式、 移动设备优先的流式栅格系统，随着屏幕或视口( viewport )尺寸的增加，系统会自动分为最多12列 Bootstrap里面container宽度是固定的，但是不同屏幕下，container的宽度不同，我们再把container划分为12等份 具体可查看官方文档：https://v3.bootcss.com/css/#grid Bootstrap栅格系统使用栅格系统用于通过一系列的行 ( row )与列( column )的组合来创建页面布局，你的内容就可以放入这些创建好的布局中。 行( row )必须放到container布局容器里面 我们实现列的平均划分 需要给列添加类前缀 xs-extra small : 超小 sm-small : 小 md-medium: 中等 lg-large : 大 列( column)大于12，多余的”列( column )”所在的元素将被作为一个整体另起一 行排列 列( column)小于12，则占不满整个container的宽度，会留有空白 每一列默认有左右15像素的 padding 可以同时为一列指定多个设备的类名，以便划分不同份数，例如class=” col-md-4 col-sm-6 “ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap-3.3.7-dist/css/bootstrap.min.css&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container .row&#123; margin-top: 5px; &#125; [class^=&quot;col&quot;]&#123; border:1px solid #ccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;p&gt;12份，每个大盒子占3份&lt;/p&gt; &lt;div class=&quot;row&quot;&gt; &lt;!--12份，每个大盒子占3份--&gt; &lt;div class=&quot;col-lg-3&quot;&gt;3份&lt;/div&gt; &lt;div class=&quot;col-lg-3&quot;&gt;3份&lt;/div&gt; &lt;div class=&quot;col-lg-3&quot;&gt;3份&lt;/div&gt; &lt;div class=&quot;col-lg-3&quot;&gt;3份&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;p&gt;12份，第1个盒子占6份，其他平分2份&lt;/p&gt; &lt;!--12份，第1个盒子占6份，其他平分2份--&gt; &lt;div class=&quot;col-lg-6&quot;&gt;6份&lt;/div&gt; &lt;div class=&quot;col-lg-2&quot;&gt;2份&lt;/div&gt; &lt;div class=&quot;col-lg-2&quot;&gt;2份&lt;/div&gt; &lt;div class=&quot;col-lg-2&quot;&gt;2份&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;p&gt;如果子盒子分数相加 小于12 则占不满整个container的宽度，会有空白&lt;/p&gt; &lt;!--如果子盒子分数相加 小于12 则占不满整个container的宽度，会有空白--&gt; &lt;div class=&quot;col-lg-6&quot;&gt;6份&lt;/div&gt; &lt;div class=&quot;col-lg-2&quot;&gt;2份&lt;/div&gt; &lt;div class=&quot;col-lg-2&quot;&gt;2份&lt;/div&gt; &lt;div class=&quot;col-lg-1&quot;&gt;1份&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;p&gt;如果子盒子分数相加 大于12 则多余的元素将被作为一个整体另起一行排列&lt;/p&gt; &lt;!--如果子盒子分数相加 大于12 则多余的元素将被作为一个整体另起一行排列--&gt; &lt;div class=&quot;col-lg-6&quot;&gt;6份&lt;/div&gt; &lt;div class=&quot;col-lg-2&quot;&gt;2份&lt;/div&gt; &lt;div class=&quot;col-lg-2&quot;&gt;2份&lt;/div&gt; &lt;div class=&quot;col-lg-3&quot;&gt;3份&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;p&gt;大屏幕下每个盒子占3份，四个一行&lt;/p&gt; &lt;p&gt;中屏幕下每个盒子占4份，三个一行&lt;/p&gt; &lt;p&gt;小屏幕下每个盒子占6份，两个一行&lt;/p&gt; &lt;p&gt;超小屏幕下每个盒子占12份，独占一行&lt;/p&gt; &lt;div class=&quot;col-lg-3 col-md-4 col-sm-6 col-xs-12&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;col-lg-3 col-md-4 col-sm-6 col-xs-12&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;col-lg-3 col-md-4 col-sm-6 col-xs-12&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;col-lg-3 col-md-4 col-sm-6 col-xs-12&quot;&gt;4&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; Bootstrap列嵌套栅格系统内置的栅格系统将内容再次嵌套。简单理解就是一个列内再分成若 干份小列。我们可以通过添加一个新的.row元素和一系列.col-sm-*元素到已经存在的.col-sm-*元素内。 栅格之间不能加margin隔开，通过在里面嵌套一个小盒子来解决距离 列嵌套最好加1个行row，这样可以取消父元素的padding值，而且高度自动和父级一样高 123456&lt;div class=&quot;col-md-4 &quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-6&quot;&gt;a&lt;/div&gt; &lt;div class=&quot;col-md-6&quot;&gt;b&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; Bootstrap列偏移使用.col-md-offset-*类可以将列向右侧偏移。这些类实际是通过使用*选择器为当前元素增加了左侧的边距( margin)。 1234567891011&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-4&quot;&gt;left 4份&lt;/div&gt; &lt;!--往右侧偏移4份，偏移份数=12 - 两个盒子的份数--&gt; &lt;div class=&quot;col-md-4 col-md-offset-4&quot;&gt;right 4份&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;!--如果只有一个盒子，则偏移= ( 12 - 8 ) / 2--&gt; &lt;div class=&quot;col-md-8 col-md-offset-2&quot;&gt;middle 8份&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; Bootstrap列排序通过使用.col-md-push-*和.col-md- pull-*类就可以很容易的改变列( column )的顺序。 12345678&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;!--把左侧的盒子往右边推8份--&gt; &lt;div class=&quot;col-md-4 col-md-push-8&quot;&gt;左侧&lt;/div&gt; &lt;!--把右侧的盒子往左边拉4份--&gt; &lt;div class=&quot;col-md-8 col-md-pull-4&quot;&gt;右侧&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; Bootstrap响应式工具为了加快对移动设备友好的页面开发工作， 利用媒体查询功能，并使用这些工具类可以方便的针对不同设备展示或隐藏页面内容。 类名 超小屏 小屏 中屏 大屏 .hidden-xs 隐藏 可见 可见 可见 .hidden-sm 可见 隐藏 可见 可见 .hidden-md 可见 可见 隐藏 可见 .hidden-lg 可见 可见 可见 隐藏 显示某个页面内容（与隐藏相反） visible-xs visible- sm visible-md visible-lg 123456789101112&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-3&quot;&gt; &lt;!--大屏幕才显示--&gt; &lt;span class=&quot;visible-lg&quot;&gt;我会显示哦&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;col-xs-3&quot;&gt;2&lt;/div&gt; &lt;!--中等屏幕下隐藏--&gt; &lt;div class=&quot;col-xs-3 hidden-md&quot;&gt;我会隐藏哦&lt;/div&gt; &lt;div class=&quot;col-xs-3&quot;&gt;4&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 阿里百秀实例 采取响应式开发方案 Bootstrap框架 采取1280px设计尺寸 屏幕划分分析 屏幕缩放发现 中屏幕 和 大屏幕 布局是一致的。因此我们列定义为 `col-md- 就可以了。md是大于等于970以上的 屏幕缩放发现 小屏幕 布局发生变化， 因此我们需要为小屏幕根据需求改变布局 屏幕缩放发现 超小屏幕布局 又发生变化，因此我们需要为超小屏幕根据需求改变布局 策略: 我们先布局 md以上的pc端布局 ,最后根据实际需求在修改小屏幕和超小屏幕的特殊布局样式 初始化准备工作 创建文件夹结构 网页骨架结构 123456&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;&lt;!--[if lt IE 9]&gt; &lt;script src=&quot;https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://oss.maxcdn.com/respond/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt; 引入相关样式文件 12345&lt;!-- 引入bootstrap 样式文件 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap/css/bootstrap.min.css&quot;&gt;&lt;!-- 引入我们自己的首页样式文件 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot;&gt;&lt;!--无需引入Normalize.css，Bootstrap已经包含--&gt; 公共初始化样式 12345678910111213141516171819202122ul &#123; list-style-type: none; margin: 0; padding: 0;&#125;a &#123; color: #666; text-decoration: none;&#125;a:hover &#123; text-decoration: none;&#125;body &#123; background-color: #f5f5f5;&#125;.container &#123; background-color: #fff;&#125; container宽度修改因为本效果图采取1280的宽度，而Bootstrap里面container宽度最大为1170px，因此我们需要手动改container宽度 1234567/* 修改container的最大宽度为 1280 根据设计稿来走的 */@media screen and (min-width: 1280px) &#123; .container &#123; width: 1280px; &#125;&#125; 代码大致布局结构 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;body&gt;&lt;!--container布局容器--&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;!--左侧占2份--&gt; &lt;header class=&quot;col-md-2&quot;&gt; &lt;div class=&quot;logo&quot;&gt;&lt;/div&gt; &lt;div class=&quot;nav&quot;&gt;&lt;/div&gt; &lt;/header&gt; &lt;!--中间占7份--&gt; &lt;article class=&quot;col-md-7&quot;&gt; &lt;!-- 新闻 --&gt; &lt;div class=&quot;news clearfix&quot;&gt;&lt;/div&gt; &lt;!-- 发表 --&gt; &lt;div class=&quot;publish&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-9&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-sm-3 pic hidden-xs&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-9&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-sm-3 pic hidden-xs&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-9&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-sm-3 pic hidden-xs&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-9&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-sm-3 pic hidden-xs&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-9&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-sm-3 pic hidden-xs&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/article&gt; &lt;!--右侧侧占3份--&gt; &lt;aside class=&quot;col-md-3&quot;&gt;&lt;/aside&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt; Glyphicons字体图标 进入Bootstrap官网查看字体图标：https://v3.bootcss.com/components/ 找到需要的图标，复制其class类名即可 使用：粘贴到class中 1&lt;a href=&quot;#&quot; class=&quot;glyphicon glyphicon-camera&quot;&gt;生活馆&lt;/a&gt; header模块 12345678910111213141516171819202122232425&lt;!--container布局容器--&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;!--header部分占2份--&gt; &lt;header class=&quot;col-md-2&quot;&gt; &lt;!--logo部分--&gt; &lt;div class=&quot;logo&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;images/logo.png&quot; alt=&quot;&quot; class=&quot;hidden-xs&quot;&gt; &lt;span class=&quot;visible-xs&quot;&gt;阿里百秀&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;!--nav部分--&gt; &lt;div class=&quot;nav&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot; class=&quot;glyphicon glyphicon-camera&quot;&gt;生活馆&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot; class=&quot;glyphicon glyphicon-picture&quot;&gt;自然汇&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot; class=&quot;glyphicon glyphicon-phone&quot;&gt;科技湖&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot; class=&quot;glyphicon glyphicon-gift&quot;&gt;奇趣事&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot; class=&quot;glyphicon glyphicon-glass&quot;&gt;美食杰&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/header&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* header */header &#123; padding-left: 0!important; /*提高权重 去掉左侧默认pdding值*/&#125;.logo &#123; background-color: #429ad9;&#125;.logo img &#123; display: block; /* width: 100%; */ /* logo图片不需要缩放 */ max-width: 100%; margin: 0 auto;&#125;/* 1.我们如果进入了超小屏幕下 logo里面的图片就隐藏起来 *//* 2. 我们事先准备好一个盒子 在logo里面，它平时是隐藏起来的，只有在超小屏幕下显示 */.logo span &#123; display: block; height: 50px; line-height: 50px; color: #fff; font-size: 18px; text-align: center;&#125;.nav &#123; background-color: #eee; border-bottom: 1px solid #ccc;&#125;.nav a &#123; display: block; height: 50px; line-height: 50px; padding-left: 30px; font-size: 16px;&#125;.nav a:hover &#123; background-color: #fff; color: #333;&#125;/*调整字体图标，实现原理F12查看*/.nav a::before &#123; vertical-align: middle; padding-right: 5px;&#125; article模块 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;article class=&quot;col-md-7&quot;&gt; &lt;!-- 新闻 --&gt; &lt;div class=&quot;news clearfix&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;upload/lg.png&quot; alt=&quot;&quot;&gt; &lt;p&gt;阿里百秀&lt;/p&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;upload/1.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;奇了 成都一小区护卫长得像马云 市民纷纷求合影&lt;/p&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;upload/2.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;奇了 成都一小区护卫长得像马云 市民纷纷求合影&lt;/p&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;upload/2.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;奇了 成都一小区护卫长得像马云 市民纷纷求合影&lt;/p&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;upload/2.jpg&quot; alt=&quot;&quot;&gt; &lt;p&gt;奇了 成都一小区护卫长得像马云 市民纷纷求合影&lt;/p&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- 发表 --&gt; &lt;div class=&quot;publish&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-9&quot;&gt; &lt;h3&gt;生活馆 关于指甲的10个健康知识 你知道几个？&lt;/h3&gt; &lt;p class=&quot;text-muted hidden-xs&quot;&gt;alibaixiu 发布于 2015-11-23&lt;/p&gt; &lt;p class=&quot;hidden-xs&quot;&gt;指甲是经常容易被人们忽略的身体部位， 事实上从指甲的健康状况可以看出一个人的身体健康状况， 快来看看10个暗藏在指甲里知识吧！&lt;/p&gt; &lt;p class=&quot;text-muted&quot;&gt;阅读(2417)评论(1)赞 (18) &lt;span class=&quot;hidden-xs&quot;&gt;标签：健康 / 感染 / 指甲 / 疾病 / 皮肤 / 营养 / 趣味生活&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;col-sm-3 pic hidden-xs&quot;&gt; &lt;img src=&quot;upload/3.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-9&quot;&gt; &lt;h3&gt;生活馆 关于指甲的10个健康知识 你知道几个？&lt;/h3&gt; &lt;p class=&quot;text-muted hidden-xs&quot;&gt;alibaixiu 发布于 2015-11-23&lt;/p&gt; &lt;p class=&quot;hidden-xs&quot;&gt;指甲是经常容易被人们忽略的身体部位， 事实上从指甲的健康状况可以看出一个人的身体健康状况， 快来看看10个暗藏在指甲里知识吧！&lt;/p&gt; &lt;p class=&quot;text-muted&quot;&gt;阅读(2417)评论(1)赞 (18) &lt;span class=&quot;hidden-xs&quot;&gt;标签：健康 / 感染 / 指甲 / 疾病 / 皮肤 / 营养 / 趣味生活&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;col-sm-3 pic hidden-xs&quot;&gt; &lt;img src=&quot;upload/3.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-9&quot;&gt; &lt;h3&gt;生活馆 关于指甲的10个健康知识 你知道几个？&lt;/h3&gt; &lt;p class=&quot;text-muted hidden-xs&quot;&gt;alibaixiu 发布于 2015-11-23&lt;/p&gt; &lt;p class=&quot;hidden-xs&quot;&gt;指甲是经常容易被人们忽略的身体部位， 事实上从指甲的健康状况可以看出一个人的身体健康状况， 快来看看10个暗藏在指甲里知识吧！&lt;/p&gt; &lt;p class=&quot;text-muted&quot;&gt;阅读(2417)评论(1)赞 (18) &lt;span class=&quot;hidden-xs&quot;&gt;标签：健康 / 感染 / 指甲 / 疾病 / 皮肤 / 营养 / 趣味生活&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;col-sm-3 pic hidden-xs&quot;&gt; &lt;img src=&quot;upload/3.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-9&quot;&gt; &lt;h3&gt;生活馆 关于指甲的10个健康知识 你知道几个？&lt;/h3&gt; &lt;p class=&quot;text-muted hidden-xs&quot;&gt;alibaixiu 发布于 2015-11-23&lt;/p&gt; &lt;p class=&quot;hidden-xs&quot;&gt;指甲是经常容易被人们忽略的身体部位， 事实上从指甲的健康状况可以看出一个人的身体健康状况， 快来看看10个暗藏在指甲里知识吧！&lt;/p&gt; &lt;p class=&quot;text-muted&quot;&gt;阅读(2417)评论(1)赞 (18) &lt;span class=&quot;hidden-xs&quot;&gt;标签：健康 / 感染 / 指甲 / 疾病 / 皮肤 / 营养 / 趣味生活&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;col-sm-3 pic hidden-xs&quot;&gt; &lt;img src=&quot;upload/3.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-9&quot;&gt; &lt;h3&gt;生活馆 关于指甲的10个健康知识 你知道几个？&lt;/h3&gt; &lt;p class=&quot;text-muted hidden-xs&quot;&gt;alibaixiu 发布于 2015-11-23&lt;/p&gt; &lt;p class=&quot;hidden-xs&quot;&gt;指甲是经常容易被人们忽略的身体部位， 事实上从指甲的健康状况可以看出一个人的身体健康状况， 快来看看10个暗藏在指甲里知识吧！&lt;/p&gt; &lt;p class=&quot;text-muted&quot;&gt;阅读(2417)评论(1)赞 (18) &lt;span class=&quot;hidden-xs&quot;&gt;标签：健康 / 感染 / 指甲 / 疾病 / 皮肤 / 营养 / 趣味生活&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;col-sm-3 pic hidden-xs&quot;&gt; &lt;img src=&quot;upload/3.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/article&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/* 当我们进入 小屏幕 还有 超小屏幕的时候 我们 nav 里面的li 浮动起来 并且宽度为 20% */@media screen and (max-width: 991px) &#123; .nav li &#123; float: left; width: 20%; &#125; article &#123; margin-top: 10px; &#125;&#125;/* 当我们进入 超小屏幕的时候 我们 nav 文字会变成14px */@media screen and (max-width: 767px) &#123; .nav li a &#123; font-size: 14px; padding-left: 3px; &#125; /* 当我们处于超小屏幕 news 第一个li 宽度为 100% 剩下的小li 各 50% */ .news li:nth-child(1) &#123; width: 100%!important; &#125; .news li &#123; width: 50%!important; &#125; .publish h3 &#123; font-size: 14px; &#125;&#125;.news li a &#123; position: relative; display: block; width: 100%; height: 100%;&#125;.news li &#123; float: left; width: 25%; height: 128px; padding-right: 10px; margin-bottom: 10px;&#125;.news li:nth-child(1) &#123; width: 50%; height: 266px;&#125;.news li:nth-child(1) p &#123; line-height: 41px; font-size: 20px; padding: 0 10px;&#125;.news li a img &#123; width: 100%; height: 100%;&#125;.news li a p &#123; position: absolute; bottom: 0; left: 0; width: 100%; height: 41px; padding: 5px 10px; margin-bottom: 0; background: rgba(0, 0, 0, .5); font-size: 12px; color: #fff;&#125;.publish &#123; border-top: 1px solid #ccc;&#125;.publish .row &#123; border-bottom: 1px solid #ccc; padding: 10px 0;&#125;.pic &#123; margin-top: 10px;&#125;.pic img &#123; width: 100%;&#125; aside模块 12345678910&lt;aside class=&quot;col-md-3&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;banner&quot;&gt; &lt;img src=&quot;upload/zgboke.jpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;hot&quot;&gt; &lt;span class=&quot;btn btn-primary&quot;&gt;热搜&lt;/span&gt; &lt;h4 class=&quot;text-primary&quot;&gt;欢迎加入中国博客联盟&lt;/h4&gt; &lt;p&gt;这里收录国内各个领域的优秀博客，是一个全人工编辑的开放式博客联盟交流和展示平台......&lt;/p&gt; &lt;/a&gt;&lt;/aside&gt; 12345678910111213141516171819.banner img &#123; width: 100%;&#125;.hot &#123; display: block; margin-top: 20px; padding: 0 20px 20px; border: 1px solid #ccc;&#125;.hot span &#123; border-radius: 0; margin-bottom: 20px;&#125;.hot p &#123; font-size: 12px;&#125;","path":"page/mobileweb03.html","date":"01-30","excerpt":"","tags":[{"name":"Bootstrap响应式","slug":"Bootstrap响应式","permalink":"http://xiaoliblog.cn/tags/Bootstrap%E5%93%8D%E5%BA%94%E5%BC%8F/"}]},{"title":"Web移动开发📲less+rem+媒体查询布局","text":"rem基础 页面布局文字能否随着屏幕大小变化而变化? 流式布局和flex布局主要针对于宽度布局 ,那高度如何设置? 怎么样让屏幕发生变化的时候元素高度和宽度等比例缩放? 比如苏宁易购移动端页面：https://m.suning.com/ rem单位 rem (root em)是一个相对单位，rem的基准是相对于htm元素的字体大小，与父元素无关 类似于em , 但em是父元素字体大小 比如，根元素( html )设置font-size= 12px;非根元素设置width：2rem;则换成px表示就是24px. 123456789101112131415div&#123; font-size: 12px;&#125;p&#123; /*em相对于父元素 的字体大小来说的 */ width: 10em; /*相对于12*10=120px*/ height: 10em; background-color:steelblue;&#125;&lt;body&gt; &lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 123456789101112131415161718html&#123; font-size: 14px;&#125;div&#123; font-size: 12px;&#125;p&#123; /*rem相对于html元素 的字体大小来说的 */ width: 10rem; /*相对于14*10=140px*/ height: 10rem; background-color:steelblue;&#125;&lt;body&gt; &lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; rem的优点就是可以通过修改html里面的文字大小来改变页面中元素的大小可以整体控制 媒体查询语法 媒体查询(Media Query)是CSS3新语法。 使用 @media查询,可以针对不同的媒体类型定义不同的样式 @media可以针对不同的屏幕尺寸设置不同的样式 当你重置浏览器大小的过程中 ,页面也会根据浏览器的宽度和高度重新渲染页面 目前针对很多苹果手机、Android手机 ,平板等设备都用得到多媒体查询 123@media mediatype and|not|only (media feature) &#123; CSS-Code;&#125; 用 @media 开头注意@符号 mediatype 媒体类型 关键字and not only media feature媒体特性必须有小括号包含 mediatype查询类型将不同的终端设备划分成不同的类型,称为媒体类型 值 解释说明 all 用于所有设备 print 用于打印机和打印预览 scree 用于电脑屏幕，平板电脑，智能手机等 关键字关键字将媒体类型或多个媒体特性连接到一起做为媒体查询的条件。 and :可以将多个媒体特性连接到一起,相当于“且”的意思。 not :排除某个媒体类型,相当于”非”的意思,可以省略。 only :指定某个特定的媒体类型,可以省略。 媒体特性每种媒体类型都具体各自不同的特性，根据不同媒体类型的媒体特性设置不同的展示风格。注意要加小括号包含 值 解释说明 width 定义输出设备中页面可见区域的宽度 min-width 定义输出设备中页面最小可见区域宽度 max-width 定义输出设备中页面最大可见区域宽度 下列代码表示：在屏幕上 并且 小于等于800像素时 设置样式为粉色，小于等于600px时设置样式为紫色，当大于800px时不再应用样式 123456789101112/*max-width表示小于等于800px*/@media screen and (max-width: 800px) &#123; body &#123; background-color: pink; &#125;&#125;/*max-width表示小于等于600px*/@media screen and (max-width: 600px) &#123; body &#123; background-color: purple; &#125;&#125; 范围设置 12345@media screen and (min-width: 600px) and (max-width:900px) &#123; body &#123; background-color: purple; &#125;&#125; 媒体查询+rem 使用媒体查询+ rem实现元素动态大小变化 rem单位是跟着html来走的，有了rem页面元素可以设置不同大小尺寸 媒体查询可以根据不同设备宽度来修改样式 媒体查询+rem 就可以实现不同设备宽度,实现页面元素大小的动态变化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; /* html &#123; font-size: 100px; &#125; */ /* 不能写死，用媒体查询，并按从小到大的顺序 */ @media screen and (min-width: 320px) &#123; html &#123; font-size: 50px; &#125; &#125; @media screen and (min-width: 640px) &#123; html &#123; font-size: 100px; &#125; &#125; .top &#123; height: 1rem; font-size: .5rem; /*html文字大小的一半*/ background-color: green; color: #fff; text-align: center; line-height: 1rem; /*垂直居中*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;top&quot;&gt;购物车&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 媒体查询引入资源 当样式比较繁多的时候，我们可以针对不同的媒体使用不同stylesheets (样式表)。 原理，就是直接在link中判断设备的尺寸，然后引用不同的css文件。 1&lt;link rel=&quot;stylesheet&quot; media=&quot;mediatype andInotlonly (media feature) &quot; href=&quot;mystylesheet. css&quot;&gt; 12345678910111213/*style320.css*/div &#123; width: 100%; height: 100px;&#125;div:nth-child(1) &#123; background-color: pink;&#125;div:nth-child(2) &#123; background-color: purple;&#125; 1234567891011121314/*style640.css*/div &#123; float: left; width: 50%; height: 100px;&#125;div:nth-child(1) &#123; background-color: pink;&#125;div:nth-child(2) &#123; background-color: purple;&#125; 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /* 当我们屏幕大于等于 640px以上的，我们让div 一行显示2个 */ /* 当我们屏幕小于640 我们让div一行显示一个 */ /* 一个建议： 我们媒体查询最好的方法是从小到大 */ /* 引入资源就是 针对于不同的屏幕尺寸 调用不同的css文件 */ &lt;/style&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style320.css&quot; media=&quot;screen and (min-width: 320px)&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style640.css&quot; media=&quot;screen and (min-width: 640px)&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; less基础 CSS是一门非程序式语言，没有变量、函数、SCOPE (作用域)等概念 CSS 需要书写大量看似没有逻辑的代码, CSS冗余度是比较高的 不方便维护及扩 展，不利于复用 CSS 没有很好的计算能力 非前端开发工程师来讲 ，往往会因为缺少CSS编写经验而很难写出组织良好且易于维护的CSS代码项目 less简介 Less ( Leaner Style Sheets的缩写)是一门CSS 扩展语言，也成为CSS预处理器。 做为CSS的一种形式的扩展，它并没有减少CSS的功能,而是在现有的CSS语法上，为CSS加入程序式语言的特性。 它在CSS的语法基础之上，引入了变量，Mixin(混入) , 运算以及函数等功能，大大简化了CSS的编写，并且降低了CSS的维护成本，就像它的名称所说的那样， Less可以让我们用更少的代码做更多的事情 Less中文网址: http://lesscss.cn/ 常见的CSS预处理器: Sass、Less.、Stylus 使用 新建一个后缀名为.less的文件，在此文件里书写less语句 Less 变量 Less编译 Less嵌套 Less 运算 less变量变量是指没有固定的值，可以改变的。因为我们CSS中的一些颜色和数值等经常使用。 1@变量名:值; 变量命名规范 必须有@为前缀 不能包含特殊字符 不能以数字开头 区分大小写 12345678910//定义一个粉色的变量@color: pink;//使用变量body&#123; background-color:@color;&#125;div&#123; color:@color;&#125; less编译 本质上， Less包含一套自定义的语法及一个解析器，用胪根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的CSS文件 所以，我们需要把我们的less文件，编译生成为css文件，这样我们的html页面才能使用 Easy LESS插件 Easy LESS插件用来把less文件编译为Css文件 安装完毕插件，重新加载下vscode。只要保存一下Less文件 ，会自动生成CSS文件 然后引入CSS文件即可 less嵌套样式嵌套 以下html文件组，存在嵌套关系 123&lt;div class=&quot;father&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;son&quot;&gt;文字&lt;/a&gt;&lt;/div&gt; Less语法对应嵌套的处理，子元素的样式直接写到父元素里即可 1234567.father&#123; width: 200px; height: 200px; .son&#123; color:red; &#125;&#125; 选择器的嵌套1234/*css写法*/#header .logo&#123; width:300px;&#125; 123456//less写法#header&#123; .logo&#123; width:300px; &#125;&#125; 如果遇见( 交集|伪类|伪元素选择器) 内层选择器的前面没有&amp;符号,则它被解析为父选择器的后代; 如果有 &amp;符号,它就被解析为父元素自身或父元素的伪类。 1234/*css写法*/a:hover&#123; color:red;&#125; 123456//less写法a&#123; &amp;:hover&#123; color:red; &#125;&#125; less运算 任何数字、颜色或者变量都可以参与运算。就是Less提供了加(+)、减(-)、乘(*)、除(/)算术运算 注意乘号(*)和除号(/)的写法 运算符中间左右有个空格隔开1px + 5 对于两个不同的单位的值之间的运算 ,运算结果的值取第一个值的单位 如果两个值之间只有 一个值有单位,则运算结果就取该单位 1234567//less@border:5px + 5;div&#123; width: 200px - 50; height: 200px * 2; border:@border solid red;&#125; 123456/*css样式*/div &#123; width: 150px; height: 400px; border: 10px solid red;&#125; rem适配方案 让一些不能等比自适应的元素，达到当设备尺寸发生改变的时候，等比例适配当前设备。 使用媒体查询根据不同设备按比例设置html的字体大小，然后页面元素使用rem做尺寸单位，当html字体大小变化元素尺寸也会发生变化，从而达到等比缩放的适配。 按照设计稿与设备宽度的比例，动态计算并设置html根标签的font-size大小; (媒体查询） CSS中，设计稿元素的宽、高、相对位置等取值，按照同等比例换算为rem为单位的值; 技术方案1 less 媒体查询 rem 技术方案2（推荐） flexible.js rem rem+媒体查询+less 设计稿常见尺寸宽度 设备 常见宽度 iphone 4.5 640px iphone 678 750px Android 常见320px、360px、 375px、 384px、 400px. 414px. 500px、 720px等，大部分4.7~5寸的安卓设备为720px 一般情况下 ,我们以一套或两套效果图适应大部分的屏幕，放弃极端屏或对其优雅降级，牺牲一些效果，现在基本以750为准 动态设置html标签font-size大小 假设设计稿是750px 假设我们把整个屏幕划分为15等份(划分标准不一可以是20份也可以是10等份 ) 每一份作为html字体大小，这里就是50px 那么在320px设备的时候，字体大小为 320/15 就是21.33px 用我们页面元素的大小除以不同的html字体大小会发现他们比例还是相同的 比如我们以750为标准设计稿 一个100*100像素的页面元素在750屏幕下，就是 100/ 50 转换为 rem 是 2rem * 2 rem比例是1比1 320屏幕下，html 字体大小为21.33，则2rem = 42.66px ，此时宽和高都是42.66 ，但是宽和高的比例还是1比1 但是已经能实现不同屏幕下页面元素盒子等比例缩放的效果 元素大小取值方法 最后的公式：页面元素的rem值 = 页面元素值(px) / ( 屏幕宽度/划分的份数) 屏幕宽度/划分的份数 就是html font- size的大小 或者：页面元素的rem值 = 页面元素值( px) / html font-size字体大小 1234567891011121314151617181920212223/* 1. 首先我们选一套标准尺寸 750为准 2. 我们用屏幕尺寸 除以 我们划分的份数 得到了 html 里面的文字大小 但是我们知道不同屏幕下得到的文字大小是不一样的 3.页面元素的rem值 = 页面元素在 750像素的下px值 / html 里面的文字大小*/@media screen and (min-width: 320px) &#123; html &#123; font-size: 21.33px; &#125;&#125; @media screen and (min-width: 750px) &#123; html &#123; font-size: 50px; &#125;&#125; div &#123; width: 2rem; height: 2rem; background-color: pink;&#125; flexible.js适配方案 手机淘宝团队出的简洁高效移动端适配库，我们再也不需要在写不同屏幕的媒体查询，因为里面js做了处理 它的原理是把当前设备划分为10等份，但是不同设备下，比例还是一致的。我们要做的，就是确定好我们当前设备的html文字大小就可以了 比如当前设计稿是750px，那么我们只需要把html文字大小设置为75px(750px/ 10)就可以，里面页面元素rem值：页面元素的px值/ 75，剩余的，让flexible.js来去算 github地址: https://github.com/amfe/lib-flexible 苏宁移动端首页rem适配布局设计 布局采取rem适配布局（less+rem+媒体查询） 本设计图采用750px设计尺寸 初始化设置 文件夹结构 引入视口标签及初始化样式 123&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;css/normalize.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot;&gt; 公共less文件 设置公共common.less文件 新建common.less 设置好最常见的屏幕尺寸,利用媒体查询设置不同的htmI字体大小,因为除了首页其他页面也需要 我们关心的尺寸有320px、360px、 375px、 384px、 400px、 414px、 424px、 480px、 540px、 720px、 750px 划分的份数我们定为15等份 因为我们pc端也可以打开我们苏宁移动端首页 ,我们默认htmI字体大小为50px ,注意这句话写到最上面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// 设置常见的屏幕尺寸 修改里面的html文字大小a &#123; text-decoration: none;&#125;// 一定要写到最上面html &#123; font-size: 50px;&#125;// 我们此次定义的划分的份数 为 15@no: 15;// 320@media screen and (min-width: 320px) &#123; html &#123; font-size: 320px / @no; &#125;&#125;// 360@media screen and (min-width: 360px) &#123; html &#123; font-size: 360px / @no; &#125;&#125;// 375 iphone 678@media screen and (min-width: 375px) &#123; html &#123; font-size: 375px / @no; &#125;&#125;// 384@media screen and (min-width: 384px) &#123; html &#123; font-size: 384px / @no; &#125;&#125;// 400@media screen and (min-width: 400px) &#123; html &#123; font-size: 400px / @no; &#125;&#125;// 414@media screen and (min-width: 414px) &#123; html &#123; font-size: 414px / @no; &#125;&#125;// 424@media screen and (min-width: 424px) &#123; html &#123; font-size: 424px / @no; &#125;&#125;// 480@media screen and (min-width: 480px) &#123; html &#123; font-size: 480px / @no; &#125;&#125;// 540@media screen and (min-width: 540px) &#123; html &#123; font-size: 540px / @no; &#125;&#125;// 720@media screen and (min-width: 720px) &#123; html &#123; font-size: 720px / @no; &#125;&#125;// 750@media screen and (min-width: 750px) &#123; html &#123; font-size: 750px / @no; &#125;&#125; 首页less文件 新建index.less 这里面写首 页的样式 将刚才设置好的common.less引入到index.less里面语法如下: 12//在index.less中导入common.less文件@import &quot;common&quot; 生成的index.css 引入到index.html里面 首页body设置 123456789101112// 首页index.css的样式less文件@import &quot;common&quot;;// @import 导入的意思 可以把一个样式文件导入到另外一个样式文件里面// link 是把一个 样式文件引入到 html页面里面body &#123; min-width: 320px; width: 15rem; /*750/50=15rem*/ margin: 0 auto; line-height: 1.5; font-family: Arial,Helvetica; background: #F2F2F2;&#125; search-content搜索模块 12345678910&lt;!-- 顶部搜索框 --&gt;&lt;div class=&quot;search-content&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;classify&quot;&gt;&lt;/a&gt; &lt;div class=&quot;search&quot;&gt; &lt;form action=&quot;&quot;&gt; &lt;input type=&quot;search&quot; value=&quot;厨卫保暖季 哒哒哒&quot;&gt; &lt;/form&gt; &lt;/div&gt; &lt;a href=&quot;#&quot; class=&quot;login&quot;&gt;登录&lt;/a&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 页面元素rem计算公式： 页面元素的px / html 字体大小 50// search-content@baseFont: 50;.search-content &#123; display: flex; position: fixed; top: 0; left: 50%; transform: translateX(-50%); width: 15rem; height: 88rem / @baseFont; background-color:#FFC001; .classify &#123; width: 44rem / @baseFont; height: 70rem / @baseFont; margin: 11rem / @baseFont 25rem / @baseFont 7rem / @baseFont 24rem / @baseFont; background: url(../images/classify.png) no-repeat; // 背景缩放 background-size: 44rem / @baseFont 70rem / @baseFont; &#125; .search &#123; flex: 1; input &#123; outline: none; width: 100%; border: 0; height: 66rem / @baseFont; border-radius: 33rem / @baseFont; background-color:#FFF2CC; margin-top: 12rem / @baseFont; font-size: 25rem / @baseFont; padding-left: 55rem / @baseFont; color: #757575; &#125; &#125; .login &#123; width: 75rem / @baseFont; height: 70rem / @baseFont; line-height: 70rem / @baseFont; margin: 10rem / @baseFont; font-size: 25rem / @baseFont; text-align: center; color: #fff; &#125;&#125; banner及广告模块 12345678910&lt;!-- banner部分 --&gt;&lt;div class=&quot;banner&quot;&gt; &lt;img src=&quot;upload/banner.gif&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;!-- 广告部分 --&gt;&lt;div class=&quot;ad&quot;&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;upload/ad1.gif&quot; alt=&quot;&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;upload/ad2.gif&quot; alt=&quot;&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;upload/ad3.gif&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/div&gt; 12345678910111213141516171819// banner.banner &#123; width: 750rem / @baseFont; height: 368rem / @baseFont; img &#123; width: 100%; height: 100%; &#125;&#125;// ad.ad &#123; display: flex; a &#123; flex: 1; img &#123; width: 100%; &#125; &#125;&#125; nav模块12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!-- nav模块 --&gt;&lt;nav&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;upload/nav1.png&quot; alt=&quot;&quot;&gt; &lt;span&gt;爆款手机&lt;/span&gt; &lt;/a&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;upload/nav1.png&quot; alt=&quot;&quot;&gt; &lt;span&gt;爆款手机&lt;/span&gt; &lt;/a&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;upload/nav1.png&quot; alt=&quot;&quot;&gt; &lt;span&gt;爆款手机&lt;/span&gt; &lt;/a&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;upload/nav1.png&quot; alt=&quot;&quot;&gt; &lt;span&gt;爆款手机&lt;/span&gt; &lt;/a&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;upload/nav1.png&quot; alt=&quot;&quot;&gt; &lt;span&gt;爆款手机&lt;/span&gt; &lt;/a&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;upload/nav1.png&quot; alt=&quot;&quot;&gt; &lt;span&gt;爆款手机&lt;/span&gt; &lt;/a&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;upload/nav1.png&quot; alt=&quot;&quot;&gt; &lt;span&gt;爆款手机&lt;/span&gt; &lt;/a&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;upload/nav1.png&quot; alt=&quot;&quot;&gt; &lt;span&gt;爆款手机&lt;/span&gt; &lt;/a&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;upload/nav1.png&quot; alt=&quot;&quot;&gt; &lt;span&gt;爆款手机&lt;/span&gt; &lt;/a&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;upload/nav1.png&quot; alt=&quot;&quot;&gt; &lt;span&gt;爆款手机&lt;/span&gt; &lt;/a&gt;&lt;/nav&gt; 1234567891011121314151617181920// navnav &#123; width: 750rem / @baseFont; a &#123; float: left; width: 150rem / @baseFont; height: 140rem / @baseFont; text-align: center; img &#123; display: block; width: 82rem / @baseFont; height: 82rem / @baseFont; margin: 10rem / @baseFont auto 0; &#125; span &#123; font-size: 25rem / @baseFont; color: #333; &#125; &#125;&#125; flexible.js适配方案设计 布局采取flexible.js+rem适配布局 设计图采用750px设计尺寸 需要从github上下载flexible.js文件，项目地址：https://github.com/amfe/lib-flexible 初始化设置 文件夹结构 引入视口标签、flexible.js及初始化样式 1234567&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no,initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;&lt;!-- 引入公共css 文件 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;css/normalize.css&quot;&gt;&lt;!-- 引入首页css 文件 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot;&gt;&lt;!-- 引入我们的flexible.js 文件 --&gt;&lt;script src=&quot;js/flexible.js&quot;&gt;&lt;/script&gt; body及公共样式 123456789101112131415body &#123; min-width: 320px; max-width: 750px; /* flexible 给我们划分了 10 等份 */ width: 10rem; margin: 0 auto; line-height: 1.5; font-family: Arial, Helvetica; background: #f2f2f2;&#125;a &#123; text-decoration: none; font-size: .333333rem;&#125; VsCode插件cssrem cssrem可以把px转换为rem 这个插件默认的html文字大小 cssroot 16px 修改cssrem插件默认文字大小，修改数值会自动保存 search-content搜索模块 123456789&lt;div class=&quot;search-content&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;classify&quot;&gt;&lt;/a&gt; &lt;div class=&quot;search&quot;&gt; &lt;form action=&quot;&quot;&gt; &lt;input type=&quot;search&quot; value=&quot;rem适配方案2很开心哦&quot;&gt; &lt;/form&gt; &lt;/div&gt; &lt;a href=&quot;#&quot; class=&quot;login&quot;&gt;登录&lt;/a&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* 如果我们的屏幕超过了 750px 那么我们就按照 750设计稿来走 不会让我们页面超过750px */@media screen and (min-width: 750px) &#123; html &#123; font-size: 75px!important; &#125;&#125;/* search-content */.search-content &#123; display: flex; position: fixed; top: 0; left: 50%; transform: translateX(-50%); width: 10rem; height: 1.173333rem; background-color: #FFC001;&#125;.classify &#123; width: .586667rem; height: .933333rem; margin: .146667rem .333333rem .133333rem; background: url(../images/classify.png) no-repeat; background-size: .586667rem .933333rem;&#125;.search &#123; flex: 1;&#125;.search input &#123; outline: none; border: 0; width: 100%; height: .88rem; font-size: .333333rem; background-color: #FFF2CC; margin-top: .133333rem; border-radius: .44rem; color: #757575; padding-left: .733333rem;&#125;.login &#123; width: 1rem; height: .933333rem; margin: .133333rem; color: #fff; text-align: center; line-height: .933333rem; font-size: .333333rem;&#125;","path":"page/mobileweb01.html","date":"01-30","excerpt":"","tags":[{"name":"Web移动开发","slug":"Web移动开发","permalink":"http://xiaoliblog.cn/tags/Web%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"}]},{"title":"Web移动开发📲移动端流式+flex布局","text":"移动端技术选型 单独制作移动端页面(主流) 流式布局(百分比布局) flex 弹性布局(强烈推荐) less+ rem+媒体查询布局 混合布局 响应式页面兼容移动端(其次) 媒体查询 bootstarp 流式布局 流式布局， 就是百分比布局,也称非固定像素布局。 通过盒子的宽度设置成百分比来根据屏幕的宽度(width)来进行伸缩 ,不受固定像素的限制,内容向两侧填充。 流式布局方式是移动web开发使用的比较常见的布局方式。 为了防止无限拉伸，以下设置了两个参数用来限制 max-width 最大宽度（max-height 最大高度） min-width 最小宽度 （min-hegiht 最小高度） 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; section &#123; width: 100%; max-width: 980px; /*最大不超过980px*/ min-width: 320px; /*最小不小于320px*/ margin: 0 auto; /*居中*/ &#125; section div &#123; float: left; width: 50%; height: 400px; &#125; section div:nth-child(1) &#123; background-color: pink; &#125; section div:nth-child(2) &#123; background-color: purple; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 京东移动端页面 访问地址：https://m.jd.com 技术选型 采取单独制作移动页面方案 采用流式布局 初始化设置 引入初始化样式 12345&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no,maximum-scale=1.0,minimum-scale=1.0&quot;&gt;&lt;!-- 引入我们的css初始化文件 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;css/normalize.css&quot;&gt;&lt;!-- 引入我们首页的css --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot;&gt; body设置 12345678910body &#123; width: 100%; min-width: 320px; max-width: 640px; margin: 0 auto; font-size: 14px; font-family: -apple-system, Helvetica, sans-serif; color: #666; line-height: 1.5;&#125; 通用CSS 123456789101112131415161718192021222324252627282930/*点击高亮我们需要清除清除 设置为transparent 完成透明*/* &#123; -webkit-tap-highlight-color: transparent;&#125;/*在移动端浏览器默认的外观在iOS上加上这个属性才能给按钮和输入框自定义样式*/input &#123; -webkit-appearance: none;&#125;/*禁用长按页面时的弹出菜单*/img,a &#123; -webkit-touch-callout: none;&#125;a &#123; color: #666; text-decoration: none;&#125;ul &#123; margin: 0; padding: 0; list-style: none;&#125;img &#123; vertical-align: middle;&#125;div &#123; /* css3 盒子模型 */ box-sizing: border-box;&#125; 顶部模块 12345678910111213&lt;!-- 顶部 --&gt;&lt;header class=&quot;app&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;img src=&quot;images/close.png&quot; alt=&quot;&quot;&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;images/logo.png&quot; alt=&quot;&quot;&gt; &lt;/li&gt; &lt;li&gt;打开京东App，购物更轻松&lt;/li&gt; &lt;li&gt;立即打开&lt;/li&gt; &lt;/ul&gt;&lt;/header&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344ul &#123; margin: 0; padding: 0; list-style: none;&#125;.app &#123; height: 45px;&#125;.app ul li &#123; float: left; height: 45px; line-height: 45px; background-color: #333333; text-align: center; color: #fff;&#125;/*按百分比划分宽度*/.app ul li:nth-child(1) &#123; width: 8%;&#125;.app ul li:nth-child(1) img &#123; width: 10px;&#125;.app ul li:nth-child(2) &#123; width: 10%;&#125;.app ul li:nth-child(2) img &#123; width: 30px; vertical-align: middle;&#125;.app ul li:nth-child(3) &#123; width: 57%;&#125;.app ul li:nth-child(4) &#123; width: 25%; background-color: #F63515;&#125; 二倍精灵图做法 在firework里面把精灵图等比例宿放为原来的一半 之后根据大小测量坐标 注意代码里面background-size也要写 : 精灵图原来宽度的一半 搜索模块 中间搜索框会自适应改变宽度，实现方案 左右两边用定位 中间搜索框为标准流，不给宽度，给margin-left和margin-right值即可 123456789 &lt;!-- 搜索 --&gt;&lt;div class=&quot;search-wrap&quot;&gt; &lt;div class=&quot;search-btn&quot;&gt;&lt;/div&gt; &lt;div class=&quot;search&quot;&gt; &lt;div class=&quot;jd-icon&quot;&gt;&lt;/div&gt; &lt;div class=&quot;sou&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;search-login&quot;&gt;登陆&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/* 搜索 */.search-wrap &#123; position: fixed; /*固定定位*/ overflow: hidden; width: 100%; height: 44px; min-width: 320px; max-width: 640px;&#125;.search-btn &#123; position: absolute; top: 0; left: 0; width: 40px; height: 44px;&#125;.search-btn::before &#123; content: &quot;&quot;; display: block; width: 20px; height: 18px; background: url(../images/s-btn.png) no-repeat; background-size: 20px 18px; /*缩放图片*/ margin: 14px 0 0 15px; /*上和左设置边距*/&#125;.search-login &#123; position: absolute; right: 0; top: 0; width: 40px; height: 44px; color: #fff; line-height: 44px;&#125;.search &#123; position: relative; height: 30px; /*不给宽度*/ background-color: #fff; margin: 0 50px; /*左右margin50px*/ border-radius: 15px; margin-top: 7px;&#125;.jd-icon &#123; width: 20px; height: 15px; position: absolute; top: 8px; left: 13px; background: url(../images/jd.png) no-repeat; background-size: 20px 15px;&#125;/*后面插入一个竖线*/.jd-icon::after &#123; content: &quot;&quot;; position: absolute; right: -8px; top: 0; display: block; width: 1px; height: 15px; background-color: #ccc;&#125;/*放大镜，为精灵图*/.sou &#123; position: absolute; top: 8px; left: 50px; width: 18px; height: 15px; background: url(../images/jd-sprites.png) no-repeat -81px 0; /*缩放是全部图缩放，要缩放为原来的一半*/ background-size: 200px auto;&#125; 焦点图模块 1234567&lt;!-- 主体内容部分 --&gt;&lt;div class=&quot;main-content&quot;&gt; &lt;!-- 滑动图 --&gt; &lt;div class=&quot;slider&quot;&gt; &lt;img src=&quot;upload/banner.dpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt;&lt;/div&gt; 123.slider img &#123; width: 100%;&#125; 品牌日模块 品牌日图片并不是一个图片 1234567891011121314151617181920&lt;!-- 主体内容部分 --&gt;&lt;div class=&quot;main-content&quot;&gt; &lt;!-- 小家电品牌日 --&gt; &lt;div class=&quot;brand&quot;&gt; &lt;div&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;upload/pic11.dpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;div&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;upload/pic22.dpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;upload/pic33.dpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415/* 品牌日 */.brand &#123; overflow: hidden; border-radius: 10px 10px 0 0;&#125;.brand div &#123; float: left; width: 33.33%;&#125;.brand div img &#123; width: 100%;&#125; 图片格式 DPG图片压缩技术京东自主研发推出DPG图片压缩技术，经测试该技术，可直接节省用户近50%的浏览流量，极大的提升了用户的网页打开速度。能够兼容jpeg，实现全平台、全部浏览器的兼容支持，经过内部和外部上万张图片的人眼浏览测试后发现，压缩后的图片和webp的清晰度对比没有差距。 webp图片格式谷歌开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器宽带资源和数据空间 导航栏nav模块 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!-- 主体内容部分 --&gt;&lt;div class=&quot;main-content&quot;&gt; &lt;!-- nav部分 --&gt; &lt;nav class=&quot;clearfix&quot;&gt; &lt;a href=&quot;&quot;&gt; &lt;img src=&quot;upload/nav1.webp&quot; alt=&quot;&quot;&gt; &lt;span&gt;京东超市&lt;/span&gt; &lt;/a&gt; &lt;a href=&quot;&quot;&gt; &lt;img src=&quot;upload/nav2.webp&quot; alt=&quot;&quot;&gt; &lt;span&gt;京东超市&lt;/span&gt; &lt;/a&gt; &lt;a href=&quot;&quot;&gt; &lt;img src=&quot;upload/nav1.webp&quot; alt=&quot;&quot;&gt; &lt;span&gt;京东超市&lt;/span&gt; &lt;/a&gt; &lt;a href=&quot;&quot;&gt; &lt;img src=&quot;upload/nav1.webp&quot; alt=&quot;&quot;&gt; &lt;span&gt;京东超市&lt;/span&gt; &lt;/a&gt; &lt;a href=&quot;&quot;&gt; &lt;img src=&quot;upload/nav1.webp&quot; alt=&quot;&quot;&gt; &lt;span&gt;京东超市&lt;/span&gt; &lt;/a&gt; &lt;a href=&quot;&quot;&gt; &lt;img src=&quot;upload/nav3.webp&quot; alt=&quot;&quot;&gt; &lt;span&gt;京东超市&lt;/span&gt; &lt;/a&gt; &lt;a href=&quot;&quot;&gt; &lt;img src=&quot;upload/nav1.webp&quot; alt=&quot;&quot;&gt; &lt;span&gt;京东超市&lt;/span&gt; &lt;/a&gt; &lt;a href=&quot;&quot;&gt; &lt;img src=&quot;upload/nav1.webp&quot; alt=&quot;&quot;&gt; &lt;span&gt;京东超市&lt;/span&gt; &lt;/a&gt; &lt;a href=&quot;&quot;&gt; &lt;img src=&quot;upload/nav1.webp&quot; alt=&quot;&quot;&gt; &lt;span&gt;京东超市&lt;/span&gt; &lt;/a&gt; &lt;a href=&quot;&quot;&gt; &lt;img src=&quot;upload/nav1.webp&quot; alt=&quot;&quot;&gt; &lt;span&gt;京东超市&lt;/span&gt; &lt;/a&gt; &lt;/nav&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627/* nav */.clearfix:after &#123; /*清除浮动*/ content: &quot;&quot;; display: block; line-height: 0; visibility: hidden; height: 0; clear: both;&#125;nav &#123; padding-top: 5px;&#125;nav a &#123; float: left; width: 20%; text-align: center;&#125;nav a img &#123; width: 40px; margin: 10px 0;&#125;nav a span &#123; display: block;&#125; 新闻快报模块 123456789101112131415&lt;!-- 主体内容部分 --&gt;&lt;div class=&quot;main-content&quot;&gt;&lt;!-- 新闻模块 --&gt; &lt;div class=&quot;news&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;upload/new1.dpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;upload/new2.dpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;upload/new3.dpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435/* news */.news &#123; margin-top: 20px;&#125;.news img &#123; width: 100%;&#125;.news a &#123; float: left; /*CSS3盒子模型，防止掉下来*/ box-sizing: border-box;&#125;.news a:nth-child(1) &#123; width: 50%; /*缩放a*/&#125;/* .news a:nth-child(2),.news a:nth-child(3),&#123; width: 25%;&#125; *//* n+2 就是从2个开始往后面选 n=0,1,2... */.news a:nth-child(n+2) &#123; width: 25%; border-left: 1px solid #ccc;&#125; Flex布局 flex是flexible Box的缩写,意为”弹性布局” ，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为flex布局 当我们为父盒子设为flex布局以后，子元素的float、 clear 和vertical-align属性将失效 伸缩布局= 弹性布局 = 伸缩盆布局 = 弹性盒布局 = flex布局 采用Flex布局的元素，称为Flex容器( flex container ) , 简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目( flex itemi) , 简称”项目”。 总结flex布局原理: .就是通过给父盒子添加flex属性，来控制子盒子的位置和排列方式 常见父项属性 flex -direction :设置主轴的方向 justify-content :设置主轴上的子元素排列方式 flex-wrap :设置子元素是否换行 align-content :设置侧轴上的子元素的排列方式(多行) align-items :设置侧轴上的子元素排列方式(单行) flex flow :复合属性,相当于同时设置了flex- direction和flex: wrap flex -direction 在flex布局中，是分为主轴和侧轴两个方向,同样的叫法有：行和列、x轴和y轴 默认主轴方向就是x轴方向，水平向右 默认侧轴方向就是y轴方向，水平向下 flex- direction属性决定主轴的方向(即项目的排列方向)注意:主轴和侧轴是会变化的，就看flex-direction设置谁为主轴，剩下的就是侧轴。而我们的子元素是跟着主轴来排列的 属性值 说明 row 默认值从左到右 row-reverse 从右到左 column 从上到下 column-reverse 从下到上 12345678910111213141516171819 div &#123; /* 给父级添加flex属性 */ display: flex; /* 默认的主轴是 x 轴 行 row 那么y轴就是侧轴喽 */ /* 我们的元素是跟着主轴来排列的 */ /* flex-direction: row; */ /* 简单了解 翻转 */ /* flex-direction: row-reverse; */ /* 我们可以把我们的主轴设置为 y轴 那么 x 轴就成了侧轴 */ flex-direction: column;&#125;&lt;body&gt; &lt;div&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; &lt;/div&gt;&lt;/body&gt; justify-content justify-content 属性定义了项目在主轴上的对齐方式 注意:使用这个属性之前一定定要确定好主轴是哪个 属性值 说明 flex-start 默认值从头部开始如果主轴是x轴,则从左到右 flex- end 从尾部开始排列 center 在主轴居中对齐(如果主轴是x轴则水平居中) space- around 平分剩余空间 space- between 先两边贴边再平分剩余空间(重要) 1234567891011121314151617181920212223 div &#123; /* 给父级添加flex属性 */ display: flex; / * 默认的主轴是 x 轴 row */ flex-direction: row; /* justify-content: 是设置主轴上子元素的排列方式 */ /* justify-content: flex-start; */ /* justify-content: flex-end; */ /* 让我们子元素居中对齐 */ /* justify-content: center; */ /* 平分剩余空间 */ /* justify-content: space-around; */ /* 先两边贴边， 在分配剩余的空间 */ justify-content: space-between;&#125;&lt;body&gt; &lt;div&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; &lt;/div&gt;&lt;/body&gt; flex-wrap flex-wrap设置子元素是否换行 默认情况下,项目都排在一条线(又称”轴线”) 上。flex-wrap属性定义, flex布局中默认是不换行的。装不开会缩小子元素的宽度，强行放一行 属性值 说明 nowrap 默认值，不换行 wrap 换行 123456789101112131415 div &#123; /* 给父级添加flex属性 */ display: flex; /* flex布局中，默认的子元素是不换行的， 如果装不开，会缩小子元素的宽度，放到父元素里面 */ /*flex-wrap: nowrap;*/ flex-wrap: wrap;&#125;&lt;body&gt; &lt;div&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; &lt;/div&gt;&lt;/body&gt; align-items align-items设置侧轴上的子元素排列方式(单行)该属性是控制子项在侧轴(默认是y轴)上的排列方式，在子项为单项的时候使用 属性值 说明 flex-start 从上到下 flex-end 从下到上 center 挤在一起居中(垂直居中) stretch 拉伸(默认值) 1234567891011121314151617181920 div &#123; /* 给父级添加flex属性 */ display: flex; /* 默认的主轴是 x 轴 row */ flex-direction: column; justify-content: center; /* 我们需要一个侧轴居中 */ /* 拉伸，但是子盒子不要给高度 */ /* align-items: stretch; */ align-items: center; /* align-content: center; */&#125;&lt;body&gt; &lt;div&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; &lt;/div&gt;&lt;/body&gt; align-content align-content 设置侧轴上的子元素的排列方式(多行)设置子项在侧轴上的排列方式并且只能用于子项出现换行的情况(多行) , 在单行下是没有效果的。 属性值 说明 flex- start 默认值在侧轴的头部开始排列 flex-end 在侧轴的尾部开始排列 center 在侧轴中间显示 space- around 子项在侧轴平分剩余空间 space-between 子项在侧轴先分布在两头，再平分剩余空间 stretch 设置子项元素高度平分父元素高度 12345678910111213141516171819202122 div &#123; /* 给父级添加flex属性 */ display: flex; /* 换行 */ flex-wrap: wrap; /* 因为有了换行，此时我们侧轴上控制子元素的对齐方式我们用 align-content */ /* align-content: flex-start; */ /* align-content: center; */ /* align-content: space-between; */ align-content: space-around;&#125;&lt;body&gt; &lt;div&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; &lt;span&gt;4&lt;/span&gt; &lt;span&gt;5&lt;/span&gt; &lt;span&gt;6&lt;/span&gt; &lt;/div&gt;&lt;/body&gt; flex-flow flx-flow属性是flex- direction和flex- wrap属性的复合属性 12345678910111213141516171819 div &#123; /* 给父级添加flex属性 */ display: flex; /* flex-direction: column; flex-wrap: wrap; */ /* 把设置主轴方向和是否换行（换列）简写 */ flex-flow: column wrap;&#125;&lt;body&gt; &lt;div&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; &lt;span&gt;4&lt;/span&gt; &lt;span&gt;5&lt;/span&gt; &lt;span&gt;6&lt;/span&gt; &lt;/div&gt;&lt;/body&gt; flex子项属性 flex子项目占的份数 align-self控制子项自己在侧轴的排列方式 order属性定义子项的排列顺压( 前后顺序) flex flex属性定义子项目分配剩余空间,用flex来表示占多少份数 123.item&#123; flex:&lt;number&gt;; /*默认为0*/&#125; 运用flex可以很方便的做以上京东页面的搜索栏布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; section &#123; display: flex; width: 60%; /*宽度设置为百分比，份数各百分比对应*/ height: 150px; background-color: pink; margin: 0 auto; &#125; section div:nth-child(1) &#123; width: 100px; height: 150px; background-color:cadetblue; &#125; section div:nth-child(2) &#123; flex: 1; /*占1份*/ background-color:rgb(84, 199, 113); &#125; section div:nth-child(3) &#123; width: 100px; height: 150px; background-color:darkgoldenrod; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/section&gt; &gt;&lt;/body&gt;&lt;/html&gt; 运用flex等分配一列盒子的空间 123456789101112131415161718p &#123; display: flex; width: 60%; /*宽度设置为百分比，份数各百分比对应*/ height: 150px;&#125;p span &#123; flex: 1; /*各占一份*/&#125;/*p span:nth-child(2) &#123; flex: 2; /*占两份*/&#125;*//*html部分*/&lt;p&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;/p&gt; align-self align-self控制子项自己在侧轴上的排列方式 align-self属性允许单个项目有与其他项目不-样的对齐方式,可覆盖align-items属性。 默议值为auto ,表示继承父元素的align-items属性,如果没有父元素,则等同于stretch。 12345678910111213141516171819div &#123; display: flex; width: 80%; height: 300px; /* 让三个子盒子沿着侧轴底侧对齐 */ /* align-items: flex-end; */ /* 我们想只让3号盒子下来底侧 */&#125;div span:nth-child(3) &#123; align-self: flex-end;&#125; &lt;div&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;/div&gt; order order属性定义项目的排列顺序 数值越小，排列越靠前，默认为0 注意：和z-index不一样 1234567891011121314151617div &#123; display: flex; width: 80%; height: 300px;&#125;div span:nth-child(2) &#123; /* 默认是0 -1比0小所以在前面 */ order: -1;&#125; &lt;div&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;/div&gt; 携程移动端首页 访问地址：https://m.ctrip.com/html5/ 布局采取flex布局 初始化设置 引入初始化CSS及视口标签 123456&lt;!--引入视口标签--&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;!-- 引入我们的css初始化文件 --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;css/normalize.css&quot;&gt;&lt;!-- 引入我们首页的css --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot;&gt; body设置 12345678910body &#123; max-width: 540px; min-width: 320px; margin: 0 auto; font: normal 14px/1.5 Tahoma, &quot;Lucida Grande&quot;, Verdana, &quot;Microsoft Yahei&quot;, STXihei, hei; color: #000; background: #f2f2f2; overflow-x: hidden; -webkit-tap-highlight-color: transparent;&#125; 通用样式 1234567891011121314ul &#123; list-style: none; margin: 0; padding: 0;&#125;a &#123; text-decoration: none; color: #222;&#125;div &#123; box-sizing: border-box;&#125; 搜索模块 12345&lt;!-- 顶部搜索 --&gt;&lt;div class=&quot;search-index&quot;&gt; &lt;div class=&quot;search&quot;&gt;搜索:目的地/酒店/景点/航班号&lt;/div&gt; &lt;a href=&quot;#&quot; class=&quot;user&quot;&gt;我 的&lt;/a&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162.search-index &#123; display: flex; /* 固定定位跟父级没有关系 它以屏幕为准 */ position: fixed; top: 0; left: 50%; /*居中*/ /* transfrom百分比相对于自身盒子宽度移动 */ -webkit-transform: translateX(-50%); transform: translateX(-50%); /* 固定的盒子必须有宽度 */ width: 100%; min-width: 320px; max-width: 540px; height: 44px; background-color: #F6F6F6; border-top: 1px solid #ccc; border-bottom: 1px solid #ccc;&#125;.search &#123; position: relative; height: 26px; line-height: 24px; border: 1px solid #ccc; flex: 1; /*左侧占比1，右侧固定大小*/ font-size: 12px; color: #666; margin: 7px 10px; padding-left: 25px; border-radius: 5px; box-shadow: 0 2px 4px rgba(0, 0, 0, .2); /*盒子阴影*/&#125;.search::before &#123; /*伪元素，放入放大镜图片*/ content: &quot;&quot;; position: absolute; top: 5px; left: 5px; width: 15px; height: 15px; background: url(../images/sprite.png) no-repeat -59px -279px; background-size: 104px auto;&#125;.user &#123; width: 44px; height: 44px; /* background-color: purple; */ font-size: 12px; text-align: center; color: #2eaae0;&#125;.user::before &#123; /*伪元素，在“我的”前面插入盒子中并放图片*/ content: &quot;&quot;; display: block; width: 23px; height: 23px; background: url(../images/sprite.png) no-repeat -59px -194px; background-size: 104px auto; margin: 4px auto -2px;&#125; 焦点图focus模块 1234 &lt;!-- 焦点图模块 --&gt;&lt;div class=&quot;focus&quot;&gt; &lt;img src=&quot;upload/focus.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt; 123456789/* focus */.focus &#123; padding-top: 44px;&#125;.focus img &#123; width: 100%;&#125; local-nav模块 123456789101112131415161718192021222324252627282930313233&lt;!-- 局部导航栏 --&gt;&lt;ul class=&quot;local-nav&quot;&gt; &lt;li&gt; &lt;a href=&quot;#&quot; title=&quot;景点·玩乐&quot;&gt; &lt;span class=&quot;local-nav-icon-icon1&quot;&gt;&lt;/span&gt; &lt;span&gt;景点·玩乐&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot; title=&quot;景点·玩乐&quot;&gt; &lt;span class=&quot;local-nav-icon-icon2&quot;&gt;&lt;/span&gt; &lt;span&gt;景点·玩乐&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot; title=&quot;景点·玩乐&quot;&gt; &lt;span class=&quot;local-nav-icon-icon3&quot;&gt;&lt;/span&gt; &lt;span&gt;景点·玩乐&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot; title=&quot;景点·玩乐&quot;&gt; &lt;span class=&quot;local-nav-icon-icon4&quot;&gt;&lt;/span&gt; &lt;span&gt;景点·玩乐&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot; title=&quot;景点·玩乐&quot;&gt; &lt;span class=&quot;local-nav-icon-icon5&quot;&gt;&lt;/span&gt; &lt;span&gt;景点·玩乐&lt;/span&gt; &lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* local-nav */.local-nav &#123; display: flex; height: 64px; margin: 3px 4px; background-color: #fff; border-radius: 8px;&#125;.local-nav li &#123; flex: 1; /*每个占比1份*/&#125;.local-nav a &#123; display: flex; flex-direction: column; /* 侧轴居中对齐 因为是单行，利用flex来实现图片和文字垂直对齐*/ align-items: center; font-size: 12px;&#125;/*利用属性选择器更换图片*/.local-nav li [class^=&quot;local-nav-icon&quot;] &#123; width: 32px; height: 32px; background-color: pink; margin-top: 8px; background: url(../images/localnav_bg.png) no-repeat 0 0; background-size: 32px auto;&#125;.local-nav li .local-nav-icon-icon2 &#123; background-position: 0 -32px;&#125;.local-nav li .local-nav-icon-icon3 &#123; background-position: 0 -64px;&#125;.local-nav li .local-nav-icon-icon4 &#123; background-position: 0 -96px;&#125;.local-nav li .local-nav-icon-icon5 &#123; background-position: 0 -128px;&#125; 背景线性渐变1234/* 背景渐变必须添加浏览器私有前缀 */background: linear-gradient (起始方向,颜色1,颜色2,...);background: -webkit- linear -gradient (left,red,blue) ;background: -webkit-linear-gradient(top left, red, blue); 背景渐变必须添加浏览器私有前缀 起始方向可以是：方位名词或者度数，如果省略默认是top 12345678 div &#123; width: 600px; height: 200px; /* 背景渐变必须添加浏览器私有前缀 */ /* background: -webkit-linear-gradient(left, red, blue); */ /* background: -webkit-linear-gradient(red, blue); */ background: -webkit-linear-gradient(top left, red, blue);&#125; 大导航栏模块 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!-- 主导航栏 --&gt;&lt;nav&gt; &lt;div class=&quot;nav-common&quot;&gt; &lt;div class=&quot;nav-items&quot;&gt; &lt;a href=&quot;#&quot;&gt;海外酒店&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;nav-items&quot;&gt; &lt;a href=&quot;#&quot;&gt;海外酒店&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;特价酒店&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;nav-items&quot;&gt; &lt;a href=&quot;#&quot;&gt;海外酒店&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;特价酒店&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;nav-common&quot;&gt; &lt;div class=&quot;nav-items&quot;&gt; &lt;a href=&quot;#&quot;&gt;海外酒店&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;nav-items&quot;&gt; &lt;a href=&quot;#&quot;&gt;海外酒店&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;特价酒店&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;nav-items&quot;&gt; &lt;a href=&quot;#&quot;&gt;海外酒店&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;特价酒店&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;nav-common&quot;&gt; &lt;div class=&quot;nav-items&quot;&gt; &lt;a href=&quot;#&quot;&gt;海外酒店&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;nav-items&quot;&gt; &lt;a href=&quot;#&quot;&gt;海外酒店&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;特价酒店&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;nav-items&quot;&gt; &lt;a href=&quot;#&quot;&gt;海外酒店&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;特价酒店&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/nav&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/* nav */nav &#123; overflow: hidden; /*出现小圆角，因为给的是大盒子nav*/ border-radius: 8px; margin: 0 4px 3px;&#125;.nav-common &#123; display: flex; height: 88px; background-color: pink;&#125;.nav-common:nth-child(2) &#123; margin: 3px 0;&#125;.nav-items &#123; /* 不冲突的 */ flex: 1; /*各占三分之一*/ display: flex; flex-direction: column; /*设置主轴方向为y轴*/&#125;.nav-items a &#123; flex: 1; /*各占一份*/ text-align: center; line-height: 44px; color: #fff; font-size: 14px; /* 文字阴影 */ text-shadow: 1px 1px rgba(0, 0, 0, .2);&#125;.nav-items a:nth-child(1) &#123; border-bottom: 1px solid #fff;&#125;.nav-items:nth-child(1) a &#123; border: 0; /*第一个a不需要边框*/ background: url(../images/hotel.png) no-repeat bottom center; /*缩放*/ background-size: 121px auto;&#125;/* -n+2就是选择前面两个元素 ，前两个盒子加右白边框*/.nav-items:nth-child(-n+2) &#123; border-right: 1px solid #fff; &#125;/*渐变色背景*/.nav-common:nth-child(1) &#123; background: -webkit-linear-gradient(left, #FA5A55, #FA994D);&#125;.nav-common:nth-child(2) &#123; background: -webkit-linear-gradient(left, #4B90ED, #53BCED);&#125;.nav-common:nth-child(3) &#123; background: -webkit-linear-gradient(left, #34C2A9, #6CD559);&#125; 侧导航栏模块 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!-- 侧导航栏 --&gt;&lt;ul class=&quot;subnav-entry&quot;&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;span class=&quot;subnav-entry-icon&quot;&gt;&lt;/span&gt; &lt;span&gt;电话费&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;span class=&quot;subnav-entry-icon&quot;&gt;&lt;/span&gt; &lt;span&gt;电话费&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;span class=&quot;subnav-entry-icon&quot;&gt;&lt;/span&gt; &lt;span&gt;电话费&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;span class=&quot;subnav-entry-icon&quot;&gt;&lt;/span&gt; &lt;span&gt;电话费&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;span class=&quot;subnav-entry-icon&quot;&gt;&lt;/span&gt; &lt;span&gt;电话费&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;span class=&quot;subnav-entry-icon&quot;&gt;&lt;/span&gt; &lt;span&gt;电话费&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;span class=&quot;subnav-entry-icon&quot;&gt;&lt;/span&gt; &lt;span&gt;电话费&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;span class=&quot;subnav-entry-icon&quot;&gt;&lt;/span&gt; &lt;span&gt;电话费&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;span class=&quot;subnav-entry-icon&quot;&gt;&lt;/span&gt; &lt;span&gt;电话费&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;span class=&quot;subnav-entry-icon&quot;&gt;&lt;/span&gt; &lt;span&gt;电话费&lt;/span&gt; &lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 123456789101112131415161718192021222324252627282930/* subnav-entry */.subnav-entry &#123; display: flex; border-radius: 8px; background-color: #fff; margin: 0 4px; flex-wrap: wrap; padding: 5px 0;&#125;.subnav-entry li &#123; /* 里面的子盒子可以写 % 相对于父级来说的 */ flex: 20%;&#125;.subnav-entry a &#123; display: flex; flex-direction: column; align-items: center;&#125;.subnav-entry-icon &#123; width: 28px; height: 28px; background-color: pink; margin-top: 4px; background: url(../images/subnav-bg.png) no-repeat; background-size: 28px auto;&#125; 销售模块 123456789101112131415161718192021222324252627282930313233&lt;!-- 销售模块 --&gt;&lt;div class=&quot;sales-box&quot;&gt; &lt;div class=&quot;sales-hd&quot;&gt; &lt;h2&gt;热门活动&lt;/h2&gt; &lt;a href=&quot;#&quot; class=&quot;more&quot;&gt;获取更多福利&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;sales-bd&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;upload/pic1.jpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;upload/pic2.jpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;upload/pic3.jpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;upload/pic4.jpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;upload/pic5.jpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;upload/pic6.jpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/* sales-box */.sales-box &#123; border-top: 1px solid #bbb; background-color: #fff; margin: 4px;&#125;.sales-hd &#123; position: relative; height: 44px; border-bottom: 1px solid #ccc;&#125;.sales-hd h2 &#123; position: relative; text-indent: -999px; overflow: hidden;&#125;.sales-hd h2::after &#123; position: absolute; top: 5px; left: 8px; content: &quot;&quot;; width: 79px; height: 15px; background: url(../images/hot.png) no-repeat 0 -20px; background-size: 79px auto;&#125;.more &#123; position: absolute; right: 5px; top: 0px; background: -webkit-linear-gradient(left, #FF506C, #FF6BC6); border-radius: 15px; padding: 3px 20px 3px 10px; color: #fff;&#125;.more::after &#123; content: &quot;&quot;; position: absolute; top: 9px; right: 9px; width: 7px; height: 7px; border-top: 2px solid #fff; border-right: 2px solid #fff; transform: rotate(45deg);&#125;.row &#123; display: flex;&#125;.row a &#123; flex: 1; border-bottom: 1px solid #eee;&#125;.row a:nth-child(1) &#123; border-right: 1px solid #eee;&#125;.row a img &#123; width: 100%;&#125;","path":"page/mobileweb02.html","date":"01-29","excerpt":"","tags":[{"name":"Web移动开发","slug":"Web移动开发","permalink":"http://xiaoliblog.cn/tags/Web%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"}]},{"title":"Web移动开发📲移动端基础","text":"移动端基础移动端浏览器 国内的UC和QQ ，百度等手机浏览器都是根据Webkit修改过来的内核,国内尚无自主研发的内核，就像国内的手机操作系统都是基于Android修改开发的一样 总结：兼容移动端主流浏览器,处理Webkit内核浏览器即可 手机屏幕 移动端设备屏幕尺寸非常多 ,碎片化严重。 Android设备有多 种分辨率: 480x800, 480x854, 540x960, 720x1280 ,1080x1920等 ,还有传说中的2K ,4k屏。 近年来iPhone的碎片化也加剧了 ,其设备的主要分辨率有: 640x960, 640x1 136, 750x1334, 1242x2208等。 作为开发者无需关注这些分辨率 ,因为我们常用的尺寸单位是px. 移动端调试方法 Chrome DevTools (谷歌浏览器)的模拟手机调试 搭建本地web服务器 ,手机和服务器个局域网内 ,通过手机访问服务器 使用外网服务器 ,直接IP或域名访问 视口视口( viewport )就是浏览器显示页面内容的屏幕区域。视口可以分为布局视口、视觉视口和理想视口 布局视口layout viewport 一般移动设备的浏览器都默认设置了 一个布局视口，用于解决早期的PC端页面在手机上显示的问题。 iOS， Android基本都将这个视口分辨率设置为983px ，所以PC上的网页大多都能在手机上呈现，只不过元素看上去很小，一般默认可以通过手动缩放网页。 视觉视口visual viewport 字面意思， 它是用户正在看到的网站的区域注意：是网站的区域。 我们可以通过缩放去操作视觉视口 ,但不会影响布局视口,布局视口仍保持原来的宽度。 理想视口ideal viewport 为了 使网站在移动端有最理想的浏览和阅读宽度而设定 理想视口，对设备来讲是最理想的视口尺寸 需要手动添写meta视口标签通知浏览器操作 meta视口标签的主要目的 :布局视口的宽度应该与理想视口的宽度一致，简单理解就是设备有多宽，我们布局的视口就多宽 meat视口标签12&lt;meta name=&quot;viewport&quot; content= &quot;width=device-width, user-scalable=no,initial-scale=1.0, maximum-scale=1.0, minimum-scale =1.0&quot;&gt; 属性 解释说明 width 宽度设置的是viewport宽度，可以设置device-width特殊值 initial- scale 初始缩放比，大于0的数字 maximum-scale 最大缩放比，大于0的数字 minimum-scale 最小缩放比，大于0的数字 user-scalable 用户是否可以缩放，yes或no ( 1或0) 加了视口标签效果 未加视口标签效果 标准viewport设置 视口宽度和设备保持一 致 视口的默认缩放比例1.0 不允许用户自行缩放 最大允许的缩放比例1.0 最小允许的缩放比例1.0 二倍图物理像素&amp;物理像素比 物理像素点指的是屏幕显示的最小颗粒，是物理真实存在的。这是厂商在出厂时就设置好了,比如苹果6\\7\\8是750 * 1334 我们开发时候的1px不是一 定等于1个物理像素的 PC端页面，1个px等于1个物理像素的，但是移动端就不尽相同 一个px的能显示的物理像素点的个数 ,称为物理像素比或屏幕像素比 设备 尺寸(英寸) 开发尺寸(px) 物理像素比(dpr) iphone3G 3.5 320*480 1.0 iphone4/4s 3.5 320*480 2.0 iphone5/s/5c 4.0 320*568 2.0 HTC One M8 4.5 360*640 3.0 iphone6 4.7 375*667 2.0 Nexus 4 4.7 384*640 2.0 Nexus 5x 5.2 411*731 2.6 iphone6 Plus 5.5 414*736 3.0 Samsung Galaxy Note 4 5.7 480*853 3.0 Sony Xperia Z Ultra 6.4 540*960 2.0 Nexus 7 (‘12) 7.0 600*960 1.3 iPad Mini 7.9 768*1024 1.0 物理像素就是我们说的分辨率，比如iPhone8的物理像素是750在iPhone8里面 1px 开发像素 = 2 个物理像素 PC端 和早前的手机屏幕/普通手机屏幕: 1CSS像素= 1.物理像素的 Retina(视网膜屏幕)是一种显示技术，可以将把更多的物理像素点压缩至一块屏幕里，从而达到更高的分辨率，并提高屏幕显示的细腻程度 多倍图 对于一张50px* 50px的图片,在手机Retina屏中打开,按照刚才的物理像素比会放大倍数,这样会造成图片模糊 在标准的viewport设置中,使用倍图来提高图片质量,解决在高清设备中的模糊问题 通常使用二倍图，因为iPhone 6\\7\\8的影响,但是现在还存在3倍图4倍图的情况这个看实际开发公司需求 背景图片注意缩放问题 比如我们我们需要一个50*50像素(css像素)的图片，但直接放到我们的iphone8里面会放大2倍100* 100就会模糊，所以我们采取的是放一个100* 100 图片然后手动的把这个图片缩小为50*50(css像素) 我们准备的图片比实际大小大2倍，这就叫做两倍图 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Web移动端开发&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no,initial-scale=1.0, maximum-scale=1.0, minimum-scale =1.0&quot;&gt; &lt;style&gt; img:nth-child(2)&#123; width: 50px; height: 50px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!--模糊的--&gt; &lt;img src=&quot;img/img.jpg&quot;&gt; &lt;!--采取2倍图--&gt; &lt;img src=&quot;img/img.jpg&quot;&gt;&lt;/body&gt;&lt;/html&gt; 背景缩放background-sizebackground-size属性规定背景图像的尺寸 1background-size:width height; 单位：长度|百分比|cover|contain cover把背景图像扩展至足够大，以使背景图像完全覆盖背景区域，先拉伸宽度，宽度足够再拉伸高度 contain把图像扩展至最大尺寸，以使其宽度和宽度完全适应内容区域，宽度和高度等比例拉伸，宽度或高度其中一个足够（达到父盒子宽或高）就不再拉伸，可能有空白区域 1background-size: 100px 50px; 1background-size: 100px; /*只写一个参数，等比例缩放*/ 1background-size: 50% 30%; /*百分比是相对于父盒子宽高*/ 1background-size: cover; 1background-size: contain; 移动端开发选择 单独制作移动端页面（主流） 通常情况下,网址域名前面加m(mobile)可以打开移动端。通过判断设备,如果是移动设备打开,则跳到移动端页面，（移动端和PC端分开制作），比如淘宝移动端：https://www.m.taobao.com/ 响应式页面兼容移动端（其次） 通过判断屏幕宽度来改变样式，以适应不同终端，比如三星电子官网：https://www.samsung.com/cn/ 制作麻烦，需要花很多精力去调兼容性问题 移动端技术解决方案 移动端浏览器基本以webkit内核为主，主要考虑webkt兼容性问题，私有前缀只需要考虑添加webkit即可 CSS初始化normalize.css 移动端CSS初始化推荐使用normalize.css/ Normalize.css :保护了有价值的默认值 Normalize.css :修复了浏览器的bug Normalize.css :是模块化的 Normalize.css :拥有详细的文档 官网地址: http://necolas.github.io/normalize.css/ CSS3盒子模型 box-sizing123div&#123; box-sizing: border-box;&#125; 传统模式宽度计算 ：盒子的宽度= CSS中设置的width + border + padding CSS3盒子模型 ： 盒子的宽度= CSS中设置的宽度width里面包含了border和padding 也就是说,我们的CSS3中的盒子模型，padding 和border不会撑大盒子了 12345678910111213141516div:nth-child(1)&#123; /*传统盒子模型=width+border+padding*/ width: 200px; height: 200px; padding: 10px; border:10px solid red;&#125;div:nth-child(2)&#123; /*padding 和border不会撑大盒子了*/ box-sizing: border-box; width: 200px; height: 200px; padding: 10px; border:10px solid red;&#125; 特殊样式 CSS3盒子模型 1234div&#123; box-sizing: border-box; -webkit-box-sizing: border-box;&#125; 点击高亮我们需要清除清除设置为transparent 为透明 123a&#123; -webkit-tap-highlight-color: transparent ;&#125; ios上加下列属性去掉默认外观，才能给按钮和输入框自定义样式 123input&#123; -webkit-appearance: none ;&#125; 禁用长按页面时的弹出菜单 123img,a &#123; -webkit-touch-callout: none; &#125;","path":"page/mobileweb04.html","date":"01-28","excerpt":"","tags":[{"name":"Web移动开发","slug":"Web移动开发","permalink":"http://xiaoliblog.cn/tags/Web%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"}]},{"title":"前端实例🥳登录表单样式","text":"素材及样式参考地址：https://www.jq22.com/daima canvas验证码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; body &#123; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; &#125; .wrap &#123; text-align: center; width: 200px; height: 200px; &#125; #myCanvas &#123; border: 1px solid #ccc; &#125; .Canvas &#123; text-align: center; &#125; .btn &#123; margin-top: 10px; width: 80px; height: 30px; border: 0; border-radius: 5px; background: rgb(84, 58, 183); color: #fff; &#125; #val &#123; margin: 10px 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;Canvas&quot;&gt; &lt;canvas width=&quot;80&quot; height=&quot;30&quot; id=&quot;myCanvas&quot;&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;input type=&quot;text&quot; id=&quot;val&quot;&gt;&lt;br&gt; &lt;button class=&quot;btn&quot;&gt;验证&lt;/button&gt; &lt;/div&gt; &lt;script&gt; // 获取随机字符串函数 function randomString(len) &#123; // 如果没有传递参数 默认就是是 5 len = len || 5 // 从这里随机 抽取 let chars = &#x27;ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678&#x27; // 获取字符串的长度 let maxPos = chars.length // 存储生存好的验证码字符串 var val = &#x27;&#x27; // 循环 for (var i = 0; i &lt; len; i++) &#123; // charAt 返回字符串中的 某个位置 的字符 传递的参数是 字符的 位置 数字 // Math.random() 获取一个 0 ~ 1 的 数字 包括 小数 val += chars.charAt(Math.random() * maxPos) &#125; return val &#125; console.log(randomString()); // 获取随机颜色函数 function randomColor() &#123; var r = Math.floor(Math.random() * 256) var g = Math.floor(Math.random() * 256) var b = Math.floor(Math.random() * 256) return &quot;rgb(&quot; + r + &quot;, &quot; + b + &quot;,&quot; + r + &quot;)&quot; &#125; console.log(randomColor()); // 获取 canvas 元素 const c = document.querySelector(&#x27;#myCanvas&#x27;) // 获取随机字符 var varification = randomString() // canvas 验证 填充函数 function cav() &#123; // 随机验证码字符串 varification = randomString() // 获取canvas 的 宽度 const cxtwidth = c.offsetWidth // 获取canvas 的 高度 const cxtheight = c.offsetHeight // 创建画布 const ctx = c.getContext(&#x27;2d&#x27;) // 重置画布 ctx.clearRect(0, 0, cxtwidth, cxtheight) // 字体颜色 ctx.fillStyle = &#x27;red&#x27; // 字体大小 和 字体 类型 ctx.font = &#x27;20px Arial&#x27; // 填充 ctx.fillText(varification, 10, 25) // 验证码上显示的线条 for (var i = 0; i &lt;= 5; i++) &#123; ctx.strokeStyle = randomColor() // 起始点 ctx.beginPath(); // 移动到指定位置 不创建 路径 ctx.moveTo(Math.random() * cxtwidth, Math.random() * cxtheight); // 创建一个新的点 ctx.lineTo(Math.random() * cxtwidth, Math.random() * cxtheight) // 填充 ctx.stroke() &#125; // 验证码上显示的小点 for (var i = 0; i &lt;= 30; i++) &#123; ctx.strokeStyle = randomColor() // 起始点 ctx.beginPath(); let x = Math.random() * cxtwidth let y = Math.random() * cxtheight // 移动 ctx.moveTo(x, y) // 创建一个新的点 ctx.lineTo(x + 1, y + 1) // 填充 ctx.stroke() &#125; &#125; cav() // 点击 验证码 容器触发 c.addEventListener(&#x27;click&#x27;, () =&gt; &#123; // 重新调用 cav() &#125;) // 获取按钮 var btn = document.querySelector(&#x27;.btn&#x27;) // 获取文本框 var val = document.querySelector(&#x27;#val&#x27;) // 点击按钮 触发 btn.addEventListener(&#x27;click&#x27;, () =&gt; &#123; if (val.value != varification) &#123; alert(&#x27;验证码不正确!&#x27;) return &#125; alert(&#x27;验证码正确!&#x27;) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 紫色渐变色登录表单1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt; &lt;title&gt;Login&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;login-container&quot;&gt; &lt;div class=&quot;left-container&quot;&gt; &lt;div class=&quot;title&quot;&gt;&lt;span&gt;登录&lt;/span&gt;&lt;/div&gt; &lt;div class=&quot;input-container&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;用户名&quot;&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;密码&quot;&gt; &lt;/div&gt; &lt;div class=&quot;message-container&quot;&gt; &lt;span&gt;忘记密码&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;right-container&quot;&gt; &lt;div class=&quot;regist-container&quot;&gt; &lt;span class=&quot;regist&quot;&gt;注册&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;actoin-container&quot;&gt; &lt;span&gt;提交&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133* &#123; padding: 0; margin: 0;&#125;html &#123; height: 100%;&#125;/* rgb(114,135,254) rgb(130,88,186)rgb(59,45,159)rgb(95, 76, 194)rgb(118,76,163) rgb(92,103,211)rgb(199, 191, 219)rgb(237,221,22) */body &#123; background-image: linear-gradient(to bottom right,rgb(114,135,254),rgb(130,88,186));&#125;body .login-container &#123; width: 600px; height: 315px; margin: 0 auto; margin-top: 20%; border-radius: 15px; box-shadow: 0 10px 50px 0px rgb(59,45,159); background-color: rgb(95, 76, 194);&#125;body .login-container .left-container &#123; display: inline-block; width: 330px; border-top-left-radius: 15px; border-bottom-left-radius: 15px; padding: 60px; background-image: linear-gradient(to bottom right,rgb(118,76,163), rgb(92,103,211));&#125;body .login-container .left-container .title &#123; color: #fff; font-size: 18px; font-weight: 200;&#125;body .login-container .left-container .title span &#123; border-bottom: 3px solid rgb(237,221,22) ;&#125;body .login-container .left-container .input-container &#123; padding: 20px 0;&#125;body .login-container .left-container .input-container input &#123; border: 0; background: none; outline: 0; color: #fff; margin: 20px 0; display: block; width: 100%; padding: 5px 0; transition: .2s; border-bottom: 1px solid rgb(199, 191, 219);&#125;body .login-container .left-container .input-container input:hover &#123; border-bottom-color: #fff;&#125;::-webkit-input-placeholder &#123; color: rgb(199, 191, 219);&#125;body .login-container .left-container .message-container &#123; font-size: 14px; transition: .2s; color: rgb(199, 191, 219); cursor: pointer;&#125;body .login-container .left-container .message-container:hover &#123; color: #fff;&#125;body .login-container .right-container &#123; width: 145px; display: inline-block; height: calc(100% - 120px); vertical-align: top; padding: 60px 0;&#125;body .login-container .right-container .regist-container &#123; text-align: center; color: #fff; font-size: 18px; font-weight: 200;&#125;body .login-container .right-container .regist-container span &#123; border-bottom: 3px solid rgb(237,221,22) ;&#125;body .login-container .right-container .actoin-container &#123; font-size: 10px; color: #fff; height: 100%; position: relative;&#125;body .login-container .right-container .actoin-container span &#123; border: 1px solid rgb(237,221,22); padding: 10px; display: inline; line-height: 25px; border-radius: 25px; position: absolute; bottom: 10px; left: calc(72px - 25px); transition: .2s; cursor: pointer;&#125;body .login-container .right-container .actoin-container span:hover &#123; background-color: rgb(237,221,22); color: rgb(95, 76, 194);&#125; 蓝紫渐变登录表单123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt; &lt;title&gt;Login2&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;login-wrapper&quot;&gt; &lt;div class=&quot;header&quot;&gt;Login&lt;/div&gt; &lt;div class=&quot;form-wrapper&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;username&quot; class=&quot;input-item&quot;&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;password&quot; class=&quot;input-item&quot;&gt; &lt;div class=&quot;btn&quot;&gt;Login&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;msg&quot;&gt; Don`t have account? &lt;a href=&quot;#&quot;&gt;Sign up&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172* &#123; padding: 0; margin: 0; font-family: &#x27;Open Sans Light&#x27;; letter-spacing: .05em;&#125;html &#123; height: 100%;&#125;body &#123; height: 100%;&#125;.container &#123; height: 100%; background-image: linear-gradient(to right,#fbc2eb,#a6c1ee);&#125;.login-wrapper&#123; background-color: #fff; width: 250px; height: 500px; border-radius: 15px; padding: 0 50px; position: relative; left: 50%; top: 50%; transform: translate(-50%,-50%);&#125;.login-wrapper .header &#123; font-size: 30px; font-weight: bold; text-align: center; line-height: 200px;&#125;.login-wrapper .form-wrapper .input-item &#123; display: block; width: 100%; margin-bottom: 20px; border: 0; padding: 10px; border-bottom: 1px solid rgb(128, 125, 125); font-size: 15px; outline: none;&#125;.login-wrapper .form-wrapper .input-item::placeholder &#123; text-transform: uppercase;&#125;.login-wrapper .form-wrapper .btn &#123; text-align: center; padding: 10px; width: 100%; margin-top: 40px; background-image: linear-gradient(to right,#a6c1ee,#fbc2eb); color: #fff;&#125;.login-wrapper .msg &#123; text-align: center; line-height: 80px;&#125;.login-wrapper .msg a &#123; text-decoration-line: none; color: #a6c1ee;&#125; 动态登录按钮表单1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;用户登录&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;login&quot;&gt; &lt;h2&gt;用户登录&lt;/h2&gt; &lt;div class=&quot;login_box&quot;&gt; &lt;!-- required就是不能为空 必须在css效果中有很大的作用 --&gt; &lt;!-- 可以简写为required --&gt; &lt;input type=&quot;text&quot; required /&gt;&lt;label&gt;用户名&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;login_box&quot;&gt; &lt;input type=&quot;password&quot; required=&quot;required&quot; /&gt;&lt;label&gt;密码&lt;/label&gt; &lt;/div&gt; &lt;a href=&quot;javascript:void(0)&quot;&gt; 登录 &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163* &#123; /* 初始化 清除页面元素的内外边距 */ padding: 0; margin: 0; /* 盒子模型 */ box-sizing: border-box;&#125;body &#123; /* 弹性布局 让页面元素垂直+水平居中 */ display: flex; justify-content: center; align-items: center; /* 让页面始终占浏览器可视区域总高度 */ height: 100vh; /* 背景渐变色 */ background: linear-gradient(#141e30, #243b55);&#125;.login &#123; /* 弹性布局 让子元素称为弹性项目 */ display: flex; /* 让弹性项目垂直排列 原理是改变弹性盒子的主轴方向 父元素就是弹性盒子 现在改变后的主轴方向是向下了 */ flex-direction: column; /* 让弹性项目在交叉轴方向水平居中 现在主轴的方向是向下 交叉轴的方向是与主轴垂直 交叉轴的方向是向右 */ align-items: center; width: 400px; padding: 40px; background-color: rgba(0, 0, 0, 0.2); box-shadow: 0 15px 25px rgba(0, 0, 0, 0.4);&#125;.login h2 &#123; color: #fff; margin-bottom: 30px;&#125;.login .login_box &#123; /* 相对定位 */ position: relative; width: 100%;&#125;.login .login_box input &#123; /* 清除input框自带的边框和轮廓 */ outline: none; border: none; width: 100%; padding: 10px 0; margin-bottom: 30px; color: #fff; font-size: 16px; border-bottom: 1px solid #fff; /* 背景颜色为透明色 */ background-color: transparent;&#125;.login .login_box label &#123; position: absolute; top: 0; left: 0; padding: 10px 0; color: #fff; /* 这个属性的默认值是auto 默认是这个元素可以被点击 但是如果我们写了none 就是这个元素不能被点击 , 就好像它可见但是不能用 可望而不可即 */ /* 这个就是两者的区别 */ pointer-events: none; /* 加个过渡 */ transition: all 0.5s;&#125;/* :focus 选择器是当input获得焦点是触发的样式 + 是相邻兄弟选择器 去找与input相邻的兄弟label *//* :valid 选择器是判断input框的内容是否合法,如果合法会执行下面的属性代码,不合法就不会执行,我们刚开始写布局的时候给input框写了required 我们删掉看对比 当没有required的话input框的值就会被认为一直合法,所以一直都是下方的样式 ,但是密码不会,密码框内的值为空,那么这句话局不合法,required不能为空 当我们给密码框写点东西的时候才会执行以下代码*/.login .login_box input:focus + label,.login .login_box input:valid + label &#123; top: -20px; color: #03e9f4; font-size: 12px;&#125;.login a &#123; overflow: hidden; position: relative; padding: 10px 20px; color: #03e9f4; /* 取消a表现原有的下划线 */ text-decoration: none; /* 同样加个过渡 */ transition: all 0.5s;&#125;.login a:hover &#123; color: #fff; border-radius: 5px; background-color: #03e9f4; box-shadow: 0 0 5px #03e9f4, 0 0 25px #03e9f4, 0 0 50px #03e9f4, 0 0 100px #03e9f4;&#125;.login a span &#123; position: absolute;&#125;.login a span:first-child &#123; top: 0; left: -100%; width: 100%; height: 2px; /* to right 就是往右边 下面的同理 */ background: linear-gradient(to right, transparent, #03e9f4); /* 动画 名称 时长 linear是匀速运动 infinite是无限次运动 */ animation: move1 1s linear infinite;&#125;.login a span:nth-child(2) &#123; right: 0; top: -100%; width: 2px; height: 100%; background: linear-gradient(transparent, #03e9f4); /* 这里多了个0.25s其实是延迟时间 */ animation: move2 1s linear 0.25s infinite;&#125;.login a span:nth-child(3) &#123; right: -100%; bottom: 0; width: 100%; height: 2px; background: linear-gradient(to left, transparent, #03e9f4); animation: move3 1s linear 0.5s infinite;&#125;.login a span:last-child &#123; left: 0; bottom: -100%; width: 2px; height: 100%; background: linear-gradient(#03e9f4, transparent); animation: move4 1s linear 0.75s infinite;&#125;/* 写一下动画 再坚持一下 视频马上就完了 */@keyframes move1 &#123; 0% &#123; left: -100%; &#125; 50%, 100% &#123; left: 100%; &#125;&#125;@keyframes move2 &#123; 0% &#123; top: -100%; &#125; 50%, 100% &#123; top: 100%; &#125;&#125;@keyframes move3 &#123; 0% &#123; right: -100%; &#125; 50%, 100% &#123; right: 100%; &#125;&#125;@keyframes move4 &#123; 0% &#123; bottom: -100%; &#125; 50%, 100% &#123; bottom: 100%; &#125;&#125; 弹出式登录表单1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt; &lt;script src=&quot;https://kit.fontawesome.com/a81368914c.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;center&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;show&quot;&gt; &lt;label for=&quot;show&quot; class=&quot;show-btn&quot;&gt;View Form&lt;/label&gt; &lt;div class=&quot;container&quot;&gt; &lt;label for=&quot;show&quot; class=&quot;close-btn fas fa-times&quot;&gt;&lt;/label&gt; &lt;div class=&quot;text&quot;&gt;Login Form&lt;/div&gt; &lt;form action=&quot;#&quot;&gt; &lt;div class=&quot;data&quot;&gt; &lt;label&gt;Email or Phone&lt;/label&gt; &lt;input type=&quot;text&quot; required&gt; &lt;/div&gt; &lt;div class=&quot;data&quot;&gt; &lt;label&gt;Password&lt;/label&gt; &lt;input type=&quot;password&quot; required&gt; &lt;/div&gt; &lt;div class=&quot;forgot-pass&quot;&gt;&lt;a href=&quot;#&quot;&gt;Forgot Password?&lt;/a&gt;&lt;/div&gt; &lt;div class=&quot;btn&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;button type=&quot;submit&quot;&gt;login&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;signup-link&quot;&gt;Not a menber? &lt;a href=&quot;#&quot;&gt;Signup now&lt;/a&gt;&lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152*&#123; margin: 0; padding: 0; outline: none; box-sizing: border-box; font-family: &quot;Poppins&quot;, sans-serif;&#125;body&#123; height: 100vh; width: 100%; background: linear-gradient(115deg, #56d8e4 10%,#9f01ea 90%);&#125;.show-btn&#123; background: #fff; padding: 10px 20px; font-size: 20px; font-weight: 500; color: #3498db; cursor: pointer; box-shadow: 0 0 10px rgba(0,0,0,0.1);&#125;.show-btn, .container&#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125;input[type=&quot;checkbox&quot;]&#123; display: none;&#125;.container&#123; display: none; background: #fff; width: 410px; padding: 30px; box-shadow: 0 0 8px rgba(0,0,0,0.1);&#125;#show:checked ~ .container&#123; display: block;&#125;.container .close-btn&#123; position: absolute; right: 20px; top: 15px; font-size: 18px; cursor: pointer;&#125;.container .close-btn:hover&#123; color: #3498db;&#125;.container .text&#123; font-size: 35px; font-weight: 600; text-align: center;&#125;.container form&#123; margin-top: -20px;&#125;.container form .data&#123; height: 45px; width: 100%; margin: 40px 0;&#125;form .data input&#123; font-size: 18px;&#125;form .data input&#123; height: 100%; width: 100%; padding-left: 10px; font-size: 17px; border: 1px solid silver;&#125;form .data input:focus&#123; border-color: #3498db; border-bottom-width: 20x;&#125;form .forgot-pass&#123; margin-top: -8px;&#125;form .forgot-pass a&#123; color: #3498db; text-decoration: none;&#125;form .forgot-pass a:hover&#123; text-decoration: underline;&#125;form .btn&#123; margin: 30px 0; height: 45px; width: 100%; position: relative; overflow: hidden;&#125;form .btn .inner&#123; height: 100%; width: 300%; position: absolute; left: -100%; z-index: -1; background: -webkit-linear-gradient(right, #56d8e4, #9f01ea); transition: all .4s;&#125;form .btn:hover .inner&#123; left: 0;&#125;form .btn button&#123; height: 100%; width: 100%; background: none; border: none; color: #fff; font-size: 18px; font-weight: 500; text-transform: uppercase; letter-spacing: 1px; cursor: pointer;&#125;form .signup-link&#123; text-align: center;&#125;form .signup-link a&#123; color: #3498db; text-decoration: none;&#125;form .signup-link a:hover&#123; text-decoration: underline;&#125; 毛玻璃效果登录表单1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; /&gt; &lt;title&gt;Static Template&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;form action=&quot;#&quot; class=&quot;login-form&quot;&gt; &lt;h2&gt;登 录&lt;/h2&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;用户名&quot; /&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;密码&quot; /&gt; &lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125html,body &#123; margin: 0; font-family: &quot;PingFang SC&quot;, &quot;Microsoft Yahei&quot;, sans-serif;&#125;.container &#123; width: 100vw; height: 100vh; display: flex; align-items: center; justify-content: center; background: url(&quot;./background.jpeg&quot;) fixed no-repeat; background-size: cover;&#125;.login-form &#123; width: 240px; height: 220px; display: flex; flex-direction: column; padding: 40px; text-align: center; position: relative; z-index: 100; background: inherit; border-radius: 18px; overflow: hidden; /* 隐藏多余的模糊效果 */&#125;.login-form::before &#123; content: &quot;&quot;; width: calc(100% + 20px); height: calc(100% + 20px); position: absolute; top: -10px; left: -10px; overflow: hidden; background: inherit; box-shadow: inset 0 0 0 200px rgba(255, 255, 255, 0.25); filter: blur(6px); z-index: -1;&#125;.login-form h2 &#123; font-size: 18px; font-weight: 400; color: #3d5245;&#125;.login-form input,.login-form button &#123; margin: 6px 0; height: 36px; border: none; background-color: rgba(255, 255, 255, 0.3); border-radius: 4px; padding: 0 14px; color: #3d5245;&#125;.login-form input::placeholder &#123; color: #3d5245;&#125;/* 补充，取消选中高亮蓝框 */.login-form button:focus,.login-form input:focus &#123; outline: 0;&#125;.login-form button &#123; margin-top: 24px; background-color: rgba(57, 88, 69, 0.4); color: white; position: relative; overflow: hidden; cursor: pointer; transition: 0.4s;&#125;.login-form button:hover &#123; background-color: rgba(12, 80, 38, 0.67);&#125;.login-form button:focus &#123; outline: 0;&#125;.login-form button::before,.login-form button::after &#123; content: &quot;&quot;; display: block; width: 80px; height: 100%; background: rgba(179, 255, 210, 0.5); opacity: 0.5; position: absolute; top: 0; left: 0; transform: skewX(-15deg); filter: blur(30px); overflow: hidden; transform: translateX(-100px);&#125;.login-form button::after &#123; width: 40px; background: rgba(179, 255, 210, 0.3); left: 60px; opacity: 0; filter: blur(5px);&#125;.login-form button:hover::before &#123; transition: 1s; transform: translateX(320px); opacity: 0.7;&#125;.login-form button:hover::after &#123; transition: 1s; transform: translateX(320px); opacity: 1;&#125; 输入隐藏与显示功能1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;login&quot;&gt; &lt;label for=&quot;&quot;&gt; &lt;img src=&quot;test_1.png&quot; alt=&quot;&quot; id=&quot;test&quot;&gt; &lt;/label&gt; &lt;input type=&#x27;password&#x27; id=&quot;psw&quot;&gt; &lt;/div&gt; &lt;script&gt; var test = document.getElementById(&#x27;test&#x27;) var psw = document.getElementById(&#x27;psw&#x27;) var flag = 0; test.onclick = function () &#123; if (flag == 0) &#123; psw.type = &#x27;text&#x27; test.src = &#x27;test.png&#x27; flag = 1 &#125; else &#123; psw.type = &#x27;password&#x27; test.src = &#x27;test_1.png&#x27; flag = 0; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930* &#123; margin: 0; padding: 0;&#125;body &#123; height: 100vh; background-image: linear-gradient(120deg, #fccb90 0%, #d57eeb 100%);&#125;.login &#123; position: relative; width: 400px; height: 40px; margin: 300px auto;&#125;input &#123; width: 400px; height: 40px; border: 0; background-color: transparent; outline: none; border-bottom: 2px solid #fff; font-size: 20px;&#125;label img&#123; position: absolute; top: 5px; right: 0px; width: 20px;&#125; 游戏暗黑风格表单1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; dir=&quot;ltr&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;link href=&quot;https://fonts.googleapis.com/css?family=Hind&amp;display=swap&quot; rel=&quot;stylesheet&quot;&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;login-form&quot;&gt; &lt;div class=&quot;logo&quot;&gt;&lt;img src=&quot;images/logo.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt; &lt;div class=&quot;social-media&quot;&gt; &lt;button class=&quot;fb&quot;&gt;&lt;img src=&quot;images/fb.png&quot; alt=&quot;&quot;&gt;&lt;/button&gt; &lt;button class=&quot;google&quot;&gt;&lt;img src=&quot;images/google.png&quot; alt=&quot;&quot;&gt;&lt;/button&gt; &lt;button class=&quot;ps&quot;&gt;&lt;img src=&quot;images/ps.png&quot; alt=&quot;&quot;&gt;&lt;/button&gt; &lt;button class=&quot;xbox&quot;&gt;&lt;img src=&quot;images/xbox.png&quot; alt=&quot;&quot;&gt;&lt;/button&gt; &lt;button class=&quot;switch&quot;&gt;&lt;img src=&quot;images/switch.png&quot; alt=&quot;&quot;&gt;&lt;/button&gt; &lt;/div&gt; &lt;h6&gt;Sign In&lt;/h6&gt; &lt;form action=&quot;&quot;&gt; &lt;div class=&quot;textbox&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Username Or Email&quot;&gt; &lt;span class=&quot;check-message hidden&quot;&gt;Required&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;textbox&quot;&gt; &lt;input type=&quot;password&quot; placeholder=&quot;Password&quot;&gt; &lt;span class=&quot;check-message hidden&quot;&gt;Required&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;options&quot;&gt; &lt;label class=&quot;remember-me&quot;&gt; &lt;span class=&quot;checkbox&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;span class=&quot;checked&quot;&gt;&lt;/span&gt; &lt;/span&gt; Remember me &lt;/label&gt; &lt;a href=&quot;#&quot;&gt;Forgot Your Password&lt;/a&gt; &lt;/div&gt; &lt;input type=&quot;submit&quot; value=&quot;Log In Now&quot; class=&quot;login-btn&quot; disabled&gt; &lt;div class=&quot;privacy-link&quot;&gt; &lt;a href=&quot;#&quot;&gt;Privacy Policy&lt;/a&gt; &lt;/div&gt; &lt;/form&gt; &lt;div class=&quot;dont-have-account&quot;&gt; Don&#x27;t have an Epic Games account? &lt;a href=&quot;#&quot;&gt;Sign Up&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(&quot;.textbox input&quot;).focusout(function()&#123; if($(this).val() == &quot;&quot;)&#123; $(this).siblings().removeClass(&quot;hidden&quot;); $(this).css(&quot;background&quot;,&quot;#554343&quot;); &#125;else&#123; $(this).siblings().addClass(&quot;hidden&quot;); $(this).css(&quot;background&quot;,&quot;#484848&quot;); &#125; &#125;); $(&quot;.textbox input&quot;).keyup(function()&#123; var inputs = $(&quot;.textbox input&quot;); if(inputs[0].value != &quot;&quot; &amp;&amp; inputs[1].value)&#123; $(&quot;.login-btn&quot;).attr(&quot;disabled&quot;,false); $(&quot;.login-btn&quot;).addClass(&quot;active&quot;); &#125;else&#123; $(&quot;.login-btn&quot;).attr(&quot;disabled&quot;,true); $(&quot;.login-btn&quot;).removeClass(&quot;active&quot;); &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231*&#123; margin: 0; padding: 0; box-sizing: border-box; font-family: &quot;hind&quot;,sans-serif; text-decoration: none;&#125;body&#123; background: #121212; min-height: 100vh; display: flex; align-items: center; justify-content: center;&#125;.login-form&#123; width: 470px; background: #202020; padding: 30px 60px;&#125;.logo&#123; height: 50px; text-align: center;&#125;.logo img&#123; height: 50px;&#125;.social-media&#123; display: flex; margin: 30px 0;&#125;.social-media button&#123; height: 50px; width: 100px; margin-right: 10px; display: flex; align-items: center; justify-content: center; cursor: pointer; border: none; transition: .3s linear;&#125;.social-media button:last-child&#123; margin: 0;&#125;.social-media button img&#123; width: 20px;&#125;.fb&#123; background: #4267b2;&#125;.google&#123; background: #fff;&#125;.ps&#123; background: #02b3e8;&#125;.xbox&#123; background: #107c10;&#125;.switch&#123; background: #e60012;&#125;.social-media button:hover &#123; opacity: .7;&#125;.login-form h6&#123; color: #f1f1f1; font-size: 15px; text-transform: uppercase; font-weight: 500;&#125;.textbox&#123; width: 100%; height: 50px; position: relative; margin-top: 15px;&#125;.textbox input&#123; width: 100%; height: 50px; border: none; background: #2b2b2b; padding: 0 15px; font-size: 16px; outline: none; color: #f4f4f4;&#125;.textbox input:focus&#123; background: #484848 !important;&#125;.check-message&#123; position: absolute; top: 50%; right: 10px; color: #fff; text-transform: uppercase; transform: translateY(-50%);&#125;.textbox input:focus + .check-message&#123; display: none;&#125;.options&#123; margin-top: 15px; color: #f4f4f480; overflow: hidden; font-size: 14px;&#125;.remember-me&#123; float: left; display: flex; align-items: center; cursor: pointer;&#125;.checkbox&#123; display: inline-block; width: 20px; height: 20px; background: #484848; margin-right: 15px; position: relative;&#125;.checkbox input&#123; width: 100%; height: 100%; opacity: 0; cursor: pointer;&#125;.checked&#123; position: absolute; left: 8px; top: 4px; width: 5px; height: 10px; border: solid #fff; border-width: 0 1px 1px 0; transform: rotate(45deg); display: none;&#125;.checkbox input:checked + .checked&#123; display: block;&#125;.options a&#123; color: #f4f4f480; font-size: 14px; float: right;&#125;.login-btn&#123; width: 100%; height: 50px; margin-top: 30px; background: #191919; border: none; outline: none; cursor: pointer; text-transform: uppercase; font-weight: 700; transition: .3s linear;&#125;.login-btn.active&#123; background: #037bee; color: #fff;&#125;.login-btn.active:hover&#123; opacity: .7;&#125;.hidden&#123; display: none;&#125;.privacy-link&#123; text-align: center; margin-top: 35px;&#125;.privacy-link a&#123; color: #f1f1f1; font-size: 14px;&#125;.dont-have-account&#123; font-size: 14px; text-align: center; color: #f4f4f480; margin: 20px 0;&#125;.dont-have-account a&#123; color: #f1f1f1;&#125;@media screen and (max-width:470px) &#123; body&#123; background: #202020; &#125; .login-form&#123; width: 100%; padding: 0 15px; &#125;&#125;","path":"page/project03.html","date":"01-28","excerpt":"","tags":[{"name":"项目案例","slug":"项目案例","permalink":"http://xiaoliblog.cn/tags/%E9%A1%B9%E7%9B%AE%E6%A1%88%E4%BE%8B/"}]},{"title":"前端实例🥳导航栏选项卡实例","text":"素材及样式参考地址：https://www.jq22.com/daima tab选项卡123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;css_tab选项卡&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;tab&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;tab&quot; id=&quot;tab1&quot; checked /&gt; &lt;input type=&quot;radio&quot; name=&quot;tab&quot; id=&quot;tab2&quot; /&gt; &lt;input type=&quot;radio&quot; name=&quot;tab&quot; id=&quot;tab3&quot; /&gt; &lt;input type=&quot;radio&quot; name=&quot;tab&quot; id=&quot;tab4&quot; /&gt; &lt;input type=&quot;radio&quot; name=&quot;tab&quot; id=&quot;tab5&quot; /&gt; &lt;label for=&quot;tab1&quot;&gt;&lt;img src=&quot;images/1.png&quot; alt=&quot;&quot; /&gt;HTML&lt;/label&gt; &lt;label for=&quot;tab2&quot;&gt;&lt;img src=&quot;images/2.png&quot; alt=&quot;&quot; /&gt;CSS&lt;/label&gt; &lt;label for=&quot;tab3&quot;&gt;&lt;img src=&quot;images/3.png&quot; alt=&quot;&quot; /&gt;JavaScript&lt;/label&gt; &lt;label for=&quot;tab4&quot;&gt;&lt;img src=&quot;images/4.png&quot; alt=&quot;&quot; /&gt;Vue&lt;/label&gt; &lt;label for=&quot;tab5&quot;&gt;&lt;img src=&quot;images/5.png&quot; alt=&quot;&quot; /&gt;React&lt;/label&gt; &lt;ul&gt; &lt;li&gt; &lt;img src=&quot;images/1.png&quot; alt=&quot;&quot; /&gt; &lt;h2&gt;HTML&lt;/h2&gt; &lt;p&gt; HTML 称为超文本标记语言，是一种标识性的语言。它包括一系列标签．通过这些标签可以将网络上的文档格式统一，使分散的 Internet 资源连接为一个逻辑整体。HTML 文本是由 HTML 命令组成的描述性文本，HTML 命令可以说明文字，图形、动画、声音、表格、链接等。 &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;images/2.png&quot; alt=&quot;&quot; /&gt; &lt;h2&gt;CSS&lt;/h2&gt; &lt;p&gt; 层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现 HTML（标准通用标记语言的一个应用）或 XML（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS 不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。 &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;images/3.png&quot; alt=&quot;&quot; /&gt; &lt;h2&gt;JavaScript&lt;/h2&gt; &lt;p&gt; JavaScript（简称“JS”）是一种具有函数优先的轻量级，解释型或即时编译型的高级编程语言。虽然它是作为开发 Web 页面的脚本语言而出名的，但是它也被用到了很多非浏览器环境中，JavaScript 基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式和声明式（如函数式编程）风格。 &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;images/4.png&quot; alt=&quot;&quot; /&gt; &lt;h2&gt;Vue&lt;/h2&gt; &lt;p&gt; VUE 是 iOS 和 Android 平台上的一款 Vlog 社区与编辑工具，允许用户通过简单的操作实现 Vlog 的拍摄、剪辑、细调、和发布，记录与分享生活。还可以在社区直接浏览他人发布的 Vlog，与 Vloggers 互动。 &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;img src=&quot;images/5.png&quot; alt=&quot;&quot; /&gt; &lt;h2&gt;React&lt;/h2&gt; &lt;p&gt; React 起源于 Facebook 的内部项目，因为该公司对市场上所有 JavaScript MVC 框架，都不满意，就决定自己写一套，用来架设 Instagram 的网站。做出来以后，发现这套东西很好用，就在 2013 年 5 月开源了。 &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117*&#123; padding: 0; margin: 0; /* 盒子模型 */ box-sizing: border-box;&#125;body&#123; display: flex; justify-content: center; align-items: center; height: 100vh; background-color: #282c34;&#125;.tab&#123; width: 700px; height: 250px; color: #607291; background-color: #fff; overflow: hidden;&#125;input&#123; display: none;&#125;label&#123; float: left; width: 140px; height: 40px; line-height: 40px; text-align: center; font-size: 14px; font-weight: 700; background-color: #e5e9ea; transition: all .3s;&#125;label:hover&#123; background-color: #fff;&#125;label img&#123; width: 20px; height: 20px; vertical-align: middle; margin-top: -5px; margin-right: 5px;&#125;ul&#123; /* 清除浮动 */ clear: both; width: 3500px; height: 210px; transition: all .5s;&#125;ul li&#123; float: left; list-style: none; width: 700px; height: 210px; padding: 40px;&#125;ul li img&#123; float: left; width: 130px; height: 130px; margin-right: 20px;&#125;ul li p&#123; /* 首行缩进两个字符 */ text-indent: 2em; /* 伸缩盒子模型 */ display: -webkit-box; /* 在伸缩盒子模型里让子元素垂直排列 */ -webkit-box-orient: vertical; /* 这个不是css的标准语句，需要配合以上两种属性一起使用，意思是只显示三行 */ -webkit-line-clamp: 3; /* 溢出隐藏 */ overflow: hidden; /* 溢出隐藏的文字呈现省略号 */ text-overflow: ellipsis; margin-top: 20px;&#125;#tab1:checked~ul&#123; margin-left: 0;&#125;#tab2:checked~ul &#123; margin-left: -700px;&#125;#tab3:checked~ul &#123; margin-left: -1400px;&#125;#tab4:checked~ul &#123; margin-left: -2100px;&#125;#tab5:checked~ul &#123; margin-left: -2800px;&#125;#tab1:checked~label[for=&quot;tab1&quot;]&#123; background-color: #fff;&#125;#tab2:checked~label[for=&quot;tab2&quot;] &#123; background-color: #fff;&#125;#tab3:checked~label[for=&quot;tab3&quot;] &#123; background-color: #fff;&#125;#tab4:checked~label[for=&quot;tab4&quot;] &#123; background-color: #fff;&#125;#tab5:checked~label[for=&quot;tab5&quot;] &#123; background-color: #fff;&#125; 侧边栏123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;侧边展开导航栏(半隐藏)&lt;/title&gt; &lt;!-- 这个是提前引入的字体图标 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/font-awesome.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;navbar&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; /&gt; &lt;!-- 复选框的id属性值和label元素的for属性值必须是相同的,才能够通过点击label选中复选框 --&gt; &lt;label for=&quot;checkbox&quot;&gt;&lt;i class=&quot;fa fa-bars&quot;&gt;&lt;/i&gt;&lt;/label&gt; &lt;ul&gt; &lt;li&gt; &lt;img src=&quot;images/1.jpg&quot; alt=&quot;&quot; /&gt; &lt;span&gt;欢迎您! 管理员&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:void(0)&quot;&gt;&lt;i class=&quot;fa fa-home&quot;&gt;&lt;/i&gt; &lt;span&gt;后台首页&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:void(0)&quot;&gt;&lt;i class=&quot;fa fa-sitemap&quot;&gt;&lt;/i&gt; &lt;span&gt;商品列表&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:void(0)&quot;&gt;&lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; &lt;span&gt;用户列表&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:void(0)&quot;&gt;&lt;i class=&quot;fa fa-shopping-cart&quot;&gt;&lt;/i&gt; &lt;span&gt;订单列表&lt;/span&gt; &lt;/a&gt; &lt;/li &lt;li&gt; &lt;a href=&quot;javascript:void(0)&quot;&gt;&lt;i class=&quot;fa fa-windows&quot;&gt;&lt;/i&gt; &lt;span&gt;功能列表&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul &lt;/div&gt;&lt;/body&gt;&lt;/html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126* &#123; /* 页面初始化 清除元素原有的内外边距 */ padding: 0; margin: 0;&#125;body &#123; /* 溢出隐藏 */ overflow: hidden;&#125;.navbar &#123; /* 相对定位 */ position: relative; /* 元素的宽度占浏览器可视区域的宽度 */ width: 100vm;&#125;.navbar input &#123; /* 隐藏元素 */ display: none;&#125;.navbar label &#123; position: absolute; top: 0; left: 70px; width: 100%; height: 43px; padding-left: 20px; font-size: 30px; color: #5a738e; background-color: #ededed; border: 1px solid #d9dee4; /* 鼠标移入变小手 */ cursor: pointer; /* 加过渡 */ transition: all 0.5s;&#125;.navbar ul &#123; /* 再加个溢出隐藏 */ overflow: hidden; /* 删除li前面的小黑点 */ list-style: none; width: 70px; /* 高度占浏览器可视区域的高度 */ height: 100vh; background-color: #2a3f54; transition: all 0.5s;&#125;.navbar ul li &#123; height: 70px; margin-bottom: 10px;&#125;/* :first-child选择器 选择到ul下面的第一个元素 */.navbar ul li:first-child &#123; /* 弹性布局 让元素在该盒子内垂直+水平居中 */ display: flex; justify-content: center; align-items: center; padding: 0 10px;&#125;.navbar ul li:first-child img &#123; width: 50px; border-radius: 50%;&#125;.navbar ul li:first-child span &#123; /* 先把文字隐藏起来 */ display: none; color: #fff; /* 文字禁止换行 */ white-space: nowrap; padding-left: 10px;&#125;.navbar ul li a &#123; /* 弹性布局 */ display: flex; justify-content: center; align-items: center; /* 这个属性改变了弹性盒子的主轴方向 现在主轴方向向下 元素也就垂直排列 */ flex-direction: column; width: 100%; height: 100%; color: #d1d1d1; /* 取消文字的下划线 */ text-decoration: none;&#125;.navbar ul li a i &#123; font-size: 25px; margin-bottom: 10px;&#125;.navbar ul li a span &#123; font-size: 10px; /* 给这个文字也加禁止换行 不然切换的一瞬间会垂直排列 */ white-space: nowrap;&#125;.navbar ul li a:hover &#123; color: #fff; background-color: #35495d;&#125;/* :checked选择器判断复选框是否被选中 *//* +是相邻兄弟选择器 找到了input的下一个兄弟label */.navbar input:checked + label &#123; left: 200px;&#125;/* ~也是兄弟选择器 但是可以找到隔了几代的兄弟 */.navbar input:checked ~ ul &#123; width: 200px;&#125;.navbar input:checked ~ ul li:first-child &#123; /* 改变了弹性项目在弹性盒子内的水平排列方式为从开头排序 */ justify-content: flex-start;&#125;.navbar input:checked ~ ul li:first-child span &#123; /* 文字显示 */ display: block;&#125;.navbar input:checked ~ ul li a &#123; /* 改变了主轴的方向为默认值 水平排列 */ flex-direction: row; /* 改变了弹性项目在弹性盒子内的水平排列方式为从开头排序 */ justify-content: flex-start;&#125;.navbar input:checked ~ ul li a i &#123; font-size: 18px; margin: 0 15px;&#125;.navbar input:checked ~ ul li a span &#123; font-size: 13px;&#125; 垂直手风琴选项卡123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;垂直手风琴&lt;/title&gt; &lt;!-- 事先引入好的字体图标库 源码会放在简介 自行下载即可 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/font-awesome.min.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot; /&gt;&lt;/head&gt;&lt;body&gt;&lt;ul class=&quot;accordion&quot;&gt; &lt;li&gt;&lt;!-- 单选框的id属性值和label 元素的for属性值相同时,就可以通过label元素来选中单选框, 每个单选框都有一个相同name属性 --&gt;&lt;!-- 这个属性主要作用是用来将单选框分类的,当每个name属性值相同时,那么这一组单选框就只能同时选中一个 --&gt; &lt;input type=&quot;radio&quot; name=&quot;item&quot; id=&quot;item1&quot; /&gt;&lt;label for=&quot;item1&quot;&gt;一级标题1&lt;i class=&quot;fa fa-caret-right&quot;&gt;&lt;/i&gt;&lt;/label&gt; &lt;ol&gt; &lt;li&gt;二级标题1&lt;/li&gt; &lt;li&gt;二级标题2&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt; &lt;input type=&quot;radio&quot; name=&quot;item&quot; id=&quot;item2&quot; /&gt;&lt;label for=&quot;item2&quot;&gt;一级标题2&lt;i class=&quot;fa fa-caret-right&quot;&gt;&lt;/i&gt;&lt;/label&gt; &lt;ol&gt; &lt;li&gt;二级标题1&lt;/li&gt; &lt;li&gt;二级标题2&lt;/li&gt; &lt;li&gt;二级标题3&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt; &lt;input type=&quot;radio&quot; name=&quot;item&quot; id=&quot;item3&quot; /&gt;&lt;label for=&quot;item3&quot;&gt;一级标题3&lt;i class=&quot;fa fa-caret-right&quot;&gt;&lt;/i&gt;&lt;/label&gt; &lt;ol&gt; &lt;li&gt;二级标题1&lt;/li&gt; &lt;li&gt;二级标题2&lt;/li&gt; &lt;li&gt;二级标题3&lt;/li&gt; &lt;li&gt;二级标题4&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt; &lt;input type=&quot;radio&quot; name=&quot;item&quot; id=&quot;item4&quot; /&gt;&lt;label for=&quot;item4&quot;&gt;一级标题4&lt;i class=&quot;fa fa-caret-right&quot;&gt;&lt;/i&gt;&lt;/label&gt; &lt;ol&gt; &lt;li&gt;二级标题1&lt;/li&gt; &lt;li&gt;二级标题2&lt;/li&gt; &lt;li&gt;二级标题3&lt;/li&gt; &lt;li&gt;二级标题4&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125* &#123; /* 页面初始化 清除元素原有的内外边距 */ padding: 0; margin: 0; /* 盒子模型 */ box-sizing: border-box;&#125;body &#123; /* 弹性布局 让页面元素垂直+水平居中 */ display: flex; justify-content: center; align-items: center; /* 让页面占浏览器可视区域的高度 */ height: 100vh;&#125;li &#123; /* 清除li元素前面的项目符号 */ list-style: none;&#125;.accordion &#123; /* 溢出隐藏 */ overflow: hidden; width: 300px; /* 圆角属性 */ border-radius: 8px; /* 盒子阴影 */ box-shadow: 0 0 10px rgba(0, 0, 0, 0.6);&#125;.accordion &gt; li &#123; width: 100%;&#125;.accordion &gt; li input &#123; /* 将单选按钮隐藏起来 */ display: none;&#125;.accordion &gt; li label &#123; /* 相对定位 */ position: relative; /* label元素是行内元素 需要将其转为块级元素 才能设置宽度和高度 */ display: block; width: 100%; padding: 20px 50px; color: #fff; background-color: #5fb878; /* 鼠标移入变小手 */ cursor: pointer;&#125;.accordion &gt; li label i &#123; /* 绝对定位 */ position: absolute; /* calc方法自动计算数值 让字体图标垂直居中 */ top: calc(50% - 12px); left: 20px; font-size: 24px; /* 加过渡 */ transition: all 0.5s;&#125;.accordion &gt; li label::after &#123; content: &quot;&quot;; /* 我们想通过after伪元素来实现三角形 有两种方法 我都给大家写出 哪种简单就用哪种 */ position: absolute; right: 20px; bottom: -14px; width: 30px; height: 15px; /* inherit这个属性值可以继承父元素的属性值 */ background-color: inherit; /* 这个属性在上期视频有讲解 这里就不浪费时间了 想了解的可以去看上期视频 我们一起来看第二种方法 */ clip-path: polygon(0 0, 100% 0, 50% 100%);&#125;/* .accordion &gt; li label::after &#123; content: &quot;&quot;; position: absolute; right: 25px; bottom: -10px; width: 20px; height: 20px; background-color: inherit; /* 第二种方法是通过旋转来实现 这种方法显然比第一种简单 transform: rotate(45deg);&#125; */.accordion &gt; li label:hover &#123; background-color: #53aa6c;&#125;/* :not()选择器选取的是除括号里的元素以外的其它元素 :first-child选择器是第一个元素 */.accordion &gt; li:not(:first-child) label &#123; border-top: 1px solid #38814d;&#125;.accordion &gt; li ol &#123; width: 100%; background-color: #333;&#125;.accordion &gt; li ol li &#123; position: relative; width: 100%; height: 0; line-height: 50px; padding-left: 20px; color: #fff; cursor: pointer; /* 加过渡 */ transition: all 0.5s;&#125;.accordion &gt; li ol li::before &#123; content: &quot;&quot;; position: absolute; top: 3px; left: 0; width: 5px; height: 44px; background-color: #5fb878; transform: scaleY(0); /* 加过渡 */ transition: all 0.5s;&#125;.accordion &gt; li ol li:hover::before &#123; transform: scaleY(1);&#125;.accordion &gt; li input:checked ~ label i &#123; transform: rotate(90deg);&#125;.accordion &gt; li input:checked ~ ol li &#123; height: 50px;&#125; 水波导航栏123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; /&gt; &lt;title&gt;CSS 导航条&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;产品介绍&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;服务介绍&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;联系我们&lt;/a&gt;&lt;/li&gt; &lt;div class=&quot;slider&quot;&gt;&lt;/div&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/header&gt; &lt;/body&gt;&lt;/html&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; /&gt; &lt;title&gt;CSS 导航条&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;产品介绍&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;服务介绍&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;联系我们&lt;/a&gt;&lt;/li&gt; &lt;div class=&quot;slider&quot;&gt;&lt;/div&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/header&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135html,body &#123; margin: 0; font-family: &quot;PingFang SC&quot;, &quot;Microsoft Yahei&quot;, sans-serif;&#125;* &#123; box-sizing: border-box;&#125;ul,li &#123; margin: 0; padding: 0;&#125;body &#123; background-color: #1e272e;&#125;nav &#123; display: flex; justify-content: center; align-items: center; height: 100vh;&#125;ul &#123; position: relative; display: flex;&#125;ul li &#123; /* 如果设置为inline-block，会有空隙 */ /* https://stackoverflow.com/questions/19038799/why-is-there-an-unexplainable-gap-between-these-inline-block-div-elements */ list-style: none; width: 120px; line-height: 40px; text-align: center;&#125;ul li a &#123; color: white; text-decoration: none;&#125;.slider &#123; width: 100px; height: 40px; background-color: #5352ed; border-radius: 4px; position: absolute; left: 10px; bottom: 0; z-index: -1; transition: all ease 0.4s; animation: 2s ease-in-out waves infinite;&#125;li:nth-child(1):hover ~ .slider &#123; left: 10px;&#125;li:nth-child(2):hover ~ .slider &#123; left: 128px;&#125;li:nth-child(3):hover ~ .slider &#123; left: 248px;&#125;li:nth-child(4):hover ~ .slider &#123; left: 368px;&#125;li:nth-child(5):hover ~ .slider &#123; left: 488px;&#125;@keyframes waves &#123; from &#123; clip-path: polygon( 0% 17%, 9% 10%, 18% 4%, 30% 0%, 43% 1%, 49% 4%, 57% 7%, 66% 10%, 78% 11%, 89% 11%, 96% 9%, 100% 7%, 100% 100%, 0% 100% ); &#125; 50% &#123; clip-path: polygon( 0% 4%, 6% 9%, 13% 13%, 23% 15%, 31% 16%, 42% 15%, 49% 13%, 61% 10%, 71% 5%, 81% 3%, 90% 2%, 100% 5%, 100% 100%, 0% 100% ); &#125; to &#123; clip-path: polygon( 0% 17%, 9% 10%, 18% 4%, 30% 0%, 43% 1%, 49% 4%, 57% 7%, 66% 10%, 78% 11%, 89% 11%, 96% 9%, 100% 7%, 100% 100%, 0% 100% ); &#125;&#125; 二级菜单栏12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;二级导航菜单&lt;/title&gt; &lt;!-- ctrl+h即可调出查询与替换窗口 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot; /&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;navbar&quot;&gt; &lt;div class=&quot;nav&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt;一级菜单1&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt;一级菜单2&lt;/a&gt; &lt;ol&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;二级菜单1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;二级菜单2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;二级菜单3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;二级菜单4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;二级菜单5&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;二级菜单6&lt;/a&gt;&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt;一级菜单3&lt;/a&gt; &lt;ol&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;二级菜单1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;二级菜单2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;二级菜单3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;二级菜单4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;二级菜单5&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;二级菜单6&lt;/a&gt;&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt;一级菜单4&lt;/a&gt; &lt;ol&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;二级菜单1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;二级菜单2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;二级菜单3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;二级菜单4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;二级菜单5&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;二级菜单6&lt;/a&gt;&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt;一级菜单5&lt;/a&gt; &lt;/li&gt; &lt;!-- 这个元素来定义滑动的线条 --&gt; &lt;li class=&quot;underline&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132* &#123; /* 页面初始化 清除元素的内外边距 */ padding: 0; margin: 0;&#125;body &#123; /* 宽度占浏览器可视区域的高度 */ width: 100vm; background-color: #f2f2f2;&#125;li &#123; /* 清除li元素前面的项目符号 */ list-style: none;&#125;a &#123; /* 清除a元素的下划线 */ text-decoration: none; color: #000;&#125;.navbar &#123; width: 100%; height: 70px; background-color: #fff; /* 盒子阴影 */ box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);&#125;.navbar .nav &#123; width: 1200px; height: 100%; /* 让元素自动水平居中 */ margin: 0 auto;&#125;.navbar .nav ul &#123; /* 相对定位 */ position: relative; /* 弹性布局 */ display: flex; /* 让子元素平均分配宽度 */ justify-content: space-around; width: 100%; height: 100%;&#125;.navbar .nav ul &gt; li &#123; width: 100%; height: 100%;&#125;.navbar .nav ul &gt; li &gt; a &#123; /* 因为a元素是行内元素 必须将其转为行内块或者块级才能设置宽度和高度 */ display: block; width: 100%; height: 100%; line-height: 70px; text-align: center;&#125;.navbar .nav ul &gt; li ol &#123; width: 100%; background-color: #fff; box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.2); /* 让盒子先沿着y轴缩放到0 也就是隐藏了 */ transform: scaleY(0); /* 我们需要将盒子从上面滑动下来 设置一下缩放的中心点即可 设置到最上面的中间位置 */ transform-origin: 50% 0; /* 设置过渡 */ transition: all 0.6s;&#125;.navbar .nav ul &gt; li ol li &#123; height: 70px; border-bottom: 1px solid rgb(245, 245, 245);&#125;.navbar .nav ul &gt; li ol li a &#123; display: block; width: 100%; height: 100%; line-height: 70px; text-align: center;&#125;.navbar .nav ul &gt; li ol li:hover &#123; background-color: rgba(0, 0, 0, 0.03);&#125;.navbar .nav ul &gt; li:hover ol &#123; transform: scaleY(1);&#125;/* 现在可以设置线条了 */.navbar .nav ul .underline &#123; /* 绝对定位 */ position: absolute; bottom: 0; left: 0; width: 240px; height: 6px; /* 设置一下盒子的左上角和右上角的圆角 */ border-top-left-radius: 6px; border-top-right-radius: 6px; background-color: #cc3333; /* 加过渡 */ transition: all 0.5s; /* 现在有个小问题 我们一起看看 ne /* 就是这个问题 这个线条有点影响鼠标移入li这个效果 */ /* 这个属性就可以解决这个问题 就貌似这个元素你能看见 但是鼠标是点击不到了 现在鼠标放到线条也没事了 */ pointer-events: none;&#125;.navbar .nav ul .underline::before &#123; content: &quot;&quot;; /* 利用::before伪元素设置三角 */ position: absolute; top: -10px; /* calc方法自动计算数值 让盒子居中 */ left: calc(50% - 9px); width: 18px; height: 10px; /* inherit可以继承父元素的属性值 */ background-color: inherit; /* 各位小伙伴可能对着属性比较陌生 我简单说一下这句话如何生成了三角形 这个属性可以绘制图案 polygon这个属性只需要提供最少三个点 就可以将三个点连接到一起 然后绘制一个图案 两个点的坐标位置(x,y) 0 100% 这个点就是说在x轴上为0px 在y轴是100% 就是盒子的高度 x轴的方向是向右 y轴的方向是向下 那么我们设置了三个点 然后将三个点连起来刚好绘制出一个三角形 不明白的小伙伴可以在纸上画一下 画出来就理解了 */ clip-path: polygon(0 100%, 50% 0, 100% 100%);&#125;.navbar .nav ul &gt; li:nth-child(2):hover ~ .underline &#123; left: 240px; background-color: #ff9933;&#125;/* 重复以上操作 */.navbar .nav ul &gt; li:nth-child(3):hover ~ .underline &#123; left: 480px; background-color: #339933;&#125;.navbar .nav ul &gt; li:nth-child(4):hover ~ .underline &#123; left: 720px; background-color: #0099cc;&#125;.navbar .nav ul &gt; li:nth-child(5):hover ~ .underline &#123; left: 960px; background-color: #9966cc;&#125; 响应式导航栏123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; /&gt; &lt;title&gt;响应式导航菜单&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;nav&gt; &lt;div class=&quot;logo&quot;&gt;小李博客&lt;/div&gt; &lt;ul class=&quot;nav-menu&quot;&gt; &lt;li&gt;首页&lt;/li&gt; &lt;li&gt;关于我&lt;/li&gt; &lt;li&gt;我的作品&lt;/li&gt; &lt;li&gt;我的简历&lt;/li&gt; &lt;li&gt;我的博客&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;burger&quot;&gt; &lt;div class=&quot;top-line&quot;&gt;&lt;/div&gt; &lt;div class=&quot;middle-line&quot;&gt;&lt;/div&gt; &lt;div class=&quot;bottom-line&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/nav&gt; &lt;header&gt;&lt;/header&gt; &lt;script src=&quot;./index.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526// 获取汉堡按钮const burger = document.querySelector(&quot;.burger&quot;);// 获取导航菜单const navMenu = document.querySelector(&quot;.nav-menu&quot;);//获取菜单项const navMenuItems = document.querySelectorAll(&quot;.nav-menu li&quot;);//注册监听burger.addEventListener(&quot;click&quot;, () =&gt; &#123; // 汉堡按钮 burger.classList.toggle(&quot;active&quot;); // 导航菜单开关 navMenu.classList.toggle(&quot;open&quot;); // 菜单项动画 navMenuItems.forEach((item, index) =&gt; &#123; // 如果已添加animation,先取消 if (item.style.animation) &#123; item.style.animation = &quot;&quot;; &#125; else &#123; item.style.animation = `0.3s ease-in slideIn forwards $&#123;index * 0.1 + 0.3&#125;s`; &#125; &#125;);&#125;); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136* &#123; margin: 0; padding: 0; box-sizing: border-box; font-family: &quot;PingFang SC&quot;, &quot;Microsoft Yahei&quot;, sans-serif;&#125;header &#123; width: 100vw; height: 100vh; background-image: url(./background.jpg); background-size: cover;&#125;nav &#123; position: absolute; top: 0; left: 0; right: 0; display: flex; align-items: center; justify-content: space-between; /* 左右padding */ padding: 0 5vw; height: 80px; background-color: rgba(65, 81, 101, 0.9);&#125;.logo &#123; font-size: 24px; font-weight: 600; color: #dadbdd; /* 占一半宽度 */ flex: 1;&#125;.nav-menu &#123; /* 占令一半宽度 */ flex: 1; display: flex; justify-content: space-between; /* 最宽550px */ max-width: 550px;&#125;.nav-menu li &#123; list-style: none; color: #dadbdd; font-weight: 600;&#125;.burger div &#123; /* 设置汉堡按钮三层条 */ width: 25px; height: 3px; background-color: #dadbdd; margin: 4px;&#125;.burger &#123; display: none;&#125;/* 屏幕适配 */@media screen and (max-width: 768px) &#123; .burger &#123; display: block; &#125; /* 小屏幕菜单显示位置为右侧抽屉形式 */ .nav-menu &#123; position: absolute; top: 80px; right: 0; bottom: 0; width: 50vw; height: calc(100vh - 80px); background-color: rgb(65, 81, 101, 0.9); flex-direction: column; justify-content: flex-start; align-items: center; /* 动画 */ transform: translateX(100%); &#125; /* 菜单打开时，滑到初始位置 */ .nav-menu.open &#123; transform: translateX(0); transition: 0.4s ease-in-out; &#125; /* 每个菜单项默认看不到，向右移动20象素 */ .nav-menu li &#123; /* 上下间距 */ margin: 3vh; transform: translateX(20px); opacity: 0; &#125; /* 汉堡按钮被点开时，设置按钮过渡 */ .burger.active div &#123; transition: 0.3s ease-in-out 0.3s; &#125; /* 第一条线旋转45度 */ .burger.active .top-line &#123; transform: rotate(45deg) translate(4px, 6px); &#125; /* 第三条线旋转-45度 */ .burger.active .bottom-line &#123; transform: rotate(-45deg) translate(4px, -6px); &#125; /* 中间线向右移动并变为透明 */ .burger.active .middle-line &#123; opacity: 0; transform: translateX(10px); transition: 0.3s ease-in-out; &#125; /* 菜单项滑入动画 */ @keyframes slideIn &#123; from &#123; transform: translateX(20px); opacity: 0; &#125; to &#123; transform: translateX(0); opacity: 1; &#125; &#125;&#125; 隐藏侧边栏123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;侧边展开导航栏(全隐藏)&lt;/title&gt; &lt;!-- 事先引入的字体图标库 观看此视频之前可以看一下上个视频简介 接上个视频发的哈 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/font-awesome.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;navbar&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; /&gt; &lt;label for=&quot;checkbox&quot;&gt; &lt;i class=&quot;fa fa-outdent&quot;&gt;&lt;/i&gt; &lt;/label&gt; &lt;ul&gt; &lt;li&gt; &lt;img src=&quot;images/bilibili.png&quot; alt=&quot;&quot; /&gt; &lt;span&gt;哔哩哔哩 (゜-゜)つロ 干杯~-&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt; &lt;i class=&quot;fa fa-home&quot;&gt;&lt;/i&gt; &lt;span&gt;后台首页&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt; &lt;i class=&quot;fa fa-sitemap&quot;&gt;&lt;/i&gt; &lt;span&gt;商品列表&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt; &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; &lt;span&gt;用户列表&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt; &lt;i class=&quot;fa fa-shopping-cart&quot;&gt;&lt;/i&gt; &lt;span&gt;订单列表&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot;&gt; &lt;i class=&quot;fa fa-windows&quot;&gt;&lt;/i&gt; &lt;span&gt;功能列表&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/* 观看此视频之前可以看一下上个视频简介 接上个视频发的哈 */* &#123; /* 初始化 清除元素的内外边距 */ padding: 0; margin: 0; /* 盒子模型 */ box-sizing: border-box;&#125;body &#123; /* 宽度占浏览器可视区域的宽度 */ width: 100vm; background-color: #f2f2f2;&#125;.navbar &#123; /* 相对定位 */ position: relative; width: 100%; height: 50px; line-height: 50px; background-color: #fff; /* 盒子阴影 */ box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.1);&#125;.navbar input &#123; /* 隐藏元素 */ display: none;&#125;.navbar label &#123; /* 绝对定位 */ position: absolute; top: 0; left: 200px; font-size: 20px; color: #666; padding-left: 20px; cursor: pointer; /* 加过渡 */ transition: all 0.5s;&#125;.navbar ul &#123; position: absolute; top: 0; left: 0; width: 200px; /* 高度占浏览器可视区域的高度 */ height: 100vh; background-color: #20222a; transition: all 0.5s;&#125;.navbar ul li &#123; width: 100%; height: 70px; margin-bottom: 10px;&#125;.navbar ul li:first-child &#123; /* 弹性布局 让图片和文字垂直+水平居中于盒子内 */ display: flex; justify-content: center; align-items: center; /* 改变了盒子的主轴方向 让两个元素垂直排列 */ flex-direction: column; width: 100%; height: 150px; padding: 10px;&#125;.navbar ul li:first-child img &#123; width: 80px; border-radius: 50%;&#125;.navbar ul li:first-child span &#123; color: #fff; font-size: 14px; /* 禁止文字换行 */ white-space: nowrap;&#125;.navbar ul li a &#123; display: flex; align-items: center; width: 100%; height: 100%; color: #d2d2d2; /* 取消a标签的下划线 */ text-decoration: none; /* 现在盒子内直接定义好左边框 不过颜色为透明色也就看不见 */ border-left: 6px solid transparent;&#125;.navbar ul li a i &#123; font-size: 18px; margin: 0 15px;&#125;.navbar ul li a span &#123; font-size: 14px;&#125;.navbar ul li a:hover &#123; color: #fff; /* 这样文字和图标会被带跑不太好看 解决办法很简单 */ /* 然后鼠标放上去变颜色就可以了 */ border-left-color: #fb7299;&#125;.navbar input:checked + label &#123; left: 0;&#125;.navbar input:checked + label i &#123; /* 沿着y轴旋转180度 */ transform: rotateY(180deg);&#125;.navbar input:checked ~ ul &#123; left: -200px;&#125; 折叠菜单栏1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;CSS导航栏&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;nav&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;div class=&quot;menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;about&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;cursos&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;blog&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;contactos&lt;/a&gt;&lt;/li&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879body &#123; margin: 0; padding: 0; min-height: 100vh; background-image: linear-gradient(to top, #a18cd1 0%, #fbc2eb 100%); font-family: &#x27;Open Sans&#x27;, Verdana, Geneva, Tahoma, sans-serif;&#125; body , .nav , .menu &#123; display: flex; justify-content: center; align-items: center; &#125; .nav &#123; position: relative; background-color: #fff; padding: 20px ; transform: 0.5s; border-radius: 50px; overflow: hidden; box-shadow: 0 8px 15px rgba(0,0,0,.2); &#125; .menu &#123; margin: 0; padding: 0; width: 0; overflow: hidden; transition: 0.5s; &#125; .nav input:checked ~ .menu &#123; width: 480px; &#125; .menu li &#123; list-style: none; margin: 0 10px; &#125; .menu li a&#123; text-decoration: none; color: #666; text-transform: uppercase; font-weight: 600; transition: 0.5s; &#125; .menu li a:hover &#123; color: #161919; &#125; .nav input &#123; width: 50px; height: 50px; cursor: pointer; opacity: 0; &#125; .nav span &#123; position: absolute; left: 30px; width: 30px; height: 4px; border-radius: 50px; background-color: #666; pointer-events: none; transition: 0.5s; &#125; .nav input:checked ~span &#123; background-color: #f974a1; &#125; .nav span:nth-child(2) &#123; transform: translateY(-8px); &#125; .nav input:checked ~ span:nth-child(2) &#123; transform: translateY(0) rotate(-45deg); &#125; .nav span:nth-child(3) &#123; transform: translateY(8px); &#125; .nav input:checked ~ span:nth-child(3) &#123; transform: translateY(0) rotate(45deg); &#125; 玻璃划过卡片样式1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;HTML+CSS 玻璃划过&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;h1&gt;bilibili&lt;/h1&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758* &#123; /* 初始化 取消页面元素的内外边距 */ padding: 0; margin: 0;&#125;body &#123; /* 弹性布局 让页面元素垂直+水平居中 */ display: flex; justify-content: center; align-items: center; /* 让页面始终占浏览器总高 */ height: 100vh; /* 溢出隐藏 */ overflow: hidden;&#125;.box &#123; /* 相对定位 */ position: relative; width: 300px; height: 200px; line-height: 200px; text-align: center; color: #fff; border-radius: 5px; /*鼠标指针变成手*/ cursor: pointer; /* 背景渐变色 */ background-image: linear-gradient(to right, #fb7299, #ff5c7c); transition: .5s;&#125;.box::after &#123; content: &#x27;&#x27;; /* 绝对定位 */ position: absolute; top: 100px; left: 0; width: 600px; height: 70px; /* 背景渐变色 */ background-image: linear-gradient(rgba(0, 0, 0, 0), rgba(255, 255, 255, .3), rgba(0, 0, 0, 0)); /* 让元素旋转-45度 位置距离距离左边不变化，距离下面走360像素的距离 */ transform: rotate(-45deg) translate(0, -360px);&#125;.box:hover::after &#123; /* 过渡时长 */ transition: 1s; transform: rotate(-45deg) translate(0, 100px);&#125;.box:hover &#123; margin-top: -20px; /* 盒子阴影 */ box-shadow: 3px 3px 3px rgba(0, 0, 0, .2);&#125; 团队介绍卡片1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-cn&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt; &lt;div class=&quot;tx&quot;&gt; &lt;img src=&quot;./images/tx.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;h3&gt;Morgan Sweeney&lt;/h3&gt; &lt;span&gt;Ant Collector&lt;/span&gt; &lt;div class=&quot;hr&quot;&gt;&lt;/div&gt; &lt;p&gt;Morgan has collected ants since they were six years old and now has many dozen ants but none in their pants.&lt;/p&gt; &lt;div class=&quot;hr_2&quot;&gt;&lt;/div&gt; &lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;Trade&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;div class=&quot;tx&quot;&gt; &lt;img src=&quot;./images/tx.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;h3&gt;Morgan Sweeney&lt;/h3&gt; &lt;span&gt;Ant Collector&lt;/span&gt; &lt;div class=&quot;hr&quot;&gt;&lt;/div&gt; &lt;p&gt;Morgan has collected ants since they were six years old and now has many dozen ants but none in their pants.&lt;/p&gt; &lt;div class=&quot;hr_2&quot;&gt;&lt;/div&gt; &lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;Trade&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;div class=&quot;tx&quot;&gt; &lt;img src=&quot;./images/tx.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;h3&gt;Morgan Sweeney&lt;/h3&gt; &lt;span&gt;Ant Collector&lt;/span&gt; &lt;div class=&quot;hr&quot;&gt;&lt;/div&gt; &lt;p&gt;Morgan has collected ants since they were six years old and now has many dozen ants but none in their pants.&lt;/p&gt; &lt;div class=&quot;hr_2&quot;&gt;&lt;/div&gt; &lt;a href=&quot;#&quot;&gt;Link&lt;/a&gt; &lt;a href=&quot;#&quot; &gt;Trade&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106* &#123; margin: 0; padding: 0; box-sizing: border-box;&#125;body &#123; height: 100vh; background-image: linear-gradient(120deg, #a1c4fd 0%, #c2e9fb 100%); &#125;li &#123; list-style: none;&#125;a &#123; text-decoration: none;&#125;ul &#123; width: 1040px; height: 500px; margin: 100px auto;&#125;ul li &#123; margin-top: 150px; position: relative; float: left; margin-left: 50px; width: 280px; height: 400px; background-color: #fff; border-radius: 15px; box-shadow: 4px 2px 3px 1px rgba(0,0,0,.1); transition: all .5s;&#125;ul li h3 &#123; margin-top: 100px; text-align: center;&#125;ul li span &#123; margin-top: 10px; display: block; text-align: center; font-size: 12px;&#125;ul li .hr &#123; margin-top: 25px; width: 100%; height: 2px; background-image: linear-gradient(120deg, #fccb90 0%, #d57eeb 100%);&#125;ul li p &#123; margin-top: 45px; margin-left: 15px; font-size: 14px;&#125;ul li .hr_2 &#123; margin-top: 65px; width: 100%; height: 2px; background: rgba(0,0,0,.1);&#125;ul li a&#123; margin: 0; padding: 0; text-align: center; line-height: 50px; display: inline-block; color: #000; font-size: 14px; width: 137px; height: 50px; transition: all .3s; border-radius: 20px; &#125;ul li a:hover&#123; background-image: linear-gradient(135deg, #667eea 0%, #764ba2 100%); transform: scale(1.2);&#125; ul li:hover &#123; transform: scale(1.1);&#125;ul li .tx&#123; box-shadow: 1px 1px 5px 1px rgba(0,0,0,.1); position: absolute; top: -80px; left: 65px; width: 150px; height: 150px; border-radius: 50%; background-color: #fff; transition: all .3s;&#125;ul li .tx img&#123; width: 90%; height: 90%; border-radius: 50%; display: block; margin-left: 8px; margin-top: 7px;&#125;ul li .tx:hover &#123; transform: scale(1.1) rotateZ(360deg);&#125;","path":"page/project04.html","date":"01-28","excerpt":"","tags":[{"name":"项目案例","slug":"项目案例","permalink":"http://xiaoliblog.cn/tags/%E9%A1%B9%E7%9B%AE%E6%A1%88%E4%BE%8B/"}]},{"title":"前端实例🥳按钮及鼠标悬浮特效","text":"素材及样式参考地址：https://www.jq22.com/daima 超链接样式 默认样式 1&lt;label&gt;默认超级链接：&lt;/label&gt;&lt;a href=&quot;#&quot;&gt;链接效果测试&lt;/a&gt; 普通下划线 1&lt;label&gt;普通下划线：&lt;/label&gt;&lt;a href=&quot;#&quot; class=&quot;noline underline&quot;&gt;链接效果测试&lt;/a&gt; 123456a.underline:hover&#123; text-decoration: underline;&#125;.noline &#123; text-decoration: none;&#125; 动态下划线 1&lt;label&gt;动态下划线：&lt;/label&gt;&lt;a href=&quot;#&quot; class=&quot;noline aniline&quot;&gt;链接效果测试&lt;/a&gt; 123456789101112131415161718192021222324252627282930a &#123; position: relative;&#125;/*去掉下划线*/.noline &#123; text-decoration: none;&#125;/* 动态下划线 */a.aniline::after &#123; content: &quot;&quot;; position: absolute; /*绝对地位控制位置中父盒子中间位置*/ left: 50%; top: 50%; /*translate百分比是相对与自身的百分比*/ transform: translate(-50%, -50%); /*初始宽度为0*/ width: 0; height: 100%; border-bottom: 2px solid #2980b9; /*加过渡效果*/ transition: 0.4s linear;&#125;/*鼠标经过宽度变为父盒子宽度*/a.aniline:hover::after &#123; width: 100%;&#125; 阴影及变色 1&lt;label&gt;阴影及变色：&lt;/label&gt;&lt;a href=&quot;#&quot; class=&quot;noline color&quot;&gt;链接效果测试&lt;/a&gt; 1234567891011121314/*去掉下划线*/.noline &#123; text-decoration: none;&#125;/* 阴影及变色 */a.color &#123; transition: 0.4s linear;&#125;a.color:hover &#123; font-weight: bold; text-shadow: 2px 2px 5px gray; color: #3498db;&#125; 带上小尾巴 1&lt;label&gt;带上小尾巴：&lt;/label&gt;&lt;a href=&quot;#&quot; class=&quot;noline tail&quot;&gt;链接效果测试&lt;/a&gt; 123456789101112131415 /*去掉下划线*/.noline &#123; text-decoration: none;&#125;/* 带上小尾巴 */a.tail::after &#123; position: absolute; margin-left: 10px; content: &quot;&quot;; color: #c0392b;&#125;a.tail:hover::after &#123; content: &quot;new!&quot;;&#125; 晃动效果 1&lt;label&gt;晃动效果：&lt;/label&gt;&lt;a href=&quot;#&quot; class=&quot;noline shake&quot;&gt;链接效果测试&lt;/a&gt; 1234567891011121314151617181920/*去掉下划线*/.noline &#123; text-decoration: none;&#125;a&#123; display: inline-block;&#125;/* 晃动效果 */a.shake:hover &#123; animation: shake 0.4s linear infinite;&#125;@keyframes shake &#123; 33% &#123; transform: rotateZ(-10deg); &#125; 66% &#123; transform: rotateZ(10deg); &#125;&#125; 跳跃效果 1&lt;label&gt;跳跃效果：&lt;/label&gt;&lt;a href=&quot;#&quot; class=&quot;noline jump&quot;&gt;链接效果测试&lt;/a&gt; 1234567891011121314151617181920212223 /*去掉下划线*/.noline &#123; text-decoration: none;&#125;a &#123; display: inline-block;&#125;/* 跳跃效果 */a.jump:hover &#123; animation: jump 0.4s linear infinite;&#125;@keyframes jump &#123; 33% &#123; transform: translateY(-5px); &#125; 66% &#123; transform: translateY(5px); &#125;&#125; 翻转效果 1&lt;label&gt;翻转效果：&lt;/label&gt;&lt;a href=&quot;#&quot; class=&quot;noline flip&quot;&gt;链接效果测试&lt;/a&gt; 12345678910111213141516/*去掉下划线*/.noline &#123; text-decoration: none;&#125;a &#123; display: inline-block;&#125;/* 翻转效果 */a.flip &#123; transition: 0.8s linear;&#125;a.flip:hover &#123; transform: rotateY(360deg);&#125; 缩放效果 12345678910111213141516171819202122/*去掉下划线*/.noline &#123; text-decoration: none;&#125;a &#123; display: inline-block;&#125;/* 缩放效果 */a.zoom:hover &#123; animation: zoom 0.8s linear infinite;&#125;@keyframes zoom &#123; 0%, 100% &#123; transform: scale(0.8); &#125; 50% &#123; transform: scale(1.2); &#125;&#125; B站弹幕按钮1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;b站弹幕按钮&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;checkbox&quot;&gt; &lt;p&gt;开启弹幕&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 获取元素 var checkbox = document.querySelector(&quot;#checkbox&quot;); // 定义初始值 var flag = 0; // 获取文本 var text = document.querySelector(&#x27;.wrap&#x27;).querySelector(&#x27;p&#x27;); // 添加点击事件 checkbox.onclick = function () &#123; if (flag == 0) &#123; // 改变文本的值 text.innerHTML = &#x27;关闭弹幕&#x27;; // 重新赋值 flag = 1; &#125; else &#123; text.innerHTML = &#x27;开启弹幕&#x27;; flag = 0; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465* &#123; margin: 0; padding: 0; box-sizing: border-box;&#125;body &#123; background: #ccc;&#125;.wrap &#123; position: absolute; /* 垂直居中 */ left: 50%; top: 50%; transform: translate(-50%, -50%);&#125;.wrap p &#123; position: absolute; top: -30px; width: 70px; height: 30px; text-align: center; line-height: 30px; color: #fff; background: #000; font-size: 14px; opacity: 0; transition: top 0.2s, opacity 0.2s;&#125;#checkbox &#123; appearance: none;&#125;#checkbox:hover ~ p &#123; top: -40px; opacity: 1;&#125;#checkbox::before &#123; position: absolute; content: &quot;&quot;; left: 0; top: 0; width: 60px; height: 30px; border-radius: 20px; background: #757575;&#125;#checkbox::after &#123; position: absolute; content: &quot;弹&quot;; left: 2px; top: 2px; text-align: center; line-height: 26px; width: 26px; height: 26px; background: #fff; border-radius: 50%; transition: all cubic-bezier(0.23, 1, 0.32, 1) 0.3s;&#125;#checkbox:checked::before &#123; background: #00a1d6;&#125;#checkbox:checked::after &#123; left: 32px; color: #00a1d6;&#125; 分享按钮123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; dir=&quot;ltr&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;share-button&quot;&gt; &lt;span&gt;&lt;i class=&quot;fas fa-share-alt&quot;&gt;&lt;/i&gt; Share!&lt;/span&gt; &lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;fab fa-facebook-f&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;fab fa-twitter&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;fab fa-instagram&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;fab fa-linkedin-in&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677body&#123; margin: 0; padding: 0; font-family: &quot;montserrat&quot;,sans-serif; background: #f1f1f1; display: flex; height: 100vh; align-items: center; justify-content: center;&#125;.share-button&#123; width: 280px; height: 80px; background: #dfe6e9; border-radius: 40px; display: flex; align-items: center; justify-content: center; overflow: hidden; position: relative; cursor: pointer; transition: .3s linear;&#125;.share-button:hover&#123; transform: scale(1.1);&#125;.share-button span&#123; position: absolute; width: 100%; height: 100%; background: #2d3436; color: #f1f1f1; text-align: center; line-height: 80px; z-index: 999; transition: .6s linear; border-radius: 40px;&#125;.share-button:hover span&#123; transform: translateX(-100%); transition-delay: .3s;&#125;.share-button a&#123; flex: 1; font-size: 26px; color: #2d3436; text-align: center; transform: translateX(-100%); opacity: 0; transition: 0.3s linear;&#125;.share-button:hover a&#123; opacity: 1; transform: translateX(0);&#125;.share-button a:nth-of-type(1)&#123; transition-delay: 1s;&#125;.share-button a:nth-of-type(2)&#123; transition-delay: 0.8s;&#125;.share-button a:nth-of-type(3)&#123; transition-delay: 0.6s;&#125;.share-button a:nth-of-type(4)&#123; transition-delay: 0.4s;&#125; 抠图风格社交按钮1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; dir=&quot;ltr&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.css&quot;&gt; &lt;body&gt; &lt;div class=&quot;social-buttons&quot;&gt; &lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;fab fa-facebook-f&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;fab fa-twitter&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;fab fa-instagram&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;fab fa-youtube&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;fab fa-linkedin-in&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748body&#123; margin: 0; padding: 0; height: 100vh; display: flex; justify-content: center; align-items: center; background: #f1f1f1;&#125;.social-buttons a&#123; display: inline-flex; text-decoration: none; font-size: 18px; width: 60px; height: 60px; color: #fff; justify-content: center; align-items: center; position: relative; margin: 0 8px;&#125;.social-buttons a::before&#123; content: &quot;&quot;; position: absolute; width: 60px; height: 60px; background: linear-gradient(45deg,#22a6b3,#30336b); border-radius: 50%; z-index: -1; transition: 0.3s ease-in;&#125;.social-buttons a:hover::before&#123; transform: scale(0);&#125;.social-buttons a i&#123; transition: 0.3s ease-in;&#125;.social-buttons a:hover i&#123; background: linear-gradient(45deg,#22a6b3,#30336b); -webkit-background-clip: text; -webkit-text-fill-color: transparent; transform: scale(2.2);&#125; 按钮动态边框特效1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; /&gt; &lt;title&gt;Static Template&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;button-wrapper&quot;&gt; &lt;svg width=&quot;240&quot; height=&quot;60&quot;&gt; &lt;rect class=&quot;rectangle&quot; width=&quot;240&quot; height=&quot;60&quot; /&gt; &lt;/svg&gt; &lt;div class=&quot;btn&quot;&gt; 按钮 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051html,body &#123; padding: 0; margin: 0; font-family: &quot;PingFang SC&quot;;&#125;.container &#123; display: flex; align-items: center; justify-content: center; width: 100vw; height: 100vh; background: #2f3542;&#125;.button-wrapper &#123; position: relative; width: 240px; height: 60px; text-align: center;&#125;.rectangle &#123; stroke-width: 8px; stroke: #ff6348; fill: transparent; /* 动画核心部分 */ stroke-dasharray: 100 500; stroke-dashoffset: -372;&#125;.btn &#123; color: white; font-size: 18px; letter-spacing: 6px; position: relative; top: -48px;&#125;@keyframes extend &#123; to &#123; stroke-dasharray: 600; stroke-dashoffset: 0; stroke-width: 2; &#125;&#125;.button-wrapper:hover .rectangle &#123; animation: 0.5s extend linear forwards;&#125; 单选框样式12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;HTML+CSS 单选按钮&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot; /&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;!-- 默认第一个单选按钮选中 --&gt; &lt;label for=&quot;html&quot;&gt;&lt;input type=&quot;radio&quot; name=&quot;radio&quot; id=&quot;html&quot; checked /&gt;&lt;span&gt;HTML&lt;/span&gt;&lt;/label&gt; &lt;label for=&quot;css&quot;&gt;&lt;input type=&quot;radio&quot; name=&quot;radio&quot; id=&quot;css&quot; /&gt;&lt;span&gt;CSS&lt;/span&gt;&lt;/label&gt; &lt;label for=&quot;js&quot;&gt;&lt;input type=&quot;radio&quot; name=&quot;radio&quot; id=&quot;js&quot; /&gt;&lt;span&gt;JavaScript&lt;/span&gt;&lt;/label&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566* &#123; /* 初始化 清除元素的内外边距 */ padding: 0; margin: 0;&#125;body &#123; /* 弹性布局 让元素在页面中垂直+水平居中 */ display: flex; justify-content: center; align-items: center; /* 让页面占浏览器可视区域的高度 */ height: 100vh; background-color: #f4e7ec;&#125;.container &#123; display: flex; /* 让子元素垂直排列 */ flex-direction: column;&#125;.container label &#123; display: flex; /* 鼠标移入变小手 */ cursor: pointer;&#125;.container label input &#123; /* 隐藏元素 先显示出来 */ display: none;&#125;/* + 是相邻兄弟选择器 */.container label input + span &#123; display: flex; /* 让伪元素和文字水平排列 */ align-items: center; padding: 15px 30px; margin-bottom: 10px; font-size: 40px; border-radius: 90px; transition: all 0.3s;&#125;/* 鼠标移入变背景颜色 */.container label input + span:hover &#123; background-color: #edd8e0;&#125;/* 选中单选按钮对应的span元素背景颜色改变 */.container label input:checked + span &#123; background-color: #edd8e0;&#125;.container label input + span::before &#123; content: &quot;&quot;; /* 伪元素是行内元素 需要转为块级元素才能设置宽高 */ display: block; width: 60px; height: 60px; /* 圆角属性 */ border-radius: 50%; margin-right: 15px; background-color: #fff; /* 盒子阴影 inset是内部阴影 */ box-shadow: 0 0 0 5px #900c3f inset; /* 加个过渡时间 */ transition: all 0.3s;&#125;.container label input:checked + span::before &#123; /* 选中的元素内部的阴影加深 */ box-shadow: 0 0 0 15px #900c3f inset;&#125; 动态渐变色按钮12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; dir=&quot;ltr&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;button class=&quot;btn btn1&quot;&gt;Hover me&lt;/button&gt; &lt;button class=&quot;btn btn2&quot;&gt;Hover me&lt;/button&gt; &lt;button class=&quot;btn btn3&quot;&gt;Hover me&lt;/button&gt; &lt;button class=&quot;btn btn4&quot;&gt;Hover me&lt;/button&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940body&#123; margin: 0; padding: 0; background: #f1f1f1;&#125;.container&#123; position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%); text-align: center;&#125;.btn&#123; border: none; margin: 20px; padding: 24px; width: 220px; font-family: &quot;montserrat&quot;,sans-serif; text-transform: uppercase; border-radius: 6px; cursor: pointer; color: #fff; background-size: 200%; transition: 0.6s;&#125;.btn1&#123; background-image: linear-gradient(to left,#FFC312,#EE5A24,#FFC312);&#125;.btn2&#123; background-image: linear-gradient(to left,#C4E538,#009432,#C4E538);&#125;.btn3&#123; background-image: linear-gradient(to left,#12CBC4,#0652DD,#12CBC4);&#125;.btn4&#123; background-image: linear-gradient(to left,#FDA7DF,#9980FA,#FDA7DF);&#125;.btn:hover&#123; background-position: right;&#125; 流光按钮12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;#&quot;&gt;sunbutton&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970* &#123; /* 初始化 取消页面的内外边距 */ padding: 0; margin: 0;&#125;body &#123; /* 弹性布局 让页面元素垂直+水平居中 */ display: flex; justify-content: center; align-items: center; /* 让页面占屏幕总高 */ height: 100vh; background-color: #000;&#125;a &#123; /* 相对定位 */ position: relative; width: 400px; height: 100px; line-height: 100px; text-align: center; text-decoration: none; text-transform: uppercase; font-size: 24px; color: #fff; /* 圆角属性 */ border-radius: 50px; /* 背景渐变色 */ background-image: linear-gradient(to right, #03a9f4, #f441a5, #ffeb3b, #09a8f4); /* 背景渐变色大小 */ background-size: 400%; z-index: 1;&#125;/* 下面设计 发光效果 */a::before &#123; content: &#x27;&#x27;; position: absolute; top: -5px; bottom: -5px; left: -5px; right: -5px; border-radius: 50px; /* 背景渐变色 */ background-image: linear-gradient(to right, #03a9f4, #f441a5, #ffeb3b, #09a8f4); /* 背景渐变色大小 */ background-size: 400%; /* 元素的位置 底层或者顶层 -值表示底层 + 值表示顶层 */ z-index: -1; /* 设置模糊度 显示发光效果 */ filter: blur(20px);&#125;a:hover &#123; /* 动画 名称 时间 infinite 是无限次播放 */ animation: sun 8s infinite;&#125;a:hover::before &#123; animation: sun 8s infinite;&#125;@keyframes sun &#123; 100% &#123; /* 背景位置 */ background-position: -400% 0; &#125;&#125; 动态社交按钮12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;HTML+CSS 社交按钮鼠标悬停效果&lt;/title&gt; &lt;!-- 提前引入的图标库 放在简介中 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css&quot; /&gt; &lt;!-- 核心样式 --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;a href=&quot;javascript:void(0)&quot; class=&quot;btn btn_facebook&quot; &gt;&lt;i class=&quot;fa fa-facebook&quot;&gt;&lt;/i &gt;&lt;/a&gt; &lt;a href=&quot;javascript:void(0)&quot; class=&quot;btn btn_twitter&quot; &gt;&lt;i class=&quot;fa fa-twitter&quot;&gt;&lt;/i &gt;&lt;/a&gt; &lt;a href=&quot;javascript:void(0)&quot; class=&quot;btn btn_google&quot; &gt;&lt;i class=&quot;fa fa-google&quot;&gt;&lt;/i &gt;&lt;/a&gt; &lt;a href=&quot;javascript:void(0)&quot; class=&quot;btn btn_instagram&quot; &gt;&lt;i class=&quot;fa fa-instagram&quot;&gt;&lt;/i &gt;&lt;/a&gt; &lt;a href=&quot;javascript:void(0)&quot; class=&quot;btn btn_pinterest&quot; &gt;&lt;i class=&quot;fa fa-pinterest&quot;&gt;&lt;/i &gt;&lt;/a&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596* &#123; /* 初始化 清除页面元素的内外边距 */ padding: 0; margin: 0;&#125;body &#123; /* 弹性布局 让页面元素垂直+水平居中 */ display: flex; justify-content: center; align-items: center; /* 让页面始终占浏览器可视区域高度总高 */ height: 100vh; background-color: #eee;&#125;/* 由于是引入的连接第三方字体图标库 网络延迟比较大 所以刷新的时候就迟迟不能出来 */.container &#123; /* 这里的弹性布局 让元素能够水平排列 并且能够让a这个行内元素设置宽度和高度 */ display: flex;&#125;.container .btn &#123; /* 溢出隐藏 */ overflow: hidden; /* 相对定位 */ position: relative; width: 90px; height: 90px; text-align: center; margin: 0 10px; border-radius: 25px; background-color: #fff; /* 盒子阴影 */ box-shadow: 0 5px 15px -5px rgba(0, 0, 0, 0.1);&#125;.container .fa &#123; /* 字体图标可以直接使用字体大小来设置大小 */ font-size: 38px; /* 缩放0.8倍 */ transform: scale(0.8); /* 行高 让这个字体图标垂直居中于盒子内 */ line-height: 90px; /* 设置一下过渡 */ /* 第三个值是贝塞尔曲线 让运动曲线有无限可能 可以到官网自行探索 https://cubic-bezier.com/ */ transition: all 0.4s cubic-bezier(0.31, -0.1, 0.43, 1.59);&#125;.container .btn::before &#123; content: &quot;&quot;; /* 绝对定位 */ position: absolute; top: 90%; left: -110%; width: 120%; height: 120%; /* 顺时针旋转45度 */ transform: rotate(45deg); transition: all 0.4s cubic-bezier(0.31, -0.1, 0.43, 1.59);&#125;.container .btn .fa-facebook &#123; color: #3b5988;&#125;.container .btn_facebook::before &#123; background-color: #3b5988;&#125;.container .btn .fa-twitter &#123; color: #00aff0;&#125;.container .btn_twitter::before &#123; background-color: #00aff0;&#125;.container .btn .fa-google &#123; color: #dc4a38;&#125;.container .btn_google::before &#123; background-color: #dc4a38;&#125;.container .btn .fa-instagram &#123; color: #bf00ff;&#125;.container .btn_instagram::before &#123; background-color: #bf00ff;&#125;.container .btn .fa-pinterest &#123; color: #c00;&#125;.container .btn_pinterest::before &#123; background-color: #c00;&#125;.container .btn:hover::before &#123; top: -10%; left: -10%;&#125;.container .btn:hover .fa &#123; color: #fff; /* 鼠标移入 恢复到原来的大小 */ transform: scale(1);&#125; 鼠标悬停发光12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;HTML+CSS 鼠标悬停发光&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;!-- javascript:void(0)是js的关键字,可以阻止连接跳转 --&gt; &lt;a href=&quot;javascript:void(0);&quot; style=&quot;--i: 1&quot;&gt;点赞&lt;/a&gt; &lt;a href=&quot;javascript:void(0);&quot; style=&quot;--i: 2&quot;&gt;投币&lt;/a&gt; &lt;a href=&quot;javascript:void(0);&quot; style=&quot;--i: 3&quot;&gt;收藏&lt;/a&gt; &lt;a href=&quot;javascript:void(0);&quot; style=&quot;--i: 4&quot;&gt;关注&lt;/a&gt; &lt;a href=&quot;javascript:void(0);&quot; style=&quot;--i: 5&quot;&gt;分享&lt;/a&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283* &#123; /* 初始化 清除页面元素的内外边距 */ padding: 0; margin: 0;&#125;.container &#123; /* 弹性布局 让页面元素垂直+水平居中 */ display: flex; justify-content: center; align-items: center; /* 让子元素水平排列 */ flex-direction: row; /* 宽度占浏览器可视窗口总宽度 高度占浏览器可视区域总高度 */ width: 100vm; height: 100vh; background-color: #000;&#125;.container a &#123; /* 相对定位 */ position: relative; /* 将a这个行内元素转为块级元素不然无法设置宽和高 */ display: block; width: 140px; height: 60px; /* 行高 */ line-height: 60px; text-align: center; margin: 40px; color: aqua; font-size: 20px; /* 取消下划线 */ text-decoration: none; /* 加一下一些过渡事件 */ transition: all 0.3s ease-in-out; /* 重头戏来了,改变各个元素的颜色,一句话就能搞定 */ /* hue-rotate是颜色滤镜 可以加不同的度数来改变颜色 这里我们用了calc自动计算的方法,还有var函数来调用我们给每一个a设置的不同的属性值1~5,然后分别乘以60度,就能够分别得到不同的度数 */ filter: hue-rotate(calc(var(--i) * 60deg));&#125;.container a::before,.container a::after &#123; /* 将两个伪元素的相同部分写在一起 */ content: &quot;&quot;; position: absolute; width: 20px; height: 20px; border: 2px solid aqua; /* 最后的.3s是延迟时间 */ transition: all 0.3s ease-in-out 0.3s;&#125;.container a::before &#123; top: 0; left: 0; /* 删除左边的伪元素的右和下边框 */ border-right: 0; border-bottom: 0;&#125;.container a::after &#123; right: 0; bottom: 0; /* 删除右边的伪元素的上边和左边的边框 */ border-top: 0; border-left: 0;&#125;.container a:hover &#123; background-color: aqua; color: #000; /* 加个发光效果和下面的倒影 */ /* 模糊度加到了50px */ box-shadow: 0 0 50px aqua; /* below 是下倒影 1px是倒影的元素相隔的距离 最后是个渐变的颜色 */ -webkit-box-reflect: below 1px linear-gradient(transparent, rgba(0, 0, 0, 0.3)); /* 设置一下以上属性的延迟时间 */ transition-delay: 0.4s;&#125;/* 在设置两条线的变化 总体来说四条各个方向的 只需要改变一下两个伪元素的宽度和高度 */.container a:hover::before,.container a:hover::after &#123; width: 138px; height: 58px; transition-delay: 0s;&#125; 缩放搜索栏123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;link href=&quot;https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.1/css/all.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt; &lt;title&gt;cool search bar&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;search&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;search-txt&quot; placeholder=&quot;searh...&quot;&gt; &lt;a class=&quot;search-btn&quot;&gt; &lt;i class=&quot;fas fa-search&quot;&gt;&lt;/i&gt; &lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849body&#123; margin:0; padding:0; background:#ffa502;&#125;.search&#123; position: absolute; top:50%; left:50%; transform:translate(-50%,-50%); background:#2f3542; height:40px; border-radius: 40px; padding:10px;&#125;.search-btn&#123; color:#ff4757; float:right; background:#2f3542; border-radius: 50%; width:40px; height:40px; display:flex; align-items:center; justify-content:center; transition:0.5s; cursor:pointer;&#125;.search-txt&#123; border:none; background:none; outline:none; float:left; padding:0; color:#dfe4ea; font-size:16px; transition:0.5s; line-height:40px; width:0px;&#125;.search:hover &gt; .search-btn&#123; background:#dfe4ea; color:#2f3542;&#125;.search:hover &gt; .search-txt&#123; width:240px; padding:0 6px;&#125; 新拟物风格12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;新拟态&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;img&quot;&gt;&lt;img src=&quot;images/1.png&quot; alt=&quot;&quot; /&gt;&lt;/div&gt; &lt;p&gt;录音机&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;img&quot;&gt;&lt;img src=&quot;images/2.png&quot; alt=&quot;&quot; /&gt;&lt;/div&gt; &lt;p&gt;通讯录&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;img&quot;&gt;&lt;img src=&quot;images/3.png&quot; alt=&quot;&quot; /&gt;&lt;/div&gt; &lt;p&gt;电话&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;img&quot;&gt;&lt;img src=&quot;images/4.png&quot; alt=&quot;&quot; /&gt;&lt;/div&gt; &lt;p&gt;短信&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;img&quot;&gt;&lt;img src=&quot;images/5.png&quot; alt=&quot;&quot; /&gt;&lt;/div&gt; &lt;p&gt;浏览器&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;img&quot;&gt;&lt;img src=&quot;images/6.png&quot; alt=&quot;&quot; /&gt;&lt;/div&gt; &lt;p&gt;相机&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;img&quot;&gt;&lt;img src=&quot;images/7.png&quot; alt=&quot;&quot; /&gt;&lt;/div&gt; &lt;p&gt;相册&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;img&quot;&gt;&lt;img src=&quot;images/8.png&quot; alt=&quot;&quot; /&gt;&lt;/div&gt; &lt;p&gt;哔哩哔哩&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;img&quot;&gt;&lt;img src=&quot;images/9.png&quot; alt=&quot;&quot; /&gt;&lt;/div&gt; &lt;p&gt;日历&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;img&quot;&gt;&lt;img src=&quot;images/10.png&quot; alt=&quot;&quot; /&gt;&lt;/div&gt; &lt;p&gt;时钟&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;img&quot;&gt;&lt;img src=&quot;images/11.png&quot; alt=&quot;&quot; /&gt;&lt;/div&gt; &lt;p&gt;Youtube&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;img&quot;&gt;&lt;img src=&quot;images/12.png&quot; alt=&quot;&quot; /&gt;&lt;/div&gt; &lt;p&gt;Facebook&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;img&quot;&gt;&lt;img src=&quot;images/13.png&quot; alt=&quot;&quot; /&gt;&lt;/div&gt; &lt;p&gt;微信&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;img&quot;&gt;&lt;img src=&quot;images/14.png&quot; alt=&quot;&quot; /&gt;&lt;/div&gt; &lt;p&gt;QQ&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;img&quot;&gt;&lt;img src=&quot;images/15.png&quot; alt=&quot;&quot; /&gt;&lt;/div&gt; &lt;p&gt;微博&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566* &#123; /* 初始化 取消页面的内外边距 */ padding: 0; margin: 0;&#125;body &#123; /* 弹性布局 让页面元素垂直+水平居中 */ display: flex; justify-content: center; align-items: center; height: 100vh; background-color: #efeeee;&#125;.container &#123; display: flex; /* 让一行中的元素平均分配宽度 */ justify-content: space-around; align-items: center; /* 元素在一行放不下时自动换行 */ flex-wrap: wrap; width: 700px; height: 600px;&#125;.container .box &#123; display: flex; justify-content: space-around; align-items: center; /* 让元素垂直排列 这里就是让包含图片的div和文字垂直排列 */ flex-direction: column; width: 100px; height: 140px; margin: 20px; /* 鼠标放上去变成小手 */ cursor: pointer;&#125;.container .box .img &#123; /* 这里让图片在盒子里垂直+水平居中 */ display: flex; justify-content: center; align-items: center; width: 100px; height: 100px; /* 圆角属性 */ border-radius: 20px; /* 盒子阴影 */ box-shadow: 18px 18px 30px rgba(0, 0, 0, 0.2), -18px -18px 30px rgba(255, 255, 255, 1); /* 过渡时间 ease-out是指先快速 后慢速 */ transition: all 0.2s ease-out;&#125;.container .box .img img &#123; width: 60px; transition: all 0.2s ease-out;&#125;.container .box p &#123; color: slategrey;&#125;.container .box .img:hover &#123; /* inset 是内部阴影 默认是外部阴影outset */ box-shadow: 0 0 0 rgba(0, 0, 0, 0.2), 0 0 0 rgba(255, 255, 255, 0.8), inset 18px 18px 30px rgba(0, 0, 0, 0.1), inset -18px -18px 30px rgba(255, 255, 255, 1);&#125;.container .box .img:hover img &#123; width: 58px;&#125;","path":"page/project05.html","date":"01-28","excerpt":"","tags":[{"name":"项目案例","slug":"项目案例","permalink":"http://xiaoliblog.cn/tags/%E9%A1%B9%E7%9B%AE%E6%A1%88%E4%BE%8B/"}]},{"title":"hexo-git-backup 博客备份及恢复","text":"博客备份备份对于静态博客来说是及其重要的，本文章介绍一种hexo-git-backup插件备份的办法来实现hexo博客备份 GitHub项目地址：https://github.com/coneycode/hexo-git-backup官方文档地址：https://github.com/coneycode/hexo-git-backup/blob/master/README.md 安装插件 首先输入命令hexo version查看Hexo版本，如图所示，我的是5.2.0版本 安装备份插件，如果你的 Hexo 版本是 2.x.x，则使用以下命令安装： 1$ npm install hexo-git-backup@0.0.91 --save Hexo 版本是 3.x.x，则使用以下命令安装： 1$ npm install hexo-git-backup --save 新建仓库 在GuiHub中新建仓库,例如Hexo_Backup，权限为private，分支为master 复制所建库的SSH链接 在Hexo配置文件中添加 1234backup: type: git repository: backup: git@github.com:xingjiahui/Hexo-Backup.git,master(分支名,新库为main) 新建的github仓库默认分支为main，旧仓库默认分支依旧为master，一定要分清楚分支名 使用1$ hexo b(back) 每次更新博客后，都需要hexo b来备份 备份的用处: 当hexo g 报错没有头绪时，可以使用备份文件 当本地文件丢失时，可以使用备份文件 使用前提，配好环境(已下载Node.js和Git) 博客恢复博客文件 建立hexo博客都会有一个独立的文件夹，电脑转移时安全的做法是将整个文件夹拷贝 必备文件 config.yml（站点配置） theme（主题文件夹） source（博客内容文件）。 次要文件 scaffolds（文章的模板） package.json（使用包的说明文件） .gitignore（限定在提交的时候哪些文件可以忽略） 三个次要文件为自动生成的，因此丢失也不怕影响博客内容，后续在hexo init时会生成这三个文件 需要删除的文件 .git文件 node_modules（进行npm install会重新生成） public（执行hexo g时会重新生成） .deploy_git文件夹（执行hexo d时会重新生成） db.json文件 其实上面这些可删除的文件即为.gitignore文件里面记载的可以忽略的内容 环境搭建 如果是更换了电脑，那么需要重新配置环境，即安装Node.js以及Git 下载安装Node.js 下载安装Git 选择适合自己系统的安装 下载安装后，右击鼠标Git Bash Here，输入如下命令，检测是否安装成功 1$ node -v 1$ npm -v 1$ git --version 源文件拷贝 如果使用了hexo-git-backup插件备份，只需要从github上拉入本地即可 1$ git clone https://github.com/username/备份仓库名.git 如果是将原来博客文件拷贝到新电脑上，可以全部拷贝，或者只拷如下几个目录 12345_config.yml package.json scaffolds&#x2F; source&#x2F; themes&#x2F; 搭建hexo注意：安装Hexo需要在你刚才拷贝源文件的文件夹内安装 在你刚才拷贝源文件的文件夹内，右键点击 Git Bash：，输入以下命令 12$ npm install -g cnpm --registry=https://registry.npm.taobao.org$ cnpm -v 12$ cnpm install -g hexo-cli$ hexo -v 安装部署插件 12$ npm install $ npm install hexo-deployer-git --save #文章部署到git 的模块 测试 123$ hexo init$ hexo g$ hexo s 本机访问localhost:4040即可看到自己发布的文章以及之前博客的界面，现在只差将博客托管到github page上了。 注意：如果仓库有改动，要更改配置文件里面deploy下的repository和backup下的repository 生成新密匙 更换了新电脑，需要在Github添加新电脑产生的密匙，并删除之前配好的密匙 在刚才拷贝源文件的文件夹内，右键点击Git Bash Here ,输入如下命令后一直按回车 123# 设置用户信息$ git config --global user.name &quot;Gitub用户名&quot;$ git config --global user.email &quot;GitHub邮箱&quot; 1$ ssh-keygen -t rsa -C &quot;Github邮箱地址&quot; 然后会生成密匙，一般是在C:\\Users\\电脑自定义名称\\.ssh下，里面的pub文件就是产生的密匙 复制pub文件里的内容，进入Github网址，点击头像找到setting设置，选择SSH and GPG keys，点击New SSH key，然后给密钥命名并将.pub文件中的内容复制到key中 在终端执行命令测试一下是否成功 1$ ssh -T git@github.com 部署发布123$ hexo clean # 清除缓存 网页正常情况下可以忽略此条命令$ hexo g # 生成静态网页$ hexo d # 开始部署 总结 本地环境搭建好（node git hexo） github 秘钥配置好 部分扩展插件装好 $ npm install hexo-deployer-git --save 用户验证填写准确","path":"page/hexobackup.html","date":"01-26","excerpt":"","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://xiaoliblog.cn/tags/Hexo/"}]},{"title":"前端三剑客🎉字体图标","text":"字体图标 字体图标iconfont使用场景：主要用于显示网页中通用、常用的一些小图标 字体图标展示的是图标，本质属于字体，放大放小都不会失真 字体图标的优点 轻量级：一个图标字体要比一系列的图像要小 灵活性：本质其实是文字，可以很随意的改变颜色、产生阴影、透明效果、旋转等 兼容性：几乎支持所有的浏览器 注意：字体图标不能替代精灵技术，只是对工作中图标部分技术的提升和优化 如果遇到一些结构和样式比较简单的小图标，就用字体图标 如果遇到一些结构和样式比较复杂的小图标，就用字体图标 字体图标下载字体图标是一些网页常见的小图标，课直接从网上下载即可 字体图标的下载 icomoon字库👉 https://icomoon.io/ 阿里iconfont字库👉https://www.iconfont.cn/ Font Awesome👉https://fontawesome.dashgame.com/ 字体图标的引入 字体图标的追加 以icomoon为例，进入官网下载 打开压缩包文件，如下所示 把下载包里面的fonts文件夹放入页面根目录下，fonts文件里的内容主要用于兼容性处理 在CSS样式中全局声明字体：简单理解把这些字体通过css引入到我们的页面中，一定注意字体文件路径的问题，代码在压缩包icomoon的style.css里面 1234567891011@font-face &#123; font-family: &#x27;icomoon&#x27;; src: url(&#x27;fonts/icomoon.eot?9xaq45&#x27;); src: url(&#x27;fonts/icomoon.eot?9xaq45#iefix&#x27;) format(&#x27;embedded-opentype&#x27;), url(&#x27;fonts/icomoon.ttf?9xaq45&#x27;) format(&#x27;truetype&#x27;), url(&#x27;fonts/icomoon.woff?9xaq45&#x27;) format(&#x27;woff&#x27;), url(&#x27;fonts/icomoon.svg?9xaq45#icomoon&#x27;) format(&#x27;svg&#x27;); font-weight: normal; font-style: normal; font-display: block;&#125; 在压缩包文件icomoon里找到demo.html文件，复制小方框或者Unicode，粘贴到想要显示的html文件里 12&lt;span&gt;字体图标:&lt;/span&gt;&lt;span&gt;字体图标：&#x27;\\e900&#x27;&lt;span&gt; 字体图标可以用字体设置CSS样式来调整 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; /*字体声明*/ @font-face &#123; font-family: &#x27;icomoon&#x27;; src: url(&#x27;fonts/icomoon.eot?9xaq45&#x27;); src: url(&#x27;fonts/icomoon.eot?9xaq45#iefix&#x27;) format(&#x27;embedded-opentype&#x27;), url(&#x27;fonts/icomoon.ttf?9xaq45&#x27;) format(&#x27;truetype&#x27;), url(&#x27;fonts/icomoon.woff?9xaq45&#x27;) format(&#x27;woff&#x27;), url(&#x27;fonts/icomoon.svg?9xaq45#icomoon&#x27;) format(&#x27;svg&#x27;); font-weight: normal; font-style: normal; font-display: block; &#125; span&#123; font-family: &#x27;icomoon&#x27;; /*字体和上面声明的要一样*/ font-size: 40px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;span&gt;字体图标:&lt;/span&gt; &lt;span&gt;&lt;/span&gt;&lt;/html&gt; 字体图标追加 如果工作中，原来的字体图标不够用了，我们就需要添加新的字体图标到原来的字体文件中 把压缩包里面的selection.json重新上传，然后选中自己想要的新图标，重新下载压缩包，并替换原来的文件即可（Import Icons→ Generater Font → Download） Font Awesome 一套绝佳的图标字体库和CSS框架||Font Awesome参考手册 Font Awesome 是一套绝佳的图标字体库和CSS框架。 Font Awesome 字体为您提供可缩放矢量图标,它可以被定制大小、颜色、阴影以及任何可以用CSS的样式。 引入CDN 要使用Font Awesome图标，请在HTML页面的 部分中添加以下行： 国内推荐CDN 1&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.css&quot;&gt; 海外推荐CDN 1&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css&quot;&gt; 使用 使用前缀 fa 和图标的名称来放置 Font Awesome 图标。 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.css&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;i class=&quot;fa fa-car&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fa fa-car&quot; style=&quot;font-size:48px;&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fa fa-car&quot; style=&quot;font-size:60px;color:red;&quot;&gt;&lt;/i&gt;&lt;/body&gt;&lt;/html&gt; 运行结果 Font Awesome 设计为与内联元素一起使用。 \\&lt;i&gt;和 \\&lt;span&gt;元素广泛用于图标。另外注意，如果更改图标容器的字体大小或颜色，图标会更改。 大图标 fa-lg (增加33％)，fa-2x，fa-3x， fa-4x，或 fa-5x 类用于增加相对于其容器的图标大小。 123456789101112131415!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;i class=&quot;fa fa-car fa-lg&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fa fa-car fa-2x&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fa fa-car fa-3x&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fa fa-car fa-4x&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fa fa-car fa-5x&quot;&gt;&lt;/i&gt; &lt;/body&gt;&lt;/html&gt; 运行结果 提示： 如果你的图标在顶部和底部被切断，请增加行高。 列表图标 fa-ul 和 fa-li 类用于替换无序列表中的默认前缀。 12345&lt;ul class=&quot;fa-ul&quot;&gt; &lt;li&gt;&lt;i class=&quot;fa-li fa fa-check-square&quot;&gt;&lt;/i&gt;List icons&lt;/li&gt; &lt;li&gt;&lt;i class=&quot;fa-li fa fa-spinner fa-spin&quot;&gt;&lt;/i&gt;List icons&lt;/li&gt; &lt;li&gt;&lt;i class=&quot;fa-li fa fa-square&quot;&gt;&lt;/i&gt;List icons&lt;/li&gt;&lt;/ul&gt; 运行结果 List icons List icons List icons 边界和被拉的图标 fa-border，fa-pull-right或 fa-pull-left 类用于拉式引用或文章图标。 123456&lt;i class=&quot;fa fa-quote-left fa-3x fa-pull-left fa-border&quot;&gt;&lt;/i&gt;Lzy_Blog -- 越努力越幸运！！！&lt;br&gt;Lzy_Blog -- 越努力越幸运！！！&lt;br&gt;Lzy_Blog -- 越努力越幸运！！！&lt;br&gt;Lzy_Blog -- 越努力越幸运！！！ 运行结果 动态图标 fa-spin 类可以让图标旋转, fa-pulse 类可以使图标以 8 步为周期进行旋转。 123456&lt;i class=&quot;fa fa-spinner fa-spin&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fa fa-circle-o-notch fa-spin&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fa fa-refresh fa-spin&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fa fa-cog fa-spin&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fa fa-spinner fa-pulse&quot;&gt;&lt;/i&gt; 运行结果 &nbsp;&nbsp;&nbsp;&nbsp; 旋转和翻转的图标 fa-rotate-* 和 fa-flip-* 类用于旋转和翻转图标。 1234567&lt;i class=&quot;fa fa-shield&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fa fa-shield fa-rotate-90&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fa fa-shield fa-rotate-180&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fa fa-shield fa-rotate-270&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fa fa-shield fa-flip-horizontal&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fa fa-shield fa-flip-vertical&quot;&gt;&lt;/i&gt; 运行结果 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 堆叠的图标 要堆叠多个图标，请使用父级上的 fa-stack 类，fa-stack-1x 类用于常规大小的图标，fa-stack-2x 用于较大的图标。 fa-inverse 类可以用作替代图标颜色。您还可以向父级添加更大的图标类，以进一步控制尺寸。 123456789101112131415161718&lt;span class=&quot;fa-stack fa-lg&quot;&gt; &lt;i class=&quot;fa fa-circle-thin fa-stack-2x&quot;&gt;&lt;/i&gt; &lt;i class=&quot;fa fa-twitter fa-stack-1x&quot;&gt;&lt;/i&gt;&lt;/span&gt;fa-twitter on fa-circle-thin&lt;br&gt; &lt;span class=&quot;fa-stack fa-lg&quot;&gt; &lt;i class=&quot;fa fa-circle fa-stack-2x&quot;&gt;&lt;/i&gt; &lt;i class=&quot;fa fa-twitter fa-stack-1x fa-inverse&quot;&gt;&lt;/i&gt;&lt;/span&gt;fa-twitter (inverse) on fa-circle&lt;br&gt; &lt;span class=&quot;fa-stack fa-lg&quot;&gt; &lt;i class=&quot;fa fa-camera fa-stack-1x&quot;&gt;&lt;/i&gt; &lt;i class=&quot;fa fa-ban fa-stack-2x text-danger&quot; style=&quot;color:red;&quot;&gt;&lt;/i&gt;&lt;/span&gt;fa-ban on fa-camera 运行结果 fa-twitter on fa-circle-thin fa-twitter (inverse) on fa-circle fa-ban on fa-camera 固定宽度图标 fa-fw 类用于设置固定宽度的图标。 当不同的图标宽度偏离对齐时，此类非常有用。 特别适用于Bootstrap的导航列表和列表组。 1234567&lt;div class=&quot;list-group&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;list-group-item&quot;&gt;&lt;i class=&quot;fa fa-home fa-fw&quot;&gt;&lt;/i&gt; Home&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;list-group-item&quot;&gt;&lt;i class=&quot;fa fa-book fa-fw&quot;&gt;&lt;/i&gt; Library&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;list-group-item&quot;&gt;&lt;i class=&quot;fa fa-pencil fa-fw&quot;&gt;&lt;/i&gt; Applications&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;list-group-item&quot;&gt;&lt;i class=&quot;fa fa-cog fa-fw&quot;&gt;&lt;/i&gt; Settings&lt;/a&gt;&lt;/div&gt; 运行结果 Home Library Applications Settings IconFonticonfont-阿里巴巴矢量图标库 新建图标项目 访问阿里巴巴矢量图标库 , 注册登录。 搜索自己心仪的图标，然后选择添加入库，加到购物车。 选择完毕后点击右上角的购物车图标，打开侧栏，选择添加到项目，如果没有项目就新建一个 可以通过上方顶栏菜单 -&gt; 资源管理 -&gt; 我的项目，找到之前添加的图标项目 引入图标阿里巴巴矢量图标库使用文档||Hexo引入阿里矢量图标库 图标引入方式一共有三种引入方式：Unicode、Font class、Symbol Unicode引入Font Class引入symbol引用Unicode是字体在网页端最原始的应用方式，特点是： 兼容性最好，支持ie6+，及所有现代浏览器。 支持按字体的方式去动态调整图标大小，颜色等等。 但是因为是字体，所以不支持多色。只能使用平台里单色的图标，就算项目里有多色图标也会自动去色。 复制代码引入HTML文件的&lt;style&gt;样式里 1234567891011&lt;style&gt;@font-face &#123; font-family: &#x27;iconfont&#x27;; /* project id 2212970 */ src: url(&#x27;//at.alicdn.com/t/font_2212970_tpy6sg1pb1r.eot&#x27;); src: url(&#x27;//at.alicdn.com/t/font_2212970_tpy6sg1pb1r.eot?#iefix&#x27;) format(&#x27;embedded-opentype&#x27;), url(&#x27;//at.alicdn.com/t/font_2212970_tpy6sg1pb1r.woff2&#x27;) format(&#x27;woff2&#x27;), url(&#x27;//at.alicdn.com/t/font_2212970_tpy6sg1pb1r.woff&#x27;) format(&#x27;woff&#x27;), url(&#x27;//at.alicdn.com/t/font_2212970_tpy6sg1pb1r.ttf&#x27;) format(&#x27;truetype&#x27;), url(&#x27;//at.alicdn.com/t/font_2212970_tpy6sg1pb1r.svg#iconfont&#x27;) format(&#x27;svg&#x27;);&#125;&lt;/style&gt; 通过图标的Unicode码来引用 1&lt;span class=&quot;iconfont&quot;&gt;&amp;#xe604;&lt;/span&gt; 既然是字体图标，那么可以通过字体属性样式来改变图标样式 1234 .iconfont&#123; font-size:40px; color:#fb7299;&#125; 运行结果 font-class是unicode使用方式的一种变种，主要是解决unicode书写不直观，语意不明确的问题。与unicode使用方式相比，具有如下特点： 兼容性良好，支持ie8+，及所有现代浏览器。 相比于unicode语意明确，书写更直观。可以很容易分辨这个icon是什么。 因为使用class来定义图标，所以当要替换图标时，只需要修改class里面的unicode引用。 不过因为本质上还是使用的字体，所以多色图标还是不支持的。 推荐复制粘贴到本地CSS中，防止以后项目图标改动导致链接失效的问题 在HTML页面中引入样式，以我的iconfont.css文件为例 1234&lt;!--本地引入--&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;iconfont.css&quot;&gt;&lt;!--CDN引入 &quot;//&quot;代表https..--&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;//at.alicdn.com/t/font_2212970_tpy6sg1pb1r.css&quot;&gt; 使用图标 123&lt;i class=&quot;iconfont icon-xxx&quot;&gt;&lt;/i&gt; &lt;!--xxx为图标名称，例如--&gt;&lt;i class=&quot;iconfont icon-git&quot;&gt;&lt;/i&gt; 定义样式 1234.iconfont&#123; font-size:40px; color:#72c4fb;&#125; 运行结果 这是一种全新的使用方式，应该说这才是未来的主流，也是平台目前推荐的用法 支持多色图标了，不再受单色限制。 通过一些技巧，支持像字体那样，通过font-size,color来调整样式。 兼容性较差，支持 ie9+,及现代浏览器。 浏览器渲染svg的性能一般，还不如png 同样推荐复制到本地JS文件引用，以我的symbolicon.js为例 1234&lt;!--本地引入--&gt;&lt;script src=&quot;symbolicon.js&quot;&gt;&lt;/script&gt;&lt;!--CDN引入--&gt;&lt;script src=&quot;//at.alicdn.com/t/font_2212970_tpy6sg1pb1r.js&quot;&gt;&lt;/script&gt; 使用图标 123&lt;svg class=&quot;icon&quot; aria-hidden=&quot;true&quot;&gt; &lt;use xlink:href=&quot;#icon-qq&quot;&gt;&lt;/use&gt;&lt;/svg&gt; 通用样式 123456789.icon &#123; /*通用属性*/ width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden; /*自定义属性*/ font-size:30px;&#125; 运行结果","path":"page/css18.html","date":"01-24","excerpt":"","tags":[{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"http://xiaoliblog.cn/tags/HTML-CSS/"}]},{"title":"前端实例🥳学成在线首页","text":"准备工作 学成在线素材PSD格式图像请戳👉密码:9fpb，并通过PS软件切图和测量颜色和像素宽度(pt) 采取结构和样式相分离思想（CSS和HTML分开） 确定页面的版心（可视区） 分析页面中的行模块，以及每个行模块中的列模块 一行中的列模块经常浮动布局，先确定每个列的大小，之后确定列的位置 制作HTML结构，先有结构，后有样式 理清布局结构非常重要 头部制作 1 号是版心盒子header 1200* 42的盒子水平居中对齐，上下给一个margin 值就可以 版心盒子里面包含 2号盒子logo 版心盒子里面包含3号盒子nav导航栏 版心盒子里面包含4号子search搜索框 版心盒子里面包含5号盒子user个人信息 注意:要求里面的4个盒子必须都是浮动 全局定义CSS 12345678910111213141516171819202122232425262728*&#123; margin: 0; padding: 0;&#125;/*公共属性*/.w&#123; width: 1200px; margin: auto;&#125;li&#123; list-style: none;&#125;a&#123; text-decoration: none;&#125;body&#123; background-color: #f3f5f7;&#125;.clearfix:before,.clearfix:after&#123; content:&quot;&quot;; display:table; &#125; .clearfix:after&#123; clear:both; &#125; .clearfix&#123; *zoom:1; &#125; 公共部分可以分模块写，到时候只需要在class上添加即可，比如所有版心宽度都是width:1200px;marigin:auto，&lt;div class=&quot;box w&quot;&gt;&lt;div&gt;添加即可 导航栏nav模块实际开发中，不会直接用链接a而是用li包含链接（li+a）的做法 1234567&lt;div class=&quot;nav&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;课程&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;职业规划&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 123456789101112131415161718192021li&#123; list-style: none;&#125;a&#123; text-decoration: none;&#125;.nav&#123; float:left; margin-left: 60px;&#125;.nav ul li&#123; float:left;&#125;.nav ul li a&#123; display: block; height: 42px; padding: 0 10px; line-height: 42px; font-size:18px; colro:#050505;&#125; 让导航栏一行显示，给li加浮动，因为li是块级元素，需要一行显示 这个nav导航栏可以不给宽度，将来可以继续添加其余文字 因为导航栏里面文字不一样多，所有最好给链接a左右padding撑开盒子，而不是指定宽度 鼠标经过下划线实现，只需要加个下边框即可 1234.nav ul li a:hover&#123; border-bottom:2px solid #00a4ff; color:#00a4ff;&#125; 充分利用盒子模型和浮动，导航栏用li+a标签，并给a标签padding撑开盒子，下划线添加下边框border-bottom即可 搜索search模块一个search盒子包含两个表单（输入框和按钮） 1234&lt;div class=&quot;search&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;输入关键词&quot;&gt; &lt;button&gt;&lt;/button&gt;&lt;/div&gt; 由于表单和按钮属于行内块元素（行内块元素之间含有默认的缝隙，需要加浮动解决） 1234567891011121314151617181920212223242526.search&#123; width: 412px; height: 42px; float: left; margin-left: 50px; background-color:bisque;&#125;.search input&#123; float: left; width: 360px; height: 40px; border:1px solid #00a4ff; border-right:0; font-size: 14px; text-indent: 15px;&#125;input::placeholder&#123; color:#bfbfbf; /*提示信息改变颜色*/&#125;.search button&#123; float: left; width: 50px; height: 42px; border:0; /*去掉边框*/ background: url(img/btn.png)&#125; 行内块元素之间含有默认的缝隙，需要加浮动解决;提示信息修改颜色用伪元素input::placeholder，按钮可以不用表单用button标签 用户user模块123&lt;div class=&quot;user&quot;&gt; &lt;img src=&quot;img/user.png&quot;&gt;qq-lilei &lt;/div&gt; 12345678910.user&#123; float: left; line-height: 42px; margin-left: 30px; font-size: 14px; color:#666;&#125;.user img&#123; vertical-align: middle;&#125; 图像和文字对齐用vertical-align:middl banner模块 1号盒子是通栏的大盒子banner ,不给宽度,给高度,给一个蓝色背景 2号盒子是版心,要水平居中对齐 3号盒子版心内,左对齐subnav侧导航栏，右浮动 4号盒子版心内,右对齐course课程，左浮动 侧导航栏subnav模块12345678910111213&lt;div class=&quot;subnav&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;前端开发 &lt;span&gt; &amp;gt; &lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;后端开发 &lt;span&gt; &amp;gt; &lt;/span&gt; &lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;移动开发 &lt;span&gt; &amp;gt; &lt;/span&gt; &lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;人工智能 &lt;span&gt; &amp;gt; &lt;/span&gt; &lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;商业预测 &lt;span&gt; &amp;gt; &lt;/span&gt; &lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;与计算&amp;大数据 &lt;span&gt; &amp;gt; &lt;/span&gt; &lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;运维&amp;测试 &lt;span&gt; &amp;gt; &lt;/span&gt; &lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;UI设计 &lt;span&gt; &amp;gt; &lt;/span&gt; &lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;产品 &lt;span&gt; &amp;gt; &lt;/span&gt; &lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 123456789101112131415161718192021.subnav&#123; width: 190px; height: 421px; background:rgba(0,0,0,0.3);/*黑色透明效果*/ float: left; /*要浮动就一起浮动*/&#125;.subnav ul li&#123; height: 45px; line-height: 45px; /*居中对齐*/ padding:0 20px; /*上下0 左右20px撑开*/&#125;.subnav ul li a&#123; font-size:14px; color:white;&#125;.subnav ul li a span&#123; /*span左浮动*/ float:right;&#125;.subnav ul li a:hover&#123; color:#00a4ff;&#125; 内容上下左右间距可以通过padding调整，要浮动一定要一起浮动，灵活运用padding撑开盒子，少设置固定宽度 course课程模块12345678910111213141516171819&lt;div class=&quot;course&quot;&gt; &lt;h2&gt;我的课程表&lt;/h2&gt; &lt;div class=&quot;content&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;h4&gt;继续学习 程序语言设计&lt;/h4&gt; &lt;p&gt;正在学习-使用对象&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;h4&gt;继续学习 程序语言设计&lt;/h4&gt; &lt;p&gt;正在学习-使用对象&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;h4&gt;继续学习 程序语言设计&lt;/h4&gt; &lt;p&gt;正在学习-使用对象&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;a href=# class=&quot;more&quot;&gt;全部课程&lt;/a&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142.course&#123; width: 230px; height: 300px; background-color: #fff; float:right; /*要浮动就一起浮动，上面的subnav也要加*/ margin-top: 50px; /*浮动盒子不存在外边距合并*/&#125;.course h2&#123; height: 48px; background-color:#94cbe9; text-align: center; line-height: 48px; font-size:18px; color:white;&#125;.content&#123; padding: 0px 20px; /*上下0 左右20px*/&#125;.content ul li&#123; padding: 14px 0px; /*上下45px 左右0*/ border-bottom: 1px solid #ccc;&#125;.content ul li h4&#123; font-size: 16px; color: #4e4e4e;&#125;.content ul li p&#123; font-size: 12px; color: #a5a5a5;&#125;.content .more&#123; display: block; height: 38px; border: 1px solid #00a4ff; text-align: center; line-height: 38px; margin-top: 5px; color:#00a4ff; font-size: 16px; font-weight: 700;&#125; 精品推荐模块 大盒子水平居中goods精品,注意此处有个盒子阴影 1号盒子是标题H3左侧浮动 2号盒子里面放链接左侧浮动, goods-item距离可以控制链接的左右外边距(注意行内元素只给左右内外边距) 3号盒子右浮动mod修改 1234567891011 &lt;div class=&quot;good w&quot;&gt; &lt;h3&gt;精品推荐&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;jQuery&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Spark&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;MySQL&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;JavaWeb&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Vue.js&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;a href=&quot;#&quot; class=&quot;mod&quot;&gt;修改兴趣&lt;/a&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132.good&#123; height: 60px; line-height: 60px; /*行高会继承给3个孩子*/ background-color: #fff; box-shadow: 0 2px 3px 3px rgba(0,0,0,0.1); /*加阴影*/ margin-top: 10px;&#125;.good h3&#123; float:left; margin-left: 30px; font-size:16px; color:#00a4ff;&#125;.good ul&#123; float:left; margin-left: 30px;&#125;.good ul li&#123; float:left;&#125;.good ul li a&#123; padding: 0 30px; font-size:16px; color:black; border-left:1px solid #ccc; /*每个a标签加一个左边框当竖线*/&#125;.mod&#123; float:right; margin-right:30px ; font-size:14px; color:#00a4ff;&#125; 精品推荐大模块 1号盒子为最大的盒子，box版心水平居中对齐 2号盒子为上面部分, box-hd – 里面左侧标题H3左浮动,右侧链接a右浮动 3号盒子为底下部分, box-bd–里面是无序列表,有10个小li组成 小li外边距的问题,这里有个小技巧:给box-hd宽度为1215就可以一行装开5个li box-hd模块1234 &lt;div class=&quot;box-hd&quot;&gt; &lt;h3&gt;精品推荐&lt;/h3&gt; &lt;a href=&quot;#&quot;&gt;查看全部&lt;/a&gt;&lt;/div&gt; 123456789101112131415.box-hd&#123; height: 45px;&#125;.box-hd h3&#123; float: left; font-size:20px; color:#494949;&#125;.box-hd a&#123; float: right; font-size:12px; color:#a5a5a5; margin-top: 10px; margin-right: 30px;&#125; box-bd模块1234567891011121314&lt;div class=&quot;box-bd&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 1234567891011121314/*把li的父亲ul修改的足够宽就能装5个盒子不换行了*/.box-bd ul&#123; width: 1225px;&#125;.box-bd ul li&#123; float: left; width: 228px; height: 270px; background-color:pink; margin-right: 15px; margin-bottom: 15px;&#125; 通过把父盒子宽度条足够宽，刚好存下5个盒子，盒子间距通过margin调整 123456789101112&lt;div class=&quot;box-bd&quot;&gt; &lt;ul class=&quot;clearfix&quot;&gt; &lt;!--清除浮动--&gt; &lt;li&gt; &lt;img src=&quot;img/pic.png&quot;&gt; &lt;h4&gt; Think PHP 5.0 博客系统实战项目演练 &lt;/h4&gt; &lt;div class=&quot;info&quot;&gt; &lt;span&gt;高级&lt;/span&gt; • 1125人在学习 &lt;/div&gt; &lt;/li&gt;&lt;/div&gt; 1234567891011121314151617.box-bd ul li img&#123; width: 100%; /*100%和父盒子一样宽*/&#125;.box-bd ul li h4&#123; margin: 20px 20px 20px 25px; /*上 右 下 左 边距*/ font-size:14px; color:#050505; font-weight: 400;&#125;.box-bd .info&#123; margin: 0 20px 0 25px; font-size:12px; color:#999;&#125;.box-bd .info span&#123; color:#ff7c2d;&#125; 合理运用width:100%; 使子盒子和父盒子一样宽 footer模块 1号盒子是通栏大盒子,底部footer给高度,底色是白色 2号盒子版心水平居中 3号盒子版权copyright左对齐 4号盒子链接组links右对齐 上面精品模块并没有给父盒子高度，会出现坍陷情况，所以需要清除浮动（给ul添加伪元素清除浮动） copyright模块123456789&lt;div class=&quot;footer&quot;&gt; &lt;div class=&quot;w&quot;&gt; &lt;div class=&quot;copyright&quot;&gt; &lt;img src=&quot;img/logo.png&quot;&gt; &lt;p&gt;学成在线致力于普及中国最好的教育它与中国一流大学和机构合作提供在线课程。&lt;br&gt; © 2017年XTCG Inc.保留所有权利。-沪ICP备15025210号&lt;/p&gt; &lt;a href=&quot;#&quot; class=&quot;app&quot;&gt;下载APP&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627/*footer模块*//*此时footer盒子会跑到精品大模块下，即精品大模块父盒子高度为o，标准流抢占位置*//*此时给ul添加clearfix伪元素清除浮动即可*/.footer&#123; height: 415px;&#125;.footer .w&#123; /*margin-top此时会出现上边距合并的情况！*/ padding-top: 35px;;&#125;.copyright&#123; float: left;&#125;.copyright p&#123; font-size: 16px; color:#666; margin: 20px 0 15px 0;&#125;.copyright .app&#123; display: block; width: 118px; height: 33px; border:1px solid #00a4ff; text-align: center; line-height: 33px; font-size: 16px; color:#00a4ff;&#125; 本实例出现父级盒子高度为0抢占位置和上边框合并问题，父级盒子高度为0用伪元素清除浮动，上边框合并改为padding控制间距 links模块使用dl定义列表来做最合适 1234567891011121314151617181920212223242526&lt;div class=&quot;links&quot;&gt; &lt;dl&gt; &lt;dt&gt;关于学成网&lt;/dt&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;关于&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;管理团队&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;工作机会&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;客户服务&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;帮助&lt;/a&gt;&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;关于学成网&lt;/dt&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;关于&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;管理团队&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;工作机会&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;客户服务&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;帮助&lt;/a&gt;&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;关于学成网&lt;/dt&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;关于&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;管理团队&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;工作机会&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;客户服务&lt;/a&gt;&lt;/dd&gt; &lt;dd&gt;&lt;a href=&quot;#&quot;&gt;帮助&lt;/a&gt;&lt;/dd&gt; &lt;/dl&gt;&lt;/div&gt; 12345678910111213141516.links&#123; float: right;&#125;.links dl&#123; float:left; margin-left: 100px;&#125;.links dl dt&#123; font-size: 16px; color:#333; margin-bottom: 5px;&#125;.links dl dd a&#123; font-size: 12px; color:#333;&#125; 源码及素材如有需要请戳👉👉👉学成在线源码及素材","path":"page/project02.html","date":"01-22","excerpt":"","tags":[{"name":"项目案例","slug":"项目案例","permalink":"http://xiaoliblog.cn/tags/%E9%A1%B9%E7%9B%AE%E6%A1%88%E4%BE%8B/"}]},{"title":"前端三剑客🎉CSS高级技巧","text":"SnipasteSnipaste是一个简单但强大的截图工具，也可以让你将截图贴回到屏幕上常用快捷键： F1可以截图（笔记本Fn+F1取消默认快捷键），同时测量大小，设置箭头 书写文字等 确定号截图范围后按F3在桌面置顶显示（非常有用的技巧） 点击图片，alt可以去色（按下shift可以切换取色模式），C可以复制 按下ESC取消图片显示 PhotoShop PS基本操作 Ctrl+R：可以打开标尺，或者视图-&gt;标尺 右击标尺，单位改为像素 Ctrl+加号可以放大视图，Ctrl+减号缩小视图 按住空格键，可以拖到视图 用选区拖动，可以测量大小 Ctrl+D可以取消选区，或者在旁边空白处点击一下也可以取消选取 PS切图 网页中常见的图片格式 jpg图像格式: JPEG ( JPG )对色彩的信息保留较好，高清，颜色较多，我们产品类的图片经常用ipg格式的 gif图像格式 : GIF格式最多只能储存256色，所以通常用来显示简单图形及字体，但是可以保存透明背景和动画效果，实际经常用于一些图片小动画效果 png图像格式是-一种新兴的网络图形格式，结合了GIF和JPEG的优点，具有存储形式丰富的特点，能够保持透明背景，如果想要切成背景透明的图片，请选择png格式. PSD图像格式PSD格式是Photoshop的专用格式，里面可以存放图层、通道、遮罩等多种设计稿，对我们前端人员来说，最大的优点我们可以直接从上面复制文字获得图片,还可以测量大小和距离 PSD格式图像请戳密码:9fpb PS切图方式有：图层切图、切片切图、PS插件切图等 图层切图 最简单的切图方式：右击图床→快速导出为PNG 但有些情况，图片和文字是分开两个图层，此时就需要合并图层（选中需要的图层→合并图层） Cutterman Cutterman是一款运行在photoShop中的插件，能够自动将你需要的图层进行输出，以代替传统繁琐流程 Cutterman官网下载地址：http://www.cutterman.cn/zh/cutterman 需要在其官网进行注册一个账号 安装完成后需要重启Photoshop软件 窗口→扩展功能→Cutterman切图神器 登录官网注册的账号即可 选中需要的图层导出即可 Sprites一个网页中往往会应用很多小的背景图像作为修饰，当网页中的图像过多时，服务器就会频繁地接收和发送请求图片，,造成服务器请求压力过大,这将大大降低页面的加载速度。 因此，为了有效地减少服务器接收和发送请求的次数，提高页面的加载速度，,出现了CSS精灵技术(也称CSS Sprites、css雪碧)。 核心原理：将网页中的一些小背景图像整合到一张大图中，这样服务器只需要一次请求就可以了 Sprites使用 精灵技术主要针对于背景图片使用，技术把多个小背景图片整合到一张大图片中 这个大突破也称为Sprites精灵图或者雪碧图，如下所示为王者荣耀官网的背景精灵图 主要借助于背景位置来实现——background-position 一般情况下精灵图都是负值（网页中的坐标：x右边走是正值，左边走是负值，y轴同理），因为给盒子添加背景图片后默认左上角对齐，需要图像处理工具(PS)进行计算位置 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; .box1&#123; width: 60px; height: 60px; margin: 100px auto; background: url(images/back.png) no-repeat -182px 0; &#125; .box2&#123; width: 27px; height: 25px; margin: 68px auto; background: url(images/back.png) no-repeat -155px -106px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 拼出自己的名字12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;仿土豆网显示隐藏遮罩案例&lt;/title&gt; &lt;style&gt; span&#123; display: inline-block; &#125; .L&#123; width: 105px; height: 123px; background: url(images/abcd.jpg) no-repeat 0 -275px; &#125; .Z&#123; width: 115px; height: 123px; background: url(images/abcd.jpg) no-repeat -478px -550px; &#125; .Y&#123; width: 115px; height: 123px; background: url(images/abcd.jpg) no-repeat -360px -550px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;span class=&quot;L&quot;&gt;L&lt;/span&gt; &lt;span class=&quot;Z&quot;&gt;Z&lt;/span&gt; &lt;span class=&quot;Y&quot;&gt;Y&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; CSS三角当一个盒子宽、高都为0时，其边框为四个三角形 123456789 .bo1&#123; width: 0px; height: 0px; border-top:10px solid pink; border-right: 10px solid red; border-bottom: 10px solid blue; border-left:10px solid green; &#125;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt; 把四个边用transparent变为透明，然后给其中一个边框添加颜色，三角形的大小取决于边框粗细 1234567 .box&#123; width: 0px; height: 0px; border: 10px solid transparent; border-top-color: darkorange; &#125;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt; 京东效果1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; .box&#123; width: 50px; height: 50px; background-color:darkseagreen; position: relative; &#125; span&#123; position:absolute; width: 0; height: 0; border: 5px solid transparent; border-left-color:turquoise; left:50px; /*为了照规兼容性*/ line-height: 0; font-size: 0; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt;&lt;/html&gt; CSS用户界面样式鼠标样式1cursor:pointer | deault | move | text | not-allowed; 设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状 属性值 描述 default 小白，默认 pointer 小手 move 移动 text 文本 not-allowed 禁止 1234567 &lt;ul&gt; &lt;li style=&quot;cursor: default;&quot;&gt;我是默认的小白鼠标样式&lt;/li&gt; &lt;li style=&quot;cursor: pointer;&quot;&gt;我是鼠标小手样式&lt;/li&gt; &lt;li style=&quot;cursor: move;&quot;&gt;我是鼠标移动样式&lt;/li&gt; &lt;li style=&quot;cursor: text;&quot;&gt;我是鼠标文本样式&lt;/li&gt; &lt;li style=&quot;cursor: not-allowed;&quot;&gt;我是鼠标禁止样式&lt;/li&gt;&lt;/ul&gt; 轮廓线outline123input&#123; outline:none;&#125; 给表单添加 outline:0; 或者 outline:none; 样式之后就可以去掉默认的蓝色边框 防止拖拽文本域resize实际开发中，文本域右下角是不允许拖拽的 123textarea&#123; resize:none;&#125; vertical-align vertical-align属性经常用于设置图片或者表单（行内块元素）和文字垂直对齐 用于设置一个元素的垂直对齐方式，但是只针对于行内元素或者行内块元素有效 1vertical-align: baseline | top | middle | bottom; 属性值 描述 baseline 默认，元素放置在父元素的基线上 top 把元素的顶端与行中最高元素的顶端对齐 middle 把此元素放置在父元素的中部 bottom 把元素的顶端与行中最低的元素的顶端对齐 1&lt;img src=&quot;images/img.jpg&quot; width=&quot;50px&quot; height=&quot;50px&quot;&gt;图片和文字默认基线对齐 123img&#123; vertical-align: bottom; &#125; 123img&#123; vertical-align: middle; &#125; 123img&#123; vertical-align: top; &#125; 123textarea&#123; vertical-align:middle;&#125; 图片、表单都属于行内块元素，默认的vertical-align是基线对齐，可以通过设置为middle居中对齐 图片底部空白缝隙bug：图片底侧会员一个空白缝隙，原因是行内块元素会和文字的基线对齐 解决方法 给图片添加vertical-align:middle|top|bottom等，只要不是基线对齐 把图片转换为display:block; 块元素没有vertical-align属性 123img&#123; vertical-align: bottom;&#125; 溢出文字省略号表示单行文本 单行文本溢出省略号显示，必须满足三个条件： 先强制一行内显示文本white-space:nowarp; //默认 normal 自动换行 超出的部分隐藏overflow:hidden; 文字用省略号替代超出的部分text-overflow:ellipsis; 123div&#123; white-space:nowarp;&#125; 1234div&#123; white-space:nowarp; overflow:hidden;&#125; 12345div&#123; white-space:nowarp; overflow:hidden; text-overflow:ellipsis;&#125; 多行文本多行文本溢出显示省略号，有较大兼容性问题，适合于webKit浏览器或移动端（移动端大部分是webkit内核），建议后台人员做此效果 12345678910div&#123; overflow:hidden; text-overflow:ellipsis; /*弹性伸缩盒子模型显示*/ display:-webkit-box; /*限制在一个块元素显示的文本的行数(显示省略号的行数)*/ -webkit-line-clamp:2; /*设置或检索伸缩盒对象的子元素的排列方式*/ -webkit-box-orient:vertical;&#125; 布局技巧margin负值运用当多个盒子添加浮动后（浮动默认无缝隙贴合），边框会累加造成边框过粗的现象，可以通过margin负值解决 让每个盒子margin往左侧移动-1px正好压住相邻盒子边框 123ul li&#123; margin-left: -1px;/*负值往左边走*/&#125; 当鼠标经过使边框变色时，会出现某一边框颜色被覆盖的情况 123ul li:hover&#123; border:1px solid blue;&#125; 解决方法就是当鼠标经过盒子的时候，适当提高当前盒子的层级即可（ 如果没有定位，则加相对定位（相对定位会保留位置，并压住其他标准流） 如果有定位，则直接加z-index 1234ul li:hover&#123; border:1px solid blue; position:relative;&#125; 文字围绕浮动元素巧妙运用浮动元素不会压住文字的特性 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .box &#123; width: 300px; height: 70px; margin: 0 auto; padding: 5px; border: 1px gray solid; &#125; .pic &#123; float: left; width: 120px; height: 60px; margin-right: 5px; &#125; .pic img &#123; width: 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;pic&quot;&gt; &lt;img src=&quot;images/imgs.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;p&gt;【集锦】热身赛-巴西0-1秘鲁 内马尔替补两人血染赛场&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 行内块元素运用应用于页码的实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;行内块的巧妙运用&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .box &#123; text-align: center; /*大盒子水平居中*/ &#125; .box a &#123; display: inline-block; width: 36px; height: 36px; background-color: #f7f7f7; border: 1px solid #ccc; text-align: center; /*水平居中*/ line-height: 36px; /*垂直居中*/ text-decoration: none; color: #333; font-size: 14px; &#125; .box .prev, .box .next &#123; /*加.box 提高权重*/ width: 85px; &#125; .box .current, .box .elp &#123; /*不需要边框*/ background-color: #fff; border: none; &#125; .box input &#123; height: 36px; width: 45px; border: 1px solid #ccc; outline: none; /*取消默认蓝色边框*/ &#125; .box button &#123; width: 60px; height: 36px; background-color: #f7f7f7; border: 1px solid #ccc; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;prev&quot;&gt;&amp;lt;&amp;lt;上一页&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;current&quot;&gt;2&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;3&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;4&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;5&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;6&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;elp&quot;&gt;...&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;next&quot;&gt;&amp;gt;&amp;gt;下一页&lt;/a&gt; 到第 &lt;input type=&quot;text&quot;&gt; 页 &lt;button&gt;确定&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; CSS三角应用 直角三角形原理 把上边框宽度调大 左边和下边的边框宽度设置为0 全部设置为透明，只保留右边的边框颜色 1234567891011div&#123; width: 0; height: 0; /*上 右 下 左*/ /*只保留右边边框的颜色*/ border-color:transparent darkcyan transparent transparent; /*样式都是solid*/ border-style: solid; /*上边框宽度要大，右边框宽度稍小，其余边框为0*/ border-width: 100px 50px 0 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; .price &#123; width: 160px; height: 24px; line-height: 24px; border: 1px solid red; margin: 0 auto; &#125; .miaosha &#123; position: relative; float: left; width: 90px; height: 100%; background-color:red; text-align: center; color: #fff; font-weight: 700; margin-right: 8px; &#125; .miaosha i &#123; position: absolute; right: 0; top: 0; width: 0; height: 0; border-color: transparent #fff transparent transparent; border-style: solid; border-width: 24px 10px 0 0; &#125; .origin &#123; font-size: 12px; color: gray; text-decoration: line-through; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;price&quot;&gt; &lt;span class=&quot;miaosha&quot;&gt; ¥1650 &lt;i&gt;&lt;/i&gt; &lt;/span&gt; &lt;span class=&quot;origin&quot;&gt;¥5650&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; CSS初始化 不同浏览器对有些标签的默认值是不同的，为了消除不同浏览器对HTML文本呈现的差异，照顾浏览器的兼容，我们需要对CSS初始化 简单理解: CSS初始化是指重设浏览器的样式。(也称为CSS reset ) 每个网页都必须首先进行CSS初始化。 这里我们以京东css初始化代码为例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/* 把我们所有标签的内外边距清零 */* &#123; margin: 0; padding: 0&#125;/* em 和 i 斜体的文字不倾斜 */em,i &#123; font-style: normal&#125;/* 去掉li 的小圆点 */li &#123; list-style: none&#125;img &#123; /* border 0 照顾低版本浏览器 如果 图片外面包含了链接会有边框的问题 */ border: 0; /* 取消图片底侧有空白缝隙的问题 */ vertical-align: middle&#125;button &#123; /* 当我们鼠标经过button 按钮的时候，鼠标变成小手 */ cursor: pointer&#125;a &#123; color: #666; text-decoration: none&#125;a:hover &#123; color: #c81623&#125;button,input &#123; /* &quot;\\5B8B\\4F53&quot; 就是宋体的意思 这样浏览器兼容性比较好 */ font-family: Microsoft YaHei, Heiti SC, tahoma, arial, Hiragino Sans GB, &quot;\\5B8B\\4F53&quot;, sans-serif&#125;body &#123; /* CSS3 抗锯齿形 让文字显示的更加清晰 */ -webkit-font-smoothing: antialiased; background-color: #fff; font: 12px/1.5 Microsoft YaHei, Heiti SC, tahoma, arial, Hiragino Sans GB, &quot;\\5B8B\\4F53&quot;, sans-serif; color: #666&#125;.hide,.none &#123; display: none&#125;/* 清除浮动 */.clearfix:after &#123; visibility: hidden; clear: both; display: block; content: &quot;.&quot;; height: 0&#125;.clearfix &#123; *zoom: 1&#125; 图片模糊处理 CSS3滤镜filter filter CSS属性将模糊或颜色偏移等图形效果应用于元素 语法: filter: 函数(); 例如: filter:blur(5px); blur模糊处理，数值越大越模糊 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; img &#123; /* blur是一个函数 小括号里面数值越大，图片越模糊 注意数值要加px单位 */ filter: blur(15px); &#125; img:hover &#123; filter: blur(0); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=&quot;images/img.jpg&quot;&gt;&lt;/body&gt;&lt;/html&gt; 浏览器私有前缀 浏览器私有前缀是为了兼容老版本的写法,比较新版本的浏览器无须添和加。 私有前缀 -moz- :代表firefox浏览器私有属性 -ms- :代表ie浏览器私有属性 -webkit- :代表safari. chrome 私有属性 -0- :代表Opera私有属性 1234-moz -border- radius: 10px;-webkit-border -radius: 10px;-o-border- radius: 10px;border- radius: 10px;","path":"page/css01.html","date":"01-21","excerpt":"","tags":[{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"http://xiaoliblog.cn/tags/HTML-CSS/"}]},{"title":"前端三剑客🎉网页背景","text":"网页背景背景颜色一般情况下元素背景色是tansparent(透明) 1background-color:transparent | color颜色值 背景图片1background-image:none | url(url) 背景平铺默认情况下，背景图片是平铺的 1backgound-repeat: repeat | no-repeat | repeat-x | repeat-y 背景图片位置1background-position: x y; 参数代表的意思是：x坐标和y坐标。可以使用方位名词或者精确单位 方位名词方位名词：top|center|bottom|left|center|right 1background-position: center top; 1background-position:right center; 如果是方位名词，和顺序无关，center right和right center效果等价如果只指定了一个方位名词，另一个值省略，则第二个值默认居中对齐 1background-position:left; /*水平一定靠左，y轴居中显示*/ 精确单位如果参数值是精确坐标，那么第一个肯定是x坐标，第二个一定是y坐标 1background-positon:20px 50px; 如果只指定了一共数值，那该数值一定是x坐标，另一个默认垂直居中 1background-position:20px; 混合参数如果指定的两个值是精确单位和方位名词混合使用，则第一个值是x坐标，第二个值是y坐标 1background-position:20px center; 背景固定background-attachment属性设置背景图像是否固定或者随着页面的其余部分滚动background-attachment可以用于制作视差滚动效果 1background-attachment:scroll | fixed; scroll 背景图像随着对象内容滚动 fixed 背景图像固定 1background-attachment:fixed; 背景属性复合写法background:背景颜色|背景图片|背景平铺|背景图像滚动|背景图片位置; 1background: transparent url(image.jpg) repeat-y fixed top; 背景色半透明1background:rgba(0,0,0,0.3); 最后一个参数是alpha透明度，取值范围在0~1之间 习惯把0.3的0省略掉，写为background:rgba(0,0,0,.3); 注意：背景半透明是指盒子背景半透明，盒子里面的内容不受影响 渐变色背景12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; box-sizing: border-box; margin: 0; padding: 0; &#125; body &#123; width: 100vw; height: 100vh; background: linear-gradient( 135deg, hsl(170deg, 80%, 70%), hsl(190deg, 80%, 70%), hsl(250deg, 80%, 70%), hsl(320deg, 80%, 70%) ); background-size: 200% 200%; animation: gradient-move 15s ease alternate infinite; &#125; @keyframes gradient-move &#123; 0% &#123; background-position: 0% 0%; &#125; 100% &#123; background-position: 100% 100%; &#125; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; 昼夜交替效果123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;昼夜交替效果&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;checkbox&quot; /&gt; &lt;label for=&quot;checkbox&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;/label&gt; &lt;div class=&quot;background&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159* &#123; /* 初始化 清除元素的内外边距 */ padding: 0; margin: 0;&#125;body &#123; /* 弹性布局 让页面元素垂直+水平居中 */ display: flex; justify-content: center; align-items: center; /* 让页面占浏览器可视区域的宽的和高度 */ width: 100vm; height: 100vh;&#125;.background &#123; /* 绝对定位 因为该元素没有父元素 那么就默认以浏览器可视区域来定位 */ position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #c2e9f6; /* 元素的堆叠顺序 不加这个属性的话其它元素就被覆盖了 这个值只要是个-值即可 */ z-index: -1; /* 提前加好元素的过渡 不然待会一个一个加就晕了 ease-in是从慢速开始一直加速到结束 */ transition: all 0.25s ease-in;&#125;input &#123; /* 隐藏复选框 */ display: none;&#125;label &#123; position: relative; width: 200px; height: 100px; border-radius: 100px; border: 5px solid #72cce3; background-color: #96dcee; transition: all 0.35s ease-in;&#125;label::before &#123; content: &quot;&quot;; position: absolute; top: 4px; left: 4px; width: 82px; height: 82px; border-radius: 50%; border: 5px solid #f5eb71; background-color: #fffaa8; transition: all 0.35s ease-in; animation: switch-reverse 0.35s forwards; /* 鼠标移入变小手 */ cursor: pointer;&#125;label::after &#123; content: &quot;&quot;; position: absolute; top: 23px; left: 143px; width: 10px; height: 10px; border-radius: 50%; box-shadow: -13px 0 0 2px #e8e8ea, -24px 14px 0 -2px #e8e8ea; transition: all 0.25s ease-in; /* 不透明度 为0 就是隐藏了 */ opacity: 0;&#125;label span &#123; position: relative; top: 45px; left: 135px; /* span是行内元素 需要将其转为块级元素才能设置宽度和高度 */ display: block; width: 10px; height: 5px; border-radius: 5px; background-color: #fff; transition: all 0.15s ease-in;&#125;label span::before,label span::after &#123; /* 将两个伪元素相同的代码写一块 */ content: &quot;&quot;; position: absolute; width: 40px; height: 5px; border-radius: 5px; background-color: #fff; transition: all 0.15s ease-in;&#125;label span::before &#123; top: -5px; left: -20px;&#125;label span::after &#123; top: 5px; left: -10px;&#125;input:checked ~ .background &#123; background-color: #808fc7;&#125;input:checked + label &#123; border-color: #5d6baa; background-color: #6b7abb;&#125;input:checked + label::before &#123; border-color: #e8e8ea; background-color: #fff; /* 这里面需要动画我们先把动画定义好 */ /* 动画 名称 时长 forwards就是动画完成后定制100%是的状态 */ animation: switch 0.35s forwards;&#125;input:checked + label::after &#123; opacity: 1; /* 过渡延迟时间 */ transition-delay: 0.25s;&#125;input:checked + label span &#123; width: 5px; left: 60px;&#125;input:checked + label span::before &#123; width: 5px; height: 5px; top: -25px;&#125;input:checked + label span::after &#123; width: 5px; height: 5px; top: 20px; left: -30px;&#125;@keyframes switch &#123; 0% &#123; left: 4px; &#125; 60% &#123; left: 4px; width: 112px; &#125; 100% &#123; left: 104px; &#125;&#125;/* 顺便定义取消复选框选中状态的动画 */@keyframes switch-reverse &#123; 0% &#123; left: 104px; &#125; 60% &#123; left: 72px; width: 112px; &#125; 100% &#123; left: 4px; &#125;&#125; 自定义404页面12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; dir=&quot;ltr&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;h2&gt;Oops! Page not found.&lt;/h2&gt; &lt;h1&gt;404&lt;/h1&gt; &lt;p&gt;We can&#x27;t find the page you&#x27;re looking for.&lt;/p&gt; &lt;a href=&quot;#&quot;&gt;Go back home&lt;/a&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839body&#123; margin: 0; padding: 0; font-family: &quot;montserrat&quot;,sans-serif; min-height: 100vh; background-image: linear-gradient(125deg,#6a89cc,#b8e994);&#125;.container&#123; width: 100%; position: absolute; top: 50%; transform: translateY(-50%); text-align: center; color: #343434&#125;.container h1&#123; font-size: 160px; margin: 0; font-weight: 900; letter-spacing: 20px; /*自定义背景图片*/ background: url(bg.gif) center no-repeat; -webkit-text-fill-color: transparent; -webkit-background-clip: text;&#125;.container a&#123; text-decoration: none; background: #e55039aa; color: #fff; padding: 12px 24px; display: inline-block; border-radius: 25px; font-size: 14px; text-transform: uppercase; transition: 0.4s;&#125;.container a:hover&#123; background: #e55039;&#125; 加载页面12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Loading&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;preloader&quot;&gt; &lt;div id=&quot;loader&quot;&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556body &#123; background-color: #222;&#125;#preloader &#123; position: fixed; top: 0; left: 0; width: 100%; height: 100%;&#125;#loader &#123; display: block; position: relative; left: 50%; top: 50%; width: 150px; height: 150px; margin: -75px 0 0 -75px; border-radius: 50%; border: 3px solid transparent; border-top-color: #9370DB; animation: spin 2s linear infinite;&#125;#loader::before &#123; content: &#x27;&#x27;; position: absolute; top: 5px; left: 5px; right: 5px; bottom: 5px; border-radius: 50%; border: 3px solid transparent; border-top-color: #BA55D3; animation: spin 3s linear infinite; &#125;#loader::after &#123; content: &#x27;&#x27;; position: absolute; top: 15px; left: 15px; right: 15px; bottom: 15px; border-radius: 50%; border: 3px solid transparent; border-top-color: #FF00FF; animation:spin 1.5s linear infinite;&#125;@keyframes spin &#123; 0% &#123; transform: rotate(0deg); &#125; 100% &#123; transform: rotate(360deg); &#125;&#125; CSS波浪效果123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;CSS波浪&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 头部盒子 --&gt; &lt;div class=&quot;header&quot;&gt; &lt;!-- 标题区域 --&gt; &lt;div class=&quot;lnner-header&quot;&gt; &lt;h1&gt;CSS波浪&lt;/h1&gt; &lt;/div&gt; &lt;!-- 波浪区域 --&gt; &lt;div&gt; &lt;!-- svg 形状 --&gt; &lt;svg class=&quot;waves&quot; viewBox=&quot;0 24 150 28&quot; preserveAspectRatio=&quot;none&quot; shape-rendering=&quot;auto&quot;&gt; &lt;!-- 形状容器 --&gt; &lt;defs&gt; &lt;path id=&quot;gentle-wave&quot; d=&quot;M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z&quot; /&gt; &lt;/defs&gt; &lt;!-- 组合形状 --&gt; &lt;g class=&quot;parallax&quot;&gt; &lt;use xlink:href=&quot;#gentle-wave&quot; x=&quot;48&quot; y=&quot;0&quot; fill=&quot;rgba(255,255,255,0.7&quot; /&gt; &lt;use xlink:href=&quot;#gentle-wave&quot; x=&quot;48&quot; y=&quot;3&quot; fill=&quot;rgba(255,255,255,0.5)&quot; /&gt; &lt;use xlink:href=&quot;#gentle-wave&quot; x=&quot;48&quot; y=&quot;5&quot; fill=&quot;rgba(255,255,255,0.3)&quot; /&gt; &lt;use xlink:href=&quot;#gentle-wave&quot; x=&quot;48&quot; y=&quot;7&quot; fill=&quot;#fff&quot; /&gt; &lt;/g&gt; &lt;/svg&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778body &#123; margin: 0;&#125;h1 &#123; font-family: &#x27;Lato&#x27;,&#x27;sans-serif&#x27;; font-weight: 300; /* font-spacing:2px; */ font-size: 48px;&#125;.header &#123; position: relative; text-align: center; /* 背景渐变 */ background: linear-gradient(60deg,rgba(84,58,183,1) 0%, rgba(0,172,193,1) 100%); color: wheat;&#125;.lnner-header &#123; height: 65vh; width: 100%; margin: 0; padding: 0; /* flex */ /* 垂直居中 */ display: flex; justify-content: center; align-items: center;&#125;.waves &#123; position: relative; width: 100%; height: 15vh; margin-bottom: -7px; /* 最小值 */ min-height: 100px; /* 最大值 */ max-height: 150px;&#125;.parallax&gt;use &#123; animation: move-forever 25s cubic-bezier(.55,.5,.45,.5) infinite;&#125;/* 选择的一个use */.parallax&gt;use:nth-child(1) &#123; /* 延迟 2s 执行 */ animation-delay: -2s; /* 7s 内 执行完毕 */ animation-duration: 7s;&#125;.parallax&gt;use:nth-child(2) &#123; animation-delay: -3s; animation-duration: 10s;&#125;.parallax&gt;use:nth-child(3) &#123; animation-delay: -4s; animation-duration: 13s;&#125;.parallax&gt;use:nth-child(4) &#123; animation-delay: -5s; animation-duration: 20s;&#125;/* 动画 */@keyframes move-forever &#123; 0% &#123; transform: translate3d(-90px,0,0); &#125; 100% &#123; transform: translate3d(85px,0,0); &#125;&#125;/* 当屏幕小于 768px 执行 */@media (max-width : 768px) &#123; .waves &#123; height: 40px; min-height: 40px; &#125; h1 &#123; font-size: 24px; &#125;&#125;","path":"page/css14.html","date":"01-20","excerpt":"","tags":[{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"http://xiaoliblog.cn/tags/HTML-CSS/"}]},{"title":"前端三剑客🎉Grid网格布局","text":"参考👉👉👉CSS Grid 布局完全指南(图解 Grid 详细教程)||CSS Grid 网格布局教程 网格布局网格布局（Grid）是最强大的 CSS 布局方案。 它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。以前，只能通过复杂的 CSS 框架达到的效果，现在浏览器内置了。上图这样的布局，就是 Grid 布局的拿手好戏。 Grid 布局与 Flex 布局有一定的相似性，都可以指定容器内部多个项目的位置。但是，它们也存在重大区别。 Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是一维布局。Grid 布局则是将容器划分成&quot;行&quot;和&quot;列&quot;，产生单元格，然后指定”项目所在”的单元格，可以看作是二维布局。Grid 布局远比 Flex 布局强大。 基本概念 容器和项目 采用网格布局的区域，称为”容器”（container）。容器内部采用网格定位的子元素，称为”项目”（item）。 12345&lt;div&gt; &lt;div&gt;&lt;p&gt;1&lt;/p&gt;&lt;/div&gt; &lt;div&gt;&lt;p&gt;2&lt;/p&gt;&lt;/div&gt; &lt;div&gt;&lt;p&gt;3&lt;/p&gt;&lt;/div&gt;&lt;/div&gt; 上面代码中，最外层的&lt;div&gt;元素就是容器，内层的三个&lt;div&gt;元素就是项目 注意：项目只能是容器的顶层子元素，不包含项目的子元素，比如上面代码的&lt;p&gt;元素就不是项目。Grid 布局只对项目生效 行和列 容器里面的水平区域称为”行”（row），垂直区域称为”列”（column）。 单元格 行和列的交叉区域，称为”单元格”（cell）。正常情况下，n行和m列会产生n x m个单元格。比如，3行3列会产生9个单元格。 网格线 划分网格的线，称为”网格线”（grid line）。水平网格线划分出行，垂直网格线划分出列。 容器属性Grid 布局的属性分成两类。一类定义在容器上面，称为容器属性；另一类定义在项目上面，称为项目属性。这部分先介绍容器属性。 display属性123div&#123; display: grid;&#125; 网格项目按行排列，网格项目占用整个容器的宽度，容器元素都是块级元素 123div&#123; display: inline-grid;&#125; 网格项目按行排列，网格项目宽度由自身宽度决定，容器为行内元素 注意，设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-\\*等设置都将失效。 显示网格容器指定了网格布局以后，接着就要划分行和列。grid-template-columns属性定义每一列的列宽，grid-template-rows属性定义每一行的行高 12345.container &#123; display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px;&#125; 上面代码指定了一个三行三列的网格，列宽和行高都是100px。除了使用绝对单位，也可以使用百分比 12345.container &#123; display: grid; grid-template-columns: 33.33% 33.33% 33.33%; grid-template-rows: 33.33% 33.33% 33.33%;&#125; repeat()有时候，重复写同样的值非常麻烦，尤其网格很多时。这时，可以使用repeat()函数，简化重复的值。上面的代码用repeat()改写如下。 12345.container &#123; display: grid; grid-template-columns: repeat(3, 33.33%); grid-template-rows: repeat(3, 33.33%);&#125; repeat()接受两个参数，第一个参数是重复的次数（上例是3），第二个参数是所要重复的值。repeat()重复某种模式也是可以的 1grid-template-columns: repeat(2, 100px 20px 80px); 上面代码定义了6列，第一列和第四列的宽度为100px，第二列和第五列为20px，第三列和第六列为80px auto-fill关键字有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用auto-fill关键字表示自动填充 1234.container &#123; display: grid; grid-template-columns: repeat(auto-fill, 100px);&#125; 上面代码表示每列宽度100px，然后自动填充，直到容器不能放置更多的列 fr关键字为了方便表示比例关系，网格布局提供了fr关键字（fraction 的缩写，意为”片段”）。如果两列的宽度分别为1fr和2fr，就表示后者是前者的两倍 1234.container &#123; display: grid; grid-template-columns: 1fr 1fr;&#125; 上面代码表示两个相同宽度的列fr可以与绝对长度的单位结合使用，这时会非常方便 1234.container &#123; display: grid; grid-template-columns: 150px 1fr 2fr;&#125; 上面代码表示，第一列的宽度为150像素，第二列的宽度是第三列的一半 minmax()minmax()函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值 1grid-template-columns: 1fr 1fr minmax(100px, 1fr); 上面代码中，minmax(100px, 1fr)表示列宽不小于100px，不大于1fr。 auto关键字auto关键字表示由浏览器自己决定长度。 1grid-template-columns: 100px auto 100px; 上面代码中，第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了min-width，且这个值大于最大宽度 网格线的名称grid-template-columns属性和grid-template-rows属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。 12345.container &#123; display: grid; grid-template-columns: [c1] 100px [c2] 100px [c3] auto [c4]; grid-template-rows: [r1] 100px [r2] 100px [r3] auto [r4];&#125; 上面代码指定网格布局为3行 x 3列，因此有4根垂直网格线和4根水平网格线。方括号里面依次是这八根线的名字。网格布局允许同一根线有多个名字，比如[fifth-line row-5]。 布局实例grid-template-columns属性对于网页布局非常有用。两栏式布局只需要一行代码 1234.wrapper &#123; display: grid; grid-template-columns: 70% 30%;&#125; 上面代码将左边栏设为70%，右边栏设为30%。传统的十二网格布局，写起来也很容易 1grid-template-columns: repeat(12, 1fr); 定义网格间隙grid-row-gap属性设置行与行的间隔（行间距），grid-column-gap属性设置列与列的间隔（列间距） 1234 .container &#123; grid-row-gap: 20px; grid-column-gap: 20px;&#125; 上面代码中，grid-row-gap用于设置行间距，grid-column-gap用于设置列间距grid-gap属性是grid-column-gap和grid-row-gap的合并简写形式，语法如下。 1grid-gap: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;; 因此，上面一段 CSS 代码等同于下面的代码。 123.container &#123; grid-gap: 20px 20px;&#125; 如果grid-gap省略了第二个值，浏览器认为第二个值等于第一个值。 根据最新标准，上面三个属性名的grid-前缀已经删grid-column-gap和grid-row-gap写成column-gap和row-gap，grid-gap写成gap。 用网格区域命名和定位项目网格布局允许指定”区域”（area），一个区域由单个或多个单元格组成。grid-template-areas属性用于定义区域 12345678.container &#123; display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px; grid-template-areas: &#x27;a b c&#x27; &#x27;d e f&#x27; &#x27;g h i&#x27;;&#125; 上面代码先划分出9个单元格，然后将其定名为a到i的九个区域，分别对应这九个单元格多个单元格合并成一个区域的写法如下 123grid-template-areas: &#x27;a a a&#x27; &#x27;b b b&#x27; &#x27;c c c&#x27;; 上面代码将9个单元格分成a、b、c三个区域 下面是一个布局实例 123grid-template-areas: &quot;header header header&quot; &quot;main main sidebar&quot; &quot;footer footer footer&quot;; 上面代码中，顶部是页眉区域header，底部是页脚区域footer，中间部分则为main和sidebar。 如果某些区域不需要利用，则使用”点”（.）表示。 123grid-template-areas: &#x27;a . c&#x27; &#x27;d . f&#x27; &#x27;g . i&#x27;; 上面代码中，中间一列为点，表示没有用到该单元格，或者该单元格不属于任何区域 注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名-start，终止网格线自动命名为区域名-end。比如，区域名为header，则起始位置的水平网格线和垂直网格线叫做header-start，终止位置的水平网格线和垂直网格线叫做header-end。 隐式网格划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行，即下图数字的顺序这个顺序由grid-auto-flow属性决定，默认值是row，即”先行后列”。也可以将它设成column，变成”先列后行” 1grid-auto-flow: column; 上面代码设置了column以后，放置顺序就变成了下图。grid-auto-flow属性除了设置成row和column，还可以设成row dense和column dense。这两个值主要用于，某些项目指定位置以后，剩下的项目怎么自动放置。 下面的例子让1号项目和2号项目各占据两个单元格，然后在默认的grid-auto-flow: row情况下，会产生下面这样的布局上图中，1号项目后面的位置是空的，这是因为3号项目默认跟着2号项目，所以会排在2号项目后面。 现在修改设置，设为row dense，表示”先行后列”，并且尽可能紧密填满，尽量不出现空格 1grid-auto-flow: row dense; 上面代码的效果如下。上图会先填满第一行，再填满第二行，所以3号项目就会紧跟在1号项目的后面。8号项目和9号项目就会排到第四行。 如果将设置改为column dense，表示”先列后行”，并且尽量填满空格。 1grid-auto-flow: column dense; 上面代码的效果如下。上图会先填满第一列，再填满第2列，所以3号项目在第一列，4号项目在第二列。8号项目和9号项目被挤到了第四列 网格项目的对齐方式justify-items属性设置单元格内容的水平位置（左中右），align-items属性设置单元格内容的垂直位置（上中下） 1234.container &#123; justify-items: start | end | center | stretch; align-items: start | end | center | stretch;&#125; 这两个属性的写法完全相同，都可以取下面这些值。 start：对齐单元格的起始边缘。 end：对齐单元格的结束边缘。 center：单元格内部居中。 stretch：拉伸，占满单元格的整个宽度（默认值） 123.container &#123; justify-items: start;&#125; 上面代码表示，单元格的内容左对齐，效果如下图 123.container &#123; align-items: start;&#125; 上面代码表示，单元格的内容头部对齐，效果如下图。place-items属性是align-items属性和justify-items属性的合并简写形式。 1place-items: &lt;align-items&gt; &lt;justify-items&gt;; 下面是一个例子。 1place-items: start end; 如果省略第二个值，则浏览器认为与第一个值相等。 网格轨道的对齐方式justify-content属性是整个内容区域在容器里面的水平位置（左中右），align-content属性是整个内容区域的垂直位置（上中下）。 1234.container &#123; justify-content: start | end | center | stretch | space-around | space-between | space-evenly; align-content: start | end | center | stretch | space-around | space-between | space-evenly; &#125; 这两个属性的写法完全相同，都可以取下面这些值。（下面的图都以justify-content属性为例，align-content属性的图完全一样，只是将水平方向改成垂直方向。） start - 对齐容器的起始边框 end - 对齐容器的结束边框 center - 容器内部居中 stretch - 项目大小没有指定时，拉伸占据整个网格容器 space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍 space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔 space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔 place-content属性是align-content属性和justify-content属性的合并简写形式。 1place-content: &lt;align-content&gt; &lt;justify-content&gt; 下面是一个例子。 1place-content: space-around space-evenly; 如果省略第二个值，浏览器就会假定第二个值等于第一个值。 项目属性项目位置属性项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。 grid-column-start属性：左边框所在的垂直网格线 grid-column-end属性：右边框所在的垂直网格线 grid-row-start属性：上边框所在的水平网格线 grid-row-end属性：下边框所在的水平网格线 1234.item-1 &#123; grid-column-start: 2; grid-column-end: 4;&#125; 上面代码指定，1号项目的左边框是第二根垂直网格线，右边框是第四根垂直网格线。图中，只指定了1号项目的左右边框，没有指定上下边框，所以会采用默认位置，即上边框是第一根水平网格线，下边框是第二根水平网格线。 除了1号项目以外，其他项目都没有指定位置，由浏览器自动布局，这时它们的位置由容器的grid-auto-flow属性决定，这个属性的默认值是row，因此会”先行后列”进行排列。读者可以把这个属性的值分别改成column、row dense和column dense，看看其他项目的位置发生了怎样的变化。 下面的例子是指定四个边框位置的效果。 123456.item-1 &#123; grid-column-start: 1; grid-column-end: 3; grid-row-start: 2; grid-row-end: 4;&#125; 这四个属性的值，除了指定为第几个网格线，还可以指定为网格线的名字。 1234.item-1 &#123; grid-column-start: header-start; grid-column-end: header-end;&#125; 上面代码中，左边框和右边框的位置，都指定为网格线的名字。 这四个属性的值还可以使用span关键字，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。 123.item-1 &#123; grid-column-start: span 2;&#125; 上面代码表示，1号项目的左边框距离右边框跨越2个网格。这与下面的代码效果完全一样。 123.item-1 &#123; grid-column-end: span 2;&#125; 使用这四个属性，如果产生了项目的重叠，则使用z-index属性指定项目的重叠顺序。 grid-column属性是grid-column-start和grid-column-end的合并简写形式，grid-row属性是grid-row-start属性和grid-row-end的合并简写形式。 1234.item &#123; grid-column: &lt;start-line&gt; / &lt;end-line&gt;; grid-row: &lt;start-line&gt; / &lt;end-line&gt;;&#125; 下面是一个例子。 1234567891011.item-1 &#123; grid-column: 1 / 3; grid-row: 1 / 2;&#125;/* 等同于 */.item-1 &#123; grid-column-start: 1; grid-column-end: 3; grid-row-start: 1; grid-row-end: 2;&#125; 上面代码中，项目item-1占据第一行，从第一根列线到第三根列线。 这两个属性之中，也可以使用span关键字，表示跨越多少个网格。 1234567891011.item-1 &#123; background: #b03532; grid-column: 1 / 3; grid-row: 1 / 3;&#125;/* 等同于 */.item-1 &#123; background: #b03532; grid-column: 1 / span 2; grid-row: 1 / span 2;&#125; 上面代码中，项目item-1占据的区域，包括第一行 + 第二行、第一列 + 第二列。斜杠以及后面的部分可以省略，默认跨越一个网格。 1234.item-1 &#123; grid-column: 1; grid-row: 1;&#125; 上面代码中，项目item-1占据左上角第一个网格 grid-area属性grid-area属性指定项目放在哪一个区域。 123.item-1 &#123; grid-area: e;&#125; 上面代码中，1号项目位于e区域，效果如下图 grid-area属性还可用作grid-row-start、grid-column-start、grid-row-end、grid-column-end的合并简写形式，直接指定项目的位置。 123.item &#123; grid-area: &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;&#125; 下面是一个例子。 123.item-1 &#123; grid-area: 1 / 1 / 3 / 3;&#125; 项目对齐方式justify-self属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目。 align-self属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目 1234.item &#123; justify-self: start | end | center | stretch; align-self: start | end | center | stretch;&#125; 这两个属性都可以取下面四个值。 start：对齐单元格的起始边缘。 end：对齐单元格的结束边缘。 center：单元格内部居中。 stretch：拉伸，占满单元格的整个宽度（默认值）。 下面是justify-self: start的例子。 123.item-1 &#123; justify-self: start;&#125; place-self属性是align-self属性和justify-self属性的合并简写形式。 1place-self: &lt;align-self&gt; &lt;justify-self&gt;; 下面是一个例子。 1place-self: center center; 如果省略第二个值，place-self属性会认为这两个值相等。","path":"page/css03.html","date":"01-19","excerpt":"","tags":[{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"http://xiaoliblog.cn/tags/HTML-CSS/"}]},{"title":"前端三剑客🎉弹性盒子模型","text":"弹性盒子模型CSS3 新增了弹性盒子模型（Flexible Box 或 FlexBox），是一种新的用于在 HTML 页面实现布局的方式。使得当 HTML 页面适应不同尺寸的屏幕和不同的设备时，元素是可预测地运行。 弹性盒子模型实现 HTML 页面布局是与方向无关的。不类似于块级布局侧重垂直方向，内联布局侧重水平方向。 弹性盒子模型主要适用于 HTML 页面的组件以及小规模的布局，而并不适用于大规模的布局，否则会影响 HTML 页面性能 伸缩容器（flex container）：包裹伸缩项目的父元素。 伸缩项目（flex item）：伸缩容器的每个子元素。 轴（axis）：每个弹性盒子模型拥有两个轴。 主轴（main axis）：伸缩项目沿其一次排列的轴被称为主轴。 侧轴（cross axis）：垂直于主轴的轴被称为侧轴。 方向（direction）：伸缩容器的主轴由主轴起点和主轴终点，侧轴由侧轴起点和侧轴终点描述伸缩项目排列的方向。 尺寸（dimension）：根据伸缩容器的主轴和侧轴，伸缩项目的宽度和高度。 对应主轴的称为主轴尺寸。 对应侧轴的称为侧轴尺寸。 开启Flexbox布局假设有下边这么一个 html 结构： 12345&lt;div class=&quot;flexbox&quot;&gt; &lt;div class=&quot;flex1&quot;&gt;Flex1&lt;/div&gt; &lt;div class=&quot;flex2&quot;&gt;Flex2&lt;/div&gt; &lt;div class=&quot;flex3&quot;&gt;Flex3&lt;/div&gt; &lt;/div&gt; 一个div 容器包含了三个 div 子元素，按照默认的布局方式进行排列。因为 div 是块级元素，每个 div 占了整个一行的空间：如果要开启容器的 flex 布局，只需要在 css 里边给父盒子设置 display: flex 属性 1display: flex; 可以看到里边的三个元素自动变成了一行，因为 flex 默认是按行进行排列的。Flexbox 布局是一维布局方式，要么按行排列，要么按列排列。 定义弹性盒子模型12display : flex;display : inline-flex; flex：设置指定元素为块级元素的弹性盒子模型。 inline-flex：设置指定元素为行内块级元素的弹性盒子模型。 样的，此属性存在浏览器兼容问题： 1234display : -webkit-flex;display: -ms-flex;display: -moz-flex;display: -o-flex; 对齐方式Flex 布局有一个隐式的坐标空间，水平方向有一条主轴(main-axis)，垂直方向上有一条交叉轴(cross-axis)： flex-direction 属性flex-direction 属性适用于伸缩容器元素，用于创建主轴的方向。 1flex-direction: row | row-reverse | column | column-reverse row：设置主轴是水平方向。 row-reverse：与 row 的排列方向相反。 column：设置主轴是垂直方向。 column-reverse：与 column 的排列方向相反。 测试用例 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .flexbox&#123; /* 将当前元素设置为弹性盒子模型的伸缩容器 */ display: flex; /* flex-direction设置主轴的方向 */ /* row:默认值 表示水平方向 column：表示垂直方向 */ flex-direction: column; width:400px; height:300px; border: 1px solid; background-color: rgb(255, 236, 220); &#125; .flex&#123; width:400px; height:50px; border: 1px solid; background-color: rgb(221, 103, 128); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;flexbox&quot;&gt; &lt;div class=&quot;flex&quot; style=&quot;background-color: rgb(115, 226, 174);&quot;&gt;Flex1&lt;/div&gt; &lt;div class=&quot;flex&quot; style=&quot;background-color: rgb(110, 226, 220);&quot;&gt;Flex2&lt;/div&gt; &lt;div class=&quot;flex&quot; style=&quot;background-color: rgb(230, 189, 115);&quot;&gt;Flex3&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; justify-content 属性CSS justify-content 属性适用于伸缩容器元素，用于设置伸缩项目沿着主轴线(即水平方向)的对齐方式 1justify-content: center | flex-start | flex-end | space-between | space-around flex-startflex-start 是默认值，如果是从左到右的文字阅读习惯(LTR)，就是靠左对齐。 1justify-content: flex-start; center居中对齐，此时整个 flex 容器被居中到了页面中间： flex-end靠右对齐： space-between两端对齐，这种对齐方式是第一个和最后一个元素贴边，中间的元素平分剩余的空间： space-evenly分散对齐，所有的元素都平分空间： space-around跟space-evenly类似，但是左右两边的留白为平分空间的 1/2. align-items属性控制交叉轴方向（即垂直方向）上的对齐方式使用align-items属性 1align-items: center | flex-start | flex-end | baseline | stretch stretchstretch 是 align-items 的默认值，它会自动把子元素拉伸成容器的高度(前提子盒子没有设置宽高)，所以之前的例子里子元素在垂直方向上都占满了容器，只要改变容器的align-items的值，它就会变成内容的高度。stretch 对齐效果如下 flex-start靠上对齐，在交叉轴开始的最上方，可以看到子元素不再占满容器高度： center居中对齐 flex-end向下对齐 baseline基线对齐，如果子元素文字尺寸和行高不同，则子元素会按照文字的基线进行对齐： 1234567.flexbox&#123; display: flex; align-items: baseline;&#125;.flex2 &#123; font-size: 24px;&#125; 如果是flex-start 对齐方式： 子元素覆盖对齐方式子元素可以通过设置 align-self 来控制自己在交叉轴上的对齐方式，例如把 .flex3 子元素在垂直方向上靠下对齐： 12345678.flexbox &#123; display: flex; align-items: flex-start;&#125;.flex3 &#123; align-self: flex-end;&#125; 在水平方向上控制子元素对齐并没有justify-self属性，而是使用margin属性，通过把左或右边距设置为auto来控制水平对齐，比如把 flex3 放到最右边： 123.flex3 &#123; margin-left: auto;&#125; 排列方式flex 支持按行排布，也支持按列排布。按列排布时，主轴和交叉轴换了方向，但是 align-items 和 justify-content 控制的轴线不变，即 align-items 还是控制交叉轴，justify-content 控制主轴：所以说，在水平方向上对齐变成了使用align-items，垂直方向则用justify-content。 要使 flex 按列排布，只需要设置 1flex-direction: column; 水平居中对齐12345.flexbox&#123; display: flex; flex-direction: column; align-items: center;&#125; 垂直居中12345.flexbox&#123; display: flex; flex-direction: column; justify-content: center;&#125; row-reverse另外 flex 布局也可以支持反向按行和列布局，相当于按容器中心线进行 180 度翻转： 1234.flexbox&#123; display: flex; flex-direction: row-reverse;&#125; column-reverse列模式下会垂直翻转： 1234.flexbox &#123; display: flex; flex-direction: column-reverse;&#125; 空间占比子元素可以通过设置flex属性来调整空间的占比，例如让 flex2 在水平方向上占据其他子元素的 2 倍大小，可以设置: 123456.flex1,.flex3 &#123; flex: 1;&#125;.flex2 &#123; flex: 2;&#125; Flex-basis在介绍 flex-basis 之前，先讲一个概念 main size，即主轴方向的尺寸，那么，在行排布模式下，也就是水平方向的尺寸，其实就是子元素的宽度，而在列模式下，它是子元素的高度，相对应的也有cross size，即行模式下是子元素的高度，列模式下是宽度。 而flex-basis是用来设置main size的，它的优先级会高于width。它的默认值是auto，即在行模式下，如果子元素设置了宽度，它就取自这个宽度值，没有设置的话，就是内容的宽度。使用 flex-basis，可以同时管理行模式下的宽度和列模式下的高度。 来看一个例子，把之前的子元素改成固定宽度，比如 50px： 123.flexbox &gt; * &#123; flex-basis: 50px;&#125; 如果再添加 width 属性，发现并不会生效： 1234.flexbox &gt; * &#123; flex-basis: 50px; width:100px&#125; 但是，可以通过设置 min-width来强制设置最小宽度： 1234.flexbox &gt; * &#123; flex-basis: 50px; min-width:100px&#125; 同理的，在列模式下，flex-basis变成了高度，因为容器高度为100px，这里把子元素高度设置成了30px总计 90px来效果： 1234567.flexbox&#123; flex-direction: column;&#125;.flexbox&gt; * &#123; flex-basis: 30px;&#125; 同样的，也可以用min-height来控制最小高度 缩放（后续例子都假设是行模式）之前的小节简单说了一下 flex 子元素空间的占比，这里把缩放单独拿出来是为了说明：除了调整 flex 子元素的增长之外，也可以调整收缩，以及flex属性背后的原理（下一小节）。 flex-grow先看一下增长，flex-grow，这个属性是说 flex 容器在有剩余空间的时候，子元素占据剩余空间的占比。例如，给.flex2子元素设置： 123.flex2 &#123; flex-grow: 1;&#125; 其它的元素保持默认的宽度（即内容的宽度，flex-basis 为 auto)，那么.flex2就会自动增长并占据整个剩余空间：如果把三个元素全部设置成 1，那么所有元素都会自动增长，并各自占据 1/3 的空间：使用 flex-grow就能够自由的调整元素的空间占比了，非常适合一些浮动的布局。 flex-shrink子元素的收缩是说：当它们的宽度超过 flex 容器之后，该如何进行收缩。通过 flex-shrink 来设置一个数值，数值越大，收缩程度也越大，比如flex-shrink: 2的元素会比flex-shrink:1收缩的值大 2 倍： flex属性说完flex-grow、flex-shrink 和 flex-basis 之后，再来看一下这个flex属性，它其实是前边三个属性的缩写，默认值是 0 1 auto，即不增长，但收缩，收缩比例为 1，flex-basis 为 auto，即取自用户定义的宽度或内容的宽度。 flex 的值可以是下边几种： 指定一个数字 - 例如flex: 1，就等同于是flex: 1 1 0，即自动缩放，比例为 1，flex-basis 为 0。 auto - 等同于flex: 1 1 auto。 指定两个数字 - 第一个为flex-grow，第二个，如果是数字则认为是 flex-shrink，如果是宽度，则是flex-basis。 指定三个值 - 分别为flex-grow，flex-shrink 和 flex-basis。 所以说，通过flex属性可以方便的同时设置flex-grow、flex-shrink 和 flex-basis 这三个值。 折行如果子元素有固定宽度，并且超出了容器的宽度，还不允许收缩的话，那么可以使用flex-wrap属性来让元素进行折行排列，使得每行的元素都不超过容器的宽度。这里跟 css grid 布局的主要区别是，它无法控制单独控制行、列的占比，比如跨行、夸列，也不能自由定位元素到特定的位置。下边的示例新增了 2 个元素，一共 5 个，每个元素的 main size 为 300px，然后超出宽度后折行： 12345678.flexbox&#123; flex-wrap: wrap;&#125;.flexbox&gt; * &#123; flex-shrink: 0; flex-basis: 300px;&#125; align-content如果 flex 容器开启了折行，那么两行及以上的内容可以通过align-content属性来控制各行之间在交叉轴上的排列规则，它的取值和 justify-content基本相同，这里演示其中几个，还是使用之前三个元素的flex容器，每个容器宽度为 300px，超出后换行： 1234567.flexbox &#123; display: flex; flex-wrap: wrap;&#125;.flexbox &gt; * &#123; flex-basis: 300px;&#125; center居中对齐 space-between两端对齐 嵌套的 flex 容器的问题如果 HTML 结构复杂，有嵌套的 flex 容器，很有可能会遇到嵌套的 flex 容器并不能自动收缩的问题，即使设置了flex-shrink。比如有下边一个 html 结构： 12345678910&lt;div class=&quot;flex&quot;&gt; &lt;div class=&quot;flex1&quot;&gt;Flex 1&lt;/div&gt; &lt;div class=&quot;flex2&quot;&gt;Flex 2&lt;/div&gt; &lt;div class=&quot;flex3&quot;&gt;Flex 3&lt;/div&gt; &lt;div class=&quot;flex4&quot;&gt; &lt;p&gt; 这是一段很长很长很长很长很长很长很长很长很长很长很长很长长很长很长很长很长很长长很长很长很长很长很长的文本 &lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 这里给之前的 flex 容器添加了一个新的子元素.flex4，这 4 个子元素都设置成flex: 1来平分空间，但是 .flex4 自己本身也是一个flex布局的容器，里边有一长串文本，我想让它超长之后自动显示省略号，它的 CSS 代码： 12345678910111213141516.flexbox&#123; display: flex;&#125;.flexbox&gt; * &#123; flex: 1;&#125;.flex4 &#123; display: flex; flex: 1; min-width: 0;&#125;.flex4 &gt; p &#123; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;&#125; 总结 开启 flex 布局使用display: flex属性。 flex 布局有主轴和交叉轴，分别使用justify-content和align-items控制对齐方式。 支持按行或列进行排列，使用flex-direction，另外也支持row-reverse和column-reverse反向排列。 子元素可以通过flex简写形式，或者flex-grow，flex-shrink，flex-basis 来调整元素的空间占比和缩放。 通过flex-wrap可以设置flex 子元素折行显示。 嵌套flex容器的缩放问题。","path":"page/css07.html","date":"01-19","excerpt":"","tags":[{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"http://xiaoliblog.cn/tags/HTML-CSS/"}]},{"title":"前端三剑客🎉动画","text":"动画CSS3 新增 animation 属性使得仅通过 CSS 的样式属性实现动画效果成为可能。实现动画包括两个部分： 用于定义动画的样式规则 用于设置动画开始、结束以及中间点样式的关键帧相对于传统使用 JavaScript 实现的动画方式，CSS3 新增的 animation 属性具有以下三个优点: 能够非常容易地创建简单动画，甚至不需要掌握 JavaScript。 动画运行效果良好，可以在低性能的系统运行。性能以及流畅程度都优于 JavaScript 实现画效果。 允许浏览器优化动画的性能和效果，让浏览器控制动画序列。 animation实现动画主要由两个部分组成 通过类似Flash 动画的 关键帧来声明一个动画 在 在animation 属性中 调用关键帧声明的动画实现一个更为复杂的动画效果 动画序列声明动画通过使用 @keyframes 建立两个或两个以上关键帧来实现。每一个关键帧都描述了动画元素在给定的时间点上应该如何渲染 123@keyframes &lt;keyframes-name&gt;&#123; &lt;keyframe-block-list&gt;&#125; keyframes-name用于设置当前动画的名称，以便通过 animation-name 属性调用 keyframe-block-list用于设置动画执行过程中的关键帧 12345678@keyframes &lt;keyframes-name&gt;&#123; 0%&#123; width:100px; &#125; 100%&#123; height:200px; &#125;&#125; 0%是动画的开始，100%是动画的完成。这样的规则就是动画序列 使用@keyframes中规定的某项CSS样式，就能创建由当前样式逐渐改变为新样式的动画效果 动画是使元素从一种样式逐渐变化为另一种样式的效果。可以改变任意多的样式任意多的次数 用百分比来规定变化发生的时间，或用关键词“from”和“to”，等同于0%和100% 实现动画动画执行完成后自动回归原始状态不需要触发条件 设置关键帧动画的名称（至少要包含两个 开始和结束）其中过程的关键字 (from、to) 可用百分比（0%、100%）替换 12345678910@keyframes animate&#123; from&#123; width: 200px; height: 200px; &#125; to&#123; width: 400px; height: 400px; &#125;&#125; 通过animation相关属性实现动画效果 123456789.box&#123; width: 200px; height: 200px; background: lightcoral; /* 设置执行动画的名称 与关键帧对应 */ animation-name: animate; /* 动画执行的时间 */ animation-duration: 2s;&#125; 以上两个子属性可简写为一个属性 1animation: animate 2s; 多个状态12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /* 动画序列 */ /* 1. 可以做多个状态的变化 keyframe 关键帧 */ /* 2. 里面的百分比要是整数 */ /* 3. 里面的百分比就是 总的时间（我们这个案例10s）的划分 25% * 10 = 2.5s */ @keyframes move &#123; 0% &#123; transform: translate(0, 0); &#125; 25% &#123; /*x移动，y不变*/ transform: translate(1000px, 0) &#125; 50% &#123;/*x不变，y移动*/ transform: translate(1000px, 500px); &#125; 75% &#123; /*x移动复原，y不动*/ transform: translate(0, 500px); &#125; 100% &#123; /*复原*/ transform: translate(0, 0); &#125; &#125; div &#123; width: 100px; height: 100px; background-color: pink; animation-name: move; animation-duration: 10s; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 动画属性 属性 描述 @keyframes 规定动画 animation 所有动画属性的简写属性，除了animation-play-state属性 animation-name [必选]规定@keyframes动画的名词 animation-duration [必选]规定动画完成一个周期所花费的秒或毫秒，默认为0 animation-timing-function 规定动画的速度曲线,默认是”ease“ animation-delay 规定动画何时开始，默认是0 animation-iteration-count 规定动画被播放的次数，默认是1，还有infinite循环播放 animation-direction 规定动画是否在下一周期逆向播放，默认是”normal”，alternate逆播放 animation-play-state 规定动画是否正在运行或暂停，默认是”running”,还有”pause” animation-fill-mode 规定动画结束后状态，保持forwards，回到起始backwards 基础属性12345678910111213141516171819@keyframes move &#123; 0% &#123; transform: translate(0, 0); &#125; 100% &#123; transform: translate(500px, 0); &#125; &#125;div &#123; width: 100px; height: 100px; background-color: pink; /* 动画名称 */ animation-name: move; /* 持续时间 */ animation-duration: 2s; /* 运动曲线 */ animation-timing-function: ease; &#125; 动画何时开始animation-delay属性控制 123456789101112131415161718192021@keyframes move &#123; 0% &#123; transform: translate(0, 0); &#125; 100% &#123; transform: translate(500px, 0); &#125; &#125;div &#123; width: 100px; height: 100px; background-color: pink; /* 动画名称 */ animation-name: move; /* 持续时间 */ animation-duration: 2s; /* 运动曲线 */ animation-timing-function: ease; /*何时开始*/ animation-delay: 1s; /*1s后开始*/&#125; 动画速度曲线animation-timing-function：规定动画的速度曲线，默认是”ease“ 属性值 描述 linear 匀速 ease 默认。动画以低速开始，然后加快，在结束前变慢 ease-in 低速开始 ease-out 低速结束 ease-in-out 低速开始和结束 steps() 指定了时间函数中的间隔数量（步长） 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; div &#123; overflow: hidden; font-size: 20px; width: 0; height: 30px; background-color: rgb(89, 158, 214); /* 让我们的文字强制一行内显示 */ white-space: nowrap; /* steps 就是分几步来完成我们的动画 有了steps 就不要在写 ease 或者linear 了 */ animation: w 4s steps(10) forwards; &#125; @keyframes w &#123; 0% &#123; width: 0; &#125; 100% &#123; width: 200px; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;小李博客我在这里等你&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 动画执行的次数animation-iteration-count 属性控制，有数值和infinite值 12345678910111213141516171819202122@keyframes move &#123; 0% &#123; transform: translate(0, 0); &#125; 100% &#123; transform: translate(500px, 0); &#125; &#125;div &#123; width: 100px; height: 100px; background-color: pink; /* 动画名称 */ animation-name: move; /* 持续时间 */ animation-duration: 2s; /* 运动曲线 */ animation-timing-function: ease; /*重复次数*/ animation-iteration-count: infinite;/*重复无限次*/ /*animation-iteration-count: 2; /*重复两次*/&#125; 动画执行的方向 每个循环内动画向前循环 即动画循环结束后直接回到起点重新开始 默认值 animation-direction: normal; 动画交替反向运行，反向运动时，动画起步后退，同时，带时间功能的函数也反向 animation-direction: alternate; 反向运动动画，每周期结束动画由尾到头运行 animation-direction: reverse; 反向交替，反向开始交替 动画第一次运行时是反向的， 然后下一次是正向，后面依次循环 animation-direction: alternate-reverse; 测试的次数必须为多次或者无限次，一次没有效果 animation-iteration-count: infinite; normal默认值 动画循环结束后直接回到起点重新开始 alternate动画交替反向运行，反向运动时，动画起步后退，同时，带时间功能的函数也反向。 reverse反向运动动画，每周期结束动画由尾到头运行 alternate-reverse反向交替，反向开始交替 动画第一次运行时是反向的， 然后下一次是正向，后面依次循环 动画执行的状态 动画运行 animation-play-state: running; 动画暂停 animation-play-state: paused; 12345678910111213141516171819202122232425262728@keyframes move &#123; 0% &#123; transform: translate(0, 0); &#125; 100% &#123; transform: translate(500px, 0); &#125;&#125; div &#123; width: 100px; height: 100px; background-color: pink; /* 动画名称 */ animation-name: move; /* 持续时间 */ animation-duration: 2s; /* 运动曲线 */ animation-timing-function: ease; /*动画次数*/ animation-iteration-count: infinite; /*动画方向*/ animation-direction: alternate;&#125;div:hover&#123; /*鼠标经过div，暂停动画*/ animation-play-state: paused;&#125; 设置动画时间外属性animation-fill-mode: 属性用于设置动画执行之前和执行之后如何为动画的目标元素应用样式 12animation-fill-mode:backforwards;animation-fill-mode:forwards; backwards默认行为，回到起始位置 forwards停留在结束状态 动画简写属性 动画简写属性 animation: 动画名称 持续时间 运动曲线 何时开始 播放次数 是否反方向 动画起始或结束的状态; 123div&#123; animation:move 5s liner 2s infinite alternate;&#125; 简写属性里面不包含animation-play-state 暂停动画：animation-play-state: puased; 经常和鼠标经过等其他配合使用 想要动画走回来，而不是跳回来：animation-direction:alternate 盒子动画结束后，停在结束位置：animation-fill-mode: forwards 实例大数据热点图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /*指定颜色就可以显示图片*/ body &#123; background-color: #333; &#125; /*背景透明图片*/ .map &#123; position: relative; width: 747px; height: 616px; background: url(img/map.png) no-repeat; margin: 0 auto;/*居中*/ &#125; /*北京大盒子*/ .city &#123; position: absolute; top: 227px; right: 193px; color: #fff; &#125; /*台北大盒子*/ .tb &#123; top: 500px; right: 80px; &#125; /*具体位置可以F12微调*/ /*小蓝点*/ .dotted &#123; width: 8px; height: 8px; background-color: #09f; border-radius: 50%; &#125; /*三个波纹*/ .city div[class^=&quot;pulse&quot;] &#123; /* 保证我们小波纹在父盒子里面水平垂直居中 放大之后就会中心向四周发散 */ position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 8px; height: 8px; box-shadow: 0 0 12px #009dfd; /*盒子阴影*/ border-radius: 50%; /*调用动画 liner匀速 infinite循环*/ animation: pulse 1.2s linear infinite; &#125; /*定义波纹动画顺序*/ .city div.pulse2 &#123; animation-delay: 0.4s; &#125; .city div.pulse3 &#123; animation-delay: 0.8s; &#125; /*定义波纹动画*/ @keyframes pulse &#123; 0% &#123;&#125; /*从8px-&gt;40px，透明度不变*/ 70% &#123; /* transform: scale(5); 我们不要用scale 因为他会让 阴影变大*/ width: 40px; height: 40px; opacity: 1;/*透明度*/ &#125; /*40px-&gt;70px，透明度0消失*/ 100% &#123; width: 70px; height: 70px; opacity: 0; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;map&quot;&gt; &lt;!--北京--&gt; &lt;div class=&quot;city&quot;&gt; &lt;!--小蓝点--&gt; &lt;div class=&quot;dotted&quot;&gt;&lt;/div&gt; &lt;!--三个波纹--&gt; &lt;div class=&quot;pulse1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;pulse2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;pulse3&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!--台北--&gt; &lt;div class=&quot;city tb&quot;&gt; &lt;div class=&quot;dotted&quot;&gt;&lt;/div&gt; &lt;div class=&quot;pulse1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;pulse2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;pulse3&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 奔跑的熊大12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; body &#123; background-color: #ccc; &#125; div &#123; position: absolute; width: 200px; height: 100px; background: url(img/bear.png) no-repeat; /* 我们元素可以添加多个动画， 用逗号分隔 */ animation: bear .4s steps(8) infinite, move 3s forwards; &#125; @keyframes bear &#123; 0% &#123; background-position: 0 0; &#125; 100% &#123; background-position: -1600px 0; &#125; &#125; @keyframes move &#123; 0% &#123; left: 0; &#125; 100% &#123; left: 50%; /* margin-left: -100px; */ transform: translateX(-50%); &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 无缝滚动123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;无缝滚动&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; * &#123; margin: 0; padding: 0; &#125; nav&#123; width: 1000px; height: 150px; border: 2px solid white; margin: 100px auto; overflow: hidden; &#125; @keyframes moving&#123; from&#123; transform: translateX(0px); &#125; to&#123; transform: translateX(-1000px); &#125; &#125; nav ul&#123; list-style-type: none; overflow: hidden; animation: moving 7s infinite linear; width: 200%; &#125; img&#123; width: 200px; height: 150px; border: 4px solid white; &#125; li&#123; float:left; &#125; body&#123; background-color:aliceblue; &#125; nav:hover ul&#123; animation-play-state:paused; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--无缝滚动开始啦--&gt; &lt;nav&gt; &lt;ul&gt; &lt;!--第一组开始--&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;images1/a.jpg&quot; /&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;images1/b.jpg&quot; /&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;images1/c.jpg&quot; /&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;images1/d.jpg&quot; /&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;images1/e.jpg&quot; /&gt; &lt;/a&gt; &lt;/li&gt; &lt;!--第一组结束--&gt; &lt;!--第二组开始--&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;images1/a.jpg&quot; /&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;images1/b.jpg&quot; /&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;images1/c.jpg&quot; /&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;images1/d.jpg&quot; /&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt; &lt;img src=&quot;images1/e.jpg&quot; /&gt; &lt;/a&gt; &lt;/li&gt; &lt;!--第二组结束--&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;!--无缝滚动结束啦--&gt; &lt;/body&gt;&lt;/html&gt; 移动的方块1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;案例4：动画&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .aniation_div &#123; margin: 100px 0 0 100px; width: 80px; height: 60px; line-height: 60px; color: white; text-align: center; border-radius: 10px; background: greenyellow; animation: move 4s; /* 动画效果，运行4s */ position: relative; /* 相对定位 */ &#125; @keyframes move&#123; /* 规定动画 */ 0% &#123; transform: rotate(0deg); left: 0px; &#125; 25% &#123; transform: rotate(20deg); left: 0px; &#125; 50% &#123; transform: rotate(0deg); left: 500px; &#125; 70% &#123; transform: rotate(0deg); left: 500px; background: #1ec7e6; &#125; 100% &#123; transform: rotateX(-360deg); /* 逆时针旋转360度 */ left: 0px; &#125; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;aniation_div&quot;&gt; 动画 &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","path":"page/css09.html","date":"01-19","excerpt":"","tags":[{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"http://xiaoliblog.cn/tags/HTML-CSS/"}]},{"title":"前端三剑客🎉过渡","text":"过渡 transition呈现的是一种过渡，是一种动画转换的过程，如渐现、渐弱、动画快慢等 CSS3 transition的过渡功能更像是一种“黄油”，通过一些CSS的简单动作触发样式平滑过渡 此属性同样存在浏览器兼容问题： 12345678/* WebKit引擎的浏览器（Chrome、Safari、Opera） */-webkit-transition : &lt;single-transition&gt;;/* Gecko引擎的浏览器（Firefox） */-moz-transition : &lt;single-transition&gt;;/* Trident引擎的浏览器（IE 10+） */-ms-transition : &lt;single-transition&gt;;/* Presto引擎的浏览器（Opera） */-o-transition : &lt;single-transition&gt;; transition:要过渡的属性 花费时间 运动曲线 何时开始 谁过渡给谁加 过渡子属性 transition-property 定义转换动画的CSS属性名称 IDENT ：指定的CSS 属性（width 、height 、background-color 属性等 ） all ：指定所有元素支持transition-property 属性的样式，一般为了方便都会使用all transition-duration 定义转换动画的时间长度，即从设置旧属性到换新属性所花费的时间，单位为秒（s） transition-timing-function 指定浏览器的过渡速度，以及过渡期间的操作进展情况，通过给过渡添加一个函数来指定动画的快慢方式 ease ：速度 由快到 慢（ 默认值 ） linear：速度 恒速（匀速运动 ） ease-in：速度 越来越快（渐显效果 ） ease-out ：速度 越来越慢（渐隐效果 ） ease-in-out ：速度 先加速再减速（渐显渐隐效果 transition-delay 指定一个动画开始执行的时间，当改变元素属性值后多长时间去执行过渡效果 正值 ：元素过渡效果不会立即触发，当过了设置的时间值后才会被 触发 负值：元素过渡效果会从该时间点开始显示，之前的动作被 截断 0：默认值，元素过渡效果立即执行 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;CSS3 过渡效果&lt;/title&gt; &lt;style&gt; div &#123; width: 200px; height: 100px; background-color: pink; /* transition: 变化的属性 花费时间 运动曲线 何时开始; */ /* transition: width .5s ease 0s, height .5s ease 1s; */ /* 如果想要写多个属性，利用逗号进行分割 */ /* transition: width .5s, height .5s; */ /* 如果想要多个属性都变化，属性写all就可以了 */ /* transition: height .5s ease 1s; */ /* 谁做过渡，给谁加 */ transition: all 0.5s; &#125; div:hover &#123; width: 400px; height: 200px; background-color: skyblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 进度条实例123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;CSS3过渡练习-进度条&lt;/title&gt; &lt;style&gt; .bar &#123; width: 150px; height: 15px; border: 1px solid red; border-radius: 7px; padding: 1px; &#125; .bar_in &#123; width: 50%; height: 100%; background-color: red; /* 谁做过渡给谁加 */ transition: all .7s; &#125; .bar:hover .bar_in &#123; width: 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;bar&quot;&gt; &lt;div class=&quot;bar_in&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 过渡触发方式 成功设置过渡的条件 具有一个 CSS 属性在过渡效果中的开始样式和最终样式 通过 transition-property 指定过渡效果要执行的样式属性名称 通过 transition-duration 设置过渡效果执行的时长 伪类触发 ：hover ：active ：focus ：checked 使用子属性 各属性之间（多个属性时）用逗号分隔例如 transition-property: background-color,width; 每个属性与时间一一对应，如果指定的时长的个数小于属性的个数，则时长列表会被重复，以与属性的个数匹配；如果指定的时长的个数大于属性的个数，则时长列表会被裁减 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 200px; height: 200px; border: 1px solid gray; /* 设置执行过渡效果开始的样式 */ background-color: lightcoral; /* 用来执行过渡效果的样式属性 */ transition-property: background-color,width; /* */ transition-duration: 1s,2s; &#125; /* 触发过渡效果的方式 */ .box:hover&#123; /* 设置执行过度效果最终的样式 */ background-color: lightyellow; width: 300px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 使用合属性用逗号分隔每个过渡。例如 transition: width 2s linear,height 2s linear; 表示 2 秒匀速过渡. 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 200px; height: 200px; background: lightcoral; transition: width 2s,height 2s; &#125; .box:hover&#123; width: 400px; height: 400px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; JavaScript触发：用JavaScript脚本触发 检测过渡是否完成须使用 JavaScript 使用. 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;transitionEnd事件&lt;/title&gt; &lt;style&gt; .box &#123; width: 200px; height: 200px; border: 1px solid gray; background: lightcoral; transition-property: background; transition-duration: 2s; &#125; .box:hover &#123; background: lightyellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot; class=&quot;box&quot;&gt;&lt;/div&gt; &lt;script&gt; var box = document.getElementById(&#x27;box&#x27;); box.addEventListener(&#x27;transitionend&#x27;, function () &#123; console.log(&#x27;这个过渡执行完毕了......&#x27;) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","path":"page/css11.html","date":"01-19","excerpt":"","tags":[{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"http://xiaoliblog.cn/tags/HTML-CSS/"}]},{"title":"前端三剑客🎉变形","text":"变形通过修改坐标，CSS transform 属性可以在不影响正常文档流的情况下改变作用内容的位置。CSStransform 包括一系列 CSS 属性，通过这些属性可以对 HTML 元素进行变形。可以进行的变形包括旋转，倾斜，缩放以及位移，同时适用于平面以及三维空间。在空间中实现 CSS 变形会稍微复杂一点。首先必须设置一个透视点 (perspective) 来配置 3D 空间然后定义 2D 元素在空间中的变形。 变形属性 transformtransform: none| &lt;transform-list&gt;属性允许你修改 CSS 视觉格式模型的坐标空间。使用它，元素可以被转换 (translate) 旋转 (rotate) 、缩放 (scale) 候斜 (skew)。该 CSS 属性可用于内联元素和块级元素。其默认值为 none, 表示匹配元素不进行任何变形。transorm-list 表示作用于元素的一个或多个变形的 CSS 函数。如果为多个函数的话，使用空格进行分隔。 transform-origin CSS 属性让你更改一个元素变形的原点默认情况，变形的原点在元素的中心点，或者是元素 X 轴和 Y 轴的 50% 处。 一个值：必须是，，或 left, center, right, top, bottom 关键字中的一个。 两个值：其中一个必须是，，或 left, center, right 关键字中的一个。另一个必须是，，或 top, center, bottom 关键字中的一个。 三个值：前两个值和只有两个值时的用法相同。第三个值必须是。它始终代表 Z 轴偏移量。 transform-style 设置元素的子元素是位于 3D 空间中还是平面中。 transform-style: flat | preserve-3d flat设置元素的子元素位于该元素的平面中。 preserve-3d指示元素的子元素应位于 3D 空间中。 perspective指定了观察者与 z=0 平面的距离，使具有三维位置变换的元素产生透视效果。 z&gt;0 的三维元素比正常大，而 z&lt;0 时则比正常小，大小程度由该属性的值决定。三维元素在观察者后面的部分不会绘制出来，即 z 轴坐标值大于 perspective 属性值的部分。默认情况下，消失点位于元素的中心，但是可以通过设置 perspective-origin 属性来改变其位置。 perspective-origin指定了观察者的位置，用作 perspective 属性的消失点。 12345/* 一个值的时候 */perspective-origin: x-position;/* 两个值的时候 */perspective-origin: x-position y-position; backface-visibility元素的背面是其正面的镜像。虽然在 2D 中不可见，但是当变换导致元素在 3D 空间中旋转时，背面可以变得可见。 （此属性对 2D 变换没有影响，它没有透视。）其只有两个值 12backface-visibility: visible;backface-visibility: hidden; 2D变形2D坐标轴，往上和往左为负值 每个效果都可以称为变形（transform），它们可以分别操控元素发生平移、旋转、缩放、倾斜等变化 12&lt;!--设置变形函数，可以是一个，也可以是多个，中间以空格分开--&gt;transform:[transform-function] *; 变形函数 translate()：平移函数，基于X、Y坐标重新定位元素的位置 scale()：缩放函数，可以使任意元素对象尺寸发生变化 rotate()：旋转函数，取值是一个度数值 skew()：倾斜函数，取值是一个度数值 2D平移 translate(x,y); 平移不脱离文档流 x: 表示水平方向 y: 表示垂直方向 translateX(x) 表示只设置X轴的位移 translate(y) 表示只设置Y轴的位移 translate最大的优点：不会影响到其他元素的位置 translate中的百分比单位是相对于自身元素的translate:(50%,50%); 对行内标签没有效果 12345.box&#123; width: 200px; height: 200px; transform: translateX(300px);&#125; 12345.box&#123; width: 200px; height: 200px; transform: translateX(50%); /*相对于自身，即盒子宽度的50%*/&#125; 2D缩放根据元素中心点缩放 scale(X,Y); X 表示水平方向 Y 表示垂直方向 值范围 0~1 之间的值，表示缩小 大于 1，表示放大倍数 注意：以元素中心点为核心进行缩放 scaleX(X)表示只设置X轴的缩放 scaleY(Y)表示只设置Y轴的缩放 scale不会影响其他盒子，而且可以设置缩放中心点transform-origin 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div&#123; width: 200px; height: 200px; background-color:skyblue; margin: 100px auto; &#125; div:hover&#123; /*1.里面写数值，就是倍数的意思*/ transform: scale(2,2); /*2.宽度为原来的2倍，高度不变*/ transform: scale(2,1); /*3.等比例缩放，简单写法，宽度2倍，高度和第一个参数一样*/ transform: scale(2); /*4.小于1为缩小*/ transform: scale(0.5,0.5); /*5.等比例缩小*/ transform: scale(0.5); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2D倾斜 skew(x,y) x代表 X 轴 y代表 Y 轴 skewX(x) 表示只设置X轴的倾斜 skewY(y) 表示只设置Y轴的倾斜 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 200px; height: 200px; background: lightpink; margin: 200px 200px; transform: skew(45deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 倾斜的过程（从零开始逐渐往上加） 2D旋转rotate () 函数用于通过指定的角度将元素根据原点进行旋转。该函数主要用于 2D 空间进行旋转。如果该角度值为正值的话，表示顺时针旋转；如果该角度值为负值的话，则表示逆时针旋转。 angle: 表示旋转的角度值，单位为 deg。 正值顺时针旋转 负值逆时针旋转 rotate( )函数只是旋转，而不会改变元素的形状 skew( )函数是倾斜，元素不会旋转，会改变元素的形状 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; .box &#123; width: 200px; height: 200px; background: lightcoral; margin: 200px 200px; transition:all 0.3s; &#125; .box:hover&#123; transform: rotate(45deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 可以通过transform-origin设置元素转换的中心点 1transfrom-origin: x y; 注意后面的参数x和y用空格隔开 x y默认转换的中心点是元素的中心点（50% 50%） 可以给x y 设置像素或者方位名词（top bottom left right center) 1234567891011div&#123; width: 200px; height: 200px; background-color:darkcyan; margin: 100px auto; transition: all 1s; transform-origin: left bottom;&#125;div:hover&#123; transform:rotate(360deg);&#125; 隐藏显示案例12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div&#123; width: 200px; height: 200px; border:1px solid cadetblue; margin: 100px auto; overflow: hidden; &#125; div::before&#123; content:&quot;看见我了&quot;; display: block; width: 100%; height: 100%; background-color: gray; transform: rotate(180deg); transform-origin: left bottom; transition: all 0.5s; &#125; /*鼠标经过div 里面的before复原*/ div:hover::before&#123; transform: rotate(0deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 图片放大案例123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div&#123; float:left; margin: 10px; overflow: hidden; &#125; div img&#123; transition: all 0.5s; &#125; div img:hover&#123; transform: scale(1.1); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;img/pic.png&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;img/pic.png&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;img/pic.png&quot;&gt;&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 分页按钮案例123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; li&#123; float:left; width: 30px; height: 30px; border:1px solid crimson; border-radius: 50%; margin: 10px; text-align: center; line-height: 30px; list-style: none; cursor:pointer; transition: all 0.4s; &#125; li:hover&#123; transform:scale(1.3); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 3D变形在 3D 效果中，使用 X 与 Y 属性与 2D 效果类似。唯一不同的是 Z 的属性。使用 Z 的属性需要添加 perspective 属性，即平面与观察者之间的距离 X轴：水平向右 x右边是正值，左边是负值 Y轴：垂直向下 y下面是正值，上面是负值 Z轴：垂直屏幕 往外面是正值，往里面是负值 3D移动 3D移动在2D移动的基础上多加了一个可以移动的方向，就是z轴方向 transform:translateX(100px) 仅仅是在x轴上移动 transform:translateY(100px) 仅仅是在Y轴上移动 transform:translateZ(100px) 仅仅是在Z轴上移动（注意：traslateZ一般用px单位） 合并简写： transform: translateX(100px) translateY(100px) translateZ(100px); transform:translate3d(x,y,z) 其中x、y、z分别指套移动的轴的方向的距离，不能省略，没有就写0 透视perspective 想要在网页产生3D效果需要透视（理解为3D物体投影在2D平面内） 模拟人类的视觉位置 ,可认为安排一只只眼睛去看 透视我们也称为视距 :视距就是人的眼睛到屏幕的距离 距离视觉点越近的在电脑平面成像越大 ,越远成像越小 透视的单位是像素 透视写在被观察元素的父盒子上面 d :就是视距,视距就是一个距离人的眼睛到屏幕的距离。 z :就是z轴,物体距离屏幕的距离, z轴越大(正值)我们看到的物体就越大。 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; body &#123; /* 透视写到被观察元素的父盒子上面 */ perspective: 500px; &#125; div &#123; width: 200px; height: 200px; background-color: pink; transform: translate3d(400px, 100px, 100px); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; translateX()12345678910111213141516171819202122232425262728293031&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;translateX()&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div&#123; position: relative; perspective: 800px; border: 1px solid red; height: 200px; width: 200px; margin-top: 20px; &#125; div img&#123; position: absolute; top:0; transition: all 2s ease;/*过渡动画*/ &#125; div img:hover&#123; transform:translateX(100px);/*鼠标移入动画，平移*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;img src=&quot;images/1.png&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; translateY()12345678910111213141516171819202122232425262728293031&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;translateY()&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div&#123; position: relative; perspective: 800px; border: 1px solid red; height: 200px; width: 200px; margin-top: 20px; &#125; div img&#123; position: absolute; top:0; transition: all 2s ease;/*过渡动画*/ &#125; div img:hover&#123; transform:translateY(100px);/*鼠标移入动画，平移*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;img src=&quot;images/1.png&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; translateZ()1234567891011121314151617181920212223242526272829303132&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;translateZ()&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div&#123; position: relative; perspective: 800px; border: 1px solid red; height: 200px; width: 200px; margin-top: 20px; &#125; div img&#123; position: absolute; top:0; transition: all 2s ease;/*过渡动画*/ &#125; div img:hover&#123; transform:translateZ(-100px);/*鼠标移入动画，平移*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;img src=&quot;images/1.png&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; transform:translateZ(100px):仅仅是在Z轴上移动，有了透视，就能看到变化 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; body &#123; perspective: 500px; &#125; div &#123; width: 200px; height: 200px; background-color: pink; margin: 100px auto; transform: translateZ(0); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3D旋转 3D旋转指可以让元素在三维平面内沿着x轴，y轴，z轴或者自定义进行旋转 transform:rotateX(45deg) 沿着x轴正方向旋转45度 transform:rotateY(45deg) 沿着y轴正方向旋转45度 transform:rotateZ(45deg) 沿着z轴正方向旋转45度 transform3d:rotate3d(x,y,z,deg) 沿着自定义轴旋转deg为角度 rotateX()1234567891011121314151617181920212223242526272829303132&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;rotateX()&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div&#123; position: relative; perspective: 800px; border: 1px solid red; height: 200px; width: 200px; margin-top: 20px; &#125; div img&#123; position: absolute; top:0; transition: all 2s ease;/*过渡动画*/ &#125; div img:hover&#123; transform: rotateX(360deg);/*鼠标移入动画，绕x轴旋转*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;img src=&quot;images/1.png&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; rotateY()12345678910111213141516171819202122232425262728293031&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;rotateY()&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div&#123; position: relative; perspective: 800px; border: 1px solid red; height: 200px; width: 200px; margin-top: 20px; &#125; div img&#123; position: absolute; top:0; transition: all 2s ease;/*过渡动画*/ &#125; div img:hover&#123; transform: rotateY(360deg);/*鼠标移入动画，绕y轴旋转*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;img src=&quot;images/1.png&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; rotateZ()12345678910111213141516171819202122232425262728293031&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;rotateZ()&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div&#123; position: relative; perspective: 800px; border: 1px solid red; height: 200px; width: 200px; margin-top: 20px; &#125; div img&#123; position: absolute; top:0; transition: all 2s ease;/*过渡动画*/ &#125; div img:hover&#123; transform: rotateZ(360deg);/*鼠标移入动画，绕z轴旋转*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;img src=&quot;images/1.png&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; rotate3d()12345678910111213141516171819202122232425262728293031&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;rotate3d()&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div&#123; position: relative; perspective: 800px; border: 1px solid red; height: 200px; width: 200px; margin-top: 20px; &#125; div img&#123; position: absolute; top:0; transition: all 2s ease;/*过渡动画*/ &#125; div img:hover&#123; transform: rotate3d(100,100,100,360deg);/*鼠标移入动画，三维空间 x,y,z，angle*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;img src=&quot;images/1.png&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3D转换属性 属性名称 描述 transform 向元素应用2D或3D转换 transform-origin 允许改变被转换元素的位置 transform-style 规定被嵌套元素如何在3D空间中显示 perspective 规定3D元素的透视效果 perspective-origin 规定元素的透视原点 backface-visibility 定义元素在不面对屏幕时是否可见 transform-origin 变形操作都是以元素的中心点为基准进行的，如果需要改变这个中心点，可以使用transform-origin属性。 1transform-origin: x-axis y-axis z-axis; transform-origin属性包含三个参数，其默认值分别为50% 50% 0，各参数的具体含义 transform-originCSS属性更改一个元素变形的原点。 12345678910111213141516171819202122232425262728293031323334353637&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;transform-origin旋转原点改变()&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div&#123; position: relative; perspective: 800px; border: 1px solid red; height: 200px; width: 200px; margin-top: 100px; margin-left: 100px; &#125; div img&#123; position: absolute; top:0; transition: all 2s ease;/*过渡动画*/ &#125; div img:hover&#123; transform: rotate(360deg); /*transform-origin:x,y,z;默认50% 50% 0；z只有长度设置*/ /*transform-origin: center;/*x,y原点在中心*/ /*transform-origin: top left;/*原点在左上角 y，x的取值*/ /*transform-origin: 50px 50px;/*x,y偏移50px为原点*/ transform-origin: bottom right 60px;/*x底部，y右,z方向60px*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;img src=&quot;images/1.png&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; transform-styletransform-style 设置元素的子元素是位于 3D 空间中还是平面中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; perspective: 500px; &#125; .box &#123; position: relative; width: 200px; height: 200px; margin: 100px auto; transition: all 2s; /* 让子元素保持3d立体空间环境 */ transform-style: preserve-3d; &#125; .box:hover &#123; transform: rotateY(60deg); &#125; .box div &#123; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: pink; &#125; .box div:last-child &#123; background-color: purple; transform: rotateX(60deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; perspectiveperspective指定了观察者与 z=0 平面的距离，使具有三维位置变换的元素产生透视效果。不设置的话，就会在2d平面投影，无意义。 perspective-origin透视原点perspective-origin是指观察者的位置，通常我们用该属性来定义视线灭点，也即视线消失的位置。 backface-visibilitybackface-visibility 指定当元素背面朝向观察者时是否可见。 实例两面翻转的盒子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; perspective: 400px; &#125; .box &#123; position: relative; width: 300px; height: 300px; margin: 100px auto; transition: all .4s; /* 让背面的紫色盒子保留立体空间 给父级添加的 */ transform-style: preserve-3d; &#125; .box:hover &#123; transform: rotateY(180deg); &#125; .front, .back &#123; position: absolute; top: 0; left: 0; width: 100%; height: 100%; border-radius: 50%; font-size: 30px; color: #fff; text-align: center; line-height: 300px; &#125; .front &#123; background-color:skyblue; z-index: 1; &#125; .back &#123; background-color:darkseagreen; /* 像手机一样 背靠背 旋转 */ transform: rotateY(180deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;front&quot;&gt;小李博客&lt;/div&gt; &lt;div class=&quot;back&quot;&gt;记得分享出去哦&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3D导航栏123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; ul &#123; margin: 100px; &#125; ul li &#123; float: left; margin: 0 5px; width: 120px; height: 35px; list-style: none; /* 一会我们需要给box 旋转 也需要透视 干脆给li加 里面的子盒子都有透视效果 */ perspective: 500px; &#125; .box &#123; position: relative; width: 100%; height: 100%; transform-style: preserve-3d; transition: all .4s; &#125; .box:hover &#123; transform: rotateX(90deg); &#125; .front, .bottom &#123; position: absolute; left: 0; top: 0; width: 100%; height: 100%; &#125; .front &#123; background-color: skyblue; z-index: 1; transform: translateZ(17.5px); &#125; .bottom &#123; background-color:darkturquoise; /* 这个x轴一定是负值 */ /* 我们如果有移动 或者其他样式，必须先写我们的移动 */ transform: translateY(17.5px) rotateX(-90deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;front&quot;&gt;小李博客&lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;记得分享出去&lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;front&quot;&gt;小李博客&lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;记得分享出去&lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;front&quot;&gt;小李博客&lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;记得分享出去&lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;front&quot;&gt;小李博客&lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;记得分享出去&lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;front&quot;&gt;小李博客&lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;记得分享出去&lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;front&quot;&gt;小李博客&lt;/div&gt; &lt;div class=&quot;bottom&quot;&gt;记得分享出去&lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 旋转木马12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123;margin:0; padding:0;&#125; img&#123;width:150px; height:200px;&#125; .box&#123; /* 透视元素 */ perspective:800px; margin:50px auto; width:900px; height:900px; /* 设置 3D 元素的基点位置*/ perspective-origin:top; /* 解决外边距的塌陷问题 */ overflow:hidden; &#125; @keyframes moving&#123; 0%&#123; transform: rotateY(0deg); &#125; 100%&#123; transform: rotateY(360deg); &#125; &#125; .box ul&#123; list-style-type: none; transform-style: preserve-3d; position: relative; margin: 150px auto; animation: moving 8s linear infinite; width: 150px; height: 200px; &#125; body&#123; background-color:darkgray; &#125; .box ul li&#123; position: absolute; top:0px; left:0px; &#125; /**每张图的旋转角度，360/个数*/ li:nth-of-type(1)&#123; transform: rotateY(0deg) translateZ(205px); &#125; li:nth-of-type(2)&#123; transform: rotateY(40deg) translateZ(205px); &#125; li:nth-of-type(3)&#123; transform: rotateY(80deg) translateZ(205px); &#125; li:nth-of-type(4)&#123; transform: rotateY(120deg) translateZ(205px); &#125; li:nth-of-type(5)&#123; transform: rotateY(160deg) translateZ(205px); &#125; li:nth-of-type(6)&#123; transform: rotateY(200deg) translateZ(205px); &#125; li:nth-of-type(7)&#123; transform: rotateY(240deg) translateZ(205px); &#125; li:nth-of-type(8)&#123; transform: rotateY(280deg) translateZ(205px); &#125; li:nth-of-type(9)&#123; transform: rotateY(320deg) translateZ(205px); &#125; ul:hover&#123; animation-play-state: paused; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=&quot;images1/aa.jpg&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images1/bb.jpg&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images1/cc.jpg&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images1/dd.jpg&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images1/ee.jpg&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images1/ff.jpg&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images1/aa.jpg&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images1/bb.jpg&quot;/&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images1/cc.jpg&quot;/&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 旋转的立方体123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;&quot;&gt; &lt;style type=&quot;text/css&quot; media=&quot;screen&quot;&gt; *&#123; margin:0; padding:0; &#125; .box&#123; position:relative; top:100px; width:300px; height:300px; margin:0 auto; background-color:#ccc; /* 透视距离 */ perspective:800px; &#125; .content&#123; /* 基本样式 */ width:200px; height:200px; /* content的位置 */ position:absolute; top:50px; left:50px; /* 3D视图 */ transform-style:preserve-3d; /* 过渡动画 */ transition:all 3s linear; &#125; /* content旋转 */ .content:hover&#123; transform: rotateX(180deg) rotateY(180deg); /*----*/ &#125; /* 方块公共样式 */ .side&#123; width: 200px; height:200px; position:absolute; /*6个div重叠*/ border:2px solid #000; background-color:rgba(0,0,0,0.3); color:#fff; line-height:200px; font-size:30px; font-weight:bold; text-align:center; text-shadow:0 -1px 0 rgba(0,0,0,0.2); border:1px solid red; &#125; /* 前 */ .side1&#123; transform:translateZ(100px); &#125; /* 后 ：rotate()会使坐标也跟着旋转*/ .side2&#123; transform:rotateX(180deg) translateZ(100px); &#125; /* 左 */ .side3&#123; transform:rotateY(-90deg) translateZ(100px); &#125; /* 右 */ .side4&#123; transform:rotateY(90deg) translateZ(100px); &#125; /* 上 */ .side5&#123; transform:rotateX(90deg) translateZ(100px); &#125; /* 下 */ .side6&#123; transform:rotateX(-90deg) translateZ(100px); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;side side1&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;side side2&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;side side3&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;side side4&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;side side5&quot;&gt;5&lt;/div&gt; &lt;div class=&quot;side side6&quot;&gt;6&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 数字翻转1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;综合实例_数字翻转&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div&#123; width: 200px; height: 200px; margin: 50px auto; border: 5px solid #000; position: relative; perspective: 5000px;/*3D元素透视效果*/ transform-style: preserve-3d;/*被嵌套元素在3d空间中显示*/ transition: all 1s ease;/*设置过渡效果*/ &#125; div:hover&#123; transform: rotateX(-90deg);/*黑边框 绕x轴逆时针旋转*/ &#125; div img&#123; position: absolute; /*两张图片定位到坐标原点*/ top:0px; left: 0px; &#125; div img.img1&#123; transform: translateZ(100px); /*z轴*/ z-index: 2; /*放第一张*/ &#125; div img.img2&#123; transform: rotateX(90deg)translateZ(100px); /*绕x轴顺时针旋转90度 z轴平移100px*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;img class=&quot;img1&quot; src=&quot;images/1.png&quot;&gt; &lt;img class=&quot;img2&quot; src=&quot;images/2.png&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 翻页效果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;综合实例_翻页效果&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123; margin: 0px; padding: 0px; &#125; ul&#123; list-style-type: none; /*设置父级大小*/ width: 150px; height: 220px; margin: 200px; position: relative; /*设置父级为透视元素*/ perspective: 500px; /*设置父级嵌套元素在3D中显示*/ transform-style: preserve-3d; &#125; ul li&#123; /*设置页面宽高*/ width: 140px; height: 160px; /*每个li都重叠*/ position: absolute; left: 0px; top:0px; /*渐变+圆角*/ background: linear-gradient(to right,black,gray); border: 1px solid lightgray; border-radius: 0 5px 5px 0; /*设置左为原点*/ transform-origin: left; transform: 5s; box-shadow: 0 5px 5px lightgray; &#125; ul li:nth-of-type(1)&#123; transform: rotateY(-28deg); &#125; ul li:nth-of-type(2)&#123; transform: rotateY(-26deg); &#125; ul li:nth-of-type(3)&#123; transform: rotateY(-24deg); &#125; ul li:nth-of-type(4)&#123; transform: rotateY(-22deg); &#125; ul li:nth-of-type(5)&#123; transform: rotateY(-20deg); color:aqua; &#125; ul:hover li:nth-of-type(1)&#123; transform: rotateY(-160deg); transition: 1s; &#125; ul:hover li:nth-of-type(2)&#123; transform: rotateY(-150deg); transition: 1.3s; &#125; ul:hover li:nth-of-type(3)&#123; transform: rotateY(-140deg); transition: 1.6s; &#125; ul:hover li:nth-of-type(4)&#123; transform: rotateY(-130deg); transition: 1.9s; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li style=&quot;line-height: 140px;text-align: center;font-size: 20px;&quot;&gt;武功秘籍&lt;/li&gt; &lt;/ul&gt;&lt;/html&gt; 立方体相册12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;main&gt; &lt;div class=&quot;cube&quot;&gt; &lt;div class=&quot;img1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;img2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;img3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;img4&quot;&gt;&lt;/div&gt; &lt;div class=&quot;img5&quot;&gt;&lt;/div&gt; &lt;div class=&quot;img6&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/main&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798html,body &#123; margin: 0;&#125;* &#123; box-sizing: border-box;&#125;body &#123; background-color: #2f3542;&#125;main &#123; display: flex; align-items: center; justify-content: center; height: 100vh;&#125;.cube &#123; width: 250px; height: 250px; transform-style: preserve-3d; transform-origin: 125px 125px 0; animation: rotate-cube 10s ease-in-out infinite;&#125;.cube &gt; div &#123; width: 250px; height: 250px; background-size: cover; background-position: center center; opacity: 0.8; position: absolute; box-shadow: inset 0 0 4px 2px rgba(106, 106, 106, 0.4);&#125;/* 前 */.cube .img1 &#123; background-image: url(&quot;https://images.pexels.com/photos/274131/pexels-photo-274131.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=2&amp;h=650&amp;w=940&quot;); transform: rotateY(0deg) translateZ(125px);&#125;/* 右 */.cube .img2 &#123; background-image: url(&quot;https://images.pexels.com/photos/1480690/pexels-photo-1480690.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=2&amp;h=650&amp;w=940&quot;); transform: rotateY(90deg) translateZ(125px);&#125;/* 左 */.cube .img3 &#123; background-image: url(&quot;https://images.pexels.com/photos/36487/above-adventure-aerial-air.jpg?auto=compress&amp;cs=tinysrgb&amp;dpr=2&amp;h=650&amp;w=940&quot;); transform: rotateY(-90deg) translateZ(125px);&#125;/* 下 */.cube .img4 &#123; background-image: url(&quot;https://images.pexels.com/photos/338713/pexels-photo-338713.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=2&amp;h=650&amp;w=940&quot;); transform: rotateX(90deg) translateZ(125px);&#125;/* 上 */.cube .img5 &#123; background-image: url(&quot;https://images.pexels.com/photos/325044/pexels-photo-325044.jpeg?cs=srgb&amp;dl=close-up-of-fish-over-black-background-325044.jpg&amp;fm=jpg&quot;); transform: rotateX(-90deg) translateZ(125px);&#125;/* 后 */.cube .img6 &#123; background-image: url(&quot;https://images.pexels.com/photos/404280/pexels-photo-404280.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=2&amp;h=650&amp;w=940&quot;); transform: rotateY(180deg) translateZ(125px);&#125;@keyframes rotate-cube &#123; 0% &#123; transform: rotateX(0deg) rotateY(0deg); &#125; 20% &#123; /* 右边图片 */ transform: rotateY(-90deg); &#125; 40% &#123; /* 上 */ transform: rotateX(-90deg); &#125; 60% &#123; /* 左 */ transform: rotateY(90deg); &#125; 80% &#123; /* 下 */ transform: rotateX(90deg); &#125; 100% &#123; transform: rotateX(0deg) rotateY(0deg); &#125;&#125; 3D折叠社交图标1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css&quot;&gt; &lt;!--&lt;script src=&quot;https://kit.fontawesome.com/a076d05399.js&quot;&gt;&lt;/script&gt;--&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;icons&quot;&gt; &lt;a href=&quot;#&quot;&gt; &lt;div class=&quot;layer&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span class=&quot;fab fa-facebook-f&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;span class=&quot;text&quot;&gt;Facebook&lt;/span&gt; &lt;/a&gt; &lt;a href=&quot;#&quot;&gt; &lt;div class=&quot;layer&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span class=&quot;fab fa-twitter&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;span class=&quot;text&quot;&gt;Twitter&lt;/span&gt; &lt;/a&gt; &lt;a href=&quot;#&quot;&gt; &lt;div class=&quot;layer&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span class=&quot;fab fa-instagram&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;span class=&quot;text&quot;&gt;Instagram&lt;/span&gt; &lt;/a&gt; &lt;a href=&quot;#&quot;&gt; &lt;div class=&quot;layer&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span class=&quot;fab fa-linkedin-in&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;span class=&quot;text&quot;&gt;Linkedin&lt;/span&gt; &lt;/a&gt; &lt;a href=&quot;#&quot;&gt; &lt;div class=&quot;layer&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span class=&quot;fab fa-youtube&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;span class=&quot;text&quot;&gt;Youtube&lt;/span&gt; &lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140*&#123; margin: 0; padding: 0; box-sizing: border-box; font-family: &quot;Poppins&quot;, sans-serif;&#125;html,body&#123; display: grid; height: 100%; place-items: center; background: #000;&#125;.icons&#123; display: inline-flex;&#125;.icons a&#123; margin: 0 25px; text-decoration: none; color: #fff; display: block; position: relative;&#125;.icons a .layer&#123; width: 55px; height: 55px; transition: transform 0.3s;&#125;.icons a:hover .layer&#123; transform: rotate(-35deg) skew(20deg);&#125;.icons a .layer span&#123; position: absolute; top: 0; left: 0; height: 100%; width: 100%; border: 1px solid #fff; border-radius: 5px; transition: all .3s;&#125;.icons a .layer span.fab&#123; font-size: 30px; line-height: 55px; text-align: center;&#125;.icons a:hover .layer span:nth-child(1)&#123; opacity: 0.2;&#125;.icons a:hover .layer span:nth-child(2)&#123; opacity: 0.4; transform: translate(5px, -5px);&#125;.icons a:hover .layer span:nth-child(3)&#123; opacity: 0.6; transform: translate(10px, -10px);&#125;.icons a:hover .layer span:nth-child(4)&#123; opacity: 0.8; transform: translate(15px, -15px);&#125;.icons a:hover .layer span:nth-child(5)&#123; opacity: 1; transform: translate(20px, -20px);&#125;.icons a:nth-child(1) .layer span,.icons a:nth-child(1) .text&#123; color: #4267B2; border-color: #4267B2;&#125;.icons a:nth-child(2) .layer span,.icons a:nth-child(2) .text&#123; color: #1DA1F2; border-color: #1DA1F2;&#125;.icons a:nth-child(3) .layer span,.icons a:nth-child(3) .text&#123; color: #E1306C; border-color: #E1306C;&#125;.icons a:nth-child(4) .layer span,.icons a:nth-child(4) .text&#123; color: #2867B2; border-color: #2867B2;&#125;.icons a:nth-child(5) .layer span,.icons a:nth-child(5) .text&#123; color: #ff0000; border-color: #ff0000;&#125;.icons a:nth-child(1) .layer span&#123; box-shadow: -1px 1px 3px #4267B2;&#125;.icons a:nth-child(2) .layer span&#123; box-shadow: -1px 1px 3px #1DA1F2;&#125;.icons a:nth-child(3) .layer span&#123; box-shadow: -1px 1px 3px #E1306C;&#125;.icons a:nth-child(4) .layer span&#123; box-shadow: -1px 1px 3px #4267B2;&#125;.icons a:nth-child(5) .layer span&#123; box-shadow: -1px 1px 3px #ff0000;&#125;.icons a .text&#123; position: absolute; left: 50%; bottom: -5px; opacity: 0; transform: translateX(-50%); transition: bottom .3s ease, opacity .3s ease;&#125;.icons a:hover .text&#123; bottom: -35px; opacity: 1;&#125;","path":"page/css05.html","date":"01-19","excerpt":"","tags":[{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"http://xiaoliblog.cn/tags/HTML-CSS/"}]},{"title":"前端三剑客🎉渐变","text":"什么是渐变 CSS 渐变是 CSS3 的 Image 模块中新增的内容。利用 CSS 渐变替代在 HTML 页面中引入渐变效果的图片，这样减少 HTML 页面加载的时间，减小带宽的占用。 由于 CSS 渐变是由浏览器直接生成，在 HTML 页面缩放时的效果要比图片更好，使得可以更灵活、便捷地调整 HTML 页面布局。 线性渐变 线性渐变由一个轴 (基准线) 定义的，并且轴上每个点都具有独立的颜色。lincar-gradient() 函数构建垂直于基准线的渐变效果，渐变的颜色取决于与之垂直相交的基准线上的色点。 基准线由包含渐变效果容器元素的中心点和一个角度来定义的。基准线上的颜色值则由不同的点来定义，包括起始点、终止点以及两者之间可选的中间点 (中间点可以有多个) 起始点是基准线和容器元素的顶点与基准线垂直线的相交点来定义。 终止点是基准线和容器元素最近顶点与基准线垂直线的相交点来定义。 渐变的 0 度是从下到上的，增加角度会使渐变顺时针旋转。 CSS linear gradient () 函数用于创建一个表示两种或多种颜色线性渐变的图片。具体语法结构如下:linear-gradient(angle/direction, color-stop1, color-stop2, ...)上述语法的参数说明: 第一个参数用于定义线性渐变的方向，并且定义渐变颜色的终止位置。 默认第一个参数如果不写就是从上到下的 angle: 通过角度来定义渐变的方向。0 度表示渐变方向从下向上，90 度表示渐变从左向右。其角度按照顺时针方向增加。 direction: 通过关键字定义渐变的方向。表示水平位置 (left 或 right)，表示垂直位置 (top 或 bottom) 。关键字的先后顺序无影响，并且都是可选的。 第二个参数、第三个参数用于定义渐变颜色的起始点和终止点。 方向参数direction 默认第一个参数如果不写就是从上到下的 123div&#123; background: linear-gradient(hotpink, darkblue);&#125; 第一个参数为方位名词 原生写法加to，所以后面的方向正好相反，而且对角线的时候上下和左右可以互换位置= 123456789101112131415161718192021222324.box1&#123; background: linear-gradient(to bottom,hotpink, darkblue);&#125;.box2&#123; background: linear-gradient(to right,hotpink, darkblue);&#125;.box3&#123; background: linear-gradient(to left,hotpink, darkblue);&#125;.box4&#123; background: linear-gradient(to top,hotpink, darkblue); &#125;.box5&#123; background: linear-gradient(to right bottom,hotpink, darkblue); &#125;.box6&#123; background: linear-gradient(to top right,hotpink, darkblue);&#125;.box7&#123; background: linear-gradient(to left bottom,hotpink, darkblue);&#125;.box8&#123; background: linear-gradient(to top left,hotpink, darkblue);&#125; 使用角度angle（角度值deg）进行控制 所有的颜色都是从中心出发，0deg是to top的方向，顺时针是正，逆时针是负 0deg / 360deg （从下到上） 90deg （从左到右） 180deg （从上到下） 270deg / -90deg （从右到左） 45deg （对角线左下到右上） 123456789101112131415161718192021222324div&#123; background: linear-gradient(0deg,#fc466b, #3f5efb);&#125;div&#123; background: linear-gradient(90deg,#fc466b, #3f5efb);&#125;div&#123; background: linear-gradient(180deg,#fc466b, #3f5efb);&#125;div&#123; background: linear-gradient(270deg,#fc466b, #3f5efb);&#125;div&#123; background: linear-gradient(360deg,#fc466b, #3f5efb);&#125;div&#123; background: linear-gradient(-90deg,#fc466b, #3f5efb);&#125;div&#123; background: linear-gradient(-180deg,#fc466b, #3f5efb);&#125;div&#123; background: linear-gradient(45deg,#fc466b, #3f5efb)&#125; 颜色参数 颜色英文字母表示 123div&#123; background: linear-gradient(slateblue, cornflowerblue);&#125; 使用transparent全透明渐变色 123div&#123; background: linear-gradient(transparent, cornflowerblue);&#125; 十六进制#RRGGBB进行颜色控制 123div&#123; background: linear-gradient(#fc466b, #3f5efb);&#125; 使用rgb/rgba进行颜色控制 123div&#123; background: linear-gradient(rgb(255,237,188), rgb(237,66,100)); /*rbg*/background: linear-gradient(rgb(255,237,188,.5), rgb(237,66,100,.5)); /*rgba*/ 使用多个有指定范围的颜色控制 在颜色后面加百分比，就可以控制在整个宽度的百分之多少的时候到达某一个颜色值 12345div&#123; background: linear-gradient(#3a1c71, #d76d77,#ffaf7b); background: linear-gradient(#3a1c71, #d76d77 20% ,#ffaf7b 70%); background: linear-gradient(#3a1c71, #d76d77 80% ,#ffaf7b 90%); &#125; 线性渐变总写法 123div&#123; background: linear-gradient(to bottom,#3a1c71, #d76d77 80% ,#ffaf7b 90%); &#125; 头像滤镜效果 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123; box-sizing: border-box; &#125; .box1&#123; width: 200px; height: 200px; border-radius: 50%; &#125; img&#123; width: 200px; float: left; border-radius: 50%; &#125; .lvjing&#123; position: relative; width: 100%; height: 100%; background: linear-gradient(to right,rgba(255,154,158,.7),rgba(250,208,196,.7)); border-radius: 50%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box1&quot;&gt; &lt;img src=&quot;https://cdn.jsdelivr.net/gh/blogimg/HexoStaticFile1/imgbed/2020/02/24/20200224111924.jpg&quot; alt=&quot;&quot;&gt; &lt;div class=&quot;lvjing&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 进度条动画123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap-3.3.7-dist/css/bootstrap.min.css&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; margin: 0; padding: 0; /*为了展示方便就用灰色的背景*/ background-color: #ccc; &#125; .load &#123; width: 500px; height: 100px; /*如果渐变出不来，有一个背景颜色*/ background: #fff; margin: 100px auto; /*间隔色的关键代码*/ background-image: linear-gradient(45deg, #fff 0%, #fff 25%, #000 25%, #000 50%, #fff 50%, #fff 75%, #000 75%, #000 100%); /*把刚才的背景压缩到100px * 100px以内的，没有设定不重复所以是重复的*/ background-size: 100px 100px; /*一秒播一次的永动动画*/ animation: move 1s linear infinite; &#125; @keyframes move &#123; 0% &#123;&#125; 100% &#123; background-position: 100px; /*终止状态是移动到100px像素的位置，然后下一秒又开始从0px开始运动*/ &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;load&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 径向渐变径向渐变由其中心点、边缘形状轮廓、位置以及颜色结束点定义的。 径向渐变的中心点至边缘形状以及其延伸的部分是由连续缩放的若干同心轮廓组成的。 颜色结束点用于设定虚拟渐变射线的变化方式，由中心点水平变化至右侧。颜色结束点由百分比设定，中心点为 0%，終止点为 100%。终止点为渐变射线与边缘形状相交点的渐变半径。 边缘形状只能是圆形或者椭圆形。 语法 radial-gradient( shape size at position,clor-stop,color-stop+) shape: 表示设置的渐变形状，默认表示椭圆(ellipse)，circle圆形 position: 表示设置起点的坐标值 第一个值：表示水平方向的值 第二个值：表示垂直方向的值 size: 表示设置渐变形状的大小 farthest-corner (默认) : 指定径向渐变的半径长度为从圆心到离圆心最远的角 closest-side ：渐变的边缘形状与容器距离渐变中心点最近的一边相切（圆形）或者至少与距离渐变中心点最近的垂直和水平边相切（椭圆） closest-corner ： 指定径向渐变的半径长度为从圆心到离圆心最近的角 farthest-side ：与closest-side相反，边缘形状与容器距离渐变中心点最远的一边相切（或最远的垂直和水平边） 圆形 该值为原型的半径 椭圆形 值为段半径和长半径 color-stop: 表示渐变的颜色，可以多个 其后也可跟位置 例如 #212121 50% 50% 参数shape 如果只有参数shape（circle,ellipse） 如果div是正方形那么circle和ellipse并没有什么区别，但是如果是长方形，那么ellipse就会根据长度进行压缩 123456div&#123; background: radial-gradient(circle,hotpink, darkblue); /*下图1和3*/&#125;div&#123; background: radial-gradient(ellipse,hotpink, darkblue); /*下图2和4*/&#125; 如果是加上长度范围和形状 该范例要说明半径要写到形状前面，且半径作用大于形状 12345678910111213141516171819div&#123; background: radial-gradient(300px circle,hotpink, darkblue);&#125;div&#123; background: radial-gradient(200px circle,hotpink, darkblue);&#125;div&#123; background: radial-gradient(100px circle,hotpink, darkblue);&#125;div&#123; background: radial-gradient(50px circle,hotpink, darkblue);&#125;div&#123; background: radial-gradient(0px circle,hotpink, darkblue);&#125;/*如果这里加了长短轴的尺寸后面又写了circle，那么circle是不起作用的，出来还是一个椭圆*/div&#123; background: radial-gradient(200px 50px ellipse,hotpink, darkblue);&#125; 参数size 第一个参数不写就默认从中间开始，样式为圆形 123div&#123; background: radial-gradient(hotpink, darkblue);&#125; 传一个半径值 1234div&#123; background: radial-gradient(300px,hotpink, darkblue); background: radial-gradient(200px,hotpink, darkblue);&#125; 传两个半径值 传两个值默认为椭圆，一个是横向的长度，一个是纵向的长度 1234div&#123; background: radial-gradient(200px 50px,hotpink, darkblue); background: radial-gradient(50px 100px,hotpink, darkblue);&#125; 如果传关键字(closest-side/closest-corner/farthest-side/farthest-corner) 这个大小是由位置决定的 如果是圆形 1234567891011121314151617181920212223242526272829303132333435363738394041/*closest-side*/div&#123; background: radial-gradient(closest-side,#ffaf7b, #d76d77 ,#3a1c71);&#125;/*40%只写一个表示40% 50%*/div&#123; background: radial-gradient(closest-side circle at 40%,#ffaf7b, #d76d77 ,#3a1c71); &#125;div&#123; background: radial-gradient(closest-side circle at 20% 30%,#ffaf7b, #d76d77 ,#3a1c71);&#125;/*closest-corner*/div&#123; background: radial-gradient(closest-corner,#ffaf7b, #d76d77 ,#3a1c71);&#125;div&#123; background: radial-gradient(closest-corner circle at 40%,#ffaf7b, #d76d77 ,#3a1c71);&#125;div&#123; background: radial-gradient(closest-corner circle at 20% 30%,#ffaf7b, #d76d77 ,#3a1c71);&#125;/*farthest-side*/div&#123; background: radial-gradient(farthest-side,#ffaf7b, #d76d77 ,#3a1c71);&#125;div&#123; background: radial-gradient(farthest-side circle at 40%,#ffaf7b, #d76d77 ,#3a1c71);&#125;div&#123; background: radial-gradient(farthest-side circle at 20% 30%,#ffaf7b, #d76d77 ,#3a1c71);&#125;/*farthest-corner*/div&#123; background: radial-gradient(farthest-corner,#ffaf7b, #d76d77 ,#3a1c71);&#125;div&#123; background: radial-gradient(farthest-corner circle at 40%,#ffaf7b, #d76d77 ,#3a1c71);&#125;div&#123; background: radial-gradient(farthest-corner circle at 20% 30%,#ffaf7b, #d76d77 ,#3a1c71);&#125; 如果是椭圆 1234567891011121314151617181920212223242526272829303132333435363738394041/*closest-side*/div&#123; background: radial-gradient(closest-side ellipse,#ffaf7b, #d76d77 ,#3a1c71);&#125;/*40%只写一个表示40% 50%*/div&#123; background: radial-gradient(closest-side ellipse at 40%,#ffaf7b, #d76d77 ,#3a1c71); &#125;div&#123; background: radial-gradient(closest-side ellipse at 20% 30%,#ffaf7b, #d76d77 ,#3a1c71);&#125;/*closest-corner*/div&#123; background: radial-gradient(closest-corner ellipse,#ffaf7b, #d76d77 ,#3a1c71);&#125;div&#123; background: radial-gradient(closest-corner ellipse at 40%,#ffaf7b, #d76d77 ,#3a1c71);&#125;div&#123; background: radial-gradient(closest-corner ellipse at 20% 30%,#ffaf7b, #d76d77 ,#3a1c71);&#125;/*farthest-side*/div&#123; background: radial-gradient(farthest-side ellipse,#ffaf7b, #d76d77 ,#3a1c71);&#125;div&#123; background: radial-gradient(farthest-side ellipse at 40%,#ffaf7b, #d76d77 ,#3a1c71);&#125;div&#123; background: radial-gradient(farthest-side ellipse at 20% 30%,#ffaf7b, #d76d77 ,#3a1c71);&#125;/*farthest-corner*/div&#123; background: radial-gradient(farthest-corner ellipse,#ffaf7b, #d76d77 ,#3a1c71);&#125;div&#123; background: radial-gradient(farthest-corner ellipse at 40%,#ffaf7b, #d76d77 ,#3a1c71);&#125;div&#123; background: radial-gradient(farthest-corner ellipse at 20% 30%,#ffaf7b, #d76d77 ,#3a1c71);&#125; 参数position 如果第一个有参数(center/top/bottom/left/right) 如果是原生写法记得要加at，而且对角线的时候上下和左右可以互换位置 123456789101112131415161718192021222324252627282930div&#123; background: radial-gradient(at center,hotpink, darkblue);&#125;div&#123; background: radial-gradient(at top,hotpink, darkblue);&#125;div&#123; background: radial-gradient(at bottom,hotpink, darkblue);&#125;div&#123; background: radial-gradient(at left,hotpink, darkblue);&#125;div&#123; background: radial-gradient(at right,hotpink, darkblue);&#125;div&#123; background: radial-gradient(at center center,hotpink, darkblue);&#125;div&#123; background: radial-gradient(at top left,hotpink, darkblue);&#125;div&#123; background: radial-gradient(at top right,hotpink, darkblue);&#125;div&#123; background: radial-gradient(at bottom right,hotpink, darkblue);&#125;div&#123; background: radial-gradient(at bottom left,hotpink, darkblue);&#125; 如果方向为具体数值确定圆心 可以是正数也可以是负数，可以超出范围 123456789101112131415div&#123; background: radial-gradient(circle at 0 0,hotpink, darkblue);&#125;div&#123; background: radial-gradient(circle at 50px 50px,hotpink, darkblue);&#125;div&#123; background: radial-gradient(circle at 100px 50px,hotpink, darkblue);&#125;div&#123; background: radial-gradient(circle at 50px 100px,hotpink, darkblue);&#125;div&#123; background: radial-gradient(circle at 100px 100px,hotpink, darkblue);&#125; 如果方向为百分比确定圆心 可以是整数也可以是负数，可以超出范围，方向和上面的一样 123456789101112131415div&#123; background: radial-gradient(circle at 0 0,hotpink, darkblue);&#125;div&#123; background: radial-gradient(circle at 25% 25%,hotpink, darkblue);&#125;div&#123; background: radial-gradient(circle at -25% 50%,hotpink, darkblue);&#125;div&#123; background: radial-gradient(circle at 50% 150%,hotpink, darkblue);&#125;div&#123; background: radial-gradient(circle at 50% 50%,hotpink, darkblue);&#125; 颜色参数 颜色参数和线性渐变类似，只是径向渐变再算百分比的时候，颜色过渡是从内而外进行的 123background: radial-gradient(#ffaf7b, #d76d77,#3a1c71); background: radial-gradient(#ffaf7b, #d76d77 20% ,#3a1c71 70%); background: radial-gradient(#ffaf7b, #d76d77 80% ,#3a1c71 90%); 径向渐变总写法 12background: radial-gradient(100px circle at 75% 75%,#ffaf7b, #d76d77 20% ,#3a1c71 60%); background: radial-gradient(200px 100px ellipse at 25% 25%,#ffaf7b, #d76d77 60% ,#3a1c71 90%); 小球案例 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; width: 200px; height: 200px; border-radius: 50%; border: 1px solid gray; background: radial-gradient(circle at 25% 25%,#DFFFDF,#00DB00,#28ff28); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 兼容性问题 只需要添加私有前缀就可以解决 注意标准语法要写在最下面，带有私有前缀的就不加to了，方向就是起始点 1234567div&#123; -webkit-background: linear-gradient(to left bottom,blue,red);/* Safari 5.1 - 6.0 */ -moz-background: linear-gradient(to left bottom,blue,red);/* Firefox 3.6 - 15 */ -ms-background: linear-gradient(to left bottom,blue,red); -o-background: linear-gradient(to left bottom,blue,red);/* Opera 11.1 - 12.0 */ background: linear-gradient(to left bottom,blue,red); /*标准语法*/&#125; 重复渐变repeating-linear-gradient() 函数和 repeating-radial-gradient() 函数来实现重复的渐变效果. 重复线性渐变repeating-linear-gradient(&lt;angle&gt; | &lt;side-or-corner&gt;, &lt;color-stop&gt;, &lt;color-stop&gt; +) 第一个参数用于定义线性渐变的方向，并且定义渐变颜色的终止位置。 auangle：通过角度来定义渐变的方向。0 度表示渐变方向从下向上，90 度表示渐变从左向右。其角度按照顺时针方向增加。 side-or-corner：通过关键字定义渐变的方向。具有两个关键字，一个表示水平位置（left 或 right），一个表示垂直位置（top 或 bottom）。关键字的先后顺序无影响，并且都是可选的。 第二个参数、第三个参数用于定义渐变颜色的起始点和终止点。 1234/* 一个由下至上的重复线性渐变, 从蓝色开始，40%后变绿， 最后渐变到红色 */repeating-linear-gradient(0deg, blue, green 40%, red); 重复渐变须在颜色后边设置起始位置，否则与线性渐变相同 重复径向渐变repeating-radial-gradient([ [ &lt;shape&gt; ] || &lt;extent-keyword&gt; ] [ at &lt;position&gt; ]?) 上述语法的参数说明： shape：用于定义径向渐变的形状，包含 circle（圆形）和 ellipse（椭圆形）。 extent-keyword：用于定义径向渐变的边缘形状的位置。 position：用于定义径向渐变的中心点位置。 color-stop：用于定义径向渐变的颜色终止点。 与重复线性渐变相似，需加上位置。也就是颜色后加上结束位置。 1234/* 一个由下至上的重复线性渐变, 从蓝色开始，40%后变绿， 最后渐变到红色 */repeating-linear-gradient(0deg, blue, green 40%, red); 唱片效果12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;重复径向渐变实现唱片效果&lt;/title&gt; &lt;style&gt; .radial-gradient &#123; position: relative; width: 262px; height: 262px; border-radius: 50%; background: linear-gradient(30deg, transparent 40%, rgba(42, 41, 40, .85) 40%) no-repeat 100% 0, linear-gradient(60deg, rgba(42, 41, 40, .85) 60%, transparent 60%) no-repeat 0 100%, repeating-radial-gradient(#2a2928, #2a2928 4px, #ada9a0 5px, #2a2928 6px); background-size: 50% 100%, 100% 50%, 100% 100%; &#125; .radial-gradient::after &#123; position: absolute; top: 50%; left: 50%; margin: -35px; border: solid 1px #d9a388; width: 68px; height: 68px; border-radius: 50%; box-shadow: 0 0 0 4px #da5b33, inset 0 0 0 27px #da5b33; background: #b5ac9a; content: &#x27;&#x27;; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;radial-gradient&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 动态渐变通过预先设置好渐变，通过animation移动background-position来呈现渐变动态变化的效果。为了使动画首尾看上去无缝衔接，渐变的首尾颜色需相同； 123456789101112131415161718192021222324.dynamics &#123; width: 100%; height: 100px; background: linear-gradient(90deg, #496eaa, #944fa8, #a8804f, #944fa8, #496eaa); background-size: 1400% 300%; animation: dynamics 20s ease infinite; -webkit-animation: dynamics 20s ease infinite; -moz-animation: dynamics 20s ease infinite;&#125;@keyframes dynamics &#123; 0% &#123; background-position: 0% 0%; &#125; 50% &#123; background-position: 50% 100%; &#125; 100% &#123; background-position: 100% 0%; &#125;&#125;&lt;div class=&quot;dynamics&quot;&gt;&lt;/div&gt;","path":"page/css13.html","date":"01-19","excerpt":"","tags":[{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"http://xiaoliblog.cn/tags/HTML-CSS/"}]},{"title":"前端三剑客🎉布局","text":"布局 第一步拆解页面布局：按照垂直方向进行划分 第二步拆解页面布局：按照水平方向进行分化 第三步拆解页面局部：垂直方向继续划分 布局名称 说明 块布局 用来布置文件。块布局包含以文档为中心的功能。 行内布局 用来布置文本 表格布局 用来布置表格 定位布局 用来对那些与其他元素五交互的定位元素进行布置 弹性盒子布局 用来布置那些可以顺利调整大小的复杂页面 网格布局 用来布置那些与一个固定网格相关的元素 普通布局头部、内容、底部 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .container &#123; width: 80%; margin: 30px auto; border:2px solid red; box-sizing: border-box; &#125; .container header &#123; width: 100%; height: 30px; background: #faa; &#125; .container .content &#123; width: 80%; height: 300px; margin: 0 auto; background: #aaf; &#125; .container footer &#123; height: 50px; background: #afa; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;header&gt;头部&lt;/header&gt; &lt;div class=&quot;content&quot;&gt;body&lt;/div&gt; &lt;footer&gt;尾部&lt;/footer&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 居中布局垂直居中 实现方法 vertical-align 前提：为父级元素设置 display 1234/*1. 将父级元素改为 display:table-cell2. 为父级元素设置 vertical-align：middle*/ 定位 (相对定位) 1234561. 为父级开启相对定位2. 为子级元素开启绝对定位3. 设置属性 top:50% transform:translateX(一半的值) 也可以使用margin-top 真实代码 123456789101112131415161718192021222324252627282930313233&lt;!-- 第一种方式 --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .a &#123; height: 600px; width: 700px; border: 1px solid gray; /* 为父级设置vertical-align属性即可 */ display: table-cell; vertical-align: middle; &#125; .b &#123; width: 300px; height: 350px; background-color: lightcoral; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;a&quot;&gt; &lt;div class=&quot;b&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536&lt;!-- 第二种方式 --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .a &#123; height: 600px; width: 700px; border: 1px solid gray; position: relative; &#125; .b &#123; width: 300px; height: 300px; background-color: lightcoral; position: absolute; top: 50%; /* 此div的高度的50% */ transform: translateY(-150px); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;a&quot;&gt; &lt;div class=&quot;b&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 水平居中实现方法 外边距（margin: 0 auto） 如果当前容器元素或后代元素中包含文本内容，该文本内容居中显示text-align 属性 (可继承) 原本的作用就是实现文本居中显示 定位（一般使用相对定位，因为不脱离文档流）只有在父级容器开启定位后，才是相对于父级进行定位 123456/* a)将 left 偏移量设置为 50%b)将子级元素向左移动(子级元素宽度的1/2)*/transform: translateX(-150px) - CSS3新增属性margin-left: -150px 真实代码： 1234567891011121314151617181920212223242526272829303132&lt;!--第一种方法--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .a &#123; height: 300px; width: 400px; border: 1px solid gray; &#125; .b &#123; width: 200px; height: 150px; background-color: lightcoral; margin: 0 auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;a&quot;&gt; &lt;div class=&quot;b&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!--第二种方法--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .a &#123; height: 300px; width: 400px; border: 1px solid gray; /* 为父级设置text-align属性 - 子级必须是行内块级元素 - 因为此属性具有遗传性，因此会将子元素中的元素也居中 */ text-align: center; &#125; .b &#123; width: 200px; height: 150px; background-color: lightcoral; display: inline-block; /* 解决子级元素居中问题 */ text-align: left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;a&quot;&gt; &lt;div class=&quot;b&quot;&gt;测试文字&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738&lt;!--第三种--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .a &#123; height: 300px; width: 400px; border: 1px solid gray; position: relative; &#125; .b &#123; width: 200px; height: 150px; background-color: lightcoral; left: 50%; /* 父级元素必须开启定位 此值为此元素宽度的一半（50%） */ transform: translateX(100px); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;a&quot;&gt; &lt;div class=&quot;b&quot;&gt;测试文字&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 同时垂直水平居中 1234567891011121314151617181920212223242526272829303132&lt;!--第一种方法--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .a &#123; height: 300px; width: 400px; border: 1px solid gray; position: relative; &#125; .b &#123; width: 200px; height: 150px; background-color: lightcoral; position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;a&quot;&gt; &lt;div class=&quot;b&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435&lt;!--第二种方法--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .a &#123; height: 300px; width: 400px; border: 1px solid gray; display: table-cell; vertical-align: middle; text-align: center; &#125; .b &#123; width: 200px; height: 150px; background-color: lightcoral; margin: 0 auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;a&quot;&gt; &lt;div class=&quot;b&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536&lt;!--第三·种方法--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .a &#123; height: 300px; width: 400px; border: 1px solid gray; display: table-cell; vertical-align: middle; text-align: center; &#125; .b &#123; width: 200px; height: 150px; background-color: lightcoral; display: inline-block; text-align: left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;a&quot;&gt; &lt;div class=&quot;b&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 多列布局两列布局一列定宽，一列自适应 关键在于自适应列 第一种 这种方式存在的问题：如果改变左边 div 的宽度，则需要同时改变右边 div 的左外边距 (margin-left)。 解决方案 ：可以将 margin-left 修改为 overflow:hidden （但依然存在问题：内容溢出隐藏） 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container &#123; width: 600px; height: 400px; border: 1px solid black; margin: 0 auto; &#125; .left &#123; width: 200px; height: 100%; background-color: lightcoral; /* 为左边div设置浮动 */ float: left; &#125; .right &#123; height: 100%; background-color: lightskyblue; /* 可以将外边距设置为 overflow:hidden */ margin-left: 200px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 第二种方法 table-cell 属性说明 设置定宽 则自适应 不设置则自适应 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container &#123; width: 600px; height: 400px; border: 1px solid black; margin: 0 auto; display: table; table-layout: fixed; &#125; .left,.right&#123; display: table-cell; &#125; .left &#123; width: 200px; height: 100%; background-color: lightcoral; &#125; .right &#123; height: 100%; background-color: lightskyblue; margin-left: 200px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 三列分布两列定宽，一列自适应 等分布局 通过浮动实现 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container&#123; width: 800px; height: 400px; border: 1px solid gray; margin: 0 auto; &#125; .column&#123; width: 25%; height: 100%; float: left; box-sizing: border-box; &#125; .box1&#123; background-color: lightcoral; &#125; .box2&#123; background-color: lightgreen; &#125; .box3&#123; background-color: lightskyblue; &#125; .box4&#123; background-color: lightpink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;column box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;column box2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;column box3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;column box4&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 通过表格实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container &#123; width: 800px; height: 400px; border: 1px solid gray; margin: 0 auto; display: table; table-layout: fixed; &#125; .column &#123; height: 100%; box-sizing: border-box; display: table-cell; &#125; .box1 &#123; background-color: lightcoral; &#125; .box2 &#123; background-color: lightgreen; &#125; .box3 &#123; background-color: lightskyblue; &#125; .box4 &#123; background-color: lightpink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;column box1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;column box2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;column box3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;column box4&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 通过无序列表实现 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container &#123; margin: 0 auto; padding: 0; border: 1px solid gray; width: 800px; height: 400px; &#125; .column &#123; list-style: none; float: left; width: 25%; height: 100%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class=&quot;container&quot;&gt; &lt;li class=&quot;column&quot;&gt;示例样式&lt;/li&gt; &lt;li class=&quot;column&quot;&gt;示例样式&lt;/li&gt; &lt;li class=&quot;column&quot;&gt;示例样式&lt;/li&gt; &lt;li class=&quot;column&quot;&gt;示例样式&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 等高布局 通过表格实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .container &#123; width: 800px; height: 400px; border: 1px solid gray; margin: 0 auto; display: table; table-layout: fixed; &#125; .left, .right &#123; /* 表格中的单元格默认时等高的 */ display: table-cell; &#125; .left &#123; width: 300px; background-color: lightcoral; &#125; .right &#123; width: 300px; background-color: lightskyblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;column left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;column right&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 全屏布局没有滚动条，布局根据窗口大小改变。 宽度问题直接设置成 100% 即可 高度问题 为 body 设置 height:100%, 为子级元素设置 height:100% vh 单位，即设置height:100vh即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;!--实现方案1--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html, body &#123; margin: 0; height: 100%; &#125; .container &#123; width: 100%; height: 100%; overflow: hidden; &#125; .top, .content, .bottom &#123; position: absolute; &#125; .top &#123; width: 100%; height: 50px; background-color: lightcoral; left: 0; top: 0; right: 0; &#125; .content &#123; width: 100%; /* height: 100px; */ background-color: lightgreen; left: 0; right: 0; top: 50px; bottom: 50px; &#125; .left, .right &#123; float: left; position: relative; &#125; .left &#123; width: 300px; height: 100%; background-color: lightskyblue; z-index: 9999; &#125; .right &#123; width: 100%; height: 100%; background-color: mediumorchid; margin-left: -300px; z-index: 0; &#125; .bottom &#123; width: 100%; height: 50px; background-color: lightgray; left: 0; bottom: 0; right: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 全屏布局容器 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;!-- 顶部栏 --&gt; &lt;div class=&quot;top&quot;&gt;&lt;/div&gt; &lt;!-- 主体: 菜单+内容区 --&gt; &lt;div class=&quot;content&quot;&gt; &lt;!-- 菜单 --&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;!-- 内容区 --&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 底部栏 --&gt; &lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;!--实现方案2--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /* 初始化边距 */ body, p &#123; margin: 0; &#125; /* 初始化高度 */ body, html, .parent &#123; height: 100%; &#125; /* 将上部 中部 下部 水平铺满 */ .top, .middle, .bottom &#123; position: absolute; left: 0; right: 0; &#125; /* 顶部始终在上 */ .top &#123; top: 0; height: 50px; &#125; /* 底部始终在下 */ .bottom &#123; bottom: 0; height: 50px; &#125; /* 中部位置 */ .middle &#123; top: 50px; bottom: 50px; &#125; .left, .right &#123; position: absolute; top: 0; bottom: 0; &#125; /* 左 */ .left &#123; width: 100px; &#125; /* 右 */ .right &#123; left: 120px; right: 0; overflow: auto; &#125; .right-in &#123; height: 1000px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;parent&quot; id=&quot;parent&quot; style=&quot;background-color: lightgrey;&quot;&gt; &lt;div class=&quot;top&quot; style=&quot;background-color: lightblue;&quot;&gt; &lt;p&gt;top&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;middle&quot; style=&quot;background-color: pink;&quot;&gt; &lt;div class=&quot;left&quot; style=&quot;background-color: orange;&quot;&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot; style=&quot;background-color: lightsalmon;&quot;&gt; &lt;div class=&quot;right-in&quot;&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;bottom&quot; style=&quot;background-color: lightgreen;&quot;&gt; &lt;p&gt;bottom&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 圣杯布局12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .container &#123; position: relative;; height: 300px; background: #ddd; padding: 0 300px 0; &#125; .container .middle&#123; float: left; width: 100%; height: 300px; &#125; .container .left&#123; float: left; position: relative; height: 300px; width: 300px; margin-left: -100%; left: -300px; &#125; .container .right &#123; float: left; position: relative; width: 300px; height: 300px; margin-left: -300px; left: 300px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 圣杯布局 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;!--middle写在最前面，这样网页在载入时，就会优先加载--&gt; &lt;div class=&quot;middle&quot; style=&quot;background-color: cyan;&quot;&gt;middle&lt;/div&gt; &lt;div class=&quot;left&quot; style=&quot;background-color: darkgreen;&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot; style=&quot;background-color: darkorange;&quot;&gt;right&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 双飞翼布局双飞翼布局和圣杯差不多，主要是将padding换成了margin而且只需要包裹middle即可 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .container&#123; float: left; width: 100%; height: 300px; background: #ddd; &#125; .container .middle&#123; height: 300px; margin: 0 300px; &#125; .left&#123; float: left; position: relative; width: 300px; height: 300px; margin-left: -100%; &#125; .right&#123; float: left; position: relative; width: 300px; height: 300px; margin-left: -300px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 圣杯布局 --&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;middle&quot; style=&quot;background-color: cyan;&quot;&gt;middle&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;left&quot; style=&quot;background-color: darkgreen;&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot; style=&quot;background-color: darkorange;&quot;&gt;right&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 综合123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; * &#123; margin:0; padding: 0; &#125; .wrapper &#123; width: 100%; display: flex; &#125; .wrapper .left &#123; width: 200px; height: 90vh; background: #faa; &#125; .wrapper .left .left-box &#123; width: 90%; height: 120px; margin: 30px auto; background: #ff4; &#125; .wrapper .left .left-box2 &#123; height: 50%; &#125; .wrapper .right &#123; width: 200px; height: 90vh; background: #afa; &#125; .wrapper .right .card &#123; width: 80%; margin: 20px auto; background-color: #f42 &#125; .wrapper .content &#123; flex: 1; min-height: 90vh; background: #aaf; column-count: 3; column-gap: 10px; &#125; .wrapper .card &#123; width: 100%; height: 100px; background: #c44; font-size: 18px; text-align: center; line-height: 100px; margin:5px 0; break-inside: avoid; &#125; header,footer &#123; height: 5vh; background: #424242; &#125; h2 &#123; text-align: center; color: #f8f8f8; &#125; @media screen and (max-width: 800px) &#123; .wrapper .content &#123; column-count: 2; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 头部 --&gt; &lt;header&gt;&lt;h2&gt;头部&lt;/h2&gt;&lt;/header&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;div class=&quot;left-box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;left-box left-box2&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;card&quot; style=&quot;height: 100px&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;card&quot; style=&quot;height: 200px&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;card&quot; style=&quot;height: 150px&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;card&quot; style=&quot;height: 210px&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;card&quot; style=&quot;height: 120px&quot;&gt;5&lt;/div&gt; &lt;div class=&quot;card&quot; style=&quot;height: 180px&quot;&gt;6&lt;/div&gt; &lt;div class=&quot;card&quot; style=&quot;height: 160px&quot;&gt;7&lt;/div&gt; &lt;div class=&quot;card&quot; style=&quot;height: 136px&quot;&gt;8&lt;/div&gt; &lt;div class=&quot;card&quot; style=&quot;height: 120px&quot;&gt;9&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;div class=&quot;card&quot;&gt;&lt;/div&gt; &lt;div class=&quot;card&quot;&gt;&lt;/div&gt; &lt;div class=&quot;card&quot;&gt;&lt;/div&gt; &lt;div class=&quot;card&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;footer&gt;&lt;h2&gt;底部&lt;/h2&gt;&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt;","path":"page/css06.html","date":"01-19","excerpt":"","tags":[{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"http://xiaoliblog.cn/tags/HTML-CSS/"}]},{"title":"前端三剑客🎉定位","text":"定位定位=定位模式+边偏移 定位模式 123div&#123; position:static | absolute | fixed | relative | sticky ;&#125; static: 默认值，表示元素为静态定位。指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。 absolute: 表示元素为绝对定位。不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。 fixed: 表示元素为固定定位。不为元素预留空间，而是通过指定元素相对于屏幕视口 (viewport)的位置来指定元素位置。 relative: 表示元素为相对定位。元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置。 sticky：表示元素为粘性定位。可以被认为是相对定位和固定定位和混合 简单来说定位就是规定被定位元素距离页面顶部及左边的距离 边偏移 top顶端偏移量，定义元素相对于其父元素上边线的距离 bottom底端偏移量，定义元素相对于其父元素下边线的距离 left左侧偏移量，定义元素相对于其父元素左边线的距离 right右侧偏移量，定义元素相对于其父元素右边线的距离 相对定位 不脱离文档流 相对于自身原来的位置进行定位（移动位置的时候参照点是自己原来的位置） 原来在标准流的位置继续占有，后面的盒子仍然不会占有它的位置，而是继续保持原来的位置 最典型的应用就是给绝对定位当爹…，用来限制绝对定位 12345div&#123; position:relative; top:30px; left:40px;&#125; 绝对定位 开启后脱离文档流，不占有原来位置，其他标准流元素会占用其原来位置 如果没有祖先元素或者祖先元素没有定位，则以浏览器为准定位 如果祖先元素有定位，则以祖先元素为参考点移动 12345678910111213.son&#123; position: absolute; top:30px; left:40px; &#125; .father&#123; position: relative; &#125;&lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;&lt;/div&gt; 如果多个祖先元素有定位（相对、绝对、固定），则以最近一级的有定位祖先元素为参考点移动位置 12345678910111213141516171819.grandfather&#123; position: relative;&#125;.son &#123; position: absolute; top: 30px; left: 40px;&#125;.father &#123;&#125; &lt;div class=&quot;grandfather&quot;&gt; grandfather have position &lt;div class=&quot;father&quot;&gt; father no position &lt;div class=&quot;son&quot;&gt;son&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 子绝父相 子级绝对定位，不会占有位置，可以放到父盒子里面的任何一个地方，不会影响其他的兄弟盒子 父盒子需要加定位限制子盒子在父盒子内显示 父盒子布局时，需要占用位置，因此父亲只能是相对定位 总结：父亲需要占有位置，因此是相对定位，子盒子不需要占有位置，因此是绝对定位 绝对定位居中算法 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; .box &#123; position: absolute; /* 1. left 走 50% 父容器宽度的一半 */ left: 50%; /* 2. margin 负值 往左边走 自己盒子宽度的一半 */ margin-left: -100px; top: 50%; margin-top: -100px; width: 200px; height: 200px; background-color: pink; /* margin: auto; */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 固定定位 相对于浏览器窗口的定位，跟父元素没有关系 不随滚动条滚动 脱离文档流，不占有原先的位置 123div&#123; position: fixed;&#125; 固定定位小技巧：固定在版心右侧位置，并且不受浏览器的缩放影响 小算法： 让固定定位的盒子left:50%，走到浏览器可视区（也可以看做版心）的一半位置 让固定定位的盒子margin-left:版心宽度的一半距离。多走版心宽度的一半位置 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; .w &#123; width: 800px; height: 1400px; background-color: pink; margin: 0 auto; &#125; .fixed &#123; position: fixed; /* 1. 走浏览器宽度的一半 */ left: 50%; /* 2. 利用margin 走版心盒子宽度的一半距离 */ margin-left: 405px; width: 50px; height: 150px; background-color: skyblue; &#125; .other&#123; width: 100px; height: 100px; background-color:seagreen; position: fixed; top:300px; left: 400px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;fixed&quot;&gt;用了算法&lt;/div&gt; &lt;div class=&quot;w&quot;&gt;版心盒子 800像素&lt;/div&gt; &lt;div class=&quot;other&quot;&gt;未用算法&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ![](https://cdn.jsdelivr.net/gh/xiaoliblog/image@310c5c1f75bcbe9ac9c4a10346dcca5ab6d84469/2021/01/21/c646bd502a7654749bf17a7b54c8f80a.png) 可以看到用了算法的固定定位不受浏览器缩放的影响 粘性定位粘性定位可以被认为是相对定位和固定定位和混合 1234div&#123; position: sticky; top:10px;&#125; 以浏览器的可视窗口为参照点移动元素（固定定位特点） 粘性定位占有原先的位置（相对定位特点） 必须添加top、left、right、bottom其中一个才有效 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; body &#123; height: 3000px; &#125; .nav &#123; /* 粘性定位 */ position: sticky; /*当距离顶部为0变成固定定位*/ top: 0; width: 800px; height: 50px; background-color: pink; margin: 100px auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;nav&quot;&gt;我是导航栏&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 堆叠在使用定位布局时，可能会出现盒子重叠的情况，此时，可以使用z-index来控制盒子的前后次序（z轴） 123div&#123; z-index:1;&#125; 数值可以是正整数、负整数或0，默认是auto，数值越大，盒子越靠上 定位的特性 行内元素添加绝对或者固定定位后，可以直接设置高度和宽度 块级元素添加绝对或者固定定位后，如果不给宽度或者高度，默认大小是内容的大小 脱标的盒子不会触发外边距塌陷，浮动元素、绝对/固定定位元素都不会触发外边距合并的问题 绝对定位（固定定位）会完全压住盒子 浮动元素不同，只会压住它下面标准流的盒子，但是不是压住下面标准流盒子里面的文字（图片） 但是绝对定位（固定定位）会压住下面标准流所有内容 浮动之所以不会压住文字，因为浮动产生的目的最初是为了做文字环绕效果 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; div&#123; width: 100px; height: 100px; background-color:seagreen; float:left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;p&gt;浮动元素不会压住文字&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; div&#123; width: 100px; height: 100px; background-color:seagreen; position: absolute; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;p&gt;浮动元素不会压住文字&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;浮动产生原来的目的是做文字环绕效果&lt;/title&gt; &lt;style&gt; img &#123; float: left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; 1993年，在古装片《战神传说》中扮演一个武功超群的渔民；同年，主演动作喜剧片《至尊三十六计之偷天换日》，在片中饰演赌术高明的千门高手钱文迪；此外，他还主演了爱情片《天长地久》，在片中塑造了一个风流不羁的江湖浪子形象。 1994年，刘德华投资并主演了剧情片《天与地》，在片中饰演面对恶势力却毫不退缩的禁毒专员张一鹏。1995年，主演赛车励志片《烈火战车》，在片中饰演叛逆、倔强的阿祖，并凭借该片获得第15届香港电影金像奖最佳男主角提名；同年在动作片《大冒险家》中演绎了立仁从小时候父母双亡到长大后进入泰国空军的故事。 1996年，主演黑帮题材的电影《新上海滩》，在片中饰演对冯程程痴情一片的丁力。1997年，担任剧情片《香港制造》的制作人；同年，主演爱情片《天若有情之烽火佳人》，在片中饰演家世显赫的空军少尉刘天伟；12月，与梁家辉联袂主演警匪动作片《黑金》，在片中饰演精明干练、嫉恶如仇的调查局机动组组长方国辉。1998年，主演动作片《龙在江湖》 &lt;img src=&quot;images/index.png&quot; alt=&quot;&quot;&gt; ，饰演重义气的黑帮成员韦吉祥；同年，出演喜剧片《赌侠1999》；此外，他还担任剧情片《去年烟花特别多》的制作人。 1993年，在古装片《战神传说》中扮演一个武功超群的渔民；同年，主演动作喜剧片《至尊三十六计之偷天换日》，在片中饰演赌术高明的千门高手钱文迪；此外，他还主演了爱情片《天长地久》，在片中塑造了一个风流不羁的江湖浪子形象。 1994年，刘德华投资并主演了剧情片《天与地》，在片中饰演面对恶势力却毫不退缩的禁毒专员张一鹏。1995年，主演赛车励志片《烈火战车》，在片中饰演叛逆、倔强的阿祖，并凭借该片获得第15届香港电影金像奖最佳男主角提名；同年在动作片《大冒险家》中演绎了立仁从小时候父母双亡到长大后进入泰国空军的故事。 1996年，主演黑帮题材的电影《新上海滩》，在片中饰演对冯程程痴情一片的丁力。1997年，担任剧情片《香港制造》的制作人；同年，主演爱情片《天若有情之烽火佳人》，在片中饰演家世显赫的空军少尉刘天伟；12月，与梁家辉联袂主演警匪动作片《黑金》，在片中饰演精明干练、嫉恶如仇的调查局机动组组长方国辉。1998年，主演动作片《龙在江湖》，饰演重义气的黑帮成员韦吉祥；同年，出演喜剧片《赌侠1999》；此外，他还担任剧情片《去年烟花特别多》的制作人。&lt;/body&gt;&lt;/html&gt;","path":"page/css08.html","date":"01-19","excerpt":"","tags":[{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"http://xiaoliblog.cn/tags/HTML-CSS/"}]},{"title":"前端三剑客🎉浮动","text":"定位是什么所谓定位，简单来说就是通过 CSS 样式属性设定 HTML 页面元素在运行时显示的位置。 定位的基本思想很简单，它允许定义元素相对于父级元素、另一个指定元素或者当前浏览器窗口应该显示的位置。 CSS 实现定位的效果主要通过浮动 ( float ) 和定位 ( position) 两个样式属性实现。 文档流 文档流也叫标准流，就是标签按照规定好的默认方式排列 将 HTML 页面中的元素自上向下分成一行一行，并在每行中按从左至右的挨次排放元素，即为文档流。 文档流是 HTML 页面的底层结构，HTML 页面创建的元素默认都在文档流中。 注意：如果在一行中不能容纳所有的元素，则会换到下一 行，继续自左向右排列。有三种状况将使得元素离开文档流而存在，分别是浮动、绝对定位、固定定位。 浮动网页布局第一准则：多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动 123div&#123; float:none | left | right;&#125; float 属性指定一个 元素应沿其容器的左侧或右侧放置，允许文本和内联元素环绕它。该属性具有以下几个值: . none: 默认值，表示元素不浮动。 left: 表示元素必须要浮动在其所在容器的左侧。 right: 表示元素必须要浮动在其所在容器的右侧。 设置为浮动后，该元素原来的位置会被下一个元素替代。当前元素设置浮动后，会影响当前元素后边的元素 所有元素都设置为浮动的话，块级元素排列顺序变为水平方向的排列， 浮动特性 浮动元素会脱离标准流，移动到指定的位置 浮动的盒子不再保留原先的位置，位置被其他标准流元素占有 如果多个盒子都设置了浮动，则它们会按照属性值一行内显示并顶端对齐排列 浮动的元素是互相贴靠在一起的（不会有缝隙），如果父级宽度装不下这些浮动的盒子，多出的盒子会另起一行对齐 浮动元素会具有行内块元素特性任何元素都可以浮动，不管原来是什么模式的元素，添加浮动之后具有行内块元素相似的特性 123456span&#123; width:100px; height:100px; background-color: turquoise; float:left; &#125; 如果块级盒子没有设置宽度，默认宽度和父级一样宽，但是添加浮动后，它的大小根据内容来决定 块级元素的浮动块级元素默认的宽度和高度 宽度是父级元素宽度的 100% 高度是 0 或者所有后代元素高度之和 设置为浮动后 宽度默认是 0 或者所有后代元素宽度之和 高度默认是 0 或者所有后代元素高度之科 多个块级元素都设置为浮动后 -&gt; 垂直方向排列变为水平方向排列 如果占满父级元素宽度的 100% 后，会自动换行 内联元素内联元素的默认宽度和高度 宽度是内容的宽度 - width 属性是无效的 高度是内容的高度 - height 属性是无效的 内联元素设置为浮动后 width 和 height 属性有效 多个内联元素依旧是水平排列 行内块级元素行内块级元素设置为浮动后，元素之间的空白间隙被取消 浮动布局 浮动元素经常和标准流父级搭配使用 先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置，符合网页布局第一准则 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;style&gt; .box&#123; width: 1200px; height: 460px; background-color: pink; margin:0 auto; &#125; .left&#123; width: 230px; height: 460px; background-color:yellowgreen; float: left; &#125; .right&#123; width: 970px; height: 460px; background-color:turquoise; float: left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;left&quot;&gt;左侧&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;右侧&lt;/div&gt; &lt;/div&gt;&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;浮动元素搭配标准流父盒子2&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; li &#123; list-style: none; &#125; .box &#123; width: 1226px; height: 285px; background-color: pink; margin: 0 auto; &#125; .box li &#123; width: 296px; height: 285px; background-color: rgb(131, 206, 193); float: left; margin-right: 14px; &#125; /* 这里必须写 .box .last 要注意权重的问题 20 */ .box .last &#123; margin-right: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class=&quot;box&quot;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li class=&quot;last&quot;&gt;4&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;浮动布局练习3&lt;/title&gt; &lt;style&gt; .box &#123; width: 1226px; height: 615px; background-color: pink; margin: 0 auto; &#125; .left &#123; float: left; width: 234px; height: 615px; background-color: rgb(112, 209, 125); &#125; .right &#123; float: left; width: 992px; height: 615px; background-color: skyblue; &#125; .right&gt;div &#123; float: left; width: 234px; height: 300px; background-color: pink; margin-left: 14px; margin-bottom: 14px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;left&quot;&gt;左青龙&lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;div&gt;6&lt;/div&gt; &lt;div&gt;7&lt;/div&gt; &lt;div&gt;8&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 浮动布局注意点 先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置 浮动的盒子只会影响浮动盒子后面的标准流，不会影响前面的标准流 浮动的特殊情况 父级与子级之间的浮动为子级元素设置浮动不能超出父级元素的范围（与父级元素浮不浮动无关） 兄弟同时设置浮动如果兄弟关系的两个元素，为下一个兄弟元素设置为浮动，下一个兄弟元素不会超过上一个兄弟元素的位置 文本与浮动的元素文本内容与浮动的元素之间，文本内容不会被浮动的元素所覆盖，而是环绕在浮动元素的周围 清除浮动为什么清除浮动由于父盒子很多情况下，不方便给高度，但是子盒子浮动又不占有位置，最后父级盒子高度为0时，就会影响下面的标准流盒子 由于浮动元素不再占有原文档的位置，所以它会对后面的元素排版产生影响 清除浮动本质 清除浮动元素造成的影响 如果父盒子本身有高度，则不需要清除浮动 清除浮动之后，父级就会根据浮动的子盒子自动检测高度，父级有了高度，就不会影响下面的标准流了 清除浮动策略 闭合浮动，只让浮动中父盒子内部影响，不影响父盒子外面的其他盒子 123div&#123; clear:none|left|right|both;&#125; clear 属性设置元素是否显示在其之前元素的下方。该属性具有以下几个值: none: 表示元素不会向下移动清除之前的浮动。 left: 表示元素被向下移动用于清除之前的左浮动。 right: 表元素被向下移动用于清除之前的右浮动。 both: 元素被向下移动用于清除之前的左右浮动。 clear 属性的使用可以分别以下两种情况: 使用 clear 属性为非浮动元素清除浮动时，该元素将移动到之前浮动元素的下方。 使用 clear 属性为浮动元素清除浮动时，该元素将移动到之前浮动元素的下方，并且会影响之后浮动元素的布局。 额外标签法额外标签法也称为隔墙法。会中浮动元素末尾添加一个空标签并添加clear:both属性。例如&lt;div style=”clear:both”&gt;&lt;/div&gt;，或者其他标签（如&lt;br&gt;等）清除浮动前 123456789 .blank&#123; clear: both;&#125; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;damao&quot;&gt;大毛&lt;/div&gt; &lt;div class=&quot;ermao&quot;&gt;二毛&lt;/div&gt; &lt;div class=&quot;blank&quot;&gt;&lt;/div&gt; /*给最后一一个盒子后面加一个空标签，并设置clear:both*/&lt;/div&gt;&lt;div class=&quot;footer&quot;&gt;&lt;/div&gt; 注意：要求这个新添加的空标签必须是块级元素 overflow可以给父级添加overflow属性，将其属性值设置为hidden、auto或scroll 123.box&#123; overflow:hidden;&#125; 缺点：无法显示溢出的部分 after伪元素清除浮动:after也是给父元素添加，相对于在后面加了一个盒子 12345678910111213141516.clearfix::after &#123; content: &quot;&quot;; display: block; clear: both; height:0; visibility:hidden;&#125;.clearfix&#123; /*IE6、7专有*/ *zoom:1;&#125;&lt;div class=&quot;box clearfix&quot;&gt;/*多个类名*/ &lt;div class=&quot;damao&quot;&gt;大毛&lt;/div&gt; &lt;div class=&quot;ermao&quot;&gt;二毛&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;footer&quot;&gt;&lt;/div&gt; 双伪元素清除浮动也是给父元素添加，相当于在前面加了盒子 12345678910111213141516.clearfix:before,.clearfix:after&#123; content:&quot;&quot;; display:table;&#125;.clearfix:after&#123; clear:both;&#125;.clearfix&#123; *zoom:1;&#125;&lt;div class=&quot;box clearfix&quot;&gt;/*多个类名*/ &lt;div class=&quot;damao&quot;&gt;大毛&lt;/div&gt; &lt;div class=&quot;ermao&quot;&gt;二毛&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;footer&quot;&gt;&lt;/div&gt; 高度塌陷发生的场景 存在父子级关系 父级没有设置高度 子级元素设置浮动 解决方案： 为父级设置高度（不推荐） 块级格式化上下文（BFC） 开启方式如下几种： 将元素设 置为浮动 (元素的 CSS 样式属性 float 值不为 none) 将元素 设置为绝对定位 将元素设 置为行内块级元素 (元素的 CSS 样式属性 display 值为 inline- -block) overflow 属 性值设置不为 visible 的块级元素 (一般情况下，值为 hidden)多多少少会带有一些副作用 案例京东垂直菜单1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body&#123; background-color: gray; &#125; ul&#123; background-color: white; width: 150px; list-style-type: none; padding: 0; &#125; ul li&#123; font-size: 14px; line-height: 25px; color: gray; padding: 0 7px ; &#125; ul li:hover&#123; color: lightcoral; background-color: lightgray; cursor: pointer; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;第一个&lt;/li&gt; &lt;li&gt;第二个&lt;/li&gt; &lt;li&gt;第三个&lt;/li&gt; &lt;li&gt;第四个&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 京东水平菜单1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body&#123; background-color: gray; &#125; ul&#123; background-color: white; list-style: none; /* 去除项目符号所占空间 */ padding-left: 0; /* 解决高度塌陷问题 */ overflow: hidden; &#125; ul li&#123; float: left; width: 95px; height: 40px; line-height: 40px; text-align: center; &#125; li:hover&#123; background-color: violet; &#125; li a&#123; text-decoration: none; color: black; &#125; ul li a&#123; display: block; width: 100%; height: 40px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&#x27;#&#x27;&gt;测试1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&#x27;#&#x27;&gt;测试2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&#x27;#&#x27;&gt;测试3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&#x27;#&#x27;&gt;测试4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&#x27;#&#x27;&gt;测试5&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;","path":"page/css10.html","date":"01-19","excerpt":"","tags":[{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"http://xiaoliblog.cn/tags/HTML-CSS/"}]},{"title":"前端三剑客🎉显示与隐藏","text":"元素显示模式 元素显示模式就是元素(标签)以什么方式进行显示，比如div自己占一行，比如一行可以放多个span HTML元素一般分块元素和行内元素 块元素常见的块元素有&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;等，其中&lt;div&gt;是最典型的块元素 块元素的特点 独占一行 可以控制高度、宽度、外边距以及内边距 宽度默认是容器（父级容器）的100% 是一个容器以及盒子，里面可以放行内或者块级元素 文字类的元素内不能使用块级元素 行内元素常见的行内元素有&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt;等，其中&lt;span&gt;是最典型的行内元素，也叫内联元素 行内元素的特点 相邻行内元素在一行上，一行可以显示多个 高、宽度直接设置是无效的 默认宽度就是它本身内容的宽度 行内元素只能容纳文本或其他行内元素 链接里面不能放链接特殊情况下链接&lt;a&gt;里面可以放块级元素，但是给&lt;a&gt;转换以下块级模式最安全 行内块元素在行内元素中有几个特殊的标签——&lt;img/&gt;、&lt;input/&gt;、&lt;td&gt;，它们同时具有块元素和行内元素的特点，称为行内块元素 行内块元素的特点 和相邻行内元素（行内块）在一行上，但是它们之间会有空白缝隙。一行可以显示多个（行内元素的特点） 默认宽度就是它本身内容的宽度（行内元素的特点） 高度、行高、外边距以及内边距都可以控制（块级元素的特点） 元素模式 元素排列 设置样式 默认宽度 包含 块级元素 一行只能放一个块级元素 可以设置宽度高度 容器的100% 容器级可以包含任何标签 行内元素 一行可以放多个行内元素 不可以直接设置宽度 它本身内容的宽度 容纳文本或其他行内元素 行内块元素 一行可以放多个行内块元素 可以设置宽度和高度 它本身内容的宽度 小米侧边栏案例实现步骤 把链接a转换为块级元素，这样链接就可以单独占一行，并且有宽度和高度 鼠标经过a给链接设置背景颜色 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; a&#123; display: block; width: 230px; height: 40px; background-color: #535758; font-size: 14px; color:white; text-decoration: none; text-indent: 2em; line-height: 40px; &#125; a:hover&#123; background-color: #ff6700; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;#&quot;&gt;手机 电话卡&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;电视 盒子&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;笔记本 平板&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;出行 穿戴&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;智能 路由器&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;健康 儿童&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;耳机 音箱&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 单行文字垂直居中的方法 让文字的行高等于盒子的高度就可以让文字在当前盒子内垂直居中 显示与隐藏display1display:none; 这种方式将元素设置隐藏后，该元素不会占用空间，并且不会占用原来的位置。 设置为以下属性时，会取消 display的隐藏。 block 将元素设置为块级元素 inline 将元素设置为内联元素 inline-block 将元素设置为行内块级元素 123456.one&#123; display:none;&#125;&lt;div class=&quot;one&quot;&gt;盒子1&lt;/div&gt;&lt;div class=&quot;two&quot;&gt;盒子2&lt;/div&gt; 123456.one&#123; display:block;&#125;&lt;div class=&quot;one&quot;&gt;盒子1&lt;/div&gt;&lt;div class=&quot;two&quot;&gt;盒子2&lt;/div&gt; visibility1visibility: hidden; 这种方式设置元素为隐藏后，该元素依旧占有页面空间 123456.one&#123; visibility:hidden;&#125;&lt;div class=&quot;one&quot;&gt;盒子1&lt;/div&gt;&lt;div class=&quot;two&quot;&gt;盒子2&lt;/div&gt; 通过将visibility属性值设置为visible将元素显示 123456.one&#123; visibility:visible;&#125;&lt;div class=&quot;one&quot;&gt;盒子1&lt;/div&gt;&lt;div class=&quot;two&quot;&gt;盒子2&lt;/div&gt; 内容溢出盒子放不下时内容就会超出盒子。内容是文本内容、一张图片和其他元素，超出指定容器元素的范围。如图 情况一（容器元素 div 内容是文本） 情况二（指定元素中的图片超出元素范围） 情况三（指定元素中子级元素超出范围） 解决方案：overflow visible：默认值。内容不会被修建，会显示在父级容器之外 hidden: 内容会被修剪，并且其余内容不可见。隐藏的部分不会被看到 scroll: 内容会被修剪，浏览器会显示滚动条以便查看其余内容。始终提示滚动条，效果不好 auto：浏览器决定如果内容溢出，提供相应的滚动条；没有溢出不做任何处理 overflow-x 属性水平方向上的溢出 visible: 默认值。内容不会被修剪，会显示在父级容器之外。 hidden: 内容会被修剪，并且其余内容不可见。. scroll: 内容会被修剪，浏览器会显示滚动条以便查看其余内容。 auto: 由浏览器决定，如果内容被修剪，就会显示滚动条。 overflow-y 相似。 text-overflow属性text-overflow 属性确定如何向用户发出未显示的溢出内容信号。它可以被剪切，显示一个省略号 (…) 或显示一个自定义字符串。该属性具有以下几个值: clip: 将文本内容超出父级容器的部分隐藏。 ellipsis: 将文本内容超出父级容器的部分使用省略号 (…) 表示。. sting: 将文本内容超出父级容器的部分使用指定文本内容表示，例如 “.” 等 设置此属性必须先设置overflow属性。无法单独使用。 显示遮罩实例 核心原理：原先半透明的黑色遮罩看不见，鼠标经过大盒子，就显示出来 遮罩的盒子不有位置，就需要用绝对定位和display配合使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; .tudou &#123; position: relative; width: 444px; height: 320px; background-color: pink; margin: 30px auto; &#125; .tudou img &#123; width: 100%; height: 100%; &#125; .mask &#123; /* 隐藏遮罩层 */ display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, .4) url(images/arr.png) no-repeat center; &#125; /* 当我们鼠标经过了 土豆这个盒子，就让里面遮罩层显示出来 */ .tudou:hover .mask &#123; /* 而是显示元素 */ display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;tudou&quot;&gt; &lt;div class=&quot;mask&quot;&gt;&lt;/div&gt; &lt;img src=&quot;images/img.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","path":"page/css16.html","date":"01-19","excerpt":"","tags":[{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"http://xiaoliblog.cn/tags/HTML-CSS/"}]},{"title":"前端三剑客🎉盒子模型","text":"盒子模型概述盒子模型又称为框模型，HTML 页面所有的元素都具有盒子模型，该模型用于设计HTML页面和实现 HTML 页面布局 相关概念 内容区（content）用于显示文本和图像 内边距（padding）内容区至边框的边距 边框（border）内容区的边界 外边距（margin）两个元素的边距之间的距离 盒子大小默认情况下，一个盒子的大小刚好容纳其中的内容 (文本、图片等)，并根据其中内容的变化而变化。通过 CSS 的 width 属性和height属性可以设置盒子显示的宽度和高度，从而改变盒子的大小。. 1234div&#123; width:100px; height:100px;&#125; 盒子阴影盒子的阴影广泛应用。但实现非常简单。 1box-shadow: offset-x | offset-y | blur | spread | color | inset; box-shadow 属性用于向盒子添加一个或多个阴影效果。 offset-x：阴影的水平偏移量。正数向右偏移，负数向左偏移。 offset-y：阴影的垂直偏移量。正数向下偏移，负数向上偏移。 blur：阴影模糊度，不能取负数，表示影子的虚实。 spread：阴影大小。正数阴影扩大（阴影大小大于盒子大小），负数阴影缩小（阴影大小小于盒子大小），0阴影与盒子同等大小。 color：阴影的颜色 inset：表示添加内阴影，默认为外阴影(outset)。 默认是外阴影(outset)，但是不可以写这个单词，否则导致阴影无效盒子阴影不占空间，不会影响其他盒子排列 1234567891011121314/* x偏移量 | y偏移量 | 阴影颜色 */box-shadow: 60px -16px teal;/* x偏移量 | y偏移量 | 阴影模糊半径 | 阴影颜色 */box-shadow: 10px 5px 5px black;/* x偏移量 | y偏移量 | 阴影模糊半径 | 阴影扩散半径 | 阴影颜色 */box-shadow: 2px 2px 2px 1px rgba(0, 0, 0, 0.2);/* 插页(阴影向内) | x偏移量 | y偏移量 | 阴影颜色 */box-shadow: inset 5em 1em gold;/* 任意数量的阴影，以逗号分隔 */box-shadow: 3px 3px red, -1em 0 0.4em olive; 外阴影设置单个阴影 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .box &#123; width: 300px; height: 300px; margin: 100px 100px; border: 1px solid #CCCCCC; box-shadow: 0px 0px 20px rgb(165, 149, 149); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 设置多个阴影 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .box &#123; width: 300px; height: 300px; margin: 100px 100px; border: 1px solid #CCCCCC; box-shadow: 0px 0px 10px red, 5px -5px 10px blue, 10px -10px 10px yellow, 20px -20px 10px black; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; spread取值对阴影大小的影响 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .box &#123; width: 100px; height: 100px; margin: 100px 100px; border: 1px solid #CCCCCC; box-shadow: 120px 0px 0px 0px red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 由上图可见，当 spread 为0时，阴影大小与元素大小相同。 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .box &#123; width: 100px; height: 100px; margin: 100px 100px; border: 1px solid #CCCCCC; box-shadow: 120px 0px 0px 10px red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 由上图可见，当 spread 为正数时，阴影大小将大于元素大小。如原来总宽高为102px的元素（包括边框2px），在设置阴影大小为10px后，阴影的宽高会变为122px（阴影宽高各加10） 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .box &#123; width: 100px; height: 100px; margin: 100px 100px; border: 1px solid #CCCCCC; box-shadow: 120px 0px 0px -10px red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 由上图可见，当 spread 为负数时，阴影大小将小于元素大小。如原来总宽高为102px的元素（包括边框2px），在设置阴影大小为-10px后，阴影的宽高会变为82px（阴影宽高各减10）。 内阴影1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .box &#123; width: 300px; height: 300px; margin: 100px 100px; border: 1px solid #CCCCCC; box-shadow: 0px 0px 20px red inset; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; # 盒子边框 ## 大小 样式 颜色 简写属性，表示边框核心要素包括 边框的宽度（默认值为 1px） 边框的样式（无默认值，必须直接给出） 边框的颜色（默认值是黑色） 显示效果：同时设置上下左右四个方向的边框 123div&#123; border: 10px solid black;&#125; 组合属性以上简写属性相当于同时为一个border设置宽度、样式和颜色。 例如上述代码可以写成以下形式 12345div&#123; border-width: 10px; border-style: solid; border-color: black;&#125; 关于三中属性的的取值问题（以border-width为例） border-width: 10px; : 代表四个方向 border-width: 10px 20px; : 第一个值表示上下、第二个值表示左右 border-width: 10px 20px 30px; : 第一个值表示上、第二个值表示左右、第三个值表示下 border-width: 10px 20px 30px 40px; : 上、右、下、左 不同方向上的边框按照上右下左的方向分别为 border-top border-right border-bottom border-left 而每个方向上的边框也可以分别设置不同的属性，例如 12345div&#123; border-top-width:10px; border-top-style:solid; border-top-color:black;&#125; 圆角边框1border-radius: 30px|30%; 属性的值代表（边框）到圆心的距离。当距离等于外部容器的一半时就形成了一个圆形 radius半径原理：（椭）圆与边框的交集形成圆角效果 参数值可以为数值或者百分比的形式 该属性是一个简写属性，可以跟四个值，分别代表左上角、右上角、右下角、左下角 border-top-left-radius border-top-right-radius border-bottom-right-radius border-bottom-left-radius 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;圆角边框&lt;/title&gt; &lt;style&gt; div&#123; width:100px; height: 100px; background-color:yellowgreen; &#125; .one&#123; border-radius: 50%; &#125; .two&#123; border-radius: 20%; &#125; .three&#123; border-top-left-radius: 20%; border-bottom-right-radius: 20%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;圆形&lt;/p&gt; &lt;div class=&quot;one&quot;&gt;&lt;/div&gt; &lt;p&gt;圆角矩形&lt;/p&gt; &lt;div class=&quot;two&quot;&gt;&lt;/div&gt; &lt;p&gt;不同的圆角&lt;/p&gt; &lt;div class=&quot;three&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ## 边框图像 使得边框可以引入图像，从而免去在某些情况下使用九宫格了。 123/* border-image: image-source image-height image-width image-repeat */border-image: url(&quot;/images/border.png&quot;) 30 30 repeat;border-image: url(&quot;/images/border.png&quot;) 30 30 stretch; border-image-width定义图像边框宽度。假如 border-image-width 大于已指定的 border-width，那么它将向内部 (padding/content) 扩展. border-image-source用于声明元素的边框图片（border-image）的资源 border-image-slice引用边框图片后，border-image-slice 属性会将图片分割为 9 个区域：四个角，四个边（edges）以及中心区域。四条切片线，从它们各自的侧面设置给定距离，控制区域的大小。上图说明了每个区域的位置。 区域 1-4 为角区域。 每一个都用一次来形成最终边界图像的角点。 区域 5-8 边区域。在最终的边框图像中重复，缩放或修改它们以匹配元素的尺寸。 区域 9 为中心区域。它在默认情况下会被丢弃，但如果设置了关键字 fill，则会将其用作背景图像。 中间的区域将不会被边框使用，但当设置有 fill 关键词时将会被作为 background-image。这个关键词可以被设置在属性的任何一个位置 (前面、后面或者两个值之间) border-image-repeat定义图片如何填充边框。或为单个值，设置所有的边框；或为两个值，分别设置水平与垂直的边框。 border-image-outset定义边框图像可超出边框盒的大小。 内边距内边距用于设置内容和边框之间的距离，不能设置颜色与元素的背景颜色保持一致. 同时可以简写， 一个值：上下左右 两个值：上下，左右 三个值：上，左右，下 四个值：上右下左 同时支持拆开写 1234padding-left: 20px;padding-top: 100px;padding-right: 50px;padding-bottom: 30px; 如果盒子已经有了宽度和高度，此时再指定内边框，会撑大盒子解决方法：如果保证盒子跟效果图大小保持一致，则让width/hegiht减去多出来的内边距大小即可 示例代码 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #container&#123; height: 200px; width: 200px; background-color: blue; /* padding: 100px; */ padding-left: 20px; padding-top: 100px; padding-right: 50px; padding-bottom: 30px; &#125; #content&#123; width: 200px; height: 200px; background-color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;container&quot;&gt; &lt;div id=&quot;content&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 如果盒子本身没有指定width/hegiht属性，则此时padding不会撑开盒子大小 导航栏实例利用padding可以撑开盒子的特性，用来实现导航栏自适应文字大小 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .nav&#123; height:41px; border-top: 1px solid #ff8500; border-bottom: 1px solid #edeef0; background-color: #fff; line-height: 41px; /*行高和父盒子高度一样，使内容居中*/ &#125; .nav a&#123; /*a属于行内元素需要转换 行内块元素*/ display: inline-block; font-size: 12px; color:#4c4c4c; text-decoration: none; height: 41px; /*高度和父盒子一样*/ padding:0 20px; /*设置内容之间的边距*/ &#125; .nav a:hover&#123; background-color:turquoise; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;nav&quot;&gt; &lt;a href=&quot;#&quot;&gt;新浪导航&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;手机新浪网&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;移动客户端&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;微博&lt;/a&gt; &lt;a href=&quot;#&quot;&gt;关于我&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 外边距外边距用于控制盒子之间的距离 左外边距 (margin-left) 控制元素当前水平方向的位置. 上外边距 (margin-top) 控制元素当前垂直方向的位置. 下外边距 (margin-bottom) 控制控制块级元素的下一个兄弟元素的位置 右外边距 (margin-right) 控制内联元素或行内会计元素的下一个兄弟元素的位置. margin-left 正值：向右移动 负值：向左移动 margin-top 正值：向下移动 负值：向下移动 margin-bottom 正值：下一个兄弟元素向下移动 负值：下一个兄弟元素向上移动 margin-right 正值：下一个兄弟元素向右移动 负值：下一个兄弟元素向左移动 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div&#123; width: 100px; height: 100px; background-color:turquoise; &#125; .two&#123; margin-top: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;one&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;two&quot;&gt;2&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 内容水平居中块级元素水平居中 外边距可以使块级盒子水平居中，但是必须满足两个条件： 盒子必须指定了宽度 盒子左右的外边距都设置为auto 1234div&#123;width:100px;margin:0 auto; /*上下0，左右auto*/&#125; 固定写法，其中 0 表示上下 auto 表示左右. 行内元素或者行内块元素水平居中，给父盒子使用text-align:center即可 12345div&#123;width:100px;margin:0 auto; /*上下0，左右auto*/text-align:center;&#125; 清除内外边距网页元素很多都带有默认的内外边距（比如ul标签），而且不同浏览器默认的也不一样，因此在布局前，首先要清除下网页元素的内外边距 1234*&#123; padding:0; margin:0;&#125; 行内元素为了照顾兼容性，尽量只设置左右内外边距，不要设置上下内外边距，但是转换为块级和行内块元素就可以了 外边距常见的问题外边距重叠当上下两个块元素（兄弟关系）相遇时，如果上面的元素有下外边距margin-bottom，下面的元素有上外边距margin-top，则它们之间的垂直间距本身margin-bottom与margin-top之和。取两个值中较大者这种现象被称为相邻块元素垂直外边距的合并，也叫外边距层叠 外边距重叠的问题只出现在上外边距和下外边距中左外边距和右外边距之间不存在外边距重叠解决方案: 简单的解决方案有两种: 为上一个元素设置下外边距为 300px 为下一个元素设置上外边距为 300px 也就是尽量只给一个盒子添加margin属性值 外边距传递对于两个嵌套关系（父子关系）的块元素，父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷较大的外边距值(此时，设置子盒子的外边距也会带动父盒子的移动) 出现这种情况就是因为子盒子贴父盒子太紧了 解决方案： 可以为父元素定义上边框 123.father&#123; border: 1px solid;&#125; 可以为父元素定义上内边框 123.father&#123; padding:1px;&#125; 可以为父元素添加overflow:hidden 123.father&#123; overflow: hidden;&#125; CSS3盒子模型box- sizing 属性用于设置盒子模型的类型，改变盒子大小的计算方式该属性的值具有两个: content-box: 默认值，称为标准盒子模型该模型设置元素在 HTML 页面中所占区域为内容区 + 内边距 + 边框的宽度 + 外边距(width+padding+border) border-box: 称为怪异盒子模型，最早是由微软提出的。该模型设置元素在 HTML 页面中所占区域为盒子的大小 + 外边距(width) 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; box-sizing: border-box; &#125; div &#123; width: 200px; height: 200px; background-color: pink; border: 20px solid red; padding: 15px; box-sizing: content-box; &#125; p &#123; width: 200px; height: 200px; background-color: pink; border: 20px solid red; padding: 15px; /* css3 盒子模型 盒子最终的大小就是 width 200 的大小 */ box-sizing: border-box; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; 小猪乔治 &lt;/div&gt; &lt;br&gt; &lt;p&gt; 小猪佩奇 &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 如果盒子模型改为box-sizing:border-box，那么padding和border就不会撑大盒了（前提是padding和border不会超过width宽度） 盒子宽度calc函数calc() 此CSS函数可以在声明CSS属性值时执行一些计算 1width:calc(100%-80px); 括号里可以使用+ - * /来进行计算 比如有一个需求：子盒子宽度永运比父盒子小30像素 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; .father &#123; width: 300px; height: 200px; background-color: pink; &#125; .son &#123; width: calc(100% - 30px); height: 30px; background-color: skyblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 需求我们的子盒子宽度永远比父盒子小30像素 --&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 应用示例实现三角形实现步骤 div 的宽高为 0 设置边框的宽度 设置边框样式 设置颜色 border-color: white white white black;/* 左边为黑色 */ 完整代码 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;边框的特殊应用&lt;/title&gt; &lt;style&gt; div &#123; width: 0; height: 0; border-width: 20px; border-style: solid; border-color: white white white black;/* 左边为黑色 */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 按钮效果1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;注册按钮效果的优化&lt;/title&gt; &lt;style&gt; .container &#123; /* 当前元素的默认宽度为父级元素的100% */ width: 659px; /* 当前元素的宽度不能是父级元素宽度的100% */ margin: 0 auto; &#125; a &#123; display: inline-block;/* 显示效果设置行内块级元素 */ /* 设置显示区域大小 */ width: 111px; height: 40px; /* 引入背景图像 */ background: url(&quot;https://tva1.sinaimg.cn/large/005B3XPgly1gbmo8n9srbj30i212w761.jpg&quot;) no-repeat; /* 修改链接的默认效果 */ color: #ffffff; text-decoration: none; /* 通过行高的设置实现垂直方向的居中效果 */ line-height: 40px; /* 通过盒子模型的内边距设置文本内容的显示位置 */ padding-left: 50px; font-size: 14px; &#125; #phone &#123; background-position: -310px -461px; &#125; #weibo &#123; background-position: -1px -601px; &#125; #qq &#123; background-position: -1px -651px; &#125; #wechat &#123; background-position: -213px -1191px; &#125; #phone:hover &#123; background-position: -310px -521px; &#125; #weibo:hover &#123; background-position: -199px -601px; &#125; #qq:hover &#123; background-position: -199px -651px; &#125; #wechat:hover &#123; background-position: -213px -1251px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- &lt;div&gt;元素称为容器元素 --&gt;&lt;div class=&quot;container&quot;&gt; &lt;a id=&quot;phone&quot; href=&quot;#&quot;&gt; 手机注册&lt;/a&gt; &lt;a id=&quot;weibo&quot; href=&quot;#&quot;&gt; 新浪微博注册&lt;/a&gt; &lt;a id=&quot;qq&quot; href=&quot;#&quot;&gt; 腾讯QQ注册&lt;/a&gt; &lt;a id=&quot;wechat&quot; href=&quot;#&quot;&gt; 微信注册&lt;/a&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 产品模块 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;综合案例-产品模块&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; body &#123; background-color: #f5f5f5; &#125; a &#123; color: #333; text-decoration: none; &#125; .box &#123; width: 298px; height: 415px; background-color:#fff; /* 让块级的盒子水平居中对齐 */ margin: 100px auto; &#125; .box img &#123; /* 图片的宽度和父亲一样宽 */ width: 100%; &#125; .review &#123; height: 70px; font-size: 14px; /* 因为这个段落没有 width属性 所有 padding不会撑开盒子的宽度 */ padding: 0 28px; margin-top: 30px; &#125; .appraise &#123; font-size: 12px; color: #b0b0b0; margin-top: 20px; padding: 0 28px; &#125; .info &#123; font-size: 14px; margin-top: 15px; padding: 0 28px; &#125; .info h4 &#123; display: inline-block; font-weight: 400; &#125; .info span &#123; color: #ff6700; &#125; .info em &#123; font-style: normal; /*小竖线处理*/ color: #ebe4e0; margin: 0 6px 0 15px; &#125; .box:hover&#123; box-shadow: 0px 0px 20px rgb(165, 149, 149); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;img src=&quot;images/img.jpg&quot; alt=&quot;&quot;&gt; &lt;p class=&quot;review&quot;&gt;快递牛，整体不错蓝牙可以说秒连。红米给力&lt;/p&gt; &lt;div class=&quot;appraise&quot;&gt;来自于 117384232 的评价&lt;/div&gt; &lt;div class=&quot;info&quot;&gt; &lt;h4&gt; &lt;a href=&quot;#&quot;&gt;Redmi AirDots真无线蓝...&lt;/a&gt;&lt;/h4&gt; &lt;em&gt;|&lt;/em&gt; &lt;span&gt; 99.9元&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","path":"page/css12.html","date":"01-19","excerpt":"","tags":[{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"http://xiaoliblog.cn/tags/HTML-CSS/"}]},{"title":"前端三剑客🎉文本样式","text":"结构化元素结构化元素就是指 HTML 元素中具有明确含义和作用的元素，例如元素表示段落。相对于 HTML 4.01 版本而言，HTML5 版本新增了一系列结构化元素 名称 代码 标题元素 &lt;h1&gt;~&lt;h6&gt; 段落元素 &lt;p&gt; 粗体元素 &lt;b&gt; 斜体元素 &lt;i&gt; 上标 /下标元素 &lt;sup&gt;/&lt;sub&gt; 换行符 &lt;br&gt; 水平线元素 &lt;hr&gt; HTML5 新增的结构元素 &lt;article&gt; 元素 &lt;section&gt; 元素 &lt;nav&gt; 元素 &lt;aside&gt; 元素 &lt;header&gt; 元素 &lt;main&gt; 元素 &lt;footer&gt; 元素 HTML4中的元素标题元素HTML 标题元素具体是指&lt;h1&gt;~&lt;h6&gt; 元素，其呈现了 6 个不同级别的标题，&lt;h1&gt; 元素级别最高，&lt;h6&gt; 元素级别最低。每个元素独占一行注意： 对于搜索引擎抓取 HTML 页面的内容，&lt;h1&gt; 元素仅次于 &lt;title&gt; 元素。为了可以被搜索引擎抓取，建议一个 HTML 页面只包含一个&lt;h1&gt; 元素。 不要为了减小标题的字体而使用低级别的标题， 而是通过使用 CSS font-size 属性实现。 避免跳过某级标题，始终要从 &lt;h1&gt; 元素开始，依次使用 &lt;h2&gt; 元素、&lt;h3&gt; 元素、… … 段落元素HTML &lt;p&gt; 元素表示一个段落，该元素通常呈现出当前段落的文本与其他段落的文本之间会以空白进行隔离。如下示例代码展示了 &lt;p&gt; 元素的用法： 12&lt;p&gt;这是第一个段落内容.&lt;/p&gt;&lt;p&gt;这是第二个段落内容.&lt;/p&gt; 粗体元素HTML &lt;b&gt; 元素用来定义需要提醒注意的内容。该元素在过去被认为是粗体元素，因为绝大多数浏览器解析该元素呈现的是粗体效果。 如果不是出于语义目的而使用 &lt;b&gt; 元素，那么让文本显示粗体更好的方式是使用将 CSS 的 font-weight 属性设置为 bold。 &lt;b&gt; 元素的应用场景例如摘要中的关键字、评论中的产品名称，或其他典型的应该加粗显示的文字。 以前&lt;b&gt; 元素的含义就是让文本变成粗体效果。但从 HTML4 版本开始，不赞成标签表示带样式信息，于是&lt;b&gt; 元素的含义发生了变化。 斜体元素HTML&lt;i&gt; 元素用来定义表现因某些原因需要区分普通文本的一系列文本，例如技术术语、外文短语或是小说中人物的思想活动等。浏览器运行解析 &lt;i&gt; 元素一般呈现的效果是斜体 上标/下标元素HTML &lt;sup&gt; 元素表示为上标元素，HTML &lt;sub&gt; 元素表示为下标元素。这两个元素的特点如下： &lt;sup&gt; 元素定义的文本内容与主体内容相比，显示更高更小。&lt;sub&gt; 元素定义的文本内容与主体内容相比，显示更低更小。如下示例代码展示了 &lt;sup&gt; 元素和 &lt;sub&gt; 元素的用法： 换行符HTML &lt;br&gt; 元素会在 HTML 页面中生成一个换行符。编写在 &lt;br&gt; 元素后的文本内容会呈现在第二行中 123456&lt;span&gt;哈哈哈&lt;/span&gt;&lt;span&gt;呵呵呵&lt;/span&gt;&lt;span&gt;哈哈哈&lt;/span&gt;&lt;br&gt;&lt;span&gt;呵呵呵&lt;/span 水平线元素HTML &lt;hr&gt; 元素用来表示段落元素之间的主题转换。在较早版本的 HTML 中，&lt;hr&gt; 元素表示一个水平线，并且浏览器运行解析也是水平线效果。但目前 &lt;hr&gt; 元素被定义为语义上的，而不是表现上。 如下示例代码展示了&lt;hr&gt; 元素的用法： 123p&gt;§1: 这是一个段落内容.&lt;/p&gt;&lt;hr&gt;&lt;p&gt;§2: 这是另一个段落内容.&lt;/p&gt; HTML5 版本的结构化元素 &lt;article&gt; 元素HTML &lt;article&gt; 元素用来定义 HTML 页面中的可独立分配或可复用结构，例如论坛的帖子、新闻网站的文章等。 12345&lt;article&gt; &lt;h1&gt;前端开发&lt;/h1&gt; &lt;p&gt;前端开发现在已经是软件开发领域中的主流。&lt;/p&gt; &lt;p&gt;&lt;small&gt;版权归属 *** 公司所有。&lt;/small&gt;&lt;/p&gt;&lt;/article&gt; &lt;section&gt; 元素HTML &lt;section&gt; 元素用来定义 HTML 页面中的独立部分，该独立部分没有更具体的的语义元素来描述该元素。关于 &lt;section&gt; 元素在开发中的使用时需要注意如下要点： 一般通过是否包含一个标题元素（&lt;h1&gt; ~ &lt;h6&gt;）作为子级元素来识别每一个 &lt;section&gt; 元素。 如果元素内容可以分为几个部分的话，应该使用 &lt;article&gt; 元素 而不是 &lt;section&gt; 元素。 12345678&lt;section&gt; &lt;article&gt; &lt;p&gt;这是第一个测试内容.&lt;/p&gt; &lt;/article&gt; &lt;article&gt; &lt;p&gt;这是第二个测试内容.&lt;/p&gt; &lt;/article&gt;&lt;/section&gt; 不要将 &lt;section&gt; 元素作为一个普通容器使用，这应该是&lt;div&gt; 元素的用法 &lt;nav&gt; 元素HTML &lt;nav&gt; 元素用来定义 HTML 页面中的导航链接，比较常见的是菜单，目录和索引 1234567&lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;设计与构建静态网站&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;JavaScript基础核心语法&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;DOM编程艺术&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 上述示例所示效果是 &lt;ul&gt; 列表元素的呈现效果，因为没有为 &lt;nav&gt; 元素设定任何 CSS 样式，默认是没有任何效果的。 关于 &lt;nav&gt; 元素在开发中的使用时需要注意如下要点： 并不是所有的链接都必须使用 &lt;nav&gt; 元素，该元素只用于将一些热门的链接放入导航栏。一个 HTML 页面可能存在多个 &lt;nav&gt; 元素 &lt;aside&gt; 元素HTML &lt;aside&gt; 元素用来定义一个和 HTML 页面中其余内容几乎无关的内容，被认为是独立于该内容的一部分并且可以被单独的拆分出来而不会使整体受影响。通常比较常见的是侧边栏或者标注框 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;aside元素&lt;/title&gt; &lt;style&gt; aside &#123; width: 40%; padding-left: .5rem; margin-left: .5rem; float: right; box-shadow: inset 5px 0 5px -5px #29627e; font-style: italic; color: #29627e; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;article&gt; &lt;p&gt; 迪斯尼电影&lt;cite&gt;海的女儿&lt;/cite&gt;（&lt;cite&gt;The Little Mermaid&lt;/cite&gt;）于 1989 年首次登上银幕。 &lt;/p&gt; &lt;aside&gt; 在首次发行期间，该片便收获了 8700 万美元的票房。 &lt;/aside&gt; &lt;p&gt; 更多有关该电影的信息… &lt;/p&gt; &lt;/article&gt;&lt;/body&gt;&lt;/html&gt; &lt;header&gt; 元素HTML &lt;header&gt; 元素用来定义 HTML 页面中的具有引导和导航作用的内容，比较常见的是 Logo、搜索框、作者名称等 一个 HTML 页面并没有限制只能出现一个 &lt;header&gt; 元素，可以为每个内容区块添加一个 &lt;header&gt; 元素 &lt;main&gt; 元素HTML &lt;main&gt; 元素用来定义 HTML 页面中的主要内容。主内容区块指与页面标题或主要功能直接相关的内容。这部分内容在 HTML 页面中应当是独一无二的，不包含任何任何重复的内容。 关于 &lt;main&gt; 元素在开发中的使用时需要注意如下要点： 一个 HTML 页面中只能出现一个 &lt;main&gt; 元素。 &lt;mian&gt; 元素不能出现在&lt;article&gt; 元素、&lt;aside&gt; 元素、&lt;nav&gt; 元素、&lt;header&gt; 元素和 &lt;footer&gt; 元素的内部。 1234&lt;main&gt; &lt;h2&gt;Coder 比赛&lt;/h2&gt; &lt;p&gt;目前正在紧张进行中...&lt;/p&gt;&lt;/main&gt; &lt;footer&gt; 元素HTML &lt;footer&gt; 元素用来定义 HTML 元素中的一个章节内容或根元素的页脚。一个页脚通常包含该章节作者、版权数据或文档相关链接等信息。 关于 &lt;footer&gt; 元素在开发中的使用时需要注意 &lt;footer&gt; 元素中的作者信息应该包含在 &lt;address&gt; 元素中 1234567&lt;footer&gt; &lt;ul&gt; &lt;li&gt;版权信息&lt;/li&gt; &lt;li&gt;站点地图&lt;/li&gt; &lt;li&gt;联系方式&lt;/li&gt; &lt;/ul&gt;&lt;/footer&gt; 空白当浏览器运行并解析 HTML 页面时，遇到两个或两个以上的连续空格时，只将其显示为一个空格效果。这种特性叫做白色空间折叠 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;多个空格 但只会显示一个空格&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 转义字符 原义字符 描述 转义字符 空格 &amp;nbsp; &lt; 小于号 &amp;lt; &gt; 大于号 &amp;gt; &amp; 和号 &amp;amp; “ 引号 &amp;quot; © 版权（copyright） &amp;copy; ® 注册商标 &amp;reg; ™ 商标 &amp;trade; × 乘号 &amp;times; ÷ 除号 &amp;divide; 语义化元素语义化元素与结构化元素类似，都是具有具体含义的元素，区别在于语义化元素更多定义一个单词、一行内容的语义或样式 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;语义化元素&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 加粗元素 --&gt; &lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;HTML声明并不是一个HTML元素。&lt;/p&gt; &lt;!-- 强调元素 --&gt; &lt;p&gt;在HTML中，有些内容是需要&lt;em&gt;着重&lt;/em&gt;来阅读的.&lt;/p&gt; &lt;!-- 引用元素 --&gt; &lt;blockquote&gt; &lt;p&gt; 这是一段用来引用的文本内容. &lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;说明：&lt;q&gt;声明并不是一个HTML元素。&lt;/q&gt;&lt;/p&gt; &lt;!-- 引文元素 --&gt; &lt;p&gt;更多信息可以阅读&lt;cite&gt;[ISO-0000]&lt;/cite&gt;.&lt;/p&gt; &lt;!-- 定义元素 --&gt; &lt;p&gt; &lt;dfn id=&quot;def-internet&quot;&gt;The Internet&lt;/dfn&gt; is a global system of interconnected networks that use the Internet Protocol Suite (TCP/IP) to serve billions of users worldwide. &lt;/p&gt; &lt;!-- 地址元素 --&gt; &lt;address&gt; &lt;a href=&quot;mailto:jim@rock.com&quot;&gt;jim@rock.com&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;tel:+13115552368&quot;&gt;(311) 555-2368&lt;/a&gt; &lt;/address&gt; &lt;!-- 内容修改元素 --&gt; &lt;p&gt;前端好&lt;del&gt;难&lt;/del&gt;&lt;ins&gt;容易&lt;/ins&gt;学习啊&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 如下列表所示展示了部分语义化元素： 名称 代码 释义 效果 加粗元素 &lt;strong&gt; HTML 页面中的十分重要的文本内容 浏览器运行 HTML 页面默认呈现的是粗体效果 强调元素 &lt;em&gt; HTML 页面中的需要用户着重阅读的文本内容 浏览器运行 HTML 页面默认呈现的是斜体效果 引用元素 &lt;blockquote&gt; 和 &lt;q&gt; HTML blockquote 元素用来定义 HTML 页面中的标记较长的引用内容，一般浏览器解析后会对其进行缩进。HTML q 元素用来定义 HTML 页面中的较短的引用内容，浏览器解析后会在其两侧使用引号包裹。 代码 1 引文元素 &lt;cite&gt; HTML 页面中的对一个作品的引用，该元素必须包含引用作品的符合简写格式的标题或者 URL，可能是一个根据添加引用元数据的约定的简写形式 浏览器解析后会呈现斜体效果 定义元素 &lt;dfn&gt; 定义 HTML 页面中的术语 有些浏览器会将&lt;dfn&gt;元素解析后呈现为斜体，但 Safari 和 Chrome 浏览器则不会改变其样式。 地址元素 &lt;address&gt; HTML 页面中提供了某个人或某个组织的联系信息 浏览器解析后会呈现为斜体效果 内容修改元素 &lt;del&gt; 和 &lt;ins&gt; HTML del 元素用来定义 HTML 页面中删除的文字内容，HTML ins 元素用来定义 HTML 页面中插入的文字内容。 代码 2 代码 1 123456&lt;blockquote&gt; &lt;p&gt; 这是一段用来引用的文本内容. &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;说明：&lt;q&gt;声明并不是一个HTML元素。&lt;/q&gt;&lt;/p&gt; 代码 2 1&lt;p&gt;前端好&lt;del&gt;难&lt;/del&gt;&lt;ins&gt;容易&lt;/ins&gt;学习啊&lt;/p&gt; 字体样式设置字体CSSfont-family 属性通过一个字体名或字体族名组成的列表来设置 HTML 页面中的字体 123p &#123; font-family: 宋体;&#125; 设置一个字体名或字体族名两种设置方法。并不推荐只为 font-family 属性设置一个值。因为这样的话，浏览器运行 HTML 页面时很可能找不到这种字体或字体族，从而导致字体不能按照预期的效果进行展示 字体族名字字体族名必须是有效的。具体可以划分成如下几种情况： 如果字体族名是一个或多个合法标识串构成的话，是可以没有引号的。 如果字体族名是一个或多个非合法标识串构成的话，是需要使用引号的。 在没有带引号的字体族名的开头是不能使用标点符号字符和数字字符的。 通用字体族名字通用字体族名是用来在指定的字体不可用时给出较好的字体。通用字体族名都是关键字，所以不可以加引号。通用字体族名由如下几种： serif：带衬线字体，笔画结尾有特殊的装饰线或衬线。 sans-serif：无衬线字体，即笔画结尾是平滑的字体。 monospace：等宽字体，即字体中每个字宽度相同。 cursive：草书字体。这种字体有的有连笔，有的还有特殊的斜体效果。 fantasy：主要是那些具有特殊艺术效果的字体 设置多个字体名或字体族名为 font-family 属性设置多个值时，值之间需要使用逗号进行分隔。浏览器会选择列表中第一个该计算机上有安装的字体 123p &#123; font-family: &quot;Gill Sans Extrabold&quot;, Helvetica, sans-serif;&#125; 字体大小123p &#123; font-size: 24px;&#125; font-size 属性的值 名称 代码 绝对大小值 xx-small、x-small、small、medium、large、x-large、x-large 相对大小值 larger、smaller 长度值 px、em、rem、ex 百分比值 该值是相对于父级元素的字体大小的百分比 关于标题元素在开发中的使用时需要注意如下要点： 建议最好使用用户默认字体大小的相对大小，避免使用除了 em 或 ex 的绝对大小单位。 如果一定要使用绝对大小的话，px 是众多单位中最好的选择 粗细程度123p &#123; font-weight: bolder;&#125; font-weight 属性的值 名称 代码 绝对值 normal 和 bold 两个值。normal 与数字值 400 等价，bold 与数字值 700 等价。 相对值 lighter 和 bolder 两个值。比从父元素继承来的值更细（lighter）/ 粗（bolder）（处在字体可行的粗细值范围内）。 数字值 介于 100 ~ 900 之间的值。 注意：一些字体只提供 normal 和 bold 两种值。 设置斜体1234567.italic &#123; font-style: italic;&#125;.oblique &#123; font-style: oblique;&#125; 不是所有的字体都有确切的oblique和 italic 字形。即便如此，浏览器也会通过使用现有的字形来模拟所缺少的字形。 font属性CSS font 属性是用来作为 font-family、font-size、font-weight、font-style、font-variant 和 line-height 属性的简写形式，或将 HTML 元素的字体设置为系统字体。 如果将 font 属性作为简写形式的话，该属性必须包含 font-family 和 font-size 属性的值。而且指定相关属性的值时，需要注意如下要点： font-style、font-variant 和 font-weight 属性必须定义在 font-size 属性之前。 line-height 属性必须定义在 font-size 属性后面，由/分隔，例如 16px/3。 font-family 属性必须最后定义。 系统字体如果将 font 属性的值指定为系统关键字的话，必须是如下系统关键字之一： caption：用于标题控件（如按钮，下拉列表等）的系统字体。 icon：用于标签图标的系统字体。 menu：菜单中（如下拉菜单和菜单列表）使用的系统字体。 message-box：用于对话框的系统字体。 small-caption：用于小标题控件的系统字体。 status-bar：用于窗口状态栏的系统字体 123456789101112131415.p1 &#123; font: 12px/14px sans-serif;&#125;.p2 &#123; font: 80% sans-serif;&#125;.p3 &#123; font: bold italic large serif;&#125;.p4 &#123; font: status-bar;&#125; 嵌入 web 字体@font-face 是 CSS 的 @规则 中的一种，用来为 HTML 页面引入在线字体。通过 @font-face 我们可以自己来准备字体文件，从而可以消除对用户电脑字体的依赖。 1234567891011@font-face &#123; [ font-family: &lt;family-name&gt;; ] || [ src: &lt;src&gt;; ] || [ unicode-range: &lt;unicode-range&gt;; ] || [ font-variant: &lt;font-variant&gt;; ] || [ font-feature-settings: &lt;font-feature-settings&gt;; ] || [ font-variation-settings: &lt;font-variation-settings&gt;; ] || [ font-stretch: &lt;font-stretch&gt;; ] || [ font-weight: &lt;font-weight&gt;; ] || [ font-style: &lt;font-style&gt;; ]&#125; font-family：所指定的字体名字将会被用于 font 或 font-family 属性。 src：通过 url() 函数指定远程字体文件的位置，或者通过 local() 函数指定用户的本地计算机上的字体。 font-variant：同 font-variant 属性。 font-stretch：同 font-stretch 属性。 font-weight：同 font-weight 属性。 font-style：同 font-style 属性。 12345678@font-face &#123; font-family: &quot;Alibaba PuHuiTi&quot;; src: url(&quot;/fonts/Alibaba-PuHuiTi-Regular.ttf&quot;);&#125;body &#123; font-family: &quot;Alibaba PuHuiTi&quot;, serif&#125; 文本样式 名称 代码 释义 文本修饰 text-decoration 设置 HTML 页面中文本排版 行间距 line-height 设置 HTML 页面中多行元素之间的空间量 字母 / 单词间距 letter-spacing/word-spacing 字距是印刷行业用来描述字母之间空隙的一个术语 水平对齐方式 text-align 设置 HTML 页面中文本内容相对于其所在元素在水平方式的对齐方式 垂直对齐方式 vertical-align 设置 HTML 页面中内联元素或表格单元格元素在垂直方向上的对齐方式 文本缩进 text-indent 设置 HTML 页面中块级元素首行文本内容之前的缩进量 文本阴影 text-shadow 设置 HTML 页面中文本内容的阴影 文本换行 word-wrap 和 word-break 让文本和浏览器的右端自动实现换行 处理空白 white-space 设置如何处理 HTML 元素中的空白 文本修饰（text-decoration）CSS text-decoration 属性用来设置 HTML 页面中文本排版（下划线、顶划线、删除线或者闪烁）。text-decoration 属性是一个简写属性，并且可以使用普通属性三个值中的任何一个。普通属性如下所示： text-decoration-line 属性：用于设置元素中的文本的修饰类型。 text-decoration-color 属性：用于设置文本修饰线的颜色。 text-decoration-style 属性：用于设置由 text-decoration-line 设定的线的样式。 如下示例代码展示了 text-decoration 的 3 个普通属性的用法： 12345p &#123; text-decoration-color: lightcoral; /* 下划线颜色 */ text-decoration-line: underline; /* 下划线 */ text-decoration-style: solid; /* 实线 */&#125; text-decoration 属性会延伸到后代元素。这意味着如果祖先元素指定了文本修饰属性，后代元素则不能将其删除 行间距（line-height）使用印刷机印刷出来的每一个字都位于一个块中，而控制两行文字之间的垂直距离就是行间距如上图所示，红色线是顶线、紫色线是中线、绿色线是基线、黄色线是底线，在本小节后面中会讲解到的 vertical-align 属性的 top、middle、baseline、bottom 指的就是这 4 条线。 行间距也称为行高指的是两行文本内容中基线的距离，即两条绿色线之间的距离。也就是上图中的 1、2、3 和 4 的区域。 行距指的是上一行的底线到下一行的顶线之间的距离，即上一行的黄色线到下一行的红色线之间的距离。 字体大小值的是顶线到底线的距离，即红色线到黄色线之间的距离。也是就是上图中的 1、2 和 4 的区域。 line-height 属性值 属性 含义 normal 关键字 该值取决于用户电脑。一般情况下，浏览器使用的默认值为 1.2。 数字值 最终的效果值是该数字值乘以该元素的字体大小（font-size 属性值） 长度值 如果使用 em 单位的可能会产生不确定的效果。 百分比值 最终的效果值是该百分比值乘以该元素的字体大小（font-size 属性值）。 123456789101112131415161718192021.div1 &#123; line-height: 1.2; font-size: 10pt; &#125; /* 无单位数值 number/unitless */ .div2 &#123; line-height: 1.2em; font-size: 10pt; &#125; /* 长度 length */ .div3 &#123; line-height: 120%; font-size: 10pt; &#125; /* 百分比 percentage */ .div4 &#123; font: 10pt/1.2 Georgia, &quot;Bitstream Charter&quot;, serif; &#125; 字母间距（letter-spacing）CSS letter-spacing 属性原意是用来设置文本字符之间的间距。在英文中是可以分为单词和字符的，但在中文中只有文字，中文中的文字就相当于英文的字符，所以 letter-spacing 属性可以适用于中文环境。 letter-spacing 属性的值 属性 含义 normal 该值是按照当前字体的正常间距确定的。 长度值 指定文字间的间距以替代默认间距，可以是负值。 123456789101112131415.first-example &#123; letter-spacing: 0.4em;&#125;.second-example &#123; letter-spacing: 1em;&#125;.third-example &#123; letter-spacing: -0.05em;&#125;.fourth-example &#123; letter-spacing: 6px; &#125; 单词间距（word-spacing）CSS word-spacing 属性用来设置 HTML 页面中标签之间或单词之间的距离，该属性对英文是有效的，但对中文是无效的。 属性 含义 normal 该值是按照当前字体的正常间距确定的。 长度值 指定单词间的间距以替代默认间距。 百分比值 指定单词之间的间距以替代默认间距的百分比。 1234567.first-example &#123; word-spacing: 15px;&#125;.second-example &#123; word-spacing: 5em;&#125; 水平对齐方式（text-align）CSS text-align 属性用来设置 HTML 页面中文本内容相对于其所在元素在水平方式的对齐方式。值得注意的是，text-align 属性并不能设置 HTML 元素本身在水平方向的对齐，而是设置 HTML 元素内部的文本内容在其元素内水平方向的对齐。 123.example &#123; text-align: right;&#125; text-align 属性的值具有 7 种类型 属性 含义 start 如果内容方向是左至右的话则等于 left，反之则为 right。 end 如果内容方向是左至右的话则等于 right，反之则为 left。 left 行内内容向左侧边对齐。 right 行内内容向右侧边对齐。 center 行内内容居中。 justify 文字向两侧对齐，对最后一行无效。 justify-all 和 justify 一致，但是强制使最后一行两端对齐。 垂直对齐方式（vertical-align）CSS vertical-align 属性用来设置 HTML 页面中内联元素或表格单元格元素在垂直方向上的对齐方式。vertical-align 属性可以被应用于 2 种环境： 设置某个内联元素的盒子模型与该内联元素的父级容器元素的垂直对齐方式。 设置表格中某个单元格中内容的垂直对齐方式。 vertical-align 属性只针对内联元素和表单单元格有效，对块级元素是无效的。 vertical-align 属性的值根据 2 种应用环境会有所不同： 应用于内联元素的值 相对于父级元素的值 baseline：使元素的基线与父元素的基线对齐。 sub：使元素的基线与父元素的下标基线对齐。 super：使元素的基线与父元素的上标基线对齐。 text-top：使元素的顶部与父元素的字体顶部对齐。 text-bottom：使元素的底部与父元素的字体底部对齐。 middle：使元素的中部与父元素的基线加上父元素 x-height 的一半对齐。 相对于行的值 top：使元素及其后代元素的顶部与整行的顶部对齐。 bottom：使元素及其后代元素的底部与整行的底部对齐。 应用于表单单元格的值 baseline：使单元格的基线，与该行中所有以基线对齐的其它单元格的基线对齐。 top：使单元格内边距的上边缘与该行顶部对齐。 middle：使单元格内边距盒模型在该行内居中对齐。 bottom：使单元格内边距的下边缘与该行底部对齐。 1234567891011img.top &#123; vertical-align: text-top;&#125;img.bottom &#123; vertical-align: text-bottom;&#125;img.middle &#123; vertical-align: middle;&#125; 文本缩进（text-indent）CSS text-indent 属性用来设置 HTML 页面中块级元素首行文本内容之前的缩进量. 123.example &#123; text-indent: 5em;&#125; 属性 含义 长度值 允许使用负值 百分比值 使用所在块级元素的宽度的百分比作为缩进 each-line 文本缩进会影响第一行，以及使用 &lt;br&gt; 元素强制断行后的第一行。 hanging 该值会对所有的行进行反转缩进：除了第一行之外的所有的行都会被缩进，看起来就像第一行设置了一个负的缩进值。 文本阴影（text-shadow）CSS text-shadow 属性用来设置 HTML 页面中文本内容的阴影。 123selector &#123; text-shadow: color offset-x offet-y blur-raduis;&#125; color：可选项，设置文本内容的阴影颜色。 offset-x：必选项，设置文本内容的阴影在水平方向的偏移量。 如果值小于 0 的话，则表示向左偏移。 如果值等于 0 的话，则表示水平方向不发生任何偏移。 如果值大于 0 的话，则表示向右偏移。 offset-y：必选项，设置文本内容的阴影在垂直方向的偏移量。 如果值小于 0 的话，则表示向上偏移。 如果值等于 0 的话，则表示垂直方向不发生任何偏移。 如果值大于 0 的话，则表示向下偏移。 blur-raduis：可选项，设置文本内容的阴影模糊半径 如果没有指定，则默认为 0。值越大，模糊半径越大，阴影也就越大越淡 设置单一阴影123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .example &#123; text-shadow: red 0 -2px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=&quot;example&quot;&gt;这是文本阴影测试&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 设置多重阴影123.example &#123; text-shadow: 1px 1px 2px black, 0 0 1em blue, 0 0 0.2em blue;&#125; 当通过 text-shadow 属性为文本内容设置多重阴影时，阴影的应用顺序是从左到右的，第一个指定的阴影在顶部 文本换行（word-wrap 和 word-break) 对于西方文本，浏览器会在半角空格或连字符的地方自动换行。 对于中文文本，可以在任何文字后面换行。通常标点符号以及前面的文字作为整体统一换行 word-wrap 属性word-wrap 属性属于微软的一个私有属性，在 CSS3 的文本规范中被重命名为 overflow-wrap。word-wrap 作为 overflow-wrap 的别名。 overflow-wrap 属性的值具有如下 2 种： normal：表示在正常的单词结束处换行。 break-word：表示如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被分割的单词会被强制分割换行。 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;overflow-wrap属性&lt;/title&gt; &lt;style&gt; .example &#123; width: 13em; background: gold; &#125; .break &#123; overflow-wrap: break-word; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=&quot;example&quot;&gt; FStrPrivFinÄndG (Gesetz zur Änderung des Fernstraßenbauprivatfinanzierungsgesetzes und straßenverkehrsrechtlicher Vorschriften) &lt;/p&gt; &lt;p class=&quot;example break&quot;&gt; FStrPrivFinÄndG (Gesetz zur Änderung des Fernstraßenbauprivatfinanzierungsgesetzes und straßenverkehrsrechtlicher Vorschriften) &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; word-break 属性CSS word-break 属性用来设置 HTML 页面中文本内容自动换行的处理方式。通过具体的属性值设置，可以告知浏览器实现任意位置的换行。 word-break 属性的值具有如下 3 种： normal：使用默认的断行规则。 break-all：对于除中文、日文和韩文外的文本内容，设置可以在任意字符间断行。 keep-all：中文、日文和韩文的文本内容不断行，其他语言的文本内容等同于 normal。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;word-break属性&lt;/title&gt; &lt;style&gt; .narrow &#123; width: 60%; padding: 20px; text-align: start; border: solid 1px #a9a9a9; &#125; .normal &#123; word-break: normal; &#125; .breakAll &#123; word-break: break-all; &#125; .keepAll &#123; word-break: keep-all; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;1. &lt;code&gt;word-break: normal&lt;/code&gt;&lt;/p&gt; &lt;p class=&quot;normal narrow&quot;&gt;This is a long and Honorificabilitudinitatibus califragilisticexpialidocious Taumatawhakatangihangakoauauotamateaturipukakapikimaungahoronukupokaiwhenuakitanatahu グレートブリテンおよび北アイルランド連合王国という言葉は本当に長い言葉&lt;/p&gt; &lt;p&gt;2. &lt;code&gt;word-break: break-all&lt;/code&gt;&lt;/p&gt; &lt;p class=&quot;breakAll narrow&quot;&gt;This is a long and Honorificabilitudinitatibus califragilisticexpialidocious Taumatawhakatangihangakoauauotamateaturipukakapikimaungahoronukupokaiwhenuakitanatahu グレートブリテンおよび北アイルランド連合王国という言葉は本当に長い言葉&lt;/p&gt; &lt;p&gt;3. &lt;code&gt;word-break: keep-all&lt;/code&gt;&lt;/p&gt; &lt;p class=&quot;keepAll narrow&quot;&gt;This is a long and Honorificabilitudinitatibus califragilisticexpialidocious Taumatawhakatangihangakoauauotamateaturipukakapikimaungahoronukupokaiwhenuakitanatahu グレートブリテンおよび北アイルランド連合王国という言葉は本当に長い言葉&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 处理空白（white-space）CSS white-space 属性用来设置如何处理 HTML 元素中的空白 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;white-space属性&lt;/title&gt; &lt;style&gt; .example-element &#123; width: 16rem; &#125; .example-element p &#123; background-color: #eee; padding: .75rem; text-align: left; &#125; #example1 &#123; white-space: normal; &#125; #example2&#123; white-space: nowrap; &#125; #example3&#123; white-space: pre; &#125; #example4&#123; white-space: pre-wrap; &#125; #example5&#123; white-space: pre-line; &#125; #example6&#123; white-space: normal; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;example-element&quot; id=&quot;example1&quot;&gt; &lt;p&gt;But ere she from the church-door stepped She smiled and told us why: &#x27;It was a wicked woman&#x27;s curse,&#x27; Quoth she, &#x27;and what care I?&#x27; She smiled, and smiled, and passed it off Ere from the door she stept—&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;example-element&quot; id=&quot;example2&quot;&gt; &lt;p&gt;But ere she from the church-door stepped She smiled and told us why: &#x27;It was a wicked woman&#x27;s curse,&#x27; Quoth she, &#x27;and what care I?&#x27; She smiled, and smiled, and passed it off Ere from the door she stept—&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;example-element&quot; id=&quot;example3&quot;&gt; &lt;p&gt;But ere she from the church-door stepped She smiled and told us why: &#x27;It was a wicked woman&#x27;s curse,&#x27; Quoth she, &#x27;and what care I?&#x27; She smiled, and smiled, and passed it off Ere from the door she stept—&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;example-element&quot; id=&quot;example4&quot;&gt; &lt;p&gt;But ere she from the church-door stepped She smiled and told us why: &#x27;It was a wicked woman&#x27;s curse,&#x27; Quoth she, &#x27;and what care I?&#x27; She smiled, and smiled, and passed it off Ere from the door she stept—&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;example-element&quot; id=&quot;example5&quot;&gt; &lt;p&gt;But ere she from the church-door stepped She smiled and told us why: &#x27;It was a wicked woman&#x27;s curse,&#x27; Quoth she, &#x27;and what care I?&#x27; She smiled, and smiled, and passed it off Ere from the door she stept—&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;example-element&quot; id=&quot;example6&quot;&gt; &lt;p&gt;But ere she from the church-door stepped She smiled and told us why: &#x27;It was a wicked woman&#x27;s curse,&#x27; Quoth she, &#x27;and what care I?&#x27; She smiled, and smiled, and passed it off Ere from the door she stept—&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;white-space属性&lt;/title&gt; &lt;style&gt; #example-element &#123; width: 16rem; &#125; #example-element p &#123; background-color: #eee; padding: .75rem; text-align: left; &#125; .example &#123; /* 设置 white-space 属性不同的值用于测试效果 */ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;example-element&quot; class=&quot;example&quot;&gt; &lt;p&gt;But ere she from the church-door stepped She smiled and told us why: &#x27;It was a wicked woman&#x27;s curse,&#x27; Quoth she, &#x27;and what care I?&#x27; She smiled, and smiled, and passed it off Ere from the door she stept—&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 如下列表总结了各种 white-space 属性值的行为： 属性值 换行符 空格和制表符 文字转行 normal 合并 合并 转行 nowrap 合并 合并 不转行 pre 保留 保留 不转行 pre-wrap 保留 保留 转行 pre-line 保留 合并 转行 break-spaces 保留 保留 转行 文本动画打字效果1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;!-- 引用有字库站酷高端黑字体 --&gt; &lt;link href=&quot;http://cdn.repository.webfont.com/webfonts/nomal/135621/46969/5e3024eaf629d810708c2ad6.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 定位文本到浏览器中央 --&gt; &lt;main&gt; &lt;!-- 文字容器，统一由h1控制 --&gt; &lt;h1&gt; &lt;!-- 使用span显示文字, data-text为Json格式的数组 --&gt; &lt;span id=&quot;text&quot; data-text=&#x27;[&quot;我是小李博客&quot;, &quot;我是前端工程师&quot;, &quot;我热爱前端开发&quot;]&#x27; &gt;&lt;/span&gt; &lt;!-- 闪烁的光标 --&gt; &lt;span class=&quot;mark&quot;&gt;&lt;/span&gt; &lt;/h1&gt; &lt;/main&gt; &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 获取显示文字的span元素const textEl = document.querySelector(&quot;#text&quot;);// 获取并解析要展示的文本数组const texts = JSON.parse(textEl.getAttribute(&quot;data-text&quot;));// 当前显示文本数组中的第几个let index = 0;// 当前显示第几个字let charIndex = 0;// 每个字显示间隔默认是500毫秒let delta = 500;// 记录动画执行开始时间let start = null;// 是否为删除动画let isDeleting = false;// 动画回调函数function type(time) &#123; window.requestAnimationFrame(type); // 初始化开始时间 if (!start) start = time; // 获取时间间隔 let progress = time - start; // 每隔一定的时间，打印出一个新的字符 if (progress &gt; delta) &#123; // 获取完整的字符 let text = texts[index]; // 如果是打字效果 if (!isDeleting) &#123; // 给展示文字的span新增一个字符，使用innerHTML来替换，charIndex自增1，然后返回新的字符串子串 textEl.innerHTML = text.slice(0, ++charIndex); // 每个字符打印出来的速度不一样，模仿人工打字的速度 delta = 500 - Math.random() * 400; &#125; else &#123; // 如果是删除效果，则把文字一个一个减掉 textEl.innerHTML = text.slice(0, charIndex--); &#125; // 把star更新为当前时间，进行下一个周期 start = time; // 如果文字已经全部打印完毕 if (charIndex === text.length) &#123; // 下次开始删除文字 isDeleting = true; // 删除文字的间隔为200毫秒 delta = 200; // 额外等待1.2秒后再删除 start = time + 1200; &#125; // 如果文字删除完毕 if (charIndex &lt; 0) &#123; isDeleting = false; // 额外增加200毫秒延迟 start = time + 200; // 把index移动到下一个文本，并且在文本数组元素个数中循环 index = ++index % texts.length; &#125; &#125;&#125;window.requestAnimationFrame(type); 123456789101112131415161718192021222324252627282930313233343536* &#123; margin: 0; padding: 0; box-sizing: border-box; font-family: &quot;huxiaobo-gdh1e91397a5f211c5&quot;, &quot;PingFang SC&quot;, &quot;Microsoft Yahei&quot;, sans-serif;&#125;main &#123; background: #2f3542; display: flex; align-items: center; justify-content: center; height: 100vh;&#125;h1 &#123; color: #f1f2f6; font-size: 5em; font-weight: 300;&#125;span.mark &#123; border-right: 2px solid white; animation: blink 0.6s step-end infinite;&#125;@keyframes blink &#123; from, to &#123; border-color: transparent; &#125; 50% &#123; border-color: white; &#125;&#125; 光影效果123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;文字光影动画&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;#&quot; class=&quot;btn-shine&quot;&gt;Get early access&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435body &#123; background: #000; font-family: &#x27;Poppins&#x27;, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; &#125; .btn-shine &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50% ,-50%); padding: 12px 48px; color: #fff; background: linear-gradient(to right , #4d4d4d 0 , #fff 10% , #4d4d4d 20%); background-position: 0; -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; animation: shine 3s linear infinite; font-weight: 600; font-size: 30px; text-decoration: none; white-space: nowrap; &#125; @keyframes shine &#123; 0% &#123; background-position: 0; &#125; 60% &#123; background-position: 280px; &#125; 100% &#123; background-position: 280px; &#125; &#125;","path":"page/css15.html","date":"01-18","excerpt":"","tags":[{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"http://xiaoliblog.cn/tags/HTML-CSS/"}]},{"title":"前端三剑客🎉颜色与单位","text":"基础知识 色调：很接近通俗意义上的颜色。 图像的相对明暗程度，在彩色图像上表现为颜色（简单的理解为颜色） 饱和度：是指颜色中灰色的含量。 色彩的纯洁性（颜色中灰色的含量），也叫饱和度 / 彩度。 亮度：是指颜色中黑色的含量。 发光体的光源面积之比（黑色的含量） 对比度：前景色与背景色之间的差异。 明暗区域最亮的白和最暗的黑之间不同亮度层级的测量，差异范围越大代表对比越大，差异范围越小代表对比越小。 Web 安全色：不需要担心颜色在不同硬件环境、操作系统和浏览器之间的差异。不必担心因不同硬件（浏览器）而造成的颜色不同。Web 安全色目前基本具有 216 种颜色，其中色彩为 210 种（开发时使用的颜色），非色彩为 6 种。关于 Web 安全色的具体颜色以及值，可以参考https://www.bootcss.com/p/websafecolors/ 前景色与背景色CSS 中的前景色和背景色就是 color 和 backgorund-color 两个属性，其中 color 属性表示前景色，background-color 属性表示背景色。 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .one&#123; color:brown; &#125; .two&#123; background-color:chartreuse &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p class=&quot;one&quot;&gt;前景色是color属性&lt;/p&gt; &lt;p class=&quot;two&quot;&gt;背景色是background-color属性&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 颜色的表示 色彩关键字色彩关键字是一个不区分大小写的标识符，其表示一个具体的颜色，例如 red 表示红色、blue 表示蓝色等。 123.test&#123; color:blue;&#125; 十六进制表示十六进制表示一共有六位，每两位分别表示红、绿、蓝，取值范围为00~FF(0~255)，数值越大亮度和饱和度越高 RGB色彩模式RGB 是一个简称，全称为Red-Green-Blue，即 红 - 绿 - 蓝。RGB 色彩模式是工业界的一种颜色标准，是通过对红、绿、蓝三个颜色通道的变化以及它们相互之间的叠加来得到各式各样的颜色的。使用十进制的数字，用逗号隔开，分别表示红-绿-蓝三色，取值范围为00~FF(0~255)以下三个表示同一个值 123456789#p1 &#123; background-color: #FFCC33;&#125;#p2 &#123; background-color: #FC3;&#125;#p3 &#123; background-color: rgb(255, 204, 51);&#125; RGBA色彩模式RGBA相较于RGB多了一个alpha，即透明度(取值0-1) 123p&#123; background-color:rgba(230,53,174,0.4);&#125; HLS色彩模式HSL 是一个简称，全称为 Hue-Saturation-Lightness，即色调 - 饱和度 - 亮度。HSL 色彩模式是一种将 RGB 色彩模型中的点在圆柱坐标系中的表示法。在 CSS 中使用 HSL 色彩模式是通过 hsl(H, S, L) 函数实现的，具体含义如下： H 表示色调，其值范围为 0 ~ 360 之间的一个角度(deg) S表示饱和度，其值范围为 0% ~ 100% 之间的百分值 L 表示亮度，其值使用百分值表示。0% 表示黑色，50% 表示标准色，100% 表示白色。 alpha 表示透明度，其值范围为 0% ~ 100% 之间的百分值 123p &#123; background-color: hsl(130, 100%, 60%,50%);&#125; 透明度opacity 属性，介于 0~1 之间，如果大于 1 则当做 1。 如果值为 0 或 0.0 则表示完全透明 如果值为 0.5 则表示半透明 如果值为 1 或 1.0 则表示不透明 123.light &#123; opacity: 0.2;&#125; RGB 模式增加了rgba(R,G,B,A)函数，其中 A 为 alpha 表示透明度。 HSL 模式增加了 hsl(H,S,L,A) 函数，其中 A 为 alpha 表示透明度。 CSS值与单位在 CSS 中除了颜色值需要不同类型描述之外，比较常见的还有长度值也需要不同类型描述，例如 10px 或 50% 等。 绝对长度单位这种长度时固定的不变的，在 HTML 中常见的单位为像素（px） 单位 名称 等价换算 cm 厘米 1cm = 96px/2.54 mm 毫米 1mm = 1/10th of 1cm Q 四分之一毫米 1Q = 1/40th of 1cm in 英寸 1in = 2.54cm = 96px pc 十二点活字 1pc = 1/16th of 1in pt 点 1pt = 1/72th of 1in px 像素 1px = 1/96th of 1in 相对长度单位相对于某个物体的长度。比如相对父级元素。使用相对长度单位相对绝对长度单位更适用于现在越发复杂的终端设备的屏幕输出。 单位 相对于 em 父元素的字体大小 ex 字符 “x” 的高度 ch 数字 “0” 的宽度 rem 根元素的字体大小 lh 元素的 line-height vw 视窗宽度的 1% vh 视窗高度的 1% vmin 视窗较小尺寸的 1% vmax 视图大尺寸的 1% 像素值(px)像素的英文为 Pixel，简写为 px。像素是指在由一个数字序列表示的图像中的一个最小单位。简单来说，如果我们把一张图片放大数倍，会发现这些连续色调其实是由许多色彩相近的小方点所组成，而这些小方点就是构成影像的最小单元就是像素 百分比(%)百分比（%） 总是将某个值作为参考，设置为这个参考值的百分比，例如 40%。在 CSS 中一般情况下，百分比（%）多是将当前 HTML 元素的父级元素作为参考值。例如如果一个父级元素拥有两个子级元素，一个子级元素的宽度为 40%，另一个子级元素的宽度为 80%，那么第二个子级元素的宽度就是第一个子级元素的宽度的 2 倍。如下示例代码所示 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;百分比&lt;/title&gt; &lt;style&gt; .parent &#123; width: 200px; height: 100px; border: 1px solid lightcoral; &#125; #child1 &#123; width: 40%; height: 50px; background-color: limegreen; &#125; #child2 &#123; width: 80%; height: 50px; background-color: lightslategray; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;parent&quot;&gt;&lt;!--宽度200px，高度100px--&gt; &lt;div id=&quot;child1&quot;&gt;&lt;!--高度20px，宽度80px&lt;/div&gt;--&gt; &lt;div id=&quot;child2&quot;&gt;&lt;!--高度50px，宽度160px&lt;/div&gt;--&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; em 与 remem 与 rem 都是相对单位，目前更多应用于移动端设备，例如手机、平板电脑的显示。具体的含义如下所示： em：是相对于当前 HTML 元素的父级元素来进行设置。 rem：是相对于当前 HTML 根元素（``）来进行设置。 上述 2 种单位都具有如下 3 种情况： 小于 1 时：表示相对于父级元素或根元素缩小。例如 0.5em 表示是父级元素的 0.5 倍，0.5rem 表示是根元素的 0.5 倍。 等于 1 时：表示与父级元素或根元素的大小保持一致。 大于 1 时：表示相对于父级元素或根元素放大。例如 1.5em 表示是父级元素的 1.5 倍，1.5rem 表示是根元素的 1.5 倍。","path":"page/css17.html","date":"01-18","excerpt":"","tags":[{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"http://xiaoliblog.cn/tags/HTML-CSS/"}]},{"title":"前端三剑客🎉CSS选择器","text":"CSS3基础CSS(Cascading Style Sheet，层叠样式表)是一种标准的格式化网页的方式，用于控制网页样式。 内容与表现分离 网页的表现统一，容易修改 丰富的样式，使得页面布局更加灵活 减少网页的代码量，增加网页的浏览速度，节省网络带宽 运用独立于页面的CSS，有利于网页被搜索引擎收录 引入方式 行内样式使用style属性引入css样式 1&lt;标签 style=&quot;属性1:值1;属性2:值2;...&quot;&gt;&lt;/标签&gt; 内部样式CSS代码写在&lt;head&gt;的&lt;style&gt;标签中 12345&lt;style type=&quot;text/css&quot;&gt; 标签&#123; 属性:值; &#125;&lt;/style&gt; 外部样式CSS代码保存在扩展名为.css的样式表中HTML文件引用扩展名为.css的样式表，有两种方式 链接式导入式区别123&lt;head&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt;&lt;/head&gt;12345678&lt;head&gt;……&lt;style type=&quot;text/css&quot;&gt;&lt;!--@import url(&quot;style.css&quot;);--&gt;&lt;/style&gt;&lt;/head&gt; 标签属于XHTML，@import是属于CSS2.1 使用链接的CSS文件先加载到网页当中，再进行编译显示 使用@import导入的CSS文件，客户端显示HTML结构，再把CSS文件加载到网页当中 @import是属于CSS2.1特有的，对不兼容CSS2.1的浏览器是无效的 CSS样式优先级（就近原则） 行内样式&gt;内部样式表&gt;外部样式表 CSS三大特性CSS三大特性：层叠性、继承性、优先级 层叠性 CSS(Cascading Style Sheets)又称为层叠样式表，所以这个第一个特性就是层叠性 层叠性用于解决样式冲突的问题；样式冲突：是指一个标签指定了相同样式同值的情况。一般情况，如果出现样式冲突，会按照书写顺序最后的为准 这种特性的原理与浏览器的渲染原理有关：一般打开网页，会先下载文档内容，加载头部的样式资源，然后按照从上而下，自外而内的顺序渲染DOM内容 123456789101112131415div&#123; width: 300px; height: 150px; background-color: red; background-color: blueviolet; color:pink; color:#fff; font-size: 30px; font-size: 20px; text-align: center; text-align: right; &#125; div&#123; color:yellow; &#125; 继承性 继承性是指书写css样式表时，子标签会继承父标签的某些样式，有一些样式是具有继承性的，想要设置一个可继承的属性，只需将它应用于父元素即可。 并不是所有的css属性都可以继承，对于 字体、文本属性等网页中通用的样式 可以使用继承 而有一些属性就不具有继承性：边框、外边距、内边距、背景、定位、元素高属性 优先级！important&gt;行内样式&gt;ID选择器&gt;类选择器&gt;标签选择器 计算法则（后定义的覆盖先定义的） 优先级就是分配给指定的 CSS 声明的一个权重，它由匹配的选择器中的每一种选择器类型的数值决定。 当优先级与多个 CSS 声明中任意一个声明的优先级相等的时候，CSS 中最后的那个声明将会被应用到元素上。 当同一个元素有多个声明的时候，优先级才会有意义。 内联样式总会覆盖内嵌样式表和外联样式表的任何样式。 元素 贡献值 继承、* 0，0，0，0 每个标签 0，0，0，1 类、伪类 0，0，1，0 ID 0，1，0，0 行内样式 1，0，0，0 !important 无穷大 max-height、max-width覆盖width、height 大于无穷大 min-height、min-width 大于max-height、max-width 计算规则 遇到有贡献值的就进行累加，例如： div ul li —&gt; 0,0,0,3 .nav ul li —&gt; 0,0,1,2 a:hover —&gt; 0,0,1,1 .nav a —&gt; 0,0,1,1 #nav p —&gt; 0,1,0,1 !important破坏优先级，被修饰的成为最高级。 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;!important规则&lt;/title&gt; &lt;style&gt; div &#123; color: blue !important; &#125; .demo &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;demo&quot;&gt;这是一个测试内容.&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 最终的颜色为 blue 一定要优化考虑使用样式规则的优先级来解决问题而不是 !important。 只有在需要覆盖全站或外部 CSS 的特定页面中使用 !important。 永远不要在你的插件中使用 !important。 永远不要在全站范围的 CSS 代码中使用 !important。 选择器分类 基本选择器：共有 5 个基本选择器，是 CSS 选择器的最为基本的用法。 层级选择器：共有 4 个层级选择器，是根据 HTML 元素之间的关系来定位 HTML 元素。 组合选择器：具有交集和并集两种用法，是将之前基本选择器和层级选择器进行组合。 伪类选择器：允许未包含在 HTML 页面中的状态信息选定位 HTML 元素。 伪元素选择器：定位所有未被包含 HTML 的实体 基本选择器 标记选择器HTML标签作为标签选择器的名称 1234&lt;style type=&quot;text/css&quot;&gt; p&#123;font-size:16px;&#125;&lt;/style&gt;&lt;p&gt;我的文本&lt;/p&gt; 类选择器以”.“来进行定义，用class去执行调用 1234&lt;style type=&quot;text/css&quot;&gt; .one&#123;font-size:16px;&#125;&lt;/style&gt;&lt;p class=&quot;one&quot;&gt;我的文本&lt;/p&gt; 类名不能是纯数字和汉字 ID选择器以”#“来定义，用id去执行 1234&lt;style type=&quot;text/css&quot;&gt; #one&#123;font-size:16px;&#125;&lt;/style&gt;&lt;p id=&quot;one&quot;&gt;我的文本&lt;/p&gt; ID选择器，只能用一次(id是唯一的)，类选择器可以反复使用 通配符选择器“*“表示所有 123&lt;style type=&quot;text/css&quot;&gt; *&#123;margin:0;padding:0&#125;&lt;/style&gt; 层次选择器 选择器 类型 说明 E F 后代选择器 选择匹配的F元素，且匹配的F元素被包含在匹配的E元素内 E&gt;F 子选择器 选择匹配的F元素，且匹配的F元素是匹配的E元素的子元素 E+F 相邻兄弟选择器 选择匹配的F元素，且匹配的F元素紧位于匹配的E元素后面 E~F 通用兄弟选择器 选择匹配的F元素，且位于匹配的E元素后所有匹配的F元素 123body p&#123; background-color: red;&#125; //body下的所有p元素都变为红色 123body&gt;p&#123; background-color: rgb(152, 190, 90);//前三个p变色&#125; 123.p1+p&#123; background-color: steelblue;&#125; //只有p1相邻的第二个p变色 123.p1~p&#123; background-color: steelblue; &#125;//p1后面的所有同级兄弟p元素变色 组合选择器 组合（并集）选择器 1234h1,h2,h3,h4,h5,h6&#123; color:blue; &#125; /*同时定义多个标签的属性*/ 组合（交集）选择器 12345p.cls &#123; color: blueviolet;&#125;/*表示把所有class名为cls的p标签都设置成blueviolet颜色*/ 属性选择器 选择器 功能描述 E[attr] 选择匹配具有属性attr的E元素 E[attr=val] 选择匹配属性值为val(区分大小写)的E元素 E[attr^=val] 选择匹配属性值以val开头的E元素 E[attr$=val] 选择匹配属性值以val结尾头的E元素 E[attr*=val] 选择匹配属性值包含val的E元素 E[attr=val]属性选择器中，属性和属性值必须完全匹配才能被选中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;CSS3新增属性选择器&lt;/title&gt; &lt;style&gt; /* 必须是input 但是同时具有 value这个属性 选择这个元素 [] */ /* input[value] &#123; color:pink; &#125; */ /* 只选择 type =text 文本框的input 选取出来 */ input[type=text] &#123; color: pink; &#125; /* 选择首先是div 然后 具有class属性 并且属性值 必须是 icon开头的这些元素 */ div[class^=icon] &#123; color: red; &#125; section[class$=data] &#123; color: blue; &#125; div.icon1 &#123; color: skyblue; &#125; /* 类选择器和属性选择器 伪类选择器 权重都是 10 */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 1. 利用属性选择器就可以不用借助于类或者id选择器 --&gt; &lt;!-- &lt;input type=&quot;text&quot; value=&quot;请输入用户名&quot;&gt; &lt;input type=&quot;text&quot;&gt; --&gt; &lt;!-- 2. 属性选择器还可以选择属性=值的某些元素 重点务必掌握的 --&gt; &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot;&gt; &lt;input type=&quot;password&quot; name=&quot;&quot; id=&quot;&quot;&gt; &lt;!-- 3. 属性选择器可以选择属性值开头的某些元素 --&gt; &lt;div class=&quot;icon1&quot;&gt;小图标1&lt;/div&gt; &lt;div class=&quot;icon2&quot;&gt;小图标2&lt;/div&gt; &lt;div class=&quot;icon3&quot;&gt;小图标3&lt;/div&gt; &lt;div class=&quot;icon4&quot;&gt;小图标4&lt;/div&gt; &lt;div&gt;我是打酱油的&lt;/div&gt; &lt;!-- 4. 属性选择器可以选择属性值结尾的某些元素 --&gt; &lt;section class=&quot;icon1-data&quot;&gt;我是安其拉&lt;/section&gt; &lt;section class=&quot;icon2-data&quot;&gt;我是哥斯拉&lt;/section&gt; &lt;section class=&quot;icon3-ico&quot;&gt;哪我是谁&lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 伪类选择器 伪类选择器用于向某些选择器添加特殊的效果，比如给链接添加特殊效果，或选择第1格，第n个元素 伪类选择器书写特点是用冒号(:)表示，比如:hover 链接伪类选择器 a:link 选择所有未被访问的链接 a:visited 选择所有已被访问的链接 a:hover 选择鼠标指针位于其上的链接 a:active 选择活动链接(鼠标按下未弹起的链接) 12345a:hover&#123; color:red; text-decoration: none; &#125;&lt;a href=&quot;#&quot;&gt;我的链接&lt;/a&gt; 为了确保生效，请按照LVHA的顺序声明:link-visited-hover-active focus伪类选择器 :focus伪类选择器用于选取获得焦点的表单元素 12345678910&lt;style&gt;input:focus&#123; background-color: springgreen;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;text&quot;&gt;&lt;/body&gt; 结构伪类选择器结构伪类选择器主要根据文档结构来选择元素，常用于根据父级选择器里面的子元素 选择器 功能描述 E:first-child 作为父元素的第一个子元素的元素E E:last-child 作为父元素的最后一个子元素的元素E E F:nth-child(n) 选择父级元素E的第n个子元素(n可以是1,2,3…)关键字为even、odd E:first-of-type 选择父元素内具有指定类型的第一个E元素 E:last-of-type 选择父元素内具有指定类型的最后一个E元素 E F:nth-of-type(n) 选择父元素内具有指定类型的第n个E元素 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; ul li:first-child &#123;background: red;&#125; ul li:last-child &#123;background: green;&#125; p:nth-child(1) &#123;background: yellow;&#125; p:nth-of-type(2) &#123;background: blue;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p class=&quot;p1&quot;&gt;p1&lt;/p&gt; &lt;p class=&quot;p2&quot;&gt;p2&lt;/p&gt; &lt;p class=&quot;p3&quot;&gt;p3&lt;/p&gt; &lt;ul&gt; &lt;li&gt;li1&lt;/li&gt; &lt;li&gt;li2&lt;/li&gt; &lt;li&gt;li3&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 使用E F:nth-child(n)和E F:nth-of-type(n)的 关键点 E F:nth-child(n)在父级里从一个元素开始查找，不分类型 E F:nth-of-type(n)在父级里先看类型，再看位置 否定伪类选择器123:not(selector) &#123; 属性 : 属性值;&#125; 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;否定伪类选择器&lt;/title&gt; &lt;style&gt; .fancy &#123; text-shadow: 2px 2px 3px gold; &#125; p:not(.fancy) &#123; /*匹配class名不是fancy的p标签*/ color: green; &#125; body :not(p) &#123; /*匹配body中不是p标签的标签*/ text-decoration: underline; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;我是一个段落。&lt;/p&gt; &lt;p class=&quot;fancy&quot;&gt;我好看极了！&lt;/p&gt; &lt;div&gt;我不是一个段落。&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 伪元素选择器伪元素选择器可以帮助我们利用CSS创建新标签元素，而不需要HTML标签，从而简化HTML结构 12345678/* CSS3 语法 */选择器::伪元素 &#123; 属性 : 属性值;&#125;/* CSS2 过时语法 (仅用来支持 IE8) */选择器:伪元素 &#123; 属性 : 属性值;&#125; 伪元素选择器的语法格式为 ::伪元素，一定不要忘记 ::。伪元素选择器只能和基本选择器配合使用，并且一个选择器只能使用一个伪元素选择器，如果要为一个选择器增加多个伪元素选择器需要分别编写 before和after 选择符 描述 ::before 在元素内部的前面插入内容 ::after 在元素内部的后面插入内容 before和after创建一个元素 ,但是属于行内元素 新创建的这个元素在文档树中是找不到的 ,所以我们称为伪元素 语法: element::before &#123;&#125; before和after必须有content 属性 before 在父元素内容的前面创建元素. after 在父元素内容的后面插入元素 伪元素选择器和标签选择器一 样,权重为1 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; a::after&#123; content: &quot;→&quot;; &#125; a::before&#123; content: &quot;♥&quot;; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;a href=&quot;xiaoliblog.cn&quot;&gt;这是一个测试内容&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; first-letter::first-letter 伪元素的作用是为匹配元素的文本内容的第一个字母设置样式内容。 如下示例代码展示了 ::first-letter 伪元素 的用法： 1234p::first-letter &#123; font-size: 130%; color:teal;&#125; first-line::first-line 伪元素的作用是为匹配 HTML 元素的文本内容的第一行设置样式内容。 如下示例代码展示了 ::first-line 伪元素 的用法： 1234567p::first-line&#123; background-color: tomato;&#125;&lt;p&gt; 我的第一行测试代码&lt;br&gt; 我的第二行测试代码&lt;/p&gt; selection::selection 伪元素的作用是匹配用户在HTML 页面选中的文本内容（比如使用鼠标或其他选择设备选中的部分）设置高亮效果。如下示例代码展示了 ::selection 伪元素的用法： 1234p::selection &#123; color: gold; background-color: red;&#125; 只有一小部分 CSS 属性可以用于::selection 伪元素： color 属性 background-color 属性 cursor 属性 caret-color 属性 outline 属性 text-decoration 属性 text-emphasis-color 属性 text-shadow 属性 伪元素使用场景伪元素字体图标使用伪元素可以简化HTML 123456789 div::after &#123; position: absolute; top: 10px; right: 10px; ont-family: &#x27;icomoon&#x27;; /* content: &#x27;&#x27;; */ content: &#x27;\\e901&#x27;; font-size: 18px;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;伪元素选择器使用场景-字体图标&lt;/title&gt; &lt;style&gt; @font-face &#123; font-family: &#x27;icomoon&#x27;; src: url(&#x27;fonts/icomoon.eot?1lv3na&#x27;); src: url(&#x27;fonts/icomoon.eot?1lv3na#iefix&#x27;) format(&#x27;embedded-opentype&#x27;), url(&#x27;fonts/icomoon.ttf?1lv3na&#x27;) format(&#x27;truetype&#x27;), url(&#x27;fonts/icomoon.woff?1lv3na&#x27;) format(&#x27;woff&#x27;), url(&#x27;fonts/icomoon.svg?1lv3na#icomoon&#x27;) format(&#x27;svg&#x27;); font-weight: normal; font-style: normal; font-display: block; &#125; div &#123; position: relative; width: 200px; height: 35px; border: 1px solid red; &#125; div::after &#123; position: absolute; top: 10px; right: 10px; font-family: &#x27;icomoon&#x27;; /* content: &#x27;&#x27;; */ content: &#x27;\\e901&#x27;; color: red; font-size: 18px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 多个遮罩效果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; .box &#123; position: relative; width: 444px; height: 320px; background-color: pink; margin: 30px auto; &#125; .box img &#123; width: 100%; height: 100%; &#125; .box::before &#123; content: &#x27;&#x27;; /* 隐藏遮罩层 */ display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, .4) url(images/arr.png) no-repeat center; &#125; /* 当我们鼠标经过了盒子，就让里面before遮罩层显示出来 */ .box:hover::before &#123; /* 而是显示元素 */ display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;img src=&quot;images/img.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;img src=&quot;images/img.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;img src=&quot;images/img.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;img src=&quot;images/img.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 伪元素清除浮动是额外标签法的升级，相当于在浮动元素的最后面创建一个盒子 1234567.clearfix::after&#123; content:&quot;&quot;; /*伪元素必须写的属性*/ display:block; /*插入必须是块级*/ height:0; /*隐藏*/ clear:both; /*清除浮动*/ visibility:hidden; /*隐藏*/&#125; 双伪元素相对于前后创建一个盒子 12345678910.clearfix:before,.clearfix:after&#123; content:&quot;&quot;; display:table; /*转换为块级元素，并在一行显示*/&#125;.clearfix:after&#123; clear:both;&#125;.clearfix&#123; *zoom:1;&#125;","path":"page/css02.html","date":"01-18","excerpt":"","tags":[{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"http://xiaoliblog.cn/tags/HTML-CSS/"}]},{"title":"前端三剑客🎉HTML基础","text":"教程推荐👉👉👉黑马程序员pink老师前端入门视频教程 HTML5+CSS3 调试工具 打开浏览器，按下F12键或者右击页面空白处-&gt;检查 左边是HTML元素结构，右边是CSS样式 右边CSS样式可以改动数值，但只是调试，并不会影响源代码 如果点击元素，发现右侧没有样式引入，极有可能是类名或者样式引入错误 如果有样式，但是样式前面有黄色感叹号提示，则是样式属性书写错误 Emmet语法 Emmet语法的前身是Zen coding，它使用缩写来提高html/css的编写速度，VsCode已经集成该语法 VsCode蓝奏云下载链接请戳密码:8ogy 快速生成HTML 生成标签：直接输入标签名按tab键即可 生成多个相同标签，标签名加上\\*个数即可 如果有父子级关系的标签，可以用&gt;，比如ul&gt;li 如果有兄弟关系的标签，用+即可，比如div+p 如果生成带有类名或者id名字的，可以直接写 标签名.demo 或者 标签名#two 再按tab键即可 如果生成的div类名是有顺序的，可以用自增符号 $ 快速生成CSS CSS基本采取简写形式即可 比如w200 ,按tab 可以生成width:200px 比如lh26，按tab 可以生成 line-height:26px 格式化代码 格式化代码可以快速调整代码结构，在VsCode中右击-&gt;格式化文档即可 HTML页面 HTML：Hyper Text Markup Language（超文本标记语言）超文本包括：文字、图片、音频、视频、动画等 W3C World Wide Web Consortium（万维网联盟） 成立于1994年，Web技术领域最权威和具影响力的国际中立性技术标准机构 W3C标准包括 结构化标准语言（XHTML 、XML） 表现标准语言（CSS） 行为标准（DOM、ECMAScript ） 网页基本结构 123456789&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt; 我的第一个网页&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 我的第一个网页&lt;/body&gt;&lt;/html&gt; 文档类型声明标签，告诉浏览器所采用的是什么规范 1&lt;!DOCTYPE html&gt; Head标签 &lt;title&gt;标签设定显示在浏览器标题栏中的内容 1&lt;title&gt;家用电器排行榜&lt;/title&gt; &lt;meta&gt;标签定义网页的字符集、关键字、描述信息等内容 12345&lt;meta charset=&quot;UTF-8&quot; /&gt;&lt;meta name=&quot;keywords&quot; content=&quot;关键字1,关键字2,关键字3,...&quot; /&gt;&lt;meta name=&quot;description&quot; content=&quot;网页描述内容&quot; /&gt;&lt;meta http-equiv=&quot;refresh&quot; content=“刷新间隔时间;url=页面地址”&gt;&lt;meat http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=某种字符集&quot;&gt; gb2312包含全部中文字符，utf-8 则包含全世界所有国家需要用到的字符，页面编码应与页面文件保存时的编码一致 Body标签 设置正文颜色与背景颜色body标签封装了页面的主体内容 1&lt;body bgcolor=&quot;页面背景颜色值&quot; text=&quot;页面正文颜色值&quot;&gt; 添加网页背景图片 12&lt;!-- fixed设置背景图片固定不动--&gt;&lt;body background=&quot;背景图片的URI&quot; bgproperties=&quot;fixed&quot;&gt; 设置网页链接文字颜色 1&lt;body link=&quot;未访问状态颜色值&quot; vlink=&quot;访问过后的颜色值&quot; alink=&quot;正在访问中的颜色&quot;&gt; 设置网页边距 1&lt;body leftmargin=&quot;左边距值&quot; rightmargin=&quot;右边距值&quot; topmargin=&quot;上边距值&quot; bottommargin=&quot;底边距值&quot;&gt; 文字与段落标记 注释 1&lt;!--注释内容--&gt; 字体设置 1&lt;font face=&quot;字体名称&quot; size=&quot;字号&quot; color=&quot;颜色值&quot;&gt;文字内容&lt;/font&gt; size字号取值范围从1到7，或者从+1到+7、从-1到-7（正负取值相对于页面默认字号） 字体样式标签 12345678&lt;strong&gt;加粗&lt;/strong&gt;、&lt;b&gt;加租&lt;/b&gt;&lt;em&gt;斜体&lt;/em&gt;&lt;sup&gt;设置为上标&lt;/sup&gt;&lt;sub&gt;设置为小标&lt;/sub&gt;&lt;big&gt;设置为大字号&lt;/big&gt;&lt;small&gt;设置为小字号&lt;/small&gt;&lt;u&gt;设置下划线&lt;/u&gt;&lt;s&gt;设置删除线&lt;/s&gt; 标题标签 123456&lt;h1&gt; 一级标题&lt;/h1&gt;&lt;h2&gt; 二级标题&lt;/h2&gt;&lt;h3&gt; 三级标题&lt;/h3&gt;&lt;h4&gt; 四级标题&lt;/h4&gt;&lt;h5&gt; 五级标题&lt;/h5&gt;&lt;h6&gt; 六级标题&lt;/h6&gt; 段落标签 1&lt;p&gt;这个一个段落&lt;/p&gt; 换行标签 1&lt;br/&gt; 预格式化标签预格式化可以保留在源代码中使用Enter、空格等键产生的各种格式 1&lt;pre&gt; .. &lt;/pre&gt; 居中标记 1&lt;center&gt;居中&lt;/center&gt; 缩排标记缩排标记可以使一段文字产生一定位置的缩进，使用多次缩排标记可以实现多次缩排 1&lt;blockquot&gt;...&lt;/blockquot&gt; 水平线标签 12&lt;hr/&gt;&lt;hr width=&quot;宽度&quot; height=&quot;高度&quot; size=&quot;粗细&quot; align=&quot;水平对齐方式&quot; color=&quot;颜色&quot; noshade&gt; noshade表示设置实心的不带阴影的效果 列表标记有序列表以数字或字母等可以表示顺序的符号为项目前导符来排列列表项的列表 12345&lt;ol&gt; &lt;li&gt;列表项一&lt;/li&gt; &lt;li&gt;列表项二&lt;/li&gt; &lt;li&gt;列表项三&lt;/li&gt;&lt;/ol&gt; 前导符设置：前导符可以取1、A、a、I、i这几种，默认为”1” 1&lt;ol type=&quot;前导符&quot;&gt; 起始编号设置： 1&lt;ol start=&quot;起始编号位序&quot;&gt; 无序列表以无序次含义的符号为前导符的列表 12345&lt;ul&gt; &lt;li&gt;列表项一&lt;/li&gt; &lt;li&gt;列表项二&lt;/li&gt; &lt;li&gt;列表项三&lt;/li&gt;&lt;/ul&gt; 前导符设置：前导符可以取disc（实心圆点）、circle（空心圆点）、square（实心小方块），默认为”disc” 1&lt;ul type=&quot;前导符&quot;&gt; 定义列表一种具有两个层次的列表，可以用于对名词的解释，其中名词为第一层次，解释为第二层次 123456789&lt;dl&gt; &lt;dt&gt;名词一&lt;/dt&gt; &lt;dd&gt;解释一&lt;/dd&gt; &lt;dd&gt;解释二&lt;/dd&gt; ... &lt;dt&gt;名词二&lt;/dt&gt; &lt;dd&gt;解释一&lt;/dd&gt; &lt;dd&gt;解释二&lt;/dd&gt;&lt;/dl&gt; 表格标签 语法 123456789101112&lt;table width=“200” border=“8”&gt; &lt;tr&gt; &lt;td&gt; 第1 个单元格的内容&lt;/td&gt; &lt;td&gt; 第2 个单元格的内容&lt;/td&gt; …… &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; 第1 个单元格的内容&lt;/td&gt; &lt;td&gt; 第2 个单元格的内容&lt;/td&gt; …… &lt;/tr&gt;&lt;/table&gt; 设置表格边框和大小 1&lt;table border=&quot;边框宽度&quot; bordercolor=&quot;边框颜色&quot; width=&quot;宽度&quot; height=&quot;高度&quot;&gt; 设置表格背景颜色和对齐方式 1&lt;table bgcolor=&quot;颜色值&quot; align=&quot;对齐方式&quot;&gt; 设置背景图片 1&lt;table background=&quot;图片路径&quot;&gt; 设置表格边框间隔 1&lt;table cellpadding=&quot;内容与边框距离值&quot; cellspacing=&quot;边框之间间距值&quot;&gt; 设置表格的标题 1&lt;caption align=&quot;水平对齐方式left/right/center&quot; valign=&quot;垂直对齐方式top/bottom&quot;&gt;表格标题&lt;/caption&gt; &lt;tr&gt;标签一个&lt;tr&gt;&lt;/tr&gt;表示一行 1&lt;tr height=&quot;行高&quot; align=&quot;水平对齐方式&quot; valign=&quot;垂直对齐方式&quot; bordercolor=&quot;颜色值&quot; bgcolor=&quot;颜色值&quot;&gt;&lt;/tr&gt; &lt;td&gt;和&lt;th&gt;标签 常用属性 描述 align 水平对齐方式，取值left，right，center valign 垂直对齐方式，取值top，middle，bottom bgcolor 单元格背景颜色 background 单元格背景图片 bordercolor 单元格边框颜色 width 单元格宽度，单位为像素或者百分比 height 单元格高度 rowspan 单元格的跨行操作 colspan 单元格的跨列操作 图片标签 常见的图像格式 位图：JPG、PNG、GIF 矢量图：ai、cdf、fh、swf 区别 位图：色彩丰富，表现力强，容量大，用于网页 矢量图：图片放大，清晰度不变，不适用于色彩，丰富的图片，用于印刷行业、网页logo等。 设置图片大小和提示 1&lt;img src=&quot;path&quot; alt=&quot;text&quot; title=&quot;text&quot; width=&quot;x&quot; height=&quot;y&quot; /&gt; src为图像路径，alt为图像的替代文章，title为鼠标悬停提示文字，width，height为宽高 设置图片与周围对象的间距 1&lt;img src=&quot;图片路径&quot; hspace=&quot;水平间距&quot; vaspace=&quot;垂直间距&quot;&gt; 设置图片的对齐方式 1&lt;img src=&quot;图片文件路径&quot; align=&quot;top/bottom/middle/left/right&quot;&gt; 设置图片边框 1&lt;img src=&quot;图片文件路径&quot; border=&quot;边框宽度&quot;&gt; 链接标签 普通链接 1&lt;a href=&quot;目标端点&quot; target=&quot; 目标窗口位置&quot;&gt; 链接文字或图像&lt;/a&gt; target属性 描述 _blank 在新窗口打开链接文档 _self 在同一个框架或同一窗口中打开链接文档(默认属性) _parent 在上一级窗口中打开，一般在框架页面中经常使用 _top 在浏览器的整个窗口中打开，忽略如何框架 框架名称 在指定的框架窗口中打开链接文档 锚链接（从A页面的甲位置跳转到本页中的乙位置） 创建跳转标记1&lt;a name=&quot;marker&quot;&gt; 乙位置&lt;/a&gt; 创建跳转链接1&lt;a href=&quot;#marker&quot;&gt; 甲位置&lt;/a&gt; 功能性链接（电子邮件、QQ、MSN） 1&lt;a href=&quot;mailto:bdqnWebmaster@bdqn.cn&quot;&gt; 联系我们&lt;/a&gt; 脚本链接 1&lt;a href=&quot;javascript:alert(&#x27;你好，欢迎访问！&#x27;)&quot;&gt;欢迎访问&lt;/a&gt; 文件下载当链接的目标文档类型属于.doc、.Rar、.zip、.exe等 1&lt;a href=&quot;task.exe&quot;&gt;可执行文件下载&lt;/a&gt; 图片链接 1&lt;a href=&quot;目标地址&quot;&gt;&lt;img src=&quot;图片地址&quot;&gt;&lt;/a&gt; 表单标签 表单标签&lt;form&gt; 123&lt;form name=&quot;表单名称&quot; action=&quot;提交方式&quot; method=&quot;提交方法&quot;&gt;...&lt;/form&gt; 输入标记&lt;input&gt; 1&lt;input type=&quot;元素类型&quot; name=&quot;表单元素名称&quot;&gt; type属性值 说明 text 单行文本框 password 密码框 file 设置文件元素 hidden 设置隐藏元素 radio 单选框元素 checkbox 复选框元素 button 普通按钮 submit 提交按钮 reset 重置按钮 image 图像按钮 属性 属性值 说明 name 自定义 value 自定义 size 正整数 readonly readonly 只读 disabled disabled 禁用 checked checked 默认选中 maxlength 正整数 允许输入最大字符数 文本框text 1&lt;input type=&quot;text&quot; name=&quot;文本框名称&quot; maxlength=&quot;最多可输入字符数&quot; size=&quot;文本框长度，单位是像素&quot; value=&quot;默认值&quot;&gt; 密码框password 1&lt;input type=&quot;password&quot; name=&quot;密码框名称&quot; readonly=&quot;readonly&quot; maxlength=&quot;最多可输入字符数&quot; size=&quot;文本框长度，单位是像素&quot; value=&quot;默认值&quot;&gt; 隐藏框hidden 1&lt;input type=&quot;hidden&quot; name=&quot;域名称&quot; value=&quot;域值&quot;&gt; 文件域file 1&lt;input type=&quot;file&quot; name=&quot;域名称&quot;&gt; 单选按钮radio 1&lt;input type=&quot;radio&quot; name=&quot;域名称&quot; value=&quot;域值&quot; checked=&quot;checked&quot;&gt; checked表示默认选中 同一组单选按钮的各个选项的名称必须相同 复选框checkbox 1&lt;input type=&quot;checkbox&quot; name=&quot;域名称&quot; value=&quot;域值&quot; checked=&quot;checked&quot;&gt; 提交按钮submit 1&lt;input type=&quot;submit&quot; name=&quot;按钮名称&quot; value=&quot;按钮显示文本&quot;&gt; 普通按钮button用于激发表单动作，常配合JavaScript脚本对表单执行操作 1&lt;input type=&quot;button&quot; name=&quot;按钮名称&quot; value=&quot;按钮显示文本&quot; onclick=&quot;javascript 函数名&quot;&gt; 重置按钮reset 1&lt;input type=&quot;reset&quot; name=&quot;按钮名称&quot; value=&quot;按钮显示名称&quot;&gt; 图像按钮 1&lt;input type=&quot;image&quot; name=&quot;按钮名称&quot; src=&quot;图像路径&quot; width=&quot;60&quot; height=&quot;60&quot;&gt; label标签 &lt;label&gt;标签为input元素定义标注（标签） &lt;label&gt;标签用于绑定一共表单元素，当点击&lt;label&gt;标签内的文本时，浏览器就会自动将焦点（光标）转到或者选择对应的表单元素上，用来增加用户体验 123&lt;label for=&quot;name&quot;&gt;用户名:&lt;/label&gt;&lt;input type=&quot;text&quot; id=&quot;name&quot;&gt;&lt;input type=&quot;radio&quot; id=&quot;nan&quot; name=&quot;sex&quot;&gt;&lt;label for=&quot;nan&quot;&gt;男&lt;/label&gt;&lt;input type=&quot;radio&quot; id=&quot;nu&quot; name=&quot;sex&quot;&gt;&lt;label for=&quot;nu&quot;&gt;女&lt;/label&gt; &lt;label&gt;标签的for属性应当与相关元素的id属性相同 HTML5新增表单 属性 说明 type=&quot;email&quot; 限制用户输入必须为Email类型 type=&quot;url&quot; 限制用户输入必须为URL类型 type=&quot;date&quot; 限制用户输入必须为日期类型 type=&quot;time&quot; 限制用户输入必须为时间类型 type=&quot;month&quot; 限制用户输入必须为月类型 type=&quot;week&quot; 限制用户输入必须为周类型 type=&quot;number&quot; 限制用户输入必须为数字类型 type=&quot;tel&quot; 手机号码 type=&quot;search&quot; 搜索框 type=&quot;color&quot; 生成一个颜色选择表单 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 我们验证的时候必须添加form表单域 --&gt; &lt;form action=&quot;&quot;&gt; &lt;ul&gt; &lt;li&gt;邮箱: &lt;input type=&quot;email&quot; /&gt;&lt;/li&gt; &lt;li&gt;网址: &lt;input type=&quot;url&quot; /&gt;&lt;/li&gt; &lt;li&gt;日期: &lt;input type=&quot;date&quot; /&gt;&lt;/li&gt; &lt;li&gt;时间: &lt;input type=&quot;time&quot; /&gt;&lt;/li&gt; &lt;li&gt;数量: &lt;input type=&quot;number&quot; /&gt;&lt;/li&gt; &lt;li&gt;手机号码: &lt;input type=&quot;tel&quot; /&gt;&lt;/li&gt; &lt;li&gt;搜索: &lt;input type=&quot;search&quot; /&gt;&lt;/li&gt; &lt;li&gt;颜色: &lt;input type=&quot;color&quot; /&gt;&lt;/li&gt; &lt;!-- 当我们点击提交按钮就可以验证表单了 --&gt; &lt;li&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 添加&lt;form&gt;表单，并点击提交按钮后，会进行验证和提醒！，这就不需要JS的验证啦 HTML5新增表单属性 属性 值 描述 required required 表示内容不能为空，必填 placeholder 提示文本 表单的提示信息，存在默认值将不显示 autofocus autofous 自动获得焦点属性，页面加载完成自动聚焦到指定表单 autocomplete off/on 当用户输入正确的值后，下次浏览器会自动记录用户输入的值，前提需要放在表单内，同时加上name属性，同时成功提交，默认on打开，off关闭(由于安全性考虑建议关闭) multiple multiple 可以多选文件提交 可以通过以下设置方式修改placeholder里面的字体颜色: 123input::placeholder &#123; color:red; &#125; 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style&gt; input::placeholder &#123; color:red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;&quot;&gt; &lt;input type=&quot;search&quot; name=&quot;sear&quot; id=&quot;&quot; required=&quot;required&quot; placeholder=&quot;提示信息&quot; autofocus=&quot;autofocus&quot; autocomplete=&quot;off&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;&quot; id=&quot;&quot; multiple=&quot;multiple&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 选择列表标签 列表&lt;select&gt; 1234&lt;select name=&quot;列表名称&quot; size=&quot;显示的选项数目&quot; multiple=&quot;multiple&quot;&gt; &lt;option value=&quot;选项值&quot; selected=&quot;selected&quot;&gt;选项一&lt;/option&gt; &lt;option value=&quot;选项值&quot;&gt;选项二&lt;/option&gt;&lt;/select&gt; multiple表示项目可多选selected表示默认选项，可设置多个 下拉列表一次只能选一个 1234&lt;select &gt; &lt;option value=&quot;选项值&quot;&gt;选项一&lt;/option&gt; &lt;option value=&quot;选项值&quot;&gt;选项二&lt;/option&gt;&lt;/select&gt; 文本域标签&lt;textarea&gt; 123&lt;textarea name=&quot;文本域名称&quot; rows=&quot;行数&quot; cols=&quot;列数(字符数)&quot;&gt;``&lt;/textarea&gt; 滚动字幕 设置滚动字幕默认情况下，&lt;marquee&gt;标签得到的滚动字幕是从右向左的 1&lt;marquee&gt;滚动文字&lt;/marquee&gt; 设置滚动方向 1&lt;marquee direction=&quot;滚动方向&quot;&gt;滚动文字&lt;/marquee&gt; direction属性值 描述 up 从下往上滚动 down 从上往下滚动 left 从左往右滚动 right 从右往左滚动 设置滚动字幕的滚动行为 1&lt;marquee behavior=&quot;滚动行为&quot;&gt;滚动文字&lt;/marquee&gt; behavior属性值 描述 scroll 设置文字循环往复滚动（默认） slide 设置文字只进行一次滚动 alternate 设置文字循环交替往返进行滚动 设置字幕的滚动速度和滚动延迟特性 1&lt;marquee scrollamount=&quot;滚动速度值(默认为6)&quot; scrolldelay=&quot;延迟时间(毫秒为单位)&quot;&gt;滚动文字&lt;/marquee&gt; 设置字幕的滚动区域及其背景色 1&lt;marquee bgcolor=&quot;颜色值&quot; width=&quot;宽度&quot; height=&quot;高度&quot;&gt;滚动字幕&lt;/marquee&gt; 设置字幕的滚动区域与周围对象的间距 1&lt;marquee hspace=&quot;水平间距&quot; vspace=&quot;垂直间距&quot;&gt;滚动文字&lt;/marquee&gt; 多媒体标签视频标签1234&lt;video controls&gt; &lt;source src=&quot;video/video.webm&quot; type=&quot;video/webm&quot;/&gt; &lt;source src=&quot;video/video.mp4&quot; type=&quot;video/mp4&quot;/&gt;&lt;/video&gt; cotrols表示提供播放、暂停和音量 的控件 自动播放 1&lt;video src=&quot;文件地址&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt; 照规兼容性 12345&lt;video autoplay&gt; &lt;source src=&quot;video/video.webm&quot; type=&quot;video/webm&quot;/&gt; &lt;source src=&quot;video/video.mp4&quot; type=&quot;video/mp4&quot;/&gt; 持 你的浏览器不支持video 元素&lt;/video&gt; video属性 值 描述 autoplay autoplay 自动播放 controls controls 显示播放控件 width 像素 播放器宽度 height 像素 播放器高度 loop loop 循环播放 preload auto（预先加载视频）、none（不预先加载视频） 是否预先加载视频 src url 视频url地址 poster imgurl 加载等待的画面图片 muted muted 静音播放 音频标签1&lt;audio src=&quot;文件地址&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt; 照规兼容性 12345&lt;audio controls&gt; &lt;source src=&quot;music/music.mp3&quot; type=&quot;audio/mpeg&quot;/&gt; &lt;source src=&quot;music/music.ogg&quot; type=&quot;audio/ogg&quot;/&gt; 持 你的浏览器不支持audio 元素&lt;/audio&gt; audio属性 值 描述 autoplay autoplay 自动播放 controls controls 显示播放控件 loop loop 循环播放 src url 音频url地址 谷歌浏览器把音频和视频自动播放禁止了 结构语义化标签 123456&lt;header&gt;&lt;h2&gt; 网页头部&lt;/h2&gt; &lt;/header&gt;&lt;section&gt;&lt;h2&gt; 网页主体部分&lt;/h2&gt;&lt;/section&gt;&lt;footer&gt;&lt;h2&gt; 网页底部&lt;/h2&gt;&lt;/footer&gt;&lt;artice&gt;独立的文章内容&lt;/artice&gt;&lt;aside&gt;相关内容或应用&lt;/aside&gt;&lt;nav&gt;导航类辅助内容&lt;/nav&gt; 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;HTML5新增语义化标签&lt;/title&gt; &lt;style&gt; header, nav &#123; height: 120px; background-color: pink; border-radius: 15px; width: 800px; margin: 15px auto; &#125; section &#123; width: 500px; height: 300px; background-color: skyblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;header&gt;头部标签&lt;/header&gt; &lt;nav&gt;导航栏标签&lt;/nav&gt; &lt;section&gt;某个区域&lt;/section&gt;&lt;/body&gt;&lt;/html&gt; # 框架结构 框架的基本结构分框架集和框架两个部分，因为只分隔窗口，不涉及页面的具体内容，所以不需要\\包裹 框架集标记&lt;frameset&gt;的作用主要是定义浏览器窗口的分割方式、各分隔窗口(框架)的大小，以及设置框架边框的颜色和粗细等属性。 属性 描述 border 设置边框粗细 bordercolor 边框颜色 frameboder 是否显示边框，可取值0或和1，或者no和yes framespacing 框架之间的间距 rows 按行，即上下(垂直)方式分割 cols 按列，即左右(水平)方式分割 左右分隔窗口 12345&lt;frameset cols=&quot;value1,value2,..&quot;&gt; &lt;frame&gt; &lt;frame&gt; ...&lt;/frameset&gt; 上下分割窗口 12345&lt;frameset rows=&quot;value1,value2,..&quot;&gt; &lt;frame&gt; &lt;frame&gt; ...&lt;/frameset&gt; 嵌套分隔窗口 123456789&lt;frameset rows=&quot;80%,*,..&quot;&gt; &lt;frame/&gt; &lt;frameset cols=&quot;20%,*,..&quot;&gt; &lt;frame&gt; &lt;frame&gt; ... &lt;/frameset&gt; ...&lt;/frameset&gt; 使用&lt;frameset&gt;标签设置框架边框 1&lt;frameset frameborder=&quot;0|1|no|yes&quot; framespacing=&quot;边框间距&quot; border=&quot;边框宽度&quot; bordercolor=&quot;颜色值&quot;&gt; 框架标记&lt;frame&gt;&lt;frame&gt;用于设置子窗口，是个单标记，必须放在frameset中 属性 描述 src 设置在框架中显示的页面的URL地址 bordercolor 设置边框颜色 frameboder 是否显示边框，可取值0或和1，或者no和yes border 设置边框粗细 name 设置框架名称，可作为超链接的target的属性值 noresize 使用时不能调整窗口的大小 scorlling 设置是否显示滚动条，可取值yes,no和auto marginwidth 设置内容与框架窗口左右边框的距离 marginheight 设置内容与框架窗口上下边框的距离 设置框架显示内容设置指定某个页面的内容 1&lt;frame src=&quot;需要显示页面的URL&quot;&gt; 设置框架边距 1&lt;frame frameborder=&quot;0|1|no|yes&quot; bordercolor=&quot;颜色值&quot;&gt; 设置框架名称 1&lt;frame name=&quot;框架名称&quot;&gt; 设置框架固定大小 1&lt;frame noresize=&quot;noresize&quot;&gt; 设置框架滚动条 1&lt;frame scrolling=&quot;auto|no|yes&quot;&gt; 设置框架边距 1&lt;frame marginheight=&quot;上、下边距&quot; marginwidth=&quot;左、右边距&quot;&gt; 不支持框架标签有些浏览器不支持框架，会显示空白页，这时，需要使用&lt;noframes&gt;显示提示信息 12345&lt;noframes&gt; &lt;body&gt; 抱歉，你的浏览器版本太低，不支持框架，无法看到页面内容，请使用较新的浏览器来浏览 &lt;/body&gt;&lt;/noframes&gt; 浮动框架标签&lt;iframe&gt;是一种特殊的框架页面，可以作为HTML文档的一部分,，放在body标签里面 属性 描述 src 设置在浮点框架中显示的页面的URL地址 width 设置浮动框架的宽度 height 设置浮动框架的高度 align 设置浮动框架的对齐方式 frameboder 是否显示边框，可取值0或和1，或者no和yes name 设置框架名称，可作为超链接的target的属性值 noresize 使用时不能调整窗口的大小 scorlling 设置是否显示滚动条，可取值yes,no和auto bordercolor 设置边框颜色 marginwidth 设置内容与框架窗口左右边框的距离 marginheight 设置内容与框架窗口上下边框的距离 在页面中嵌入浮动框架 1&lt;iframe src=&quot;源文件地址&quot;&gt; 浮动框架的大小 1&lt;iframe src=&quot;源文件地址&quot; width=&quot;宽度&quot; heigth=&quot;高度&quot;&gt; 浮点框架的对齐方式 1&lt;iframe src=&quot;源文件地址&quot; align=&quot;对齐方式&quot;&gt; 实现页面间的相互跳转 在被打开的框架上加name属性1&lt;iframe name=&quot;mainFrame&quot; src=&quot;a.html&quot;/&gt; 在超链接上设置target目标窗口属性为希望显示的框架窗口名1&lt;a href=&quot;a.html&quot; target=&quot;mainFrame&quot;&gt; 下边显示第二页&lt;/a&gt; 综合实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;综合案例-注册页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h4&gt;青春不常在，抓紧谈恋爱&lt;/h4&gt; &lt;table width=&quot;600&quot; &gt; &lt;!-- 第一行 --&gt; &lt;tr&gt; &lt;td&gt;性别:&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;nan&quot;&gt; &lt;label for=&quot;nan&quot;&gt; 男 &lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;nv&quot;&gt; &lt;label for=&quot;nv&quot;&gt; 女&lt;/label&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第二行 --&gt; &lt;tr&gt; &lt;td&gt;生日:&lt;/td&gt; &lt;td&gt; &lt;select&gt; &lt;option&gt;--请选择年份--&lt;/option&gt; &lt;option&gt;2001&lt;/option&gt; &lt;option&gt;2002&lt;/option&gt; &lt;option&gt;2003&lt;/option&gt; &lt;/select&gt; &lt;select&gt; &lt;option&gt;--请选择月份--&lt;/option&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;/select&gt; &lt;select&gt; &lt;option&gt;--请选择日--&lt;/option&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第三行 --&gt; &lt;tr&gt; &lt;td&gt;所在地区&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; value=&quot;北京思密达&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!-- 第四行 --&gt; &lt;tr&gt; &lt;td&gt;婚姻状况:&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;radio&quot; name=&quot;marry&quot; checked=&quot;checked&quot;&gt;未婚 &lt;input type=&quot;radio&quot; name=&quot;marry&quot;&gt; 已婚 &lt;input type=&quot;radio&quot; name=&quot;marry&quot;&gt; 离婚 &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第五行 --&gt; &lt;tr&gt; &lt;td&gt;学历:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; value=&quot;博士后&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!-- 第六行 --&gt; &lt;tr&gt; &lt;td&gt;喜欢的类型:&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; name=&quot;love&quot; &gt; 妩媚的 &lt;input type=&quot;checkbox&quot; name=&quot;love&quot; &gt; 可爱的 &lt;input type=&quot;checkbox&quot; name=&quot;love&quot; &gt; 小鲜肉 &lt;input type=&quot;checkbox&quot; name=&quot;love&quot; &gt; 老腊肉 &lt;input type=&quot;checkbox&quot; name=&quot;love&quot; checked=&quot;checked&quot;&gt; 都喜欢 &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第七行 --&gt; &lt;tr&gt; &lt;td&gt;个人介绍&lt;/td&gt; &lt;td&gt; &lt;textarea&gt;个人简介&lt;/textarea&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!-- 第八行 --&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;submit&quot; value=&quot;免费注册&quot; &gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot;&gt; 我同意注册条款和会员加入标准 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;#&quot; &gt; 我是会员，立即登录&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt; &lt;h5&gt;我承诺&lt;/h5&gt; &lt;ul&gt; &lt;li&gt;年满18岁、单身&lt;/li&gt; &lt;li&gt;抱着严肃的态度&lt;/li&gt; &lt;li&gt;真诚寻找另一半&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;","path":"page/css04.html","date":"01-18","excerpt":"","tags":[{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"http://xiaoliblog.cn/tags/HTML-CSS/"}]},{"title":"JavaWeb🌍smbms注销及权限过滤","text":"注销 思路：移除Session，跳转到登录页面 首先在util包下定义常量类Constants保存SessionID 123456package com.hitenine.util;public class Constants &#123; public final static String USER_SESSION = &quot;userSession&quot;;&#125; 在servlet.user包下，创建LogoutServlet方法· 123456789101112131415161718192021222324package com.hitenine.servlet.user;import com.hitenine.util.Constants;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class LogoutServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //移除用户的Constants.USER_SESSION req.getSession().removeAttribute(Constants.USER_SESSION); resp.sendRedirect(req.getContextPath() + &quot;/login.jsp&quot;); //返回登录页面 &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; 在web.xml中注册 12345678&lt;servlet&gt; &lt;servlet-name&gt;LogoutServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.hitenine.servlet.user.LogoutServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;LogoutServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/jsp/logout.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 登录拦截器 在filter包中创建SysFilter过滤器 123456789101112131415161718192021222324252627282930313233343536package com.hitenine.filter;import com.hitenine.pojo.User;import com.hitenine.util.Constants;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class SysFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest req = (HttpServletRequest) request; HttpServletResponse resp = (HttpServletResponse) response; //从Session中获取用户 User user = (User) req.getSession().getAttribute(Constants.USER_SESSION); if (null == user) &#123; //已经被移除或者注销了，或者未登录 resp.sendRedirect(&quot;/smbms/error.jsp&quot;); &#125; else &#123; chain.doFilter(request, response); &#125; &#125; @Override public void destroy() &#123; &#125;&#125; web.xml中注册 12345678910&lt;!--用户登录过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;SysFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.hitenine.filter.SysFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;SysFilter&lt;/filter-name&gt; &lt;!--所有JSP文件下的都过滤--&gt; &lt;url-pattern&gt;/jsp/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;","path":"page/JavaWeb18.html","date":"01-18","excerpt":"","tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://xiaoliblog.cn/tags/JavaWeb/"}]},{"title":"JavaWeb🌍smbms登录流程实现","text":"登录流程 编写前端页面 编写login.jsp登录页面 123456789101112131415161718192021222324252627282930313233343536373839&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;系统登录 - 超市订单管理系统&lt;/title&gt; &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;$&#123;pageContext.request.contextPath &#125;/css/style.css&quot; /&gt; &lt;script type=&quot;text/javascript&quot;&gt; /* if(top.location!=self.location)&#123; top.location=self.location; &#125; */ &lt;/script&gt;&lt;/head&gt;&lt;body class=&quot;login_bg&quot;&gt; &lt;section class=&quot;loginBox&quot;&gt; &lt;header class=&quot;loginHeader&quot;&gt; &lt;h1&gt;超市订单管理系统&lt;/h1&gt; &lt;/header&gt; &lt;section class=&quot;loginCont&quot;&gt; &lt;form class=&quot;loginForm&quot; action=&quot;$&#123;pageContext.request.contextPath&#125;/login.do&quot; name=&quot;actionForm&quot; id=&quot;actionForm&quot; method=&quot;post&quot; &gt; &lt;div class=&quot;info&quot;&gt;$&#123;error&#125;&lt;/div&gt; &lt;div class=&quot;inputbox&quot;&gt; &lt;label&gt;用户名：&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;input-text&quot; id=&quot;userCode&quot; name=&quot;userCode&quot; placeholder=&quot;请输入用户名&quot; required/&gt; &lt;/div&gt; &lt;div class=&quot;inputbox&quot;&gt; &lt;label&gt;密码：&lt;/label&gt; &lt;input type=&quot;password&quot; id=&quot;userPassword&quot; name=&quot;userPassword&quot; placeholder=&quot;请输入密码&quot; required/&gt; &lt;/div&gt; &lt;div class=&quot;subBtn&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;/&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot;/&gt; &lt;/div&gt; &lt;/form&gt; &lt;/section&gt; &lt;/section&gt;&lt;/body&gt;&lt;/html&gt; 设置欢迎界面 在web.xml中配置欢迎页，欢迎页面是指java后台启动成功后可以设置启动成功后，访问http://localhost:8080 就跳转到欢迎页面（即登录页面），而不是默认的index.jsp页面 1234&lt;!--设置欢迎页面--&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;login.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; 欢迎页面实现原理 前端发送http://localhost:8080 到服务端，服务端根据web.xml中的 welcome-file-list中的welcome-file属性在WebRoot（eclipse）或Webapp（idea） 目录下查找到welcome-file配置的文件，如果有则将页面返回给前端，如果没有，则返回404给前端 Dao持久化层接口 创建dao.user包，在dao.user包下创建UserDao持久层接口操作数据库 使用面向接口编程的方法， 1234567891011121314package com.hitenine.dao.user;import com.hitenine.pojo.User;import java.sql.Connection;import java.sql.SQLException;import java.util.List;public interface UserDao &#123; //得到要登录的用户 public User getLoginUser(Connection connection, String userCode) throws SQLException;&#125; 实现接口 在dao.user包下创建UserDaoImpl实现UserDao接口的方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.hitenine.dao.user;import com.hitenine.dao.BaseDao;import com.hitenine.pojo.User;import com.mysql.cj.util.StringUtils;import javax.servlet.http.HttpServlet;import java.sql.*;import java.util.ArrayList;import java.util.List;public class UserDaoImpl extends HttpServlet implements UserDao &#123; //得到要登录的用户 @Override public User getLoginUser(Connection connection, String userCode) throws SQLException &#123; PreparedStatement pstm = null; ResultSet rs = null; User user = null; if (null != connection) &#123; String sql = &quot;select * from smbms_user where userCode=?&quot;; Object[] params = &#123;userCode&#125;; rs = BaseDao.execute(connection, pstm, rs, sql, params); if (rs.next()) &#123; user = new User(); user.setId(rs.getInt(&quot;id&quot;)); user.setUserCode(rs.getString(&quot;userCode&quot;)); user.setUserName(rs.getString(&quot;userName&quot;)); user.setUserPassword(rs.getString(&quot;userPassword&quot;)); user.setGender(rs.getInt(&quot;gender&quot;)); user.setBirthday(rs.getDate(&quot;birthday&quot;)); user.setPhone(rs.getString(&quot;phone&quot;)); user.setAddress(rs.getString(&quot;address&quot;)); user.setUserRole(rs.getInt(&quot;userRole&quot;)); user.setCreatedBy(rs.getInt(&quot;createdBy&quot;)); user.setCreationDate(rs.getTimestamp(&quot;creationDate&quot;)); user.setModifyBy(rs.getInt(&quot;modifyBy&quot;)); user.setModifyDate(rs.getTimestamp(&quot;modifyDate&quot;)); &#125; BaseDao.closeResource(null, pstm, rs); &#125; return user; &#125;&#125; Service业务层 业务层主要调用持久层 接口 创建service.user包，在包下创建UserService接口 12345678910package com.hitenine.service.user;import com.hitenine.pojo.User;import java.util.List;public interface UserService &#123; //用户登录 public User login(String userCode, String password);&#125; 接口实现 在service.user包下创建UserServiceImpl实现接口 12345678910111213141516171819202122232425262728293031323334353637383940package com.hitenine.service.user;import com.hitenine.dao.BaseDao;import com.hitenine.dao.user.UserDao;import com.hitenine.dao.user.UserDaoImpl;import com.hitenine.pojo.User;import org.junit.Test;import java.sql.Connection;import java.sql.SQLException;import java.util.List;public class UserServiceImpl implements UserService &#123; //业务层都会调用dao层，所以我们要引入Dao层 private UserDao userDao; public UserServiceImpl() &#123; userDao = new UserDaoImpl(); &#125; //用户登录 @Override public User login(String userCode, String password) &#123; Connection connection = null; User user = null; try &#123; connection = BaseDao.getConnection(); //通过业务层调用对应的数据库操作 user = userDao.getLoginUser(connection, userCode); &#125; catch (SQLException e) &#123; //e.printStackTrace(); &#125; finally &#123; BaseDao.closeResource(connection, null, null); &#125; return user; &#125;&#125; Servlet控制层 控制层主要调用业务层 创建servlet.user包，在包下创建LoginServlet处理请求信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.hitenine.servlet.user;import com.hitenine.pojo.User;import com.hitenine.service.user.UserServiceImpl;import com.hitenine.util.Constants;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class LoginServlet extends HttpServlet &#123; //Servlet:控制层，调用业务层 @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;LoginServlet---start---&quot;); //获取用户名和密码 String userCode = req.getParameter(&quot;userCode&quot;); String userPassword = req.getParameter(&quot;userPassword&quot;); //和数据库中的密码进行对比，调用业务层 UserServiceImpl userService = new UserServiceImpl(); User user = userService.login(userCode, userPassword); //这里已经把登录的人给查出来了// user.getUserPassword().equals(userPassword) if (null != user) &#123; //查有此人，可以登录 //将用户的信息放到Session中 req.getSession().setAttribute(Constants.USER_SESSION, user); System.out.println(&quot;Session --- &gt; &quot; + req.getSession()); //跳转到内部主页 resp.sendRedirect(&quot;jsp/frame.jsp&quot;); &#125; else &#123; //查无此人，无法登录 //转发会登陆页面，顺带提示用户名或者密码错误 req.setAttribute(&quot;error&quot;, &quot;用户名或者密码不正确&quot;); req.getRequestDispatcher(&quot;login.jsp&quot;).forward(req, resp); &#125; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; 在web.xml中进行注册 123456789&lt;!--Servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.hitenine.servlet.user.LoginServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/login.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;","path":"page/JavaWeb17.html","date":"01-17","excerpt":"","tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://xiaoliblog.cn/tags/JavaWeb/"}]},{"title":"JavaWeb🌍smbms项目搭建","text":"项目结构 环境搭建 搭建一个Maven Web项目 导入相关依赖 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.18&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp.jstl-api&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- standard标签库--&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.62&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; IDEA连接数据库 项目结构搭建 ORM映射数据库搭建 创建数据库smbms 1CREATE DATABASE smbms 创建smbms_address表 12345678910111213CREATE TABLE `smbms_address` ( `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;, `contact` VARCHAR(15) DEFAULT NULL COMMENT &#x27;联系人姓名&#x27;, `addressDesc` VARCHAR(50) DEFAULT NULL COMMENT &#x27;收货地址&#x27;, `postCode` VARCHAR(15) DEFAULT NULL COMMENT &#x27;邮编&#x27;, `tel` INT(20) DEFAULT NULL COMMENT &#x27;联系人电话&#x27;, `createdBy` VARCHAR(20) DEFAULT NULL COMMENT &#x27;创建者&#x27;, `creationDate` DATETIME DEFAULT NULL COMMENT &#x27;创建时间&#x27;, `modifyBy` BIGINT(20) DEFAULT NULL COMMENT &#x27;修改者&#x27;, `modifyDate` DATETIME DEFAULT NULL COMMENT &#x27;修改时间&#x27;, `userId` BIGINT(20) DEFAULT NULL COMMENT &#x27;用户ID&#x27;, PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8; 编写smbms_user表· 12345678910111213141516CREATE TABLE `smbms_user` ( `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;, `userCode` VARCHAR(15) DEFAULT NULL COMMENT &#x27;用户编码&#x27;, `userName` VARCHAR(15) DEFAULT NULL COMMENT &#x27;用户名字&#x27;, `userPassword` VARCHAR(20) DEFAULT NULL COMMENT &#x27;用户密码&#x27;, `gender` INT(10) DEFAULT NULL COMMENT &#x27;性别&#x27;, `birthday` DATE DEFAULT NULL COMMENT &#x27;出生日期&#x27;, `phone` VARCHAR(20) DEFAULT NULL COMMENT &#x27;电话&#x27;, `address` VARCHAR(30) DEFAULT NULL COMMENT &#x27;地址&#x27;, `userRole` BIGINT(20) DEFAULT NULL COMMENT &#x27;用户角色&#x27;, `createdBy` BIGINT(20) DEFAULT NULL COMMENT &#x27;创建者&#x27;, `creationDate` DATETIME DEFAULT NULL COMMENT &#x27;创建时间&#x27;, `modifyBy` BIGINT(20) DEFAULT NULL COMMENT &#x27;更新者&#x27;, `modifyDate` DATETIME DEFAULT NULL COMMENT &#x27;更新时间&#x27;, PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8; 编写smbms_role表 12345678910CREATE TABLE `smbms_role` ( `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;, `roleCode` VARCHAR(30) DEFAULT NULL COMMENT &#x27;角色编码&#x27;, `roleName` VARCHAR(15) DEFAULT NULL COMMENT &#x27;角色名称&#x27;, `createdBy` BIGINT(20) DEFAULT NULL COMMENT &#x27;创建者&#x27;, `creationDate` DATETIME DEFAULT NULL COMMENT &#x27;创建时间&#x27;, `modifyBy` BIGINT(20) DEFAULT NULL COMMENT &#x27;更新者&#x27;, `modifyDate` DATETIME DEFAULT NULL COMMENT &#x27;更新时间&#x27;, PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8; 编写smbms_bill表 123456789101112131415CREATE TABLE `smbms_bill` ( `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;, `billCode` VARCHAR(30) DEFAULT NULL COMMENT &#x27;账单编码&#x27;, `productName` VARCHAR(20) DEFAULT NULL COMMENT &#x27;商品名称&#x27;, `productDesc` VARCHAR(50) DEFAULT NULL COMMENT &#x27;商品描述&#x27;, `productUnit` VARCHAR(60) DEFAULT NULL COMMENT &#x27;商品数量&#x27;, `productCount` DECIMAL(20,2) DEFAULT NULL COMMENT &#x27;总金额&#x27;, `totalPrice` DECIMAL(20,2) DEFAULT NULL COMMENT &#x27;是否支付&#x27;, `isPayment` INT(10) DEFAULT NULL COMMENT &#x27;供应商ID&#x27;, `createdBy` BIGINT(20) DEFAULT NULL COMMENT &#x27;创建者&#x27;, `creationDate` DATETIME DEFAULT NULL COMMENT &#x27;创建时间&#x27;, `modifyBy` BIGINT(20) DEFAULT NULL COMMENT &#x27;更新者&#x27;, `modifyDate` DATETIME DEFAULT NULL COMMENT &#x27;更新时间&#x27;, PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8; 编写smbms_provider表· 123456789101112131415CREATE TABLE `smbms_provider` ( `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;, `proCode` VARCHAR(15) DEFAULT NULL COMMENT &#x27;供应商编码&#x27;, `proName` VARCHAR(15) DEFAULT NULL COMMENT &#x27;供应商名称&#x27;, `proDesc` VARCHAR(50) DEFAULT NULL COMMENT &#x27;供应商描述&#x27;, `proContact` VARCHAR(15) DEFAULT NULL COMMENT &#x27;供应商联系人&#x27;, `proPhone` VARCHAR(20) DEFAULT NULL COMMENT &#x27;供应商电话&#x27;, `proAddress` VARCHAR(30) DEFAULT NULL COMMENT &#x27;供应商地址&#x27;, `proFax` VARCHAR(20) DEFAULT NULL COMMENT &#x27;供应商传真&#x27;, `createdBy` BIGINT(20) DEFAULT NULL COMMENT &#x27;创建者&#x27;, `creationDate` DATETIME DEFAULT NULL COMMENT &#x27;创建时间&#x27;, `modifyBy` BIGINT(20) DEFAULT NULL COMMENT &#x27;更新者&#x27;, `modifyDate` DATETIME DEFAULT NULL COMMENT &#x27;更新时间&#x27;, PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8; 实体类编写 实体类放pojo包下 User用户实体类 12345678910111213141516171819202122232425262728package com.hitenine.pojo;import java.util.Date;public class User &#123; private Integer id; //id private String userCode; //用户编码 private String userName; //用户名称 private String userPassword; //用户密码 private Integer gender; //性别 private Date birthday; //出生日期 private String phone; //电话 private String address; //地址 private Integer userRole; //用户角色 private Integer createdBy; //创建者 private Integer modifyBy; //更新者 private Date creationDate; //创建时间 private Date modifyDate; //更新时间 private Integer age; //年龄 private String userRoleName; //用户角色名称 public Integer getAge() &#123; Date date = new Date(); Integer age = date.getYear() - birthday.getYear(); return age; &#125; //getter和setter方法 //toString方法&#125; Role实体类 1234567891011121314package com.hitenine.pojo;import java.util.Date;public class Role &#123; private Integer id; //id private String userCode; //角色编码 private String roleName; //角色名称 private Integer createdBy; //创建者 private Date creationDate; //创建时间 private Integer modifyBy; //更新者 private Date modifyDate; //更新时间 //getter和setter方法&#125; Provider供应商实体类 123456789101112131415public class Provider &#123; private Integer id; //id private String proCode; //供应商编码 private String proName; //供应商名称 private String proDesc; //供应商描述 private String proContact; //供应商联系人 private String proPhone; //供应商电话 private String proAddress; //供应商地址 private String proFax; //供应商传真 private Integer createdBy; //创建者 private Date creationDate; //创建时间 private Integer modifyBy; //更新者 private Date modifyDate; //更新时间 //getter和setter方法&#125; Bill订单实体类 1234567891011121314151617181920212223package com.hitenine.pojo;import java.util.Date;//订单public class Bill &#123; private Integer id; //id private String billCode; //账单编码 private String productName; //商品名称 private String productDesc; //商品描述 private String productUnit; //商品单位 private String productCount; //商品数量 private String totalPrice; //总金额 private String isPayment; //是否支付 private String providerId; //供应商ID private Integer createdBy; //创建者 private Date creationDate; //创建时间 private Integer modifyBy; //更新者 private Date modifyDate; //更新时间 private String providerName; //供应商名称 //getter和setter方法&#125; 配置JDBC 在resources目录下创建db.propertise配置文件 1234driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/smbms?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf-8username=rootpassword=root 在dao包下创建BaseDao操作数据库的公共类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113package com.hitenine.dao;import java.io.IOException;import java.io.InputStream;import java.sql.*;import java.util.Properties;//操作数据库的公共类public class BaseDao &#123; private static String driver; private static String url; private static String username; private static String password; //静态代码块，类加载的时候就初始化了 static &#123; Properties properties = new Properties(); //通过类加载器读取对应的资源 InputStream is = BaseDao.class.getClassLoader().getResourceAsStream(&quot;db.properties&quot;); try &#123; properties.load(is); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; driver = properties.getProperty(&quot;driver&quot;); url = properties.getProperty(&quot;url&quot;); username = properties.getProperty(&quot;username&quot;); password = properties.getProperty(&quot;password&quot;); &#125; //获取数据库的连接 public static Connection getConnection() &#123; Connection connection = null; try &#123; Class.forName(driver); connection = DriverManager.getConnection(url, username, password); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return connection; &#125; //编写查询公共方法 public static ResultSet execute(Connection connection, PreparedStatement preparedStatement, ResultSet resultSet, String sql, Object[] params) throws SQLException &#123; //预编译的sql，在后面直接执行就可以了 preparedStatement = connection.prepareStatement(sql); for (int i = 0; i &lt; params.length; i++) &#123; //setObject，占据符从1开始，但是我们的数组是从0开始的 preparedStatement.setObject(i + 1, params[i]); &#125; resultSet = preparedStatement.executeQuery(); return resultSet; &#125; //编写增删改公共方法 public static int execute(Connection connection, PreparedStatement preparedStatement, String sql, Object[] params) throws SQLException &#123; //预编译的sql，在后面直接执行就可以了 preparedStatement = connection.prepareStatement(sql); for (int i = 0; i &lt; params.length; i++) &#123; //setObject，占据符从1开始，但是我们的数组是从0开始的 preparedStatement.setObject(i + 1, params[i]); &#125; int updateRows = preparedStatement.executeUpdate(); return updateRows; &#125; //释放资源 public static boolean closeResource(Connection connection, PreparedStatement preparedStatement, ResultSet resultSet) &#123; boolean flag = true; if (null != resultSet) &#123; try &#123; resultSet.close(); //GC回收 resultSet = null; &#125; catch (SQLException e) &#123; e.printStackTrace(); flag = false; &#125; &#125; if (null != preparedStatement) &#123; try &#123; preparedStatement.close(); //GC回收 preparedStatement = null; &#125; catch (SQLException e) &#123; e.printStackTrace(); flag = false; &#125; &#125; if (null != connection) &#123; try &#123; connection.close(); //GC回收 connection = null; &#125; catch (SQLException e) &#123; e.printStackTrace(); flag = false; &#125; &#125; return flag; &#125;&#125; 过滤器统一编码 在filter包下创建CharacterEncodingFilter过滤器 1234567891011121314151617181920212223package com.hitenine.filter;import javax.servlet.*;import java.io.IOException;//字符编码过滤器public class CharacterEncodingFilter implements Filter &#123; public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; request.setCharacterEncoding(&quot;utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); chain.doFilter(request, response); &#125; public void destroy() &#123; &#125;&#125; 在web.xml中注册过滤器 123456789&lt;!--字符编码过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.hitenine.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 静态资源导入","path":"page/JavaWeb16.html","date":"01-16","excerpt":"","tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://xiaoliblog.cn/tags/JavaWeb/"}]},{"title":"JavaWeb🌍各种转发及路径问题","text":"相关概念 服务器的站点根目录 以tomcat服务器为例，tomcat服务器站点根目录就是安装目录C:\\JavaWeb\\tomcat\\webapps，服务器下的webapps就是服务器的站点根目录 web应用的根目录 创建的web工程需要部署到tomcat服务器上才能进行查看，每个web工程都是一个web应用，tomcat安装目录下的webapps下存放着服务器上的web应用。如下：Test文件夹为该web应用的根目录 绝对路径 绝对路径就是你的主页上的文件或目录在硬盘上真正的路径，(URL和物理路径) 例如：C:\\xyz\\test.txt 代表了test.txt文件的绝对路径。http://www.sun.com/index.html 也代表了一个URL绝对路径。 相对路径 相对于某个基准目录的路径。包含Web的相对路径（HTML中的相对目录）， 在项目中，/代表Web站点的根目录，./代表当前目录, ../代表上级目录， …/…/ 代表文件所在的父级目录的父级目录（回到上一级的上一级） 超链接 假设基础目录如下 服务器地址：localhost:8080 Web项目名称：Demo 加了/ 12&lt;a href=&quot;/a&quot;&gt;超链接1&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;/$&#123;pageContext.request.contextPath&#125;&quot;&gt;超链接2&lt;/a&gt;&lt;br&gt; 前面加了/，对应的访问路径如下 1234&#x2F;&#x2F;超链接1，href&#x3D;&quot;&#x2F;a&quot;localhost:8080&#x2F;a&#x2F;&#x2F;超链接2，href&#x3D;&quot;&#x2F;$&#123;pageContext.request.pageContext&#125;&quot;Demo&#x2F; 未加/ 12&lt;a href=&quot;a&quot;&gt;超链接3&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;$&#123;pageContext.request.contextPath&#125;&quot;&gt;超链接4&lt;/a&gt;&lt;br&gt; 超链接href中是未加/ 的结果如下 1234&#x2F;&#x2F;超链接3，href&#x3D;&quot;a&quot;，目标地址如下：localhost:8080&#x2F;Demo&#x2F;a&#x2F;&#x2F;超链接4，href&#x3D;&quot;$&#123;pageContext.request.pageContext&#125;&quot;，目标地址如下：localhost:8080&#x2F;Demo&#x2F; 表单 Deom项目下有form 1234&lt;form action=&quot;/form&quot; method = &quot;get&quot;&gt; &lt;input value=&quot;提交1&quot; type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;br&gt;&lt;!--localhost:8080/form?--&gt; 1234&lt;form action=&quot;/$&#123;pageContext.request.contextPath&#125;/form&quot; method = &quot;get&quot;&gt; &lt;input value=&quot;提交2&quot; type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;br&gt;&lt;!--Demo/form?--&gt; 1234&lt;form action=&quot;form&quot; method = &quot;post&quot;&gt; &lt;input value=&quot;提交3&quot; type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;br&gt;&lt;!--localhost:8080/Demo/form--&gt; 1234&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/form&quot; method = &quot;post&quot;&gt; &lt;input value=&quot;提交4&quot; type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;br&gt;&lt;!--localhost:8080/Demo/form--&gt; 重定向 重定向是客户端行为 ，流程是 客户端发送HTTP请求给服务器 服务器接收请求后发送302状态码和新的请求地址给客户端 客户端接收到302状态码后，会自动发送新的http请求到新的请求地址 所以重定向一共有两次请求，地址栏会发生变化，因为是新的请求所以request不能传递 一般来说，重定向是交给浏览处理的，在 JavaWeb 中，交给浏览器处理的 / 表示的是 http://主机|IP:端口 ，例如：http://localhost:8080 或者 http://127.0.0.1:8080 1response.sendRedirect(&quot;/error.jsp&quot;); //跳转到失败界面 也就是说，上面跳转到http://localhost:8080/shop/error.jsp 但推荐以下写法，会自动获取项目名称 1response.sendRedirect(pageContext.request.contextPath + &quot;/error.jsp&quot;); 请求转发 请求转发是服务器行为，流程是 客户端发送http请求给服务器 服务器接收请求后在内部自己转发到新的地址 服务器返回响应给客户端 所以请求转发只有一次转发，地址栏不会变，一直都是第一次的地址，request可以传递 一般来说，请求转发是交给Servlet容器处理的，在 JavaWeb 中，交给Servlet容器处理的 / 表示的是 http://主机|IP:端口/站点名 ，例如：http://localhost:8080/Demo 或者 http://127.0.0.1:8080/Demo 1request.getRequestDispatcher(&quot;/main.jsp&quot;).forward(request, response); //请求转发到主界面 上面代码就是跳转到了 http://localhost:8080/Demo/main.jsp 或者 http://127.0.0.1:8080/Demo/main.jsp 这个界面 路径问题 重定向因为是从客户端发来的，所以只知道发到那个服务器，不知道发给那个项目，所以重定向的”/“表示http:服务器ip:8080/ 请求转发因为服务器内部自己转发，因此知道发给那个项目，所以请求转发的”/“表示http:服务器ip:8080/项目名/ 重定向没有”/“表示在当前目录，请求转发没有”/“表示相对于当前资源的相对路径 在jsp中加入下面这段代码，表示当前的基础路径为”http:服务器ip:8080/项目名/“，对后面的路径提交很方便友好 12345&lt;% String path = request.getContextPath(); String basePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path+&quot;/&quot;;%&gt;&lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt; JSP获取根目录的两种写法 1$&#123;pageContext.request.contextPath&#125; 1&lt;%=request.getContextPath()%&gt; 相对路径和绝对路径详细总结请参考：https://blog.csdn.net/StackFlow/article/details/78882860","path":"page/JavaWeb15.html","date":"01-15","excerpt":"","tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://xiaoliblog.cn/tags/JavaWeb/"}]},{"title":"JavaWeb🌍MVC三层架构","text":"JSP开发模型 JSP技术在Web应用程序的开发过程中运用十分广泛，为了更方便地使用JSP技术，Sun公司提供了JSP开发模型。接下来讲解JSP模型的发展历史。 JSP Model 2架构模型采用JSP+Servlet+ JavaBean的技术，此技术将原本JSP页面中的流程控制代码提取出来，封装到Servlet中，从而实现了整个程序页面显示、流程控制和业务逻辑的分离。 Servlet充当了控制器的角色，它首先接收浏览器发送的请求，然后根据请求信息实例化JavaBean对象用来封装操作数据库后返回的数据，最后选择相应的JSP页面将响应结果显示在浏览器中。 MVC三层架构三层架构 三层架构是指：视图层 View、服务层 Service，与持久层 Dao。它们分别完成不同的功能 View 层：用于接收用户提交请求的代码在这里编写 Service 层：系统的业务逻辑主要在这里完成 Dao 层：直接操作数据库的代码在这里编写 为了更好的降低各层间的耦合度，在三层架构程序设计中，采用面向抽象编程 即上层对下层的调用，是通过接口实现的 而下层对上层的真正服务提供者，是下层接口的实现类 服务标准（接口）是相同的，服务提供者（实现类）可以更换 这就实现了层间解耦合 MVC设计模式 MVC设计模式，即Model 模型、View 视图，及 Controller 控制器。 View：视图，为用户提供使用界面，与用户直接进行交互。 Model：模型，承载数据，并对用户提交请求进行计算的模块。其分为两类： 一类称为数据承载 Bean：实体类，专门用户承载业务数据的，如 Student、User 等 一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理用户提交请求的。 Controller：控制器，用于将用户请求转发给相应的 Model 进行处理，并根据 Model 的计算结果向用户提供相应响应 MVC 架构程序的工作流程： 用户通过 View 页面向服务端提出请求，可以是表单请求、超链接请求、AJAX 请求等 服务端 Controller 控制器接收到请求后对请求进行解析，找到相应的 Model 对用户请求进行处理 Model 处理后，将处理结果再交给 Controller Controller 在接到处理结果后，根据处理结果找到要作为向客户端发回的响应 View 页面。页面经渲染（数据填充）后，再发送给客户端 MVC与三层架构的关系 Model 业务处理，业务逻辑（Service） 数据持久层CRUD（Dao） View 展示数据 提供链接发起Servlet请求（a,from,img…) Controller（Servlet） 接收用户的请求（req：请求参数、Session信息…) 交给业务层处理对应的代码 控制视图的跳转","path":"page/JavaWeb14.html","date":"01-15","excerpt":"","tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://xiaoliblog.cn/tags/JavaWeb/"}]},{"title":"操作系统⚡I/O管理","text":"I/O管理 I/O设备分类 按使用特性分类 人机交互类外设鼠标、键盘、打印机等等，传输速度慢 存储类移动硬盘、光盘等，传输速度块 物理通信设备调制解调器等，速度一般 按传输速度分类 低速设备鼠标、键盘等，每秒几百字节 中速设备激光打印机等，每秒数千到上万字节 高速设备磁盘等，每秒数千至千兆字节 按信息交换的单位 块设备如磁盘等，传输数据块，可寻址（随机读写） 字符设备鼠标键盘，传输字符，不可寻址，输入输出采用中断驱动方式 I/O控制器 机械部件执行具体的I/O操作，比如鼠标键盘的按钮，显示器的屏幕，移动硬盘的磁臂 电子部件 CPU和机械部件的中介，通常是插入主板的电路板 又叫I/O控制器，设备控制器 接受和识别CPU的命令控制寄存器保存命令和参数 向CPU报告设备状态状态寄存器记录设备状态，如：1表示空闲，0表示忙碌 数据交换数据寄存器用于双方数据交换的缓冲区 地址识别通过CPU提供的地址判断读写哪个寄存器 组成 内存映像I/O 和 寄存器独立编址统一编址/独立编址 I/O控制方式 程序直接控制 中断驱动方式 直接存储器存取(DMA)方式 通道控制方式 对比 I/O软件层次结构 用户层软件提供易用的库函数 设备独立性软件提供调用接口(read/write系统调用)设备保护差错处理设备分配与回收数据缓冲区管理建立逻辑设备名到物理设备名的映射关系根据设备类型调用相应的驱动程序 设备驱动程序设置设备的寄存器检测设备状态 中断处理程序 I/O核心子系统由设备独立性软件、设备驱动程序、中断处理程序组成，属于操作系统内核部分，即I/O系统 假脱机技术(SPOOLing)在用户层软件实现，但是408大纲将其归入I/O核心子系统 脱机技术脱机技术指的是脱离主机的控制进行输入输出操作很久以前是纸带输入，速度太慢，于是通过外围控制机将纸带数据输入到磁带，再输入主机，输出同理缓解CPU与慢速I/O设备的速度矛盾 假脱机技术实现原理 共享打印机原理分析 设备分配与回收 设备分配应该考虑的因素 设备的固有属性独占设备、共享设备、虚拟设备(SPOOLing技术将独占设备改造成虚拟的共享设备) 设备分配算法先来先服务、优先级高者优先、短任务优先等等 设备分配的安全性安全分配方式：串行使用设备，为进程分配一个设备后将进程阻塞，I/O完成再唤醒。不会产生死锁不安全分配方式：进程请求I/O，操作系统负责分配设备，进程可以继续执行或者请求新的I/O，直到某个I/O无法满足才阻塞进程。可能产生死锁 静态分配和动态分配 进程运行前分配全部资源/运行时动态分配，见死锁那章 数据结构 一个通道控制多个设备控制器，一个设备控制器控制多个设备 分配过程 分配过程改进 缓冲区管理 缓冲区的作用 缓冲区可以使用专门的硬件寄存器实现，成本高容量小，更多时候使用内存做缓冲区 缓和CPU与I/O的速度矛盾 减少对CPU的中断频率，放宽对CPU中断的时间限制（中断驱动的字符型设备） 解决数据粒度不匹配的问题（字符型/块型） 提高CPU与I/O的并行性 单缓冲 双缓冲 循环缓冲 缓冲池","path":"page/os01.html","date":"01-15","excerpt":"","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://xiaoliblog.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统⚡文件管理","text":"文件管理 文件的属性 文件名主要是给用户看，同一个目录下不允许重名文件 标识符一个系统内各文件标识符唯一，对用户毫无可读性，给操作系统看的 类型文件扩展名 位置文件存放路径，给用户看的，在外存中的地址用户是看不到的 大小 创建时间 上次修改/访问时间 所有者信息 保护信息 文件的逻辑结构 什么是逻辑结构 逻辑结构：在用户看来，文件内部的数据是如何组织起来物理结构：操作系统看来，文件的数据如何存放在外存中 无结构文件又叫流式文件，比如txt，由一些二进制或者字符流组成 有结构文件 又叫记录式文件，比如数据库表，由一组相似的记录组成 记录是一组相关数据线的集合，每条记录有一个数据项可作为关键字 根据记录的长度是否相等，分为：定长记录，可变长记录 顺序文件 链式存储逻辑上相邻的记录，在物理上离散存储。无论是定长/可变长记录，都无法实现随机存取，只能从链头开始遍历 顺序存储逻辑上相邻的记录，在物理上也相邻。没有说明的情况下，顺序文件指采用顺序存储的顺序文件 可变长记录无法实现随机存取 定长记录可以实现随机存储。如果采用串结构(记录顺序与关键字无关)，无法快速找到某个关键字对应的记录，如果采用顺序结构(记录按关键字排序的)，可以使用折半查找快速找到记录 索引文件 索引表本身是定长记录的顺序文件，索引表项包含索引号，长度，指针，真正的记录可以在物理上离散存储。 索引号可以是关键字，这样就能折半查找加快检索速度，用于对信息处理及时性要求高的场合，解决了顺序文件增删不便的问题 可以用不同的数据项建立多个索引表 索引顺序文件 将记录分组，每一个组对应一个索引表项 检索记录时先检索索引表，找到分组，再顺序查找分组 记录过多时，可以建立多级索引表 记录N的表，平均查找次数是N/2 文件目录 文件控制块(FCB)一个FCB 对应一个文件，一个FCB就是一个目录项，FCB的有序集合叫“文件目录”FCB包含了文件的基本信息，存取控制信息，使用信息等等，最重要的是文件名、文件存放的物理地址对目录的操作:搜索、创建文件、删除文件、显示文件、修改文件 单级目录结构 两级目录结构 多级(树形)目录结构共享不方便 无环图目录结构 索引节点(FCB改进） 文件的物理结构 文件块、物理块 连续分配 优点：支持随机访问；顺序访问时速度最快（移动磁头所需的时间短） 缺点：不方便文件扩展，每次扩展都得迁移到一段连续的空间，代价大；存储空间利用率低，产生磁盘碎片 链接分配 隐式链接方便拓展，磁盘利用率高不支持随机访问，查找效率低 显式链接逻辑块号转物理块号不需要访问磁盘，因此支持随机访问；扩展方便且不会有磁盘碎片缺点是FAT要占用一定的存储空间 索引分配每一个文件建立一张索引表，其中记录文件的逻辑块对应的物理块。存放索引表的磁盘块叫索引块，存放文件数据的磁盘块叫数据块。 链接方案 多层索引 混合索引 对比 对比 文件存储空间管理 存储空间划分与初始化 管理方法 空闲表法 空闲链表法 空闲盘块链 空闲盘区链 位示图法 成组链接法适用于大型文件系统，文件卷的目录区中，专门用一个磁盘块作为超级块，系统启动时读入内存，并且保持内外存超级块数据同步比较复杂，看视频：https://www.bilibili.com/video/BV1YE411D7nH?p=52 文件的基本操作 创建文件(creat) 在外存中找到文件所需的空间 根据文件路径找到对应目录，创建文件对应的目录项​ 删除文件(delete) 根据路径找到目录文件，找到文件名对应的目录项 回收文件占用的磁盘块 .删除目录项​​ 打开文件(open) 根据路径找到目录文件，找到文件名对应的目录项，检测用户权限 将目录项复制到该进程在内存中的打开文件表中，返回表目编号​(索引号/文件描述符) 关闭文件(close) 删除进程的打开文件表中对应项 回收分配给该文件的内存空间等资源 系统打开文件表的打开计数器count-=1(归零时删除该项)​​ 读文件(read) 需提供进程打开文件表中的索引号，读入的数据量，数据在内存中存放的位置 从读指针​指向的外存位置读取指定大小的数据到指定的内存区域 写文件(write) 需要提供打开文件表中的索引号，写出的数据量，写回外存的数据位置(写指针指向) 文件共享 基于索引结点的共享(硬链接) 基于符号链的共享(软链接) 文件保护 口令保护 FCB中保存口令，访问时与用户提供的口令对比 开销小，但是不够安全 加密保护 用密码对文件数据流加密，访问时用密码解密，比如异或加密 保密性强，不需要存储密码，但是加密/解密要花费一定的时间 访问控制 每一个文件FCB中增加一个访问控制表(ACL)，控制各用户的访问权限 精简的访问列表，以组为单位，标记其访问权限，比如Linux里面分：所有者，所属组，其他人 文件系统的层次结构 磁盘管理磁盘的结构 磁盘/磁道/扇区 如何在磁盘中读写数据 盘面/柱面/物理地址 磁盘分类 磁盘调度算法 读写时间 调度算法 先来先服务(FCFS)根据进程请求访问磁盘的先后顺序调度公平；如果大量进程访问的磁道很分散，虚拟会很差​ 最短寻道时间优先(SSTF)优先处理当前磁头最近的磁道，保证寻道时间最短（眼前最优，未必整体最优）性能较好，但是可能产生饥饿现象 扫描算法(SCAN)又叫电梯算法，在SSTF算法的基础上，规定磁头只有移动到磁道尽头（最外侧或者最内侧）才能往回移动性能较好，不会饥饿；但是只能扫描到最边上的磁道才能改变磁头方向，越外侧的的磁道，响应频率越高 LOOK调度算法改进SCAN算法，磁头边移动边观察(LOOK)，如果移动方向没有请求了，就不必继续扫描，直接调头 循环扫描算法(C-SCAN)只有磁头朝着某个方向移动（比如磁道号增大方向）时才处理访问请求，移动到最边上后直接返回到另一边（0号磁道），返回途中不处理请求 相比SACN算法各个位置的磁道响应频率很平均​ C-LOOK算法改进C-SCAN算法，磁头移动方向上如果没有请求了，就直接返回到最靠近边缘的请求磁道即可 减少磁盘延时 交替编号一个盘面上，让逻辑相邻的扇区在物理上有一定间隔，使读取连续逻辑扇区所需的延迟时间更小​（如果没有间隔，读入N号扇区时数据时需要一些时间处理，导致错过N+1号扇区，磁盘需要再转一圈才能读到N+1） 磁盘物理地址设计 错位命名 磁盘管理 磁盘初始化 引导快 坏块管理","path":"page/os05.html","date":"01-15","excerpt":"","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://xiaoliblog.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统⚡内存管理","text":"内存管理 内存基础 什么是内存 内存是用于存放数据的硬件，程序执行前需要先放到内存中才能被CPU处理 储存单元按字节编址：一个存储单元1字节，8个二进制位，1字节对应一个地址按字长编址：一个存储单元1个字长，字长16位的计算机一个存储单元16个二进制位2^10=1K 2^20=1M 2^30=1G4G内存的地址长度: 4*2^30=2^32 ，所以需要32个二进制位(32位操作系统最大支持4GB内存，指针大小4字节) 内存地址内存从0开始，每一个地址对应一个存储单元 进程运行的基本原理 指令的工作原理CPU按照程序段的指令去内存某个位置存取数据，一条 指令由操作码+若干参数组成编译生成的指令中一般使用逻辑地址 逻辑地址/物理地址逻辑地址（相对地址）物理地址（绝对地址） 从写程序到程序运行 编辑源文件 编译源代码文件(.c)生成目标模块(.o)，将高级语言翻译为机器语言每一个目标模块都具有独立的逻辑地址 0-xxx 链接目标模块生成装入模块(可执行文件,如.exe)，链接完成使得各模块形成整体的链接地址 装入(载)将装入模块装入内存运行，装入后形成物理地址 三种链接方式 静态链接装入前链接成一个完整模块 装入时动态链接运行前边装入边链接 运行时动态链接运行时需要什么模块才装入并链接 三种装入方式 绝对装入编译时产生绝对地址，只适用于单道程序环境(那时候还没有操作系统，编译器负责实现) 可重定位装入(静态重定位)编译链接后的装入模块地址是逻辑地址，装入时进行重定位，将指令中逻辑地址+装入的起始物理地址得到真实的物理地址一个作业装入内存时，必需分配其要求的全部内存空间，内存不够就不能装入作业一旦进入内存，运行期间就不能再移动，也不能再申请内存空间，因为地址都写死了早期多道批处理操作系统使用 动态运行时装入(动态重定位)运行时才将逻辑地址转换为物理地址，需要设置**重定位寄存器(或者叫基址寄存器)**允许程序在内存中发生移动，而且程序可以分配到不连续的储存区，也支持动态申请内存只需装入部分代码即可投入运行，可以向用户提供一个比存储空间大得多的地址空间现代操作系统使用 内存空间分配与回收连续分配管理方式为用户进程分配的内存必须是一个连续的内存空间 单一连续分配 固定分区分配 动态分区分配 回收内存时，回收区前后的空闲分区应该合并 动态分区分配算法 首次适应(First Fit)空闲分区按地址递增顺序排列，每次分配内存时查找空闲分区链(表)，找到第一个满足要求的分区即可每次从低地址部分查找，高地址的大分区更有可能被保存下来效果最佳 最佳适应(Best Fit)空闲分区按容量递增顺序链接，每次分配内存时按顺序查找内存分区链(表)，找到第一个可以满足的空闲分区优先使用最小连续内存区，尽可能多的留下大块空闲区，满足大进程需求，但是会留下非常多难以利用的外部碎片 最坏适应(Worst Fit)有叫最大适应算法(Largest Fit)空闲分区按容量递减顺序排序，每次分配找到能满足要求的第一个空闲分区优先使用最大的连续空闲区，使得分配后的剩余空闲区不会太少，方便使用，但是如果后面需要大内存区间就没办法了 邻近适应(Next Fit)又叫循环首次适应算法空闲分区按地址递增顺序构成循环链表，每次内存分配时从刚才查找结束位置开始，找到第一个能满足要求的空闲分区无论是低地址还是高地址的空闲分区，都有相同的概率被使用，导致最后无大分区可用​ 对比 非连续分配管理方式为用户进程分配的内存可以是一个分散的内存空间 基本分页存储管理分页管理 基本分页存储管理的思想：把内存分成一个个相等的小分区，在按分区大小把进程拆分成一个个小部分 (x) 基本地址变换机构 页表寄存器(PTR) 保存页表在内存中的起始地址F和页表长度M 进程未执行的时候，F和M放在PCB中，进程被调度时，操作系统内核将其放到PTR中 地址转换过程 对页表项目的探讨 快表地址变换机构 局部性原理 时间局部性:如果执行了程序中的某条指令,那么不久后这条指令很有可能再次执行;如果某个数据被访问过,不久之后该数据很可能再次被访问。(因为程序中存在大量的循环) 空间局部性:一旦程序访问了某个存储单元,在不久之后,其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的） 什么是快表(TLB) 又称联想寄存器(TLB) ,是一种访问速度比内存快很多的高速缓冲存储器,用来存放当前访问的若干页表项,以加速地址变换的过程。与此对应,内存中的页表常称为慢表。 地址变换过程 两级页表 单级页表的问题Q1：所有的页表项都要连续存放，页表很大时，需要占用很多很多个连续的页框。比如32位逻辑地址分页储存，页面大小4K，则页表最多2^20项，一项占4B，一共需要1024个连续的页框才能放得下Q2：没有必要让整个页表常驻内存，进程在一段时间可能只访问某几个特定的页面 两级页表原理 如何实现地址变换 注意事项 基本分段存储管理 什么是段表 如何实现地址变换 分段VS分页- 段页式存储管理 分段分页的优缺点 段页式管理 段表、页表 如何实现地址变换 内存空间的扩充覆盖技术 交换(对换)技术内存紧张时，把进程暂时换出到外存（例：进程的中级调度(内存调度)，挂起态，七状态模型）磁盘分为对换区(swap)和文件区，前者连续分配追求I/O速度，后者离散分配追求存储空间利用率优先换出阻塞进程、低优先级进程（可能导致饥饿）、还要考虑进程在内存的驻留时间，PCB不会换出 虚拟储存技术 传统存储方式的缺点 连续分配/非连续分配 一次性作业必须一次性全部装入内存后才能开始运行。大作业无法运行,多道程序并发度下降。 驻留性作业在运行期间一直驻留在内存，内存中驻留大量的暂时用不到的数据，浪费了宝贵的内存资源。 局部性原理 时间局部性现在访问的指令、数据在不久后很可能再次访问 空间局部性现在访问的内存单元周围的内存空间很可能在不久之后访问 高速缓存频繁访问的数据放到更高速的储存器中 虚拟内存的定义和特征 程序不需要全部装入内存即可运行，运行时根据需要动态调入数据，内存不够时，换出一些数据到外存 多次性作业无需在运行时一次装入内存，而是允许分多次调用 对换性作业无需在运行时常驻内存，允许作业换入、换出 虚拟性从逻辑上扩充了内存容量，用户看到的容量，远大于实际容量 虚拟内存的最大容量是由计算机的地址结构（CPU寻址范围）确定的虚拟内存的实际容量=min（内存和外存容量之和，CPU寻找范围） 如何实现虚拟内存请求调页访问的信息不存在时，操作系统负责将需要的信息从外存调入内存 页面置换内存空间不足时，将内存中暂时不用的信息换到外存页面的换入换出需要磁盘I/O，时间开销是很大的，缺页率越小越好 最佳置换算法OPT 先进先出置换算法FIFO 最近最久未使用算法LRU 时钟置换算法CLOCK 改进型时钟置换算法 对比 虚拟内存的实现请求分页存储管理 页表机制 缺页中断机构 访问的页面不存在时，产生缺页中断(属于内中断的故障 fault)，操作系统缺页中断处理程序中断，进程放到阻塞队列，待调页完成后将进程唤醒，放到就绪队列 如果内存有空闲块，则为进程分配一个空闲块，将缺页装入其中，并修改页表相应页表项 如果内存没有空闲块，由页面置换算法选择一个页面淘汰(若该页面在内存期间被修改过，则需要先将其写回外存)，腾出一个空间再装入缺页​​ 一条指令执行期间，可能产生多次缺页中断 地址变换机构 请求分段存储管理请求段页式存储管理内存保护进程1只能访问进程1的内存，不能越界访问其它进程或者操作系统的内存区方法一：在CPU中设置上限/下限寄存器，保存进程可访问的物理地址的上下限方法二：重定位寄存器(基址寄存器)+界地址寄存器(限长寄存器)重定位寄存器中保存了进程的起始物理地址P1，界地址寄存器保存了进程的最大逻辑地址P2, 进程可以访问的物理内存位置是P1~P1+P2 页面分配策略 相关概念 固定分配局部置换) 系统为每个进程分配一定数量的物理块,在整个运行期间都不改变。 若进程在运行中发生缺页,则只能从该进程在内存中的页面中选出一页换出,然后再调入需要的页面。 缺点:很难在刚开始就确定应为每个进程分配多少个物理块才算合理。(采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数) 可变分配全局置换 刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。 当某进程发生缺页时,从空闲物理块中取出一块分配给该进程;若已无空闲物理块,则可选择一个未锁定的页面换出外存,再将该物理块分配给缺页的进程。 只要某进程缺页,都将获得新的物理块,仅当空闲物理块用完时,系统才选择一个未锁定的页面调出。 被选择调出的页可能是系统中任何一个进程中的页,因此这个被选中的进程拥有的物理块会减少,缺页率会增加。 可变分配局部置换 刚开始会为每个进程分配一定数量的物理块。当某进程发生缺页时,只允许从该进程自己的物理块中选出一个进行换出外存。 如果进程在运行中频繁地缺页,系统会为该进程多分配几个物理块,直至该进程缺页率趋势适当程度; 反之,如果进程在运行中缺页率特别低,则可适当减少分配给该进程的物理块。 调入页面的时机 预调页策略 运行前调入，根据空间局部性原理,一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过,则又是低效的。 因此可以预测不久之后可能访问到的页面,将它们预先调入内存,但目前预测成功率只有50%左右。故这种策略主要用于进程的首次调入,由程序员指定应该调入的部分。 请求调页策略运行时调入，进程在运行期间发现缺页时才将所缺页面调入内存。由这种策略调入的页面一定会被访问到,但由于每次只能调入一页,而每次调页都要磁盘I/O操作,因此I/O开销较大。 从何处调页 对换区空间足够 对换区空间不够 Unix方式 抖动(颠簸)现象给进程分配的物理块太少，刚刚换出的页面马上又要换入内存,刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动或颠簸。 工作集","path":"page/os04.html","date":"01-15","excerpt":"","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://xiaoliblog.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统⚡进程管理","text":"进程管理 进程的定义 进程的定义：程序段、数据段、PCB三部分组成了进程实体(进程映像) 一般情况下,我们把进程实体就简称为进程,例如,所谓创建进程,实质上是创建进程实体中的PCB;而撤销进程,实质上是撤销进程实体中的PCB 注意: PCB是进程存在的唯一标志! 从不同的角度,进程可以有不同的定义,比较传统典型的定义有: 进程是程序的一次执行过程。 进程是一个程序及其数据在处理机上顺序执行时所发生的活动。 进程是具有独立功能的程序在数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位（强调“动态性”） 引入进程实体的概念后，可把进程定义为:进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。 注：严格来说，进程实体和进程并不一样,进程实体是静态的，进程则是动态的。不过,除非题目专门考察二者区别，否则可以认为进程实体就是进程。因此我们也可以说“进程由程序段、数据段、PCB三部分组成 进程的组成 程序段存放程序代码本身 数据段存放程序运行过程中处理的各种数据（如全局变量、局部变量、宏定义的常量等） PCB 进程管理所需的数据都放在这里，PCB是进程存在的唯一标志，操作系统通过PCB来管理进程 进程的组织系统里面通常有数千个PCB，为了更有效地管理，需要用适当的方式把他们组织起来 链接方式按照进程状态将PCB分为多个队列操作系统持有指向各个队列的指针 索引方式根据进程状态不同，建立几张索引表操作系统持有指向各索引表的指针 进程的特征进程和程序是两个截然不同的概念，相比于程序，进程拥有以下特征： 动态性最基本特征。进程是程序的一次执行过程，是动态地产生、变化和消亡的 并发性内存中有多个进程实体，各进程可以并行执行 独立性进程是能独立运行、获得资源、接受调度的基本单位 异步性各进程按各自独立的、不可预测的速度向前推进，异步性会导致并发程序执行结果的不确定性，操作系统要提供“进程同步机制”来解决异步问题 结构性每一个进程都会配置PCB，结构上看，进程由程序段、数据段、PCB组成 进程的状态基本状态：运行态、就绪态、阻塞态/等待态 运行态(Running)占有CPU，并在CPU上运行单核处理器一个时刻只有一个进程处于运行态，双核两个 就绪态(Ready)进程已经具备一切运行条件，除了没有空闲CPU，导致暂时不能运行万事俱备，只差CPU 阻塞态(Waiting/Blocked)等待某一事件而暂时不能运行，比如等待操作系统分配打印机、等待磁盘读写为了提高CPU利用效率，进程需要先准备好其它所需资源，才能得到CPU的服务 创建状态(New)操作系统为该进程分配所需内存等系统资源，为其创建、初始化PCB(分配PID等等) 终止状态(Terminated)进程运行结束，或者出现Bug导致无法继续执行，操作系统需要撤销进程完成资源回收，撤销PCB 进程间转换 进程控制 什么是进程控制？进程控制的主要功能是对系统中的所有进程实施有效的管理,它具有创建新进程、撤销已有进程、实现进程状态转换等功能。简而言之就是实现进程状态切换。 某一个进程，把它的PCB从一个队列放到另一个队列，但是并没有把PCB当中的状态标志改成相应的新的状态，为防止这个问题，引入了原语操作。 如何实现进程控制？当关中断指令接收到外部中断信号时，会被忽略掉，暂时不会处理，这就保证了原语执行不被中断。直到执行到开中断指令，接收到外部中断信号才会开始处理。 进程控制相关原语进程控制会导致进程状态的转换。无论哪个原语,要做的无非三类事情: 更新PCB中的信息(如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境)a. 所有的进程控制原语一定都会修改进程状态标志b. 剥夺当前运行进程的CPU使用权必然需要保存其运行环境c. 某进程开始运行前必然要恢复期运行环境 将PCB插入合适的队列 分配/回收资源 进程通信 进程通信就是进程之间的信息交换。 进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有各自的内存地址空间，它们相互独立。 为了保证安全，一个进程不能直接访问另一个进程的地址空间 但是进程之间的信息交换又是必须实现的，为了保证进程间的安全通信，操作系统提供了一些方法实现。 共享存储 管道通信 消息传递 线程线程的引入在没引入进程之前，系统中各个程序只能串行执行 资源分配、调度传统进程机制中，进程是资源分配、调度的基本单位引入线程后，进程是资源分配的基本单位，线程是调度的基本单位 并发性传统进程机制，只能进程间并发现在各线程之间也能并发 系统开销传统进程并发，需要切换进程的运行环境，系统开销大同一个进程内的线程间并发，不需要切换环境，开销小 线程的属性 线程是处理机调度的单位 多CPU计算机中，各个线程可占用不同的CPU 每个线程都有一个线程ID、线程控制块（TCP） 线程也有就绪、阻塞、运行三种基本状态 线程几乎不拥有系统资源，资源分配给进程 同一进程的不同线程间共享进程的资源 由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预 同一进程中的线程切换，不会引起进程切换 不同进程中的线程切换，会引起进程切换 切换进程内的线程，系统开销很小 切换进程，系统开销较大 线程的实现方式 用户级线程 内核级线程 组合方式 多线程模型 多对一模型 一对一模型 多对多模型 处理机调度 基本概念 调度的三个层次 高级调度（作业调度） 中级调度（内存调度） 低级调度（进程调度） 区别 补充：七状态模型 调度的时机和方式 什么适合需要进程调度？ 进程自动放弃处理机 进程正常终止 运行过程中发生异常终止 进程主动请求阻塞（等待I/O） 进程被动放弃处理机 时间片用完 更紧急的事情需要处理（I/O中断） 更高优先级的进程进入就绪队列 不能进行进程调度与切换的情况 在处理中断的过程中（中断处理过程很复杂，很难做到同时完成进程切换） 在原子操作的过程中（原语）。原子操作不可中断，要一气呵成 进程在操作系统内核程序临界区中。 临界资源是指：进程需要互斥访问的资源，临界区：访问临界资源的代码 内核程序临界区：访问内核数据结构的代码，比如进程的就绪队列（就绪进程PCB组成）。 进程访问就绪队列时会加锁，还没退出临界区（临界资源没解锁）的期间，是无法进行调度和切换的。内核临界区访问临界资源应该尽快完成，否则会影响内核其它管理功能。 普通临界区访问临界资源不会直接影响操作系统内核管理工作，这个时候可以调度和切换。比如打印机完成打印之前，进程不允许调度就会导致CPU一直空闲。 进程在操作系统内核程序临界区中不能进行调度与切换 （√）进程处于临界区时不能进行处理机调度 （×） 进程调度的方式 非剥夺(非抢占)式只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。实现简单，开销小，但是无法实时处理紧急任务，适合早期批处理系统。 剥夺(抢占)式如果有更重要更紧急的进程需要使用处理机，直接剥夺当前进程资源。适合分时操作系统、实时操作系统。 进程的切换与过程 “狭义的进程调度”与“进程切换”的区别狭义调度指：从就绪队列中选择一个要运行的进程，这个进程可能是刚刚暂停的，也可能是另一个进程，后一种情况就需要进程切换进程切换：一个进程让出处理机，由另一个进程占用处理机的过程广义进程调度：包含了选择一个进程和进程切换两个步骤 进程切换的过程保存原进程的数据恢复新进程的数据（数据包括：程序计数器，程序状态字，各种数据寄存器等现场信息） 进程切换是有代价的，过于频繁的调度、切换会导致效率低下，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少 调度算法的评价指标 CPU利用率：指CPU“忙碌”的时间占总时间的比例 CPU忙碌时间(+IO时间)/总时间 系统吞吐量：单位时间内完成作业的数量 总共完成的作业数/总时间 周转时间：是指从作业被提交给系统开始，到作业完成为止的这段时间间隔，作业被提交给系统开始到作业完成的时间，包括高级调度、低级调度的时间、进程在CPU执行的时间、等待I/O的时间 周转时间=作业完成时间-作业提交时间 平均周转时间=各作业周转时间之和/作业数 带权周转时间= 作业周转时间 / 作业实际运行时间 = （作业完成时间 - 作业提交时间）/ 作业实际运行时间周转时间相同的情况下，作业运行时间长的，用户体验更好（浪费的时间少，带权周转时间一定大于 1，越小越好 平均带权周转时间=各作业带权周总时间之和/作业数 等待时间：指进程/作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低 等待时间=进程/作业处于等待处理机状态时间之和 对于进程：等待时间是进程建立之后，等待被服务的时间之和（等待I/O的时间不计入） 对于作业：作业在外存后备队列等待被调度的时间 + 建立进程之后的等待时间 响应时间：用户提交请求到首次产生响应所用的时间 调度算法(早期系统)先来先服务FCFS 先来先服务（FCFS：First Come First Service） 公平角度考虑，作业/进程谁先到后备/就绪队列的谁先得到服务，非抢占式算法 优点：公平，算法简单 缺点：对长作业（进程）有利，对短作业不利（带权周转时间很大）比如下面例题中P3的带权周转时间为8 不会导致饥饿 作业优先SJF 短作业优先（SJF：Shortest Job First） 算法思想：追求最少的平均等待时间，最少平均周转时间，最少平均带权周转时间 算法规则：需要服务时间最短的作业。进程先得到服务 可以调度作业和进程（短进程优先算法SPF: Shortest Process First） SJF和SPF是非抢占式算法，抢占式版本：最短剩余时间优先算法(SRTN,Shortest Remaining Time Next) 优点：“最短的”平均等待时间、平均周转时间，最短剩余时间优先算法更短 缺点：不公平，短作业有利，长作业不利。 可能导致饥饿，如果有源源不断的短作业到来，长作业可能一直得不到服务（饿死） 最短剩余时间优先SRTN 最短剩余时间优先算法(SRTN,Shortest Remaining Time Next) 高响应比优先HRRN 高响应比优先（HRRN：Highest Response Ratio Next） 算法思想：综合考虑作业/进程的等待时间和服务时间 算法规则：每次调度时选择响应比最高的作业/进程。响应比=(等待时间+要求服务时间)/要求服务时间（响应比&gt;=1） 非抢占式，除非当前作业/进程主动放弃处理机，才需要调度 优点：综合考虑了等待时间和运行时间，等待时间相同时，要求服务时间短的优先(SJF的优点)，要求服务时间相同时，等待时间长的优先(FCFS的优点) 对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题 对比 调度算法（交互式系统）时间片轮转RR 时间片轮转（RR：Round-Robin) 常用于分时操作系统，注重响应时间，而非周转时间 算法思想：公平、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应 算法规则：按照各进程到达就绪队列的顺序,轮流让各个进程执行一个时间片(如100ms) 若进程未在一个时间片内执行完,则剥夺处理机,将进程重新放到就绪队列队尾重新排队。 用于进度调度（作业在放入内存并建立进程后才能被分配处理机时间片） 抢占式算法，由时钟中断通知CPU时间片已到，不会饥饿 缺点：高频率进程切换，有一定的开销，不区分任务的紧急程度 优点：公平；响应快，适用于分时操作系统 优先级调度算法 优先级调度算法 调度时选择优先级高的进程，可以作业调度和进程调度以及I/O调度 适用于实时操作系统，可能发生饥饿 多级反馈队列调度算法 对其他算法权衡折中，抢占式，可能导致饥饿 算法规则 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大 新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾 只有第k级队列为空时，才会为k+1级队头的进程分配时间片 动画演示 总结 进程同步与互斥 进程同步 进程具有异步性，各并发执行的进程以各自独立、不可预测的速度向前推进。 有时需要保证不同的进程按照特地的次序推进，比如管道读、写数据两个操作必需按照“写数据-&gt;读数据”的顺序执行，所以引入进程同步的问题 进程同步又叫进程的“直接制约关系”，它是指为了完成某种任务而建立两个或多个进程 这些进程因为需要在某些位置上协调工作次序而产生制约关系。 进程互斥 临界资源：一个时间段内只允许一个进程使用的资源（比如一些物理设备，变量数据，内存缓冲区） 对临界资源的访问必需互斥地进行，互斥又叫“间接制约关系” 进程互斥指一个进程访问某些临界资源时，另一个想要访问该临界资源的进程必需等待，直到资源被释放。 对临界资源的互斥访问，可以在逻辑上分为如下四个部分 do&#123; entry section; //进入区 &#123;上锁&#125; critical section; //临界区 &#123; 访问临界资源的那段代码&#125; exit section; //退出区 &#123;解锁&#125; remainder section; //剩余区 &#123;做其他处理&#125; &#125; 为了实现对临界资源的互斥访问，需要遵循以下原则 空间让进临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区 忙则等待当已有进程进入临界区时，其他试图进入临界区的进程必须等待 有限等待对请求访问的进程，应保证能在有限时间内进入临界区(保证不会饥饿) 让权等待当进程不能进入临界区时，应立即释放处理机，防止进程忙等待 进程互斥软件实现 单标志法算法思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予 双标志先检查法 双标志后检查法 Peterson算法Perterson算法用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则，但是依然未遵循让权等待的原则 进程互斥硬件实现 中断屏蔽方法 TestAndSet指令 Swap指令 信号量机制针对以上两种实现方法无法实现的问题，1965年，荷兰学者Dijkstra提出了一种卓有成效的实现进程互斥、同步的方法——信号量机制 用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作,从而很方便的实现了进程互斥、进程同步。 信号量其实就是一个变量(可以是 个整数,也可以是更复杂的记录型变量),可以用一个信号量来表示系统中某种资源的数量,比如:系统中只有一台打印机,就可以设置一个初值为1的信号量 原语是一种特殊的程序段,其执行只能一气呵成,不可被中断。原语是由关中断/开中断指令实现的。 软件解决方案的主要问题是由“进入区的各种操作无法一气呵成” ,因此如果能把进入区、退出区的操作都用“原语”实现,使这些操作能“一气呵成”就能避免问题。 一对原语：wait(S)原语和signal(S)原语,可以理解为函数,函数名分别为wait和signal,括号里的信号量S就是参数。 wait, signal原语常简称为P,V操作(来自荷兰语proberen和verhogen) 。因此,做题的时候常把wait(S).signal(S)两个操作分别写为P(S)、V(S) 整型信号量 记录型信号量动画演示 信号量机制实现进程互斥 信号量机制实现进程同步 信号量机制实现前驱关系 总结 生产者消费者问题 问题分析 如何实现 能否改变相邻P、V操作的顺序？ 多生产者消费者问题 问题分析 如何实现 吸烟者问题 问题分析 如何实现 读写者问题 问题分析 如何实现 哲学家就餐问题 问题分析 如何解决 管程 为什么引入管程信号量机制编写程序困难，PV顺序错误可能导致死锁 管程的定义 管程是一种高级的同步机制，是一种特殊的软件模块，包括： 局部于管程的共享数据结构说明 对数据结构进行操作的一组过程（函数） 对共享数据初始化的语句 管程有一个名字（就是OOP里面的封装思想） 管程的基本特征 管程中的共享数据结构只能被管程内部的过程（函数）访问 一个进程只能通过调用管程内的过程（函数）才能访问管程内的数据 每次仅允许一个进程在管程内执行某个内部过程（这个特性是编译器实现的） 用管程解决生产者消费者问题 Java 死锁 什么是死锁并发环境下，各进程因为竞争资源造成的：互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象 死锁、饥饿、死循环 死锁产生的条件 对不可剥夺资源分配不合理可能导致死锁 互斥条件争抢互斥资源 不剥夺条件进程获得的资源未使用完成，其它进程不能强行夺走，只能等待主动释放 请求和保持条件进程已经保持了至少一个资源，但是又提出新的资源请求，同时该资源被其它进程占有，此时请求进程被阻塞，但是对自己拥有资源又保持不放 循环等待条件死锁时存在循环等待链，但是存在循环等待链不一定出现死锁（同类资源大于1，可能链条外的某个进程释放了资源） 死锁的处理策略 预防死锁破坏产生死锁的条件 避免死锁避免系统进入不安全状态（银行家算法） 检测和解除允许死锁发生，操作系统负责检测死锁并解除 死锁的处理不允许死锁发生 静态策略：预防死锁 破坏互斥条件将物理互斥的资源改造为逻辑共享设备，SPOOLing技术将打印机改造成共享设备 破坏不剥夺条件方案一：某个进程所需的资源得不到满足时，主动释放自己保持的资源，以后再重新申请方案二：操作系统协助，将资源剥夺给优先级高的资源实现复杂，可能造成获得资源前一阶段的工作白做，而且反复申请资源增加系统开销，可能导致进程饥饿 破坏请求和保持条件静态分配法：进程分配好需要的资源再投入运行，运行时不再申请实现简单，但是资源利用率极低，可能导致某些进程饥饿​ 破坏循环等待条件顺序资源分配法：首先给系统资源编号，每一个进程必需按照进程递增的顺序请求资源（大编号无法请求小编号资源，也就不能线程循环等待的情况）按编号申请资源，编程很麻烦不方便添加新设备，需要重新分配编号；进程实际使用资源的顺序可能和编号顺序不一致，导致需要提前申请不必要的资源导致浪费​ 动态策略：避免死锁 什么是安全序列系统按照这种序列分配资源，能让每个进程都顺利完成 什么是系统的不安全状态只要存在一个安全序列，系统就是安全状态找不到安全序列，系统就是不安全状态，意味着可能所有进程都无法顺利执行下去（如果有进程提前归还资源，那系统也有可能可以回到安全状态）不安全状态可能发生死锁（不一定发生），安全状态一定不会死锁 银行家算法 允许死锁发生 死锁检测 死锁解除","path":"page/os03.html","date":"01-15","excerpt":"","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://xiaoliblog.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统⚡概述","text":"参考👉👉👉思维导图来源||操作系统王道幕布笔记—ZaxTyson||操作系统王道学习视频 操作系统引论及概述 OS功能和目标操作系统(Operating System，OS)是计算机系统中最重要的系统软件，它管理整个计算机系统的软件资源和硬件资源，是用户与计算机硬件的桥梁，是其它软件和程序的运行基础。（1）作为系统资源的管理者 处理机管理计算机系统中最重要的资源是中央处理机（简称CPU），任何计算都必须在CPU上进行。在处理机管理中，最核心的问题是CPU时间的分配问题，这涉及分配的策略和方法。 存储器管理存储管理的主要工作是对内存储器进行合理分配、有效保护和扩充。内存是现代计算机系统的中心，是可以被CPU和I/O设备共同访问的数据仓库。内存通常是CPU直接寻址和访问的、唯一的大容量存储器。 设备管理设备管理是操作系统中最庞杂、琐碎的部分，其原因是：①设备管理涉及很多实际的物理设备，这些设备品种繁多、用法各异。②各种外部设备都能和主机并行工作，而且，有些设备可被多个进程所共享。③主机和外部设备，以及各类外部设备之间的速度极不匹配，极差很大。 文件管理以上三种管理都是针对计算机的硬件资源的管理。文件系统管理则是对软件资源的管理。为了管理庞大的系统软件资源及用户提供的程序和数据，操作系统将它们组织成文件的形式，操作系统对软件的管理实际上是对文件系统的管理。 作业管理作业指用户在一次计算过程中或者事务处理过程中，要求计算机所作工作的集合。作业由程序、数据和作业说明书组成。在批处理系统中，作业是占据内存的基本单位。作业管理是通过管理让这些作业按照自己所想要的方式来进行工作。 （2）作为用户和计算机硬件之间的接口 命令接口命令接口允许用户直接使用，命令接口又分联机命令接口和脱机命令接口。联机命令接口：用户说一句，系统做一句（交互式命令接口）。脱机命令接口：用户说一堆，系统做一堆（批处理命令接口）。 程序接口用户程序间接使用 GUI（图像用户界面） OS特征OS四大特征：并发、共享、虚拟、异步。 并发并发: 指两个或多个事件在同一时间间隔内发生。宏观上是同时发生的,但微观上是交替发生的。并行: 指两个或多个事件在同一时刻同时发生。并发和共享是操作系统的两个最基本特征。操作系统并发性指计算机系统中同时存在着多个运行着的程序。 例如：8-9点一号执行，9-10点二号执行，10-11点三号执行，为并发情况。而在8点一二号一起执行为并行情况。 共享资源共享指系统中的资源可供内存中多个并发执行的进程共同调用。互斥共享｜ 同一个时间段只允许一个进程访问资源(摄像头/麦克风)同时共享｜ 允许一个时间段多个进程“同时”(宏观上)访问某些资源（微观上是分时共享），比如硬盘读写并发和共享互为存在条件。 虚拟虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体(前者)是实际存在的,而逻辑上对应物(后者)是用户感受到的。 异步异步是指,在多道程序环境下,允许多个程序并发执行,但由于资源有限,进程的执行不是一贯到底的,是走走停停（等待资源进程阻塞）,以不可预知的速度向前推。 OS发展与分类 手工操作阶段纸带机（用户独占全机，人机速度矛盾，资源利用率极低）。 单道批处理系统引入了脱机输入/输出技术（磁带），通过监督程序（操作系统雏形）控制作业输入输出。外围机负责把输入纸带录入磁带。缓解了人机速度矛盾，提高了资源利用率，但是CPU是串行的，大量CPU时间浪费在I/O等待上。 多道批处理系统磁带往内存输入多道程序，并发执行，输入、计算、输出互不干扰操作系统诞生，引入了中断技术，资源利用率大幅上升，但是缺少人机交互功能，用户响应时间长（用户提交作业之后只能等待作业完成）。 分时操作系统分时操作系统：计算机以时间片为单位轮流为各个用户/作业服务,各个用户可通过终端与计算机进行交互。主要优点:用户请求可以被即时响应,解决了人机交互问题。允许多个用户同时使用一台计算机,并且用户对计算机的操作相互独立,感受不到别人的存在。主要缺点:不能优先处理一些紧急任务。操作系统对各个用户/作业都是完全公平的,循环地为每个用户/作业服务一个时间片,不区分任务的紧急性。 实时操作系统硬实时系统：必须在绝对严格的规定时间内完成处理。软实时系统：能接受偶尔违法时间规定。主要优点:能够优先响应一些紧急任务,某些紧急任务不需时间片排队。在实时操作系统的控制下,计算机系统接收到外部信号后及时进行处理,并且要在严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性。 网络操作系统网络操作系统:是伴随着计算机网络的发展而诞生的,能把网络中各个计算机有机地结合起来,实现数据传送等功能,实现网络中各种资源的共享(如文件共享)和各台计算机之间的通信。(如: Windows NT就是一种典型的网络操作系统,网站服务器就可以使用) 分布式操作系统分布式操作系统:主要特点是分布性和并行性。系统中的各台计算机地位相同,任何工作都可以分布在这些计算机上,由它们并行、协同完成这个任务。 OS运行机制/体系结构运行机制 指令指令就是处理器(CPU)能识别、处理的最基本命令。特权指令：如内存清零指令。（不允许用户程序使用）非特权指令：如普通的运算指令。 处理机状态用户态：此时CPU只能执行非特权指令。核心态：特权命令、非特权命令都可执行。 处理机状态用程序状态寄存器(PSW)中的某标志位来标识当前处理器处于什么状态。如0为用户态，1为核心态。 程序内核程序：系统的管理者，可以执行特权和非特权指令，运行在核心态。应用程序：只能执行非特权指令，运行在用户态。 OS内核计算机最底层的软件，是操作系统最核心的部分。实现操作系统内核功能的程序才是内核程序。 时钟管理实现计时功能。 中断处理负责实现中断机制。 原语是一种特殊的程序，处于操作系统最底层，是最接近硬件的部分。运行时间短，调用频繁，具有原子性——运行只能一气呵成，不可中断。 系统资源管理进程管理、存储管理、设备管理。 有的操作系统不把这个作为“内核功能”（微内核)，不同操作系统，对内核功能的划分可能不一样。 体系结构操作系统的体系结构：大内核和微内核。 大内核将操作系统的主要功能模块都作为系统内核，运行在核心态。高性能，但是内核代码庞大难以维护。 微内核只把基本概念保留在内核。功能少，功能清晰方便维护，但是需要频繁的在核心态和用户态之间切换，性能低。 OS体系结构可以类比于企业的管理问题：内核就是企业的管理层，负责一些重要的工作。只有管理层才能执行特权指令，普通员工只能执行非特权指令。用户态、核心态之间的切换相当于普通员工和管理层之间的工作交流。大内核：企业初创时体量不大，管理层的人会负责大部分的事情。微内核：随着企业体力越来越大，管理层只负责最核心的一些工作。 中断和异常中断机制的诞生：早期计算机，各程序只能串行执行，系统资源利用率低。为了解决上述问题，人们发明操作系统，引入中断机制，实现了多道程序并发执行。本质：发生中断就意味着需要操作系统介入,开展管理工作。 中断的概念和作用中断信号可以使CPU从用户态切换为核心态,使操作系统获得计算机的控制权。有了中断才能实现多道程序并发执行。 由于操作系统的管理工作(比如进程切换、分配I/O设备等)需要使用特权指令,因此CPU要从用户态转为核心态。 中断是CPU从用户态-&gt;核心态切换的唯一途径。核心态-&gt;用户态切换只需要执行一个特权指令，将PSW设置为0。 中断的分类 内中断(异常/例外/陷入)信号来源CPU内部，与当前执行的指令有关自愿中断(指令中断) ： 系统调用时使用的访管指令(陷入指令/trap指令) 强迫中断： 1.硬件故障（缺页错误）2.软件中断（除0错误） 陷阱、陷入(trap) 有意而为之的异常，系统调用 故障(fault) 错误条件引起的，可能被故障处理程序修复的，如缺页 终止(abort) 致命错误，无法修复，终止处理程序不再将控制返回给应用程序，如除0 外中断(狭义中断)信号来源CPU外部，与当前执行的指令无关外设请求： 外设(比如打印机)I/O操作完成发出中断信号 键盘输入一个字符​ 人工干预： 用户强制终止一个进程 系统调用操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中，程序接口由一组系统调用组成。系统调用是操作系统提供给应用程序(程序员/编程人员)使用的接口,可以理解为一种可供应用程序调用的特殊函数,应用程序可以发出系统调用请求来获得操作系统的服务,操作系统会对各个请求进行协调管理。 例如A和B共用打印机，A按下打印后，打印机工作，B接着又按下打印，打印机不会把A和B的打印内容混合在一起。 应用程序通过系统调用请求操作系统的服务。​系统中的各种共享资源都由操作系统统一掌管,因此在用户程序中,凡是与资源有关的操作(如存储分配、I/O操作、文件管理等) ,都必须通过系统调用的方式向操作系统提出服务请求,由操作系统代为完成。这样可以保证系统的稳定性和安全性,防止用户进行非法操作。系统调用相关的处理需要在核心态下完成。 系统调用与库函数的区别 系统调用是操作系统向上提供的接口 有的库函数是对于系统调用的进一步封装 大多数高级语言提供的库函数间接进行系统调用 系统调用过程","path":"page/os02.html","date":"01-15","excerpt":"","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://xiaoliblog.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"JavaScript🌞正则表达式","text":"正则表达式 正则表达式查询网站I Hate Regex 什么是正则表达式 正则表达式（Regular Expression，简称regexp） 概念：是一种描述字符串结构的语法规则（描述字符串特征） 作用：用于验证各种字符串是否匹配这个特征。 应用：在项目开发中，手机号码指定位数的隐藏、数据采集、敏感词的过滤以及表单的验证等功能，都可以利用正则表达式来实现。 获取正则对象 字面量方式 12/pattern/flags//例如：/abc/gi RegExp对象构造函数方式 12new RegExp(pattern[,flags])RegExp(pattern[,flags]) 1234//示例var str=&#x27;Abc123abc456abc&#x27;;var reg=new RegExp(&#x27;abc&#x27;,&#x27;gi&#x27;);console.log(str.match(reg)); pattern：模式文本，由元字符和文本字符（普通字符）组成。 flags：模式修饰符。 模式符 说明 g 用于在目标字符串中实现全局匹配（多次） i 忽略大小写 m 实现多行匹配 u 以Unicode编码执行正则表达式 y 粘性匹配，仅匹配目标字符串中此正则表达式的lastindex属性指示的索引 ^ 匹配字符串开始的位置 $ 匹配字符串结束的位置 使用正则对象 RegExp对象提供的exec()方法，一次仅返回一个匹配结果，匹配成功返回数组，否则返回null 123var str=&#x27;Abc123abc456abc&#x27;;var reg=/abc/gi;console.log(reg.exec(str)); //返回Abc String对象提供的match()方法，匹配出所有符合要求的内容，匹配成功返回数组，否则返回false 123var str=&#x27;Abc123abc456abc&#x27;;var reg=/abc/gi;console.log(str.match(reg)); //返回Abc、abc、abc 转义字符的处理 使用反斜线对特殊字符进行转义 12345var str=&#x27;^abc\\\\1.23*edf$&#x27;;var reg1=/\\./;console.log(str.match(reg1));var reg2=new RegExp(&#x27;\\\\.&#x27;);console.log(str.match(reg2)); 12345678910111213141516&lt;form&gt; &lt;p&gt;请输入用户名&lt;input type=&quot;text&quot; id=&quot;username&quot; &gt;&lt;/p&gt; div id=&#x27;tips&#x27;&gt;&lt;/div&gt; &lt;p&gt;&lt;input type=&quot;button&quot; value=&quot;提交&quot; onclick=&quot;checkname()&quot;&gt;&lt;/p&gt;&lt;/form&gt;&lt;script&gt; function checkname()&#123; var username = document.getElementById(&#x27;username&#x27;).value; var reg = /admin/gi; if(!(username.match(reg)==null))&#123; document.getElementById(&#x27;tips&#x27;).innerHTML = &#x27;用户名不能包含admin&#x27;; &#125;else&#123; document.getElementById(&#x27;tips&#x27;).innerHTML = &#x27;注册成功&#x27;; &#125; &#125;&lt;/script&gt; 字符类别与集合 字符类别 使正则表达式更加简洁，便于阅读。 字符 含义 字符 含义 . 匹配除“\\n”外的任何单个字符 \\f 匹配一个换页符（form-feed) \\d 匹配任意一个阿拉伯数字 \\D 匹配任意一个非阿拉伯数字字符 \\s 匹配一个空白符，包括空格、制表符、换页符、换行符等 \\S 匹配一个非空白符 \\w 匹配任意一个字母（大小写）、数字和下划线 \\W 匹配任意一个非“字母（大小写）、数字和下划线”的字符 字符集合 正则表达式中的”[]”可以实现一个字符集合 pattern 说明 [cat] 匹配字符集合中的任意一个字符c、a、t [^cat] 匹配除c、a、t以外的字符 [B-Z] 匹配字母B~Z范围内的字符 [^a-z] 匹配字母a~z范围外的字符 [a-zA-Z0-9] 匹配大小写字母和0~9范围内的字符 [\\u4e00-\\u9fa5] 匹配任意一个中文字符 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;限定输入内容&lt;/title&gt; &lt;style&gt; input[type=text]&#123;width: 40px;border-color: #bbb;height: 25px;font-size: 14px;border-radius: 2px;outline: 0;border: #ccc 1px solid;padding: 0 10px;-webkit-transition: box-shadow .5s;margin-bottom: 15px;&#125; input[type=text]:hover, input[type=text]:focus,input[type=submit]:hover&#123;border: 1px solid #56b4ef; box-shadow: inset 0 1px 3px rgba(0,0,0,.05),0 0 8px rgba(82,168,236,.6); -webkit-transition: box-shadow .5s;&#125; input::-webkit-input-placeholder &#123;color: #999; -webkit-transition: color .5s;&#125; input:focus::-webkit-input-placeholder, input:hover::-webkit-input-placeholder &#123;color: #c2c2c2; -webkit-transition: color .5s;&#125; input[type=submit]&#123;height: 30px; width: 80px; background: #4393C9; border:1px solid #fff;color: #fff;font:14px bolder; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;form id=&quot;form&quot;&gt; 年份 &lt;input type=&quot;text&quot; name=&quot;year&quot;&gt; 月份 &lt;input type=&quot;text&quot; name=&quot;month&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;查询&quot;&gt; &lt;/form&gt; &lt;div id=&quot;result&quot;&gt;&lt;/div&gt; &lt;script&gt; function checkYear(obj) &#123; if (!obj.value.match(/^\\d&#123;4&#125;$/)) &#123; obj.style.borderColor = &#x27;red&#x27;; result.innerHTML = &#x27;输入错误，年份为4位数字表示&#x27;; return false; &#125; result.innerHTML = &#x27;&#x27;; return true; &#125; function checkMonth(obj) &#123; if (!obj.value.match(/^((0?[1-9])|(1[012]))$/)) &#123; obj.style.borderColor = &#x27;red&#x27;; result.innerHTML = &#x27;输入错误，月份为1~12之间&#x27;; return false; &#125; result.innerHTML = &#x27;&#x27;; return true; &#125; var form = document.getElementById(&#x27;form&#x27;); // &lt;form&gt;元素对象 var result = document.getElementById(&#x27;result&#x27;); // &lt;div&gt;元素对象 var inputs = document.getElementsByTagName(&#x27;input&#x27;); // &lt;input&gt;元素集合 form.onsubmit = function() &#123; return checkYear(inputs.year) &amp;&amp; checkMonth(inputs.month); &#125;; inputs.year.onfocus = function() &#123; this.style.borderColor = &#x27;&#x27;; &#125;; inputs.month.onfocus = function() &#123; this.style.borderColor = &#x27;&#x27;; &#125;; if (!String.prototype.trim) &#123; String.prototype.trim = function() &#123; return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, &#x27;&#x27;); &#125;; &#125; inputs.year.onblur = function() &#123; this.value = this.value.trim(); checkYear(this); &#125;; inputs.month.onblur = function() &#123; this.value = this.value.trim(); checkMonth(this); &#125;; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 字符限定与分组 限定符 1var reg=/\\d&#123;6&#125;/gi; //匹配6个连续出现的数字 限定符 说明 举例 ? 匹配前面的字符零次或一次 ht?t + 匹配前面的字符一次或多次 bre+ad * 匹配前面的字符零次或多次 ro*se &#123;n&#125; 匹配前面的字符n次 hit&#123;2&#125;er &#123;n,&#125; 匹配前面的字符最少n次 hit&#123;2,&#125;er &#123;n,m&#125; 匹配前面的字符最少n次，最多m次 fe&#123;0,2&#125; 贪婪与懒惰匹配 贪婪匹配表示匹配尽可能多的字符 懒惰匹配表示匹配尽可能少的字符 在默认情况下，是贪婪匹配，若想实现懒惰匹配，需在上一个限定符后面加上”?”符号 12345var str=&#x27;webWEBWebwEb&#x27;;var reg1=/w.*b/gi; //贪婪匹配var reg2=/w.*?b/gi; //懒惰匹配console.log(reg1.exec(str)); //webWEBWebwEb 获得最先出现的w到最后出现的bconsole.log(reg2.exec(str)); //web 获得最先出现的w到最先出现的b 括号字符 被括号字符“()“括起来的内容，称之为”子表达式“ 改变限定符的作用范围 123456//改变前正则表达式：catch|er可匹配的结果：catch、er//改变后正则表达式：cat(ch|er)可匹配的结果：catch、cater 分组 123456//分组前正则表达式：abc&#123;2&#125;可匹配的结果：abcc//分组后正则表达式： a(bc)&#123;2&#125;可匹配的结果：abcbc 捕获 将子表达式匹配到的内容存储到系统的缓存区中。 123456var res1 = &#x27;1234&#x27;.match(/\\d\\d\\d\\d/g);console.log(res1); //[&quot;1234&quot;]var res2 = &#x27;1234&#x27;.match(/(\\d)(\\d)(\\d)(\\d)/);console.log(res2); // [&quot;1234&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;]var res3 = &#x27;1234&#x27;.match(/(\\d)(\\d)(\\d)(\\d)/g);console.log(res3); //[&quot;1234&quot;] 反向引用 在正则表达式中，获取存放在缓存区内的子表达式的捕获内容，则可以使用”\\n“(n&gt;0)的方式引用 1234\\1：第一个子表达式捕获的内容\\2：第二个子表达式捕获的内容var reg1=/(\\d)\\1\\1/gi; 连续三个相同的数字var reg2=/(\\s)(\\s)\\1\\2/gi; ABAB格式 正则相关方法 RegExp对象 的test()方法： 检测正则表达式与指定的字符串是否匹配，返回true或false。 12345var reg = /([A-Z])([A-Z])\\1\\2/g;console.log(reg.test(&#x27;1234&#x27;)); //false console.log(reg.test(&#x27;abab&#x27;)); //falseconsole.log(reg.test(&#x27;CDCD&#x27;)); //trueconsole.log(reg.test(&#x27;EfEf&#x27;)); //false String对象的search()方法： 可以返回指定模式的子串在字符串首次出现的位置，查找失败返回-1。 123var str = &#x27;123*abc.456&#x27;;console.log(str.search(&#x27;.*&#x27;)); //0 console.log(str.search(/[\\.\\*]/)); //3 search()方法如果传入一个非正则表达式对象，则会将其转换为正则表达式对象 String对象的split()方法 用于根据指定的分隔符将一个字符串分割成字符串数组，其分割后的字符串数组中不包括分隔符。 当分隔符不只一个时，需要定义正则对象才能够完成字符串的分割操作。 1234var str = &#x27;test@123.com&#x27;;var reg = /[@\\.]/;var split_res = str.split(reg);console.log(split_res); // 输出结果：(3) [&quot;test&quot;, &quot;123&quot;, &quot;com&quot;] String对象的replace()方法 用 newChar 字符替换字符串中出现的所有 searchChar 字符，并返回替换后的新字符串。 123var str = &#x27;test@123.com&#x27;;var str_new= str.replace(‘123’,’163’);console.log(str_new); // 输出结果：test@163.com replace：获取捕获内容，并对捕获内容进行替换 1234var str=&#x27;12ab34&#x27;;var reg=/(\\d)(\\d)/gi;console.log(str.match(reg));console.log(str.replace(reg,&#x27;*&#x27;)); //[&quot;12&quot;,[&quot;34&quot;]] *ab* $n:获取第n个字表达式捕获的内容 1234var str = &#x27;Regular Capture&#x27;;var reg = /(\\w+)\\s(\\w+)/gi;var newStr = str.replace(reg,&#x27;$2 $1&#x27;);console.log(newStr); 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;内容查找与替换&lt;/title&gt; &lt;style&gt; div&#123;float:left;&#125; input&#123;margin:0 20px;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;过滤前内容:&lt;br&gt; &lt;textarea id=&quot;pre&quot; rows=&quot;10&quot; cols=&quot;40&quot;&gt;&lt;/textarea&gt; &lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;过滤&quot;&gt; &lt;/div&gt; &lt;div&gt;过滤后内容:&lt;br&gt; &lt;textarea id=&quot;res&quot; rows=&quot;10&quot; cols=&quot;40&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;script&gt; document.getElementById(&#x27;btn&#x27;).onclick = function () &#123; // 定义查找并需要替换的内容规则，[\\u4e00-\\u9fa5]表示匹配任意中文字符 var reg = /(bad)|[\\u4e00-\\u9fa5]/gi; var str = document.getElementById(&#x27;pre&#x27;).value; var newstr = str.replace(reg, &#x27;*&#x27;); document.getElementById(&#x27;res&#x27;).innerHTML = newstr; &#125;; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 表单验证12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;表单验证&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;case03.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;box-head&quot;&gt;填写注册信息&lt;/div&gt; &lt;div class=&quot;box-body&quot;&gt; &lt;form&gt; &lt;!-- ----- --&gt; &lt;table&gt; &lt;!-- ------- --&gt; &lt;tr&gt; &lt;th&gt;用户名称：&lt;/th&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;长度4~12，英文大小写字母&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;div&gt;&lt;/div&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;密 码：&lt;/th&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;pwd&quot; placeholder=&quot;长度6~20，大小写字母、数字或下划线&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;div&gt;&lt;/div&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;确认密码：&lt;/th&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;repwd&quot; placeholder=&quot;请再次输入密码进行确认&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;div&gt;&lt;/div&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;手机号码：&lt;/th&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;tel&quot; placeholder=&quot;13、14、15、17、18开头的11位手机号&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;div&gt;&lt;/div&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;电子邮箱：&lt;/th&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;email&quot; placeholder=&quot;用户名@域名（域名后缀至少2个字符）&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;div&gt;&lt;/div&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt;&lt;td colspan=&quot;3&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt;&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;case03.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314body&#123;margin-top:20px;&#125;.box&#123;font-size:13px;margin:0 auto; width: 80%;&#125;.box-head&#123;padding:15px 20px;font-size:14px; text-align: center; font-size:24px; font:bolder;&#125;.box-body&#123;padding:10px 20px;&#125;.box-body th&#123;font-weight:normal;vertical-align:top;padding-top:12px;&#125;.box-body tr:last-child&#123; text-align: center;&#125;.box-body input&#123;vertical-align:middle;font-family:Tahoma,simsun;font-size:12px;&#125;.box-body input[type=text],.box-body input[type=password]&#123;border-color: #bbb;height: 38px;font-size: 14px;border-radius: 2px;outline: 0;border: #ccc 1px solid;padding: 0 10px; width: 350px;-webkit-transition: box-shadow .5s;margin-bottom: 15px;&#125;.box-body input[type=text]:hover, .box-body input[type=text]:focus, .box-body input[type=password]:hover, .box-body input[type=password]:focus &#123;border: 1px solid #56b4ef; box-shadow: inset 0 1px 3px rgba(0,0,0,.05),0 0 8px rgba(82,168,236,.6); -webkit-transition: box-shadow .5s;&#125;.box-body input::-webkit-input-placeholder &#123;color: #999; -webkit-transition: color .5s;&#125;.box-body input:focus::-webkit-input-placeholder, input:hover::-webkit-input-placeholder &#123;color: #c2c2c2; -webkit-transition: color .5s;&#125;.box-body input[type=submit]&#123;padding:4px 15px;cursor:pointer; width:120px; height:40px; background: #4393C9; border:1px solid #fff; color: #fff;font:16px bolder;&#125;.box-body .error&#123;border:1px solid #FF3300; background: #FFF2E5; font-size:10px; height: 30px; line-height: 30px;margin-bottom:10px; padding:0 10px;&#125;.box-body .success&#123;border:1px solid #01BE00; background: #E6FEE4; font-size:10px; height: 30px; line-height: 30px;margin-bottom:10px; padding:0 10px;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 获取所有input框var inputs = document.getElementsByTagName(&#x27;input&#x27;);inputs[0].focus();// 为每个input框添加失去焦点事件for (var i = 0; i &lt; inputs.length - 1; ++i) &#123; inputs[i].onblur = function()&#123; inputBlur(this); &#125;&#125;function inputBlur(obj) &#123; var name = obj.name; // 获取输入框的name值 var val = obj.value; // 获取输入框的value值 var tips = obj.placeholder; // 获取输入框中的提示信息 // var fu = obj.parentNode; // var xiongdi = fu.nextSibling.nextSibling; //回车会被当成一个文本节点，所以要next两次 var tips_obj = obj.parentNode.nextSibling.nextSibling.firstChild; // 获取提示信息显示的div元素对象 // 1. 去掉两端的空白字符 val = val.trim(); // 2. 文本框内容为空，给出提示信息 if (!val) &#123; error(tips_obj, &#x27;输入框不能为空&#x27;); return false; &#125; // 3. 获取正则匹配规则和提示信息 var reg_msg = getRegMsg(name, tips); // 4. 检测是否否he正则匹配 if (reg_msg[&#x27;reg&#x27;].test(val)) &#123; // 匹配成功，显示成功的提示信息 success(tips_obj, reg_msg[&#x27;msg&#x27;][&#x27;success&#x27;]); &#125; else &#123; // 匹配失败，显示失败的提示信息 error(tips_obj, reg_msg[&#x27;msg&#x27;][&#x27;error&#x27;]); &#125;&#125;// 根据input的name值，设置正则规则及提示信息function getRegMsg(name, tips) &#123; var reg = msg = &#x27;&#x27;; switch (name) &#123; case &#x27;username&#x27;: reg = /^[a-zA-Z]&#123;4,12&#125;$/; msg = &#123;&#x27;success&#x27;: &#x27;用户名输入正确&#x27;, &#x27;error&#x27;: tips&#125;; break; case &#x27;pwd&#x27;: reg = /^\\w&#123;6,20&#125;$/; msg = &#123;&#x27;success&#x27;: &#x27;密码输入正确&#x27;, &#x27;error&#x27;: tips&#125;; break; case &#x27;repwd&#x27;: var con = document.getElementsByTagName(&#x27;input&#x27;)[1].value; reg = RegExp(&quot;^&quot; + con + &quot;$&quot;); msg = &#123;&#x27;success&#x27;: &#x27;两次密码输入正确&#x27;, &#x27;error&#x27;: &#x27;两次输入的密码不一致&#x27;&#125;; break; case &#x27;tel&#x27;: reg = /^1[34578]\\d&#123;9&#125;$/; msg = &#123;&#x27;success&#x27;: &#x27;手机号码输入正确&#x27;, &#x27;error&#x27;: tips&#125;; break; case &#x27;email&#x27;: reg = /^(\\w+(\\_|\\-|\\.)*)+@(\\w+(\\-)?)+(\\.\\w&#123;2,&#125;)+$/; msg = &#123;&#x27;success&#x27;: &#x27;邮箱输入正确&#x27;, &#x27;error&#x27;: tips&#125;; break; &#125; return &#123;&#x27;reg&#x27;: reg, &#x27;msg&#x27;: msg&#125;;&#125;// 成功function success(obj, msg) &#123; obj.className = &#x27;success&#x27;; obj.innerHTML = msg;&#125;// 失败function error(obj, msg) &#123; obj.className = &#x27;error&#x27;; obj.innerHTML = msg + &#x27;，请重新输入&#x27;;&#125;","path":"page/js07.html","date":"01-15","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xiaoliblog.cn/tags/JavaScript/"}]},{"title":"JavaScript🌞事件","text":"事件 事件：用户行为，如单击、鼠标移动等； 事件处理程序：对事件进行处理的代码； 事件驱动式：侦测到用户行为、执行事件处理程序的过程； 事件流：事件传播的过程（捕获+冒泡） 事件捕获方式（网景）事件流传播的顺序应该是从DOM树的根节点到发生事件的元素节点。 事件冒泡方式（微软）事件流传播的顺序应该是从发生事件的元素节点到DOM树的根节点。 事件绑定方式 行内绑定式 事件处理程序中this关键字用于指向window对象 1&lt;标签名 事件=&quot;事件的处理程序&quot;&gt; 动态绑定式 事件处理程序中this关键字用于指向当前正在操作的DOM元素对象 1DOM元素对象.事件=事件的处理程序 事件监听 事件监听：可以为一个事件添加多个事件处理程序。 123456789101112131415/*DOM对象.addEventListener(type,callback,[capture]);type：事件类型 callback：表示事件的处理程序capture：默认false表示在冒泡阶段完成事件处理 true表示在捕获阶段完成事件的处理*/ var div=document.getElementById(&#x27;div&#x27;); div.addEventListener(&#x27;click&#x27;,function()&#123; console.log(&quot;one&quot;); &#125;); div.addEventListener(&#x27;click&#x27;,function()&#123; console.log(&quot;two&quot;); &#125;); 事件对象 在Javascript中，当发生事件时，都会产生一个事件对象event，这个对象中包含着所有与事件有关的信息。 获取事件对象 1234btn.onclick=function(e)&#123; var event = e || window.event; //e为现版本 window.event为早期版本 console.log(event);&#125; 假false：undefined、null、NaN、0、空串 真true：其它都为真 真前：true||任何值，都返回前面的值 假后：false||任何值，都返回后面的值 事件对象常用属性/方法 说明 type 返回当前事件的类型，如click target 返回触发此事件的元素（事件的目标节点） stopPropagation() 阻止事件冒泡 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot; /&gt; &lt;title&gt;Document&lt;/title&gt;&lt;style&gt; .d1&#123; width:100px; height:100px; border:1px red solid; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;div&quot; class=&#x27;d1&#x27;&gt; &lt;input type=&quot;button&quot; value=&quot;点击我&quot; id=&quot;btn&quot;/&gt; &lt;/div&gt; &lt;script&gt; var div = document.getElementById(&#x27;div&#x27;); var btn = document.getElementById(&#x27;btn&#x27;); div.onclick = function()&#123; console.log(&quot;div div div&quot;); &#125; btn.onclick = function(e)&#123; console.log(&quot;btn btn btn&quot;); //type 类型 target目标 event.stopPropagation()阻止冒泡 //得到事件对象 var event = e || window.event; console.log( event.type ); //--click console.log( event.target ); //-- &lt;input type=&quot;button&quot; value=&quot;点击我&quot; id=&quot;btn&quot;/&gt; event.stopPropagation(); //-- btn &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 页面事件 事件名称 事件触发时机 load 当页面载入完毕后触发 unload 当页面关闭时触发 123456789101112131415161718192021222324&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot; /&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- &lt;script&gt; document.getElementById(&#x27;demo&#x27;).onclick = function()&#123; console.log(&#x27;单击&#x27;); &#125; &lt;/script&gt; --&gt;&lt;script&gt; window.onload = function()&#123; document.getElementById(&#x27;demo&#x27;).onclick = function()&#123; console.log(&#x27;单击&#x27;); &#125; &#125;&lt;/script&gt;&lt;div id=&#x27;demo&#x27;&gt;点我&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 焦点事件 焦点事件多用于表单验证功能 事件名称 事件触发时机 focus 当获得焦点时触发（不会冒泡） blur 当失去焦点时（不会冒泡） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;验证用户名和密码是否为空&lt;/title&gt; &lt;style&gt; body&#123;background:#ddd;&#125; .box&#123;background:#fff;padding:20px 30px;width:400px;margin: 0 auto;text-align:center;&#125; .btn&#123;width:180px;height:40px;background:#3388ff;border:1px solid #fff;color:#fff;font-size:14px;&#125; .ipt&#123;width:260px;padding:4px 2px;&#125; .tips&#123;width:440px;height:30px;margin:5px auto;background:#fff;color:red;border:1px solid #ccc;display:none;line-height:30px;padding-left:20px;font-size:13px;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;tips&quot; class=&quot;tips&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt; &lt;p&gt;&lt;label&gt;用户名：&lt;input id=&quot;user&quot; class=&quot;ipt&quot; type=&quot;text&quot;&gt;&lt;/label&gt;&lt;/p&gt; &lt;p&gt;&lt;label&gt;密 码：&lt;input id=&quot;pass&quot; class=&quot;ipt&quot; type=&quot;password&quot;&gt;&lt;/label&gt;&lt;/p&gt; &lt;p&gt;&lt;button id=&quot;login&quot; class=&quot;btn&quot;&gt;登录&lt;/button&gt;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var user = document.getElementById(&#x27;user&#x27;); var pass = document.getElementById(&#x27;pass&#x27;); var tips = document.getElementById(&#x27;tips&#x27;); user.onblur = function()&#123; if(user.value===&#x27;&#x27;)&#123; tips.innerHTML = &#x27;用户名不能为空&#x27;; tips.style.display = &#x27;block&#x27;; &#125; &#125; pass.onblur = function()&#123; if(user.value===&#x27;&#x27;)&#123; tips.innerHTML = &#x27;密码不能为空&#x27;; tips.style.display = &#x27;block&#x27;; &#125; &#125; &lt;/script&gt; &lt;!-- &lt;script&gt; window.onload = function() &#123; addBlur(getElement(&#x27;user&#x27;)); // 检测id为user的元素失去焦点后，value值是否为空 addBlur(getElement(&#x27;pass&#x27;)); // 检测id为pass的元素失去焦点后，value值是否为空 &#125;; function getElement(obj) &#123; // 根据id获取指定元素 return document.getElementById(obj); &#125; function addBlur(obj) &#123; // 为指定元素添加失去焦点事件 obj.onblur = function() &#123; isEmpty(this); &#125;; &#125; function isEmpty(obj) &#123; // 检测表单是否为空 if (obj.value === &#x27;&#x27;) &#123; getElement(&#x27;tips&#x27;).style.display = &#x27;block&#x27;; getElement(&#x27;tips&#x27;).innerHTML = &#x27;注意：输入内容不能为空! &#x27;; &#125; else &#123; getElement(&#x27;tips&#x27;).style.display = &#x27;none&#x27;; &#125; &#125; &lt;/script&gt; --&gt; &lt;/body&gt;&lt;/html&gt; 鼠标事件 事件名称 事件触发时机 click 单击(动态绑定用onclick) dblclick 双击 mouseover/mouseout 鼠标进入/离开 change 当内容发生改变时触发，一般用于select对象 mousedown/mouseup 按下 / 松开 任意鼠标键 mousemove 在元素内当鼠标移动时持续触发 位置属性 描述 clientX/clinetY 触发点相对浏览器可视区域左上角距离，不随页面滚动而变化（所有浏览器） pageX / pageY 触发点相对文档区域左上角距离，随页面滚动而滚动（IE6~8不兼容） screenX / screenY 触发点位于屏幕的距离，不随页面滚动而变化 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .mouse&#123;position:absolute;background:#ffd965;width:40px;height:40px;border-radius:20px;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;mouse&quot; class=&quot;mouse&quot;&gt;&lt;/div&gt; &lt;script&gt; document.onclick = function(event)&#123; //获取事件对象的兼容性 var event = event || window.event; //鼠标在页面上的位置 var pageX = event.pageX || event.clientX + document.documentElement.scrollLeft; var pageY = event.pageY || event.clientY + document.documentElement.scrollTop; //计算div应该显示的位置 var targetX = pageX - mouse.offsetWidth/2; var targetY = pageY - mouse.offsetHeight / 2; //在鼠标位置显示div mouse.style.display = &#x27;block&#x27;; mouse.style.left = targetX + &#x27;px&#x27;; mouse.style.top = targetY + &#x27;px&#x27;; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 键盘事件 事件名称 事件触发时机 keypress 键盘非功能键按下时触发 keydown 键盘所有键键按下时触发 keyup 键盘按键弹起时触发 keypress事件保存的按键值是ASCII码，keydown和keyup事件保存的按键值是虚拟键码keycode 常用的keycode 回车：13 左上右下：37、38、39、40 Tab：9 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/*按下键盘的enter键，下一个文本框获得焦点。 第一步：查找页面元素第二步：为每一个input添加“键盘按下”事件第三步：判断按下的是否为Enter键第四步：如果是enter键，则寻找当前input框第五步：根据当前，计算下一个input框的index第六步：下一个input框获得焦点*/&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;按Enter键切换&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;用户姓名：&lt;input type=&quot;text&quot;&gt;&lt;/p&gt; &lt;p&gt;电子邮箱：&lt;input type=&quot;text&quot;&gt;&lt;/p&gt; &lt;p&gt;手机号码：&lt;input type=&quot;text&quot;&gt;&lt;/p&gt; &lt;p&gt;个人描述：&lt;input type=&quot;text&quot;&gt;&lt;/p&gt; &lt;script&gt; // 为四个input添加键盘事件 // 查找页面元 var inputs = document.getElementsByTagName(&#x27;input&#x27;); for(var i=0;i&lt;inputs.length;i++)&#123; inputs[i].onkeydown = function(e)&#123;//  处理：如果按下的是回车键，//  下一个输入框（当前—遍历，？==this）获得焦点（focus） e = e || window.event; if(e.keyCode==13)&#123; for(var j=0;j&lt;inputs.length;j++)&#123; if(inputs[j]==this)&#123; var index = j+1; // 边界处理 if(index==inputs.length)&#123; index = 0; &#125; inputs[index].focus(); &#125; &#125; &#125; &#125; &#125; // //查找页面元素 // var inputs = document.getElementsByTagName(&#x27;input&#x27;); // //为每一个input添加“键盘按下”事件 // for(var i=0;i&lt;inputs.length;i++)&#123; // inputs[i].onkeydown = function(e)&#123; // //判断按下的是否为Enter键 // var e = e || window.event; // if(e.keyCode===13)&#123; // //是enter键，则寻找当前input框 // for(var j=0;j&lt;inputs.length;j++)&#123; // if(inputs[j]===this)&#123; // //console.log(j); // //下一个input框的index // var index = ++j; // if(index==inputs.length)&#123; // index=0; // &#125; // console.log(index); // //下一个input框获得焦点 // inputs[index].focus(); // break; // &#125; // &#125; // &#125; // &#125; // &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 表单事件 事件名称 事件触发条件 submit 当表单提交时触发 reset 当表单重置时触发 这两个事件的返回值若是false则会取消默认操作，否则将执行默认操作 图片放大特效素材： big.jpg small.jpg 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/*（1）页面构成大div：包括左div+右div左div：包含图片+div(遮罩--移动、显示或隐藏)右div：包含 图片（显示或隐藏）（2）JS实现步骤第一步：鼠标经过与移出，遮罩和大图的显示与隐藏第二步：遮罩的移动，通过为小图添加鼠标移动事件来实现第三步：大图的显示区域*/&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123;width:350px;height:350px;border:1px solid #ccc;position:relative&#125; .big&#123;width:400px;height:400px;position:absolute;top:0;left:360px;border:1px solid #ccc;overflow:hidden;display:none&#125; /* overflow:hidden是当元素内的内容溢出的时候使它隐藏溢出的部分，即超出部分隐藏 */ .mask&#123;width:175px;height:175px;background:rgba(255,255,0,.4);position:absolute;top:0;left:0;cursor:move;display:none&#125;/*cursor:move 光标形状*/ .small&#123;position:relative&#125; .box img&#123;vertical-align:top&#125; #bigBox img&#123;position:absolute&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot; id=&quot;box&quot;&gt; &lt;div id=&quot;smallBox&quot; class=&quot;small&quot;&gt; &lt;img src=&quot;images/small.jpg&quot;&gt; &lt;div id=&quot;mask&quot; class=&quot;mask&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;bigBox&quot; class=&quot;big&quot;&gt; &lt;img id=&quot;bigImg&quot; src=&quot;images/big.jpg&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; //第一步：鼠标经过与移出，遮罩和大图的显示与隐藏 -- 遮罩默认在小图的左上角 function $(id)&#123; //定义函数，根据id值获取元素对象 return document.getElementById(id); &#125; $(&#x27;smallBox&#x27;).onmouseover = function()&#123; console.log(&quot;jirnu &quot;); $(&#x27;mask&#x27;).style.display = &#x27;block&#x27;; $(&#x27;bigBox&#x27;).style.display = &#x27;block&#x27;; &#125;; $(&#x27;smallBox&#x27;).onmouseout = function()&#123; $(&#x27;mask&#x27;).style.display = &#x27;none&#x27;; $(&#x27;bigBox&#x27;).style.display = &#x27;none&#x27;; &#125;; //第二步：遮罩的移动，通过为小图添加鼠标移动事件来实现 $(&#x27;smallBox&#x27;).onmousemove = function(event)&#123; var event = event || window.event; //计算鼠标在页面中的坐标 var pageX = event.pageX || event.clientX + dodument.documentElement.scroll; var pageY = event.pageY || event.clientY + document.documentElement.scrollTop; //计算遮罩的位置:x = 鼠标位置的x - 遮罩宽度的一半， y类似 var maskX = pageX - $(&#x27;mask&#x27;).offsetWidth / 2; var maskY = pageY - $(&#x27;mask&#x27;).offsetHeight / 2; //遮罩边界处理 -- 遮罩不能移动到小图以外的位置 if(maskX&lt;0)&#123; //左边界 maskX = 0; &#125; if(maskX&gt;$(&#x27;smallBox&#x27;).offsetWidth - $(&#x27;mask&#x27;).offsetWidth)&#123;//右边界 //修改遮罩的显示位置 -- 移动 maskX = $(&#x27;smallBox&#x27;).offsetWidth - $(&#x27;mask&#x27;).offsetWidth; &#125; if(maskY&lt;0)&#123; //上边界 maskY = 0; &#125; if(maskY&gt;$(&#x27;smallBox&#x27;).offsetHeight - $(&#x27;mask&#x27;).offsetHeight)&#123; //下边界 maskY=$(&#x27;smallBox&#x27;).offsetHeight - $(&#x27;mask&#x27;).offsetHeight; &#125; $(&#x27;mask&#x27;).style.left = maskX + &#x27;px&#x27;; $(&#x27;mask&#x27;).style.top = maskY + &#x27;px&#x27;; //第三步：大图的显示区域 -- 按照遮罩在小图中的区域，显示大图中相应区域 -- 比例计算 // 按照比例移动大图 大图片能够移动的总距离 = 大图的宽度 - 大盒子的宽度 var bigImgToMove = $(&#x27;bigImg&#x27;).offsetWidth - $(&#x27;bigBox&#x27;).offsetWidth; // 遮罩能够移动的总距离 = 小盒子的宽度 - 遮罩的宽度 var maskToMove = $(&#x27;smallBox&#x27;).offsetWidth - $(&#x27;mask&#x27;).offsetWidth; // 计算移动比例rate = 大图片能够移动的总距离/遮罩能够移动的总距离 var rate = bigImgToMove / maskToMove; // 设置大图片当前的位置 = rate * 遮罩当前的位置 $(&#x27;bigImg&#x27;).style.left = - rate * maskX + &#x27;px&#x27;; $(&#x27;bigImg&#x27;).style.top = - rate * maskY + &#x27;px&#x27;; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","path":"page/js07.html","date":"01-15","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xiaoliblog.cn/tags/JavaScript/"}]},{"title":"JavaScript🌞DOM","text":"DOM 什么是DOM？ 文 档（Document）表示HTML文件。 节 点：文档中所有的内容，都称为节点。 节点类型：标签节点（元素）、文本节点、属性节点、注释节点。 DOM：Document Object Model，文档对象模型。 作 用：完成对HTML文档内所有元素的获取、访问、标签属性和样式的设置等操作。 DOM HTML 节点树 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;DOM节点&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=&quot;t1.png&quot;&gt; &lt;h1&gt;喜欢的水果&lt;/h1&gt; &lt;p&gt;DOM应用&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; HTML元素操作获取页面元素 利用document对象的方法 document对象的方法 说明 getElementById() 返回对拥有指定id的第一个对象的引用 getElementsByName() 返回带有指定名称的对象集合 getElementsByTagName() 返回带有指定标签名的对象集合 getElementsByClassName() 返回带有指定类名的对象集合（不支持IE6~8） querySelector() 返回文档中匹配到指定元素或CSS选择器的第1个对象的引用 querySelectorAll() 返回文档中匹配到指定元素或CSS选择器的第1个对象集合 1234567891011121314151617181920 &lt;div id=&quot;box&quot;&gt;box&lt;/div&gt; &lt;div class=&quot;bar&quot;&gt;bar1&lt;/div&gt; &lt;div class=&quot;bar&quot;&gt;bar2&lt;/div&gt; &lt;div name=&quot;main&quot;&gt;main1&lt;/div&gt; &lt;div name=&quot;main&quot;&gt;main2&lt;/div&gt;&lt;script&gt; console.log(document.getElementById(&quot;box&quot;)); //返回对象集合，可以通过下标获得指定项 console.log(document.getElementsByName(&quot;main&quot;)[0]); console.log(document.getElementsByClassName(&quot;bar&quot;)); console.log(document.getElementsByTagName(&quot;div&quot;)); //HTML5新增方法 console.log(document.querySelector(&quot;div&quot;)); //获取匹配到的第1个div console.log(document.querySelector(&quot;#box&quot;)); //获取id为box的第1个div console.log(document.querySelector(&quot;.bar&quot;)); //获取class为bar的第1个div console.log(document.querySelector(&quot;div[name]&quot;)); //获取含有name属性的第1个div console.log(document.querySelector(&quot;div.bar&quot;)); //获取文档中class为bar的第1个div console.log(document.querySelector(&quot;div#box&quot;)); //获取文档中id为box的第1个div&lt;/script&gt; 利用documetn对象的属性 document对象的属性 说明 document.body 返回文档的body元素 document.documentElement 返回文档的html元素 document.forms 返回对文档中所有Form对象引用 document.images 返回对文档中所有Image对象引用 12345678910&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; var body=document.getElementsByTagName(&#x27;body&#x27;)[0]; //获取body元素 var html=document.getElementsByTagName(&#x27;html&#x27;)[0]; //获取html元素 console.log(document.body === body); //返回比较结果 true console.log(document.documentElement === html); //返回比较结果 true&lt;/script&gt; 利用Element对象的方法 Element对象的方法 说明 getElementsByClassName 返回某个元素内具有指定class的元素 getElementsByTagName 返回某个元素内具有指定tag的元素 123456789 &lt;ul id=&quot;ul&quot;&gt; &lt;li&gt;PHP&lt;/li&gt; &lt;li&gt;JS&lt;/li&gt; &lt;li&gt;JQuery&lt;/li&gt; &lt;ul&gt;&lt;script&gt; var lis = document.getElementById(&#x27;ul&#x27;).getElementsByTagName(&#x27;li&#x27;); console.log(lis);&lt;/script&gt; 通过document对象或者Element对象调用getElementsByClassName()方法、getElementsByTagName()方法、children属性等返回的对象集合，实际上是一个HTMLCollection对象; document对象调用getElementsByName()方法在Chrom浏览器中返回的是NodeList对象，IE11返回的是HTMLCOllection对象。 HTMLCollection用于元素操作，NodeList用于节点操作 更改元素内容 Element对象的属性 说明 innerHTML 设置或返回元素开始和结束标签之间的HTML innerText(不推荐) 设置或返回元素中去除所有标签的内容 textContent 设置或者返回指定节点的文本内容 document对象的方法 说明 document.write() 向文档写入指定的内容 document.writeln() 向文档写入指定的内容后并换行 1234567891011//html代码 &lt;div id=&#x27;div&#x27;&gt; &lt;h2&gt;标题文字&lt;/h2&gt; &lt;p&gt;段落1111&lt;/p&gt; &lt;/div&gt;//JS代码实现&lt;script&gt; var div=document.getElementById(&#x27;div&#x27;); var str=&#x27;&lt;h2&gt;标题文字&lt;/h2&gt;&lt;p&gt;段落1111&lt;/p&gt;&#x27;; div.innerHTML=str;&lt;/script&gt; 更改元素属性1ele.setAttribute(&#x27;属性名&#x27;,&#x27;属性值&#x27;); 方法 说明 setAttribute(name, value) 设置或者改变指定属性的值 getAttribute(name) 返回指定元素的属性值 removeAttribute(name) 从元素中删除指定的属性 利用attributes属性可以获取一个HTML元素的所有属性，以及所有属性的个数length 12345678910111213141516 &lt;ul&gt; &lt;li&gt;php&lt;/li&gt; &lt;li&gt;js&lt;/li&gt; &lt;li class=&quot;red&quot;&gt;java&lt;/li&gt; &lt;/ul&gt;&lt;script&gt; //获得节点 var child = document.getElementsByTagName(&#x27;li&#x27;)[2]; //删除属性1 child.removeAttribute(&#x27;class&#x27;); //删除属性2 var attr = child.getAttributeNode(&#x27;class&#x27;); child.removeAttributeNode(attr); //删除节点 child.parentNode.removeChild(child);&lt;/script&gt; 12345678910111213&lt;div class=&#x27;gray&#x27; id=&#x27;thick&#x27; align=&#x27;center&#x27;&gt;test word.&lt;/div&gt;&lt;script&gt; var ele = document.getElementsByTagName(&#x27;div&#x27;)[0]; console.log(&quot;当前属性个数：&quot; + ele.attributes.length); //添加属性 -- 实现和第12行同样的效果（二者留其一即可） ele.setAttribute(&#x27;align&#x27;, &#x27;center&#x27;); ele.setAttribute(&#x27;class&#x27;, &#x27;gray&#x27;); ele.setAttribute(&#x27;id&#x27;, &#x27;thick&#x27;); //移除属性 ele.removeAttribute(&#x27;id&#x27;);&lt;/script&gt; 更改元素样式1ele.style.样式名:值; 常见style属性操作样式名 说明 background 设置或返回元素的背景属性 backgroundColor 设置或返回元素的背景色 display 设置或返回元素的显示类型 height 设置或返回元素的高度 left 设置或返回定位元素的左部位置 textAlign 设置或返回文本的水平对齐方式 textDecoration 设置或返回文本的修饰 textIndent 设置或返回文本第一行的缩进 在操作样式名称时，需要去掉CSS样式名里的中横线”-“,并将第二个英文首字母大写例如background-color，需要修改为：backgroundColor 123456789101112131415161718192021&lt;style type=&quot;text/css&quot;&gt; .gray&#123;background:#ccc;&#125; #thick&#123;font-weight:bolder;&#125;&lt;/style&gt;&lt;div&gt;test word.&lt;/div&gt;&lt;script&gt; var ele = document.getElementsByTagName(&#x27;div&#x27;)[0]; console.log(&quot;当前属性个数：&quot; + ele.attributes.length); ele.style.textAlign = &#x27;center&#x27;; ele.style.background = &#x27;#ccc&#x27;; ele.style.fontWeight = &#x27;bolder&#x27;; // //添加属性 -- 实现和第12行同样的效果（二者留其一即可） // ele.setAttribute(&#x27;align&#x27;, &#x27;center&#x27;); // ele.setAttribute(&#x27;class&#x27;, &#x27;gray&#x27;); // ele.setAttribute(&#x27;id&#x27;, &#x27;thick&#x27;); // //移除属性 // ele.removeAttribute(&#x27;id&#x27;);&lt;/script&gt; classList 由于一个元素的类选择器可以有多个，可以利用div元素对象.classList的方式，获取类选择器列-表 classList方法 说明 add() 可以给元素添加类名，一次只能添加一个 remove() 可以将元素的类名删除，一次只能删除一个 toggle() 切换元素的样式，若元素之前没有指定名称的样式则添加，如果有则移除 item() 根据接收的数字索引参数，获取元素的类名 contains 判断元素是否包含指定名称的样式，若包含则返回true，否则返回false 可以通过classList的属性length获取元素类名的个数 12345678910111213&lt;div class=&quot;bar bar1&quot;&gt;bar1&lt;/div&gt;&lt;style type=&quot;text/css&quot; media=&quot;screen&quot;&gt; .ys&#123; color:red; &#125;&lt;/style&gt;&lt;script&gt; var mydiv=document.getElementsByTagName(&#x27;div&#x27;)[0]; console.log(mydiv.classList.length); //获得元素的所有类名 mydiv.classList.add(&quot;ys&quot;); //添加样式 mydiv.classList.remove(&quot;ys&quot;); //删除样式s&lt;/script&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;标签栏切换效果&lt;/title&gt; &lt;style&gt; body&#123;margin:0;padding:0;&#125; .tab-box&#123;width:383px;margin:10px;border:1px solid #ccc;border-top:2px solid #206F96;&#125; .tab-head&#123;height:31px;&#125; .tab-head-div&#123;width:95px;height:30px;float:left;border-bottom:1px solid #ccc;border-right:1px solid #ccc;background:#206F96;line-height:30px;text-align:center;cursor:pointer;color:#fff;&#125; .tab-head .current&#123;background:#fff;border-bottom:1px solid #fff;color:#000;&#125; .tab-head-r&#123;border-right:0;&#125; .tab-body-div&#123;display:none;margin:20px 10px;&#125; .tab-body .current&#123;display:block;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;tab-box&quot;&gt; &lt;div class=&quot;tab-head&quot;&gt; &lt;div class=&quot;tab-head-div current&quot;&gt;标签一&lt;/div&gt; &lt;div class=&quot;tab-head-div&quot;&gt;标签二&lt;/div&gt; &lt;div class=&quot;tab-head-div&quot;&gt;标签三&lt;/div&gt; &lt;div class=&quot;tab-head-div tab-head-r&quot;&gt;标签四&lt;/div&gt; &lt;/div&gt; &lt;!--jkdjfk?--&gt; &lt;div class=&quot;tab-body&quot;&gt; &lt;div class=&quot;tab-body-div current&quot;&gt; 1 &lt;/div&gt; &lt;div class=&quot;tab-body-div&quot;&gt; 2 &lt;/div&gt; &lt;div class=&quot;tab-body-div&quot;&gt; 3 &lt;/div&gt; &lt;div class=&quot;tab-body-div&quot;&gt; 4 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 获取标签栏的所有标签元素对象 var tabs = document.getElementsByClassName(&#x27;tab-head-div&#x27;); // 获取标签栏的所有内容对象 var divs = document.getElementsByClassName(&#x27;tab-body-div&#x27;); // 遍历标签的元素对象,为每个标签元素对象添加鼠标滑过事件 for(var i in tabs)&#123; //遍历 tabs[i].onmouseover = function()&#123; //加事件 for(var j in tabs)&#123; //再次遍历 if(tabs[j]==this)&#123; //判断当前，加current tabs[j].classList.add(&#x27;current&#x27;); divs[j].classList.add(&#x27;current&#x27;); &#125;else&#123; //非当前，去current tabs[j].classList.remove(&#x27;current&#x27;); divs[j].classList.remove(&#x27;current&#x27;); &#125; &#125; &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; DOM节点操作 文档中的所有内容，称为节点。 根据作用，划分为：标签节点、文本节点和属性节点。 获取节点12345document.getElementById（）element.firstChild()element.lastChild()element.parentNode()element.childNodes() 属性 说明 firstChild 访问当前节点的首个子节点 lastChild 访问当前节点的最后一个子节点 nodeName 访问当前节点名称 nodeValue 访问当前节点的值 nextSibiling 返回同ff一树层级中指定节点之后紧跟的节点（下一个兄弟） previousSibling 返回同ff一树层级中指定节点的前一个节点（前一个兄弟） parentNode 访问当前元素节点的父节点 childNodes 访问当前元素节点的所有子节点集合（含回车符，返回NodeList） childNodes属性用于节点操作，返回NdeList对象的集合，包括回车符、文本节点等其他类型的节点 children属性用于元素操作，返回HTMLCollection对象的集合，不包括文本节点等其他类型的节点 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id=&quot;ul1&quot;&gt; &lt;li&gt;JS&lt;/li&gt; &lt;li&gt;BOM&lt;/li&gt; &lt;li&gt;DOM&lt;/li&gt; &lt;!--注释--&gt; &lt;/ul&gt;&lt;script&gt; var ul1 = document.getElementById(&quot;ul1&quot;); console.log(&quot;1--nodeName--&quot; + ul1.nodeName); console.log(&quot;2--nodeValue--&quot; + ul1.nodeValue); var txt1 = ul1.firstChild; console.log(&quot;3--nodeName--&quot; + txt1.nodeName); console.log(&quot;4--nodeValue--&quot; + txt1.nodeValue); var li1 = txt1.nextSibling; console.log(&quot;5--nodeName--&quot; + li1.nodeName); console.log(&quot;6--nodeValue--&quot; + li1.nodeValue); var txtJS = li1.firstChild.nodeValue; console.log(&quot;7--txtJS--&quot; + txtJS); console.log(&quot;8--&quot; + li1.nextSibling.nodeName); console.log(&quot;9--&quot; + ul1.childNodes.length); console.log(&quot;10--&quot; + ul1.children.length);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 节点追加 方法名 说明 document.createElement() 创建元素节点 document.createTextNode() 创建文本节点 document.createAttribute() 创建属性节点 appendChild() 在指定元素的子节点列表的末尾添加一个节点 insertBefore() 为当前节点增加一个子节点（插入到指定子节点之后） getAttributeNode() 返回指定名称的属性节点 setAttributeNode() 设置或者改变名称的属性节点 123456789101112131415161718192021&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot; /&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2 align=&#x27;center&#x27;&gt;Hello JS!&lt;/h2&gt; //JS实现 &lt;script&gt; var h2 = document.createElement(&#x27;h2&#x27;); var text = document.createTextNode(&#x27;hello JS&#x27;); var attr = document.createAttribute(&#x27;algin&#x27;); attr.value = &#x27;center&#x27;; h2.setAttributeNode(attr); h2.appendChild(text); document.body.appendChild(h2); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 删除节点 删除节点使用removeChild()和removeAttributeNode()实现，它们的返回值是被移出的元素节点或属性节点 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot; media=&quot;screen&quot;&gt; .strong&#123; font-weight:bolder; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;PHP&lt;/li&gt; &lt;li&gt;JavaScript&lt;/li&gt; &lt;li class=&quot;strong&quot;&gt;UI&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; //删除第3个li的文本 var li3 = document.getElementsByTagName(&quot;li&quot;)[2]; //获得元素 li var attr = li3.getAttributeNode(&#x27;class&#x27;); //通过li获得其名称为class的属性节点 li3.removeAttributeNode(attr); //删除li3的属性节点 //删除第3个li var ul = document.getElementsByTagName(&#x27;ul&#x27;)[0]; ul.removeChild(li3); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 折叠菜单123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;&quot;&gt; &lt;style type=&quot;text/css&quot; media=&quot;screen&quot;&gt; *&#123; margin:0; padding:0; list-style:none; font-size:14px; &#125; #nav&#123; margin:10px; text-align:center; line-height:25px; width:200px; &#125; .title&#123; background: #336699; color:#fff; border-bottom:1px solid #fff; cursor:pointer; &#125; .title1&#123; background:#888; color:#000; border-bottom:1px solid #666; cursor:pointer; &#125; .content li&#123; color:#336699; background:#ddd; border-bottom:1px solid #fff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;nav&quot;&gt; &lt;div id=&quot;menu1&quot; class=&quot;title&quot; onclick=&quot;showmenu(&#x27;1&#x27;)&quot;&gt;Ajax下载&lt;/div&gt; &lt;div id=&quot;list1&quot; class=&quot;content&quot; style=&quot;display:none&quot;&gt; &lt;!-- 探究：文档末 --&gt; &lt;ul&gt; &lt;li&gt;AAA&lt;/li&gt; &lt;li&gt;BBB&lt;/li&gt; &lt;li&gt;CCC&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id=&quot;menu2&quot; class=&quot;title&quot; onclick=&quot;showmenu(&#x27;2&#x27;)&quot;&gt;JQuery下载&lt;/div&gt; &lt;div id=&quot;list2&quot; class=&quot;content&quot; style=&quot;display:none&quot;&gt; &lt;ul&gt; &lt;li&gt;AAA&lt;/li&gt; &lt;li&gt;BBB&lt;/li&gt; &lt;li&gt;CCC&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; function showmenu(id)&#123; var list = document.getElementById(&quot;list&quot; + id); var menu = document.getElementById(&quot;menu&quot; + id); if(list.style.display==&#x27;none&#x27;)&#123; list.style.display=&#x27;block&#x27;; //用元素操作：样式 menu.setAttribute(&#x27;class&#x27;, &#x27;title1&#x27;); &#125;else&#123; list.style.display=&#x27;none&#x27;; menu.setAttribute(&#x27;class&#x27;, &#x27;title&#x27;); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","path":"page/js06.html","date":"01-15","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xiaoliblog.cn/tags/JavaScript/"}]},{"title":"JavaScript🌞BOM","text":"BOM JS组成 ECMAScript：JS基本语法、数组、函数和对象。 BOM：浏览器对象模型（Brower Object Model）。 DOM：文档对象模型（Document Object Model )。 BOM作用及结构图 浏览器对象：内置对象，实现JS操作浏览器窗口及窗口上的控件，实现用户和页面的动态交互。 BOM：浏览器对象模型。 window window对象是BOM中所有对象的核心，同时也是BOM中所有对象的父对象。 全局变量、函数、内置对象均能被window对象调用。 123456789var area = &#x27;Beijing&#x27;;function getArea()&#123; return this.area;&#125;console.log(window.area); //访问变量，输出结果：Beijingconsole.log(window.area()); //访问window对象的属性，输出结果为：Beijingconsole.log(getArea()); //调用自定义函数，输出结果：Beijingconsole.log(window.getArea()); //调用window对象的方法，输出结果：Beijingconsole.log(window.Number(area)); //调用内置函数，将变量area转换为数值型，输出结果：NaN 定义在全局作用域中的getArea()函数，函数体内的this关键字指向window对象。 对于window对象的属性和方法在调用时可以省略window，直接访问其属性和方法即可。 弹出对话框和窗口 输入对话框 1var str=prompt(&#x27;请输入测试的选项&#x27;,&#x27;用户名和密码&#x27;); 确认对话框 12345678910&lt;input type=&quot;button&quot; value=&quot;删除&quot; onclick=&quot;del()&quot;&gt;&lt;script&gt; function del()&#123; if(confirm(&#x27;确定要删除吗？&#x27;))&#123; //你按下了“确定”按钮 &#125;else&#123; //你按下了“取消”按钮 &#125; &#125;&lt;/script&gt; 打开与关闭窗口 1234open(URL,name,specs,replace);//name指定target属性或窗口的名称//specs设置浏览器窗口的特征（如大小、位置）//replace设置为true，表示替换浏览器历史中的当前条目,设置为false(默认值)，表示在浏览历史中创建新的条目 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;这是第一个页面&lt;/h2&gt; &lt;form action=&quot;test1 windowd对象的属性和方法_submit&quot; method=&quot;get&quot; accept-charset=&quot;utf-8&quot;&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; value=&quot;打开窗口&quot; onclick=&quot;openWin()&quot;&gt; &lt;/form&gt; &lt;script&gt; //第一组：对话框 // window.alert(&quot;alert&quot;); // console.log(&quot;confirm:&quot; + window.confirm(&quot;confirm&quot;)); //观察点击”确认“和”取消“两种情况的输出结果 // console.log(&quot;prompt:&quot; + window.prompt(&quot;prompt&quot;,100)); //第二组：窗口的打开与关闭 function openWin()&#123; window.open(&quot;test1 第二个页面.html&quot;,&quot;_blank&quot;,&#x27;width=400,height=200,left=200&#x27;); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 窗口位置和大小 定时器 通过window对象提供的方法实现在指定时间后执行特定操作，也可以让程序代码每隔一段时间执行一次，实现间歇操作。 方法 说明 setTimeout() 在指定的毫秒数后调用函数或执行一段代码 setInterval() 按照指定的周期(以毫秒计)来调用函数或执行一段代码 clearTimeout() 取消由setTimeout()方法设置的定时器 clearInterval() 取消由setInterval()方法设置的定时器 1234567891011121314//一次性定时器var timer = window.setTimeout(echoStr,3000); //echoStr定时调用的函数,3000为时间，单位毫秒function echoStr()&#123; console.log(&quot;Hello JS!&quot;);&#125;window.clearTimeout(timer); //周期性定时器var timer = window.setInterval(echoStr,3000); function echoStr()&#123; console.log(&quot;Hello JS!&quot;);&#125;window.clearInterval(timer); 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div&#123;width:50px;height:50px;border:1px solid #ccc;margin-left:5px;line-height:50px;text-align: center;color:red;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;timeDiv&quot;&gt;0&lt;/div&gt; &lt;form&gt; &lt;input type=&quot;button&quot; value = &quot;开始&quot; id=&quot;start&quot;/&gt; &lt;input type=&quot;button&quot; value = &quot;暂停&quot; id=&quot;pause&quot;/&gt; &lt;/form&gt; &lt;script&gt; var start = document.getElementById(&#x27;start&#x27;); var pause = document.getElementById(&#x27;pause&#x27;); var timeDiv = document.getElementById(&#x27;timeDiv&#x27;); var time = 0; start.onclick = function()&#123; timer = window.setInterval(startFun, 1000); &#125; pause.onclick = function()&#123; window.clearInterval(timer); &#125; function startFun()&#123; time++; timeDiv.innerHTML = time; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;限时秒杀&lt;/title&gt; &lt;style&gt; .box&#123;margin:0 auto;position:relative;background:url(images/flash_sale.png);width:702px;height:378px;&#125; .box div&#123;float:left;width:50px;height:50px;border:1px solid #ccc;margin-left:5px;line-height:50px;text-align: center;color:red;position:relative;top:260px;left:305px;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div id=&quot;s&quot;&gt;&lt;/div&gt; &lt;!-- 剩余的秒数 --&gt; &lt;/div&gt; &lt;script&gt; var s = 5; var timer = window.setInterval(myFun,1000); function myFun()&#123; document.getElementById(&#x27;s&#x27;).innerHTML = s + &#x27;秒&#x27;; s--; if(s&lt;0)&#123; window.clearInterval(timer); &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; location localtion对象可以更改当前用户中浏览器中访问的URL，实现新文档的载入、重载以及替换等功能。 每一个网页文件都有一个访问标记符，用于唯一标识它的访问位置，以便浏览器可以访问的，这个访问标记符称为URL(Uniform Resource Locator,统一资源定位符)。URL中包含了网络协议、服务器的主机名、端口号、资源名称字符串、参数以及锚点 1http:&#x2F;&#x2F;www.example.com:80&#x2F;web&#x2F;index.html?a&#x3D;3&amp;b&#x3D;4#res 更改URL location对象的方法 说明 assign() 载入一个新的文档 reload() 重新载入当前文档 replace 用新的文档替换当前文档 reload() 参数为true时，它会绕过缓存，从服务器上重新下载该文档，类似于浏览器中的刷新页面按钮 12345678910111213141516171819202122 &lt;input type=&quot;button&quot; value=&quot;载入新页面&quot; onclick=&quot;newPage()&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;刷新页面&quot; onclick=&quot;freshPage()&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;替换页面&quot; onclick=&quot;replacePage()&quot;&gt; &lt;p id=&quot;time&quot;&gt;&lt;/p&gt;&lt;script&gt; //获取并显示当前页面载入的时间 var ds=new Date(); var d=ds.getDate(); document.getElementById(&#x27;time&#x27;).innerHTML=t; //载入新的页面 function newPage()&#123; window.location.assign(&#x27;http://www.baidu.com&#x27;); &#125; //刷新页面 function freshPage()&#123; window.location.reload(true); &#125; //替换，不能后退 function replace()&#123; window.location.replace(‘http://www.baidu.com’); &#125;&lt;/script&gt; 获取URL参数 属性 说明 search 返回URL地址中的参数 hash 返回一个URL的锚部分 host 返回一个URL的主机名和端口 hostname 返回URL的主机名 href 返回完整的主机名 pathname 返回URL的路径名 port 返回一个URL服务器使用的端口号 protocol 返回一个URL协议 获取URL的指定部分：location.属性名 设置URL的指定部分：location.属性名 = 值 123456//假设用户在地址栏中访问:http://localhost/search.html?goods=books&amp;price=40location.search; //获取:&quot;?goods=books&amp;price=40&quot;//获取URL地址location.href;//设置URL地址location.href=&quot;http://www.baidu.com&quot;; 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;定时跳转&lt;/title&gt; &lt;style&gt; body&#123;background:gray;&#125; div&#123;margin:20px auto;width:350px;height:150px;border:1px solid #000;background:white;padding:10px;&#125; h2&#123;text-align:center;&#125; span&#123;font-size:150%;color:red;margin:0 10px;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;h2&gt;提交成功&lt;/h2&gt; &lt;a href=&quot;http://www.baidu.com&quot;&gt; &lt;span id=&quot;seconds&quot;&gt;3&lt;/span&gt;秒后系统会自动跳转，也可单击此链接跳转 &lt;/a&gt; &lt;/div&gt; &lt;script&gt; function timing(secs,url)&#123; var seconds=document.getElementById(&#x27;seconds&#x27;); seconds.innerHTML=--secs; if(secs&gt;0)&#123; setTimeout(&#x27;timing(&#x27;+secs+&#x27;,\\&#x27;&#x27;+url+&#x27;\\&#x27;)&#x27;,1000); &#125;else&#123; location.href=url; &#125; &#125;; timing(3,&#x27;http://www.baidu.com&#x27;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; history history对象可以对用户在浏览器中访问过的URL历史记录进行操作。但history不能直接获取用户浏览过的URL go()方法：当参数值是一个负整数时，表示“后退”指定的页数；当参数值是一个正整数时，表示“前进”指定的页数。 当go()方法的参数为1或-1时，与forward()和back()方法的作用相同。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//第一个页面&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;定时跳转&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;这是第一个页面&lt;/h1&gt; &lt;form&gt; &lt;input type=&quot;button&quot; value=&quot;前进&quot; id=&quot;qianjin&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;打开新页面&quot; id=&quot;dakai&quot; /&gt; &lt;/form&gt; &lt;script&gt; var qianjin = document.getElementById(&quot;qianjin&quot;); qianjin.onclick = function()&#123; window.history.forward(); //window.history.go(1); &#125; var dakai = document.getElementById(&quot;dakai&quot;); dakai.onclick = function()&#123; window.location.assign(&quot;u6 前进和后退2.html&quot;); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;//第二个页面&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;定时跳转&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;这是第二个页面&lt;/h2&gt; &lt;form&gt; &lt;input type=&quot;button&quot; id=&quot;houtui&quot; value=&quot;后退&quot;/&gt; &lt;/form&gt; &lt;script&gt; var houtui = document.getElementById(&#x27;houtui&#x27;); houtui.onclick = function()&#123; window.history.back(); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; navigator navigator对象提供了有关浏览器的信息。 screen 返回当前渲染窗口中与屏幕相关的属性信息，如屏幕的宽度和高度等。 红绿灯倒计时 分析红绿灯： ① 横向三色交通信号灯的亮灯的顺序一般为“绿-&gt;黄-&gt;红-&gt;绿”依次循环。 ② 亮灯时长需根据路口的实际情况等因素来考虑设置，如红灯亮设置为3秒，绿灯亮设置为5秒，黄灯亮设置为3秒。核心功能： 改变背景颜色 + 倒计时 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;红绿灯倒计时&lt;/title&gt; &lt;style&gt; .box&#123;width:250px;height:52px;padding:15px 30px;border:2px solid #ccc;border-radius:16px;margin:0 auto;&#125; .box .count&#123;width:60px;color:#666;font-size:280%;line-height:50px;padding-left:6px;margin-left:5px;border:1px solid #fff&#125; .box div&#123;margin-left:5px;float:left;width:50px;height:50px;border-radius:50px;border:1px solid #666;&#125; .gray&#123;background-color:#eee;&#125; .red&#123;background-color:red;&#125; .yellow&#123;background-color:yellow;&#125; .green&#123;background-color:#26ff00;&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; //编写HTML页面 &lt;div class=&quot;box&quot;&gt; &lt;div id=&quot;red&quot;&gt;&lt;/div&gt; &lt;div id=&quot;yellow&quot;&gt;&lt;/div&gt; &lt;div id=&quot;green&quot;&gt;&lt;/div&gt; &lt;div class=&quot;count&quot; id=&quot;count&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 获取红、黄、绿灯以及倒计时的元素对象 //lamp：整个红绿灯对象 var lamp = &#123; red: &#123; //red:lamp的成员,红灯对象 obj: document.getElementById(&#x27;red&#x27;), //obj:存储信号灯的元素对象 timeout: 3, //信号灯剩余亮灯时间 style: [&#x27;red&#x27;, &#x27;gray&#x27;, &#x27;gray&#x27;], //当红灯亮起时，红、黄、绿信号灯的背景颜色 next: &#x27;green&#x27; //红灯之后亮起的信号灯 &#125;, yellow: &#123; obj: document.getElementById(&#x27;yellow&#x27;), timeout: 3, style: [&#x27;gray&#x27;, &#x27;yellow&#x27;, &#x27;gray&#x27;], next: &#x27;red&#x27; &#125;, green: &#123; obj: document.getElementById(&#x27;green&#x27;), timeout: 5, style: [&#x27;gray&#x27;, &#x27;gray&#x27;, &#x27;green&#x27;], next: &#x27;yellow&#x27; &#125;, //创建红绿灯对象（增加设置信号灯背景颜色的函数） changeStyle(style) &#123; this.red.obj.className = style[0]; //根据参数，更改obj的样式名称，实现更改背景颜色 this.yellow.obj.className = style[1]; this.green.obj.className = style[2]; &#125; &#125;; var count = &#123; //根据参数，更改num的值，即更改倒计时时间 obj: document.getElementById(&#x27;count&#x27;), change: function(num) &#123; this.obj.innerHTML = (num &lt; 10) ? (&#x27;0&#x27; + num) : num; &#125; &#125;; //初始状态 -- 绿灯亮 var now = lamp.green; //用变量now记录当前状态 lamp.changeStyle(now.style); //设置信号灯的背景颜色 var timeout = now.timeout; //记录信号灯亮起时的时间 count.change(timeout); //设置倒计时时间 //改变时间 -- 定时器 window.setInterval(myfun,1000); function myfun()&#123; timeout--; //倒计时 if(timeout&gt;0)&#123; //倒计时时间未结束 count.change(timeout); //，刷新页面 &#125;else&#123; //倒计时时间结束 now = lamp[now.next]; //切换信号灯颜色 -- 注意：不能写为 now = now.next; 这样是将一个字符串如yellow赋值给now； lamp.changeStyle(now.style); timeout = now.timeout; count.change(timeout); &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","path":"page/js05.html","date":"01-15","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xiaoliblog.cn/tags/JavaScript/"}]},{"title":"JavaScript🌞对象","text":"对象 面向对象的特征主要可以概括为封装性、继承性、多态性。 自定义对象字面量{}创建对象1234567891011 var o1=&#123;&#125;; var o2=&#123;name:&#x27;Jim&#x27;&#125;; var o3=&#123;name:&#x27;Jim&#x27;,age:19,gender:&#x27;男&#x27;&#125;; var o4 = &#123; name: &#x27;Jim&#x27;, age: 19, gender: &#x27;男&#x27;, sayHello: function() &#123; console.log(&#x27;你好&#x27;); &#125;&#125;; 访问对象成员 对象名.属性; 对象名.方法名() 12o4.name;o4.sayHello(); 增加对象成员 引用不存在的成员，即增加成员 12345o4.tall=181;o4.introduce=function()&#123; console.log(o4.name+o4.tall);&#125;o4.introduce(); 可变成员名 如果对象的成员名不确定时，还可通过一个变量保存成员的名称，使用[]语法来实现可变成员名。成员名：字符串 12var key=&#x27;id&#x27;;o4[key]=123; 对象成员遍历 typeof：判断成员类型，function表示方法 访问方法：o4[i]() 访问属性：o4[i] 12345678for(var i in o4)&#123; console.log(typeof(o4[i])); if(typeof(o4[i])==&quot;function&quot;)&#123; o4[i](); //访问方法 &#125;else&#123; console.log(o4[i]); //访问属性 &#125;&#125; 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;动态增加对象成员&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form&gt; &lt;input id=&quot;key&quot; type=&quot;text&quot; value=&quot;name&quot;&gt; &lt;input id=&quot;val&quot; type=&quot;text&quot; value=&quot;Jack&quot;&gt; &lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;测试&quot;&gt; &lt;/form&gt; &lt;script&gt; var k = document.getElementById(&#x27;key&#x27;); var v = document.getElementById(&#x27;val&#x27;); var btn = document.getElementById(&#x27;btn&#x27;); var o = &#123;&#125;; //创建空对象 btn.onclick = function()&#123; //当点击btn时，调用匿名函数 o[k.value] = v.value; //增加属性，k的value为键、v的value为值 console.log(o); //打印对象 &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 深拷贝与浅拷贝 浅拷贝—复制快捷方式 12var o1 = &#123;name: &#x27;Jim&#x27;, age: 19, gender: &#x27;男&#x27;&#125;;var o2=o1; 深拷贝—复制文件本身 123456function deepCopy(obj)&#123; var o = &#123;&#125;; for(var k in obj)&#123; //假设k是简单的成员（不是对象） o[k] = obj[k]; &#125;&#125; this指向 使用new调用构造函数时，this指向新创建的对象 123456function Person(name,age)&#123; this.name = name; this.age = age;&#125;var o1 = new Person(“Jack”,18);var o2 = new Person(“Lily”,20); 将函数作为对象的方法调用，this指向该对象 12345678var obj = &#123; name:”Jack”, age:19, sayHello:function()&#123; console.log( this.name + “,” + this.age); &#125;&#125;;obj.sayHello(); 直接通过函数名调用函数，this指向全局对象window 1234function foo()&#123; return this;&#125;console.log(foo()===window); //true 内置对象String对象 成员 作用 length 获取字符串长度 charAt(index) 获取index位置的字符，位置从0开始 indexOf(searchValue) 获取seerchValue在字符串中首次出现的位置 lastIndexOf(searchValue) 获取seerchValue在字符串中最后出现的位置 substring(start[,end]) 截取从start位置到end位置之间的一个子字符串 substr(start[,length]) 截取从start位置开始到length长度的子字符串 toLowerCase() 获取字符串的小写形式 toUpperCase() 获取字符串的大写形式 split([separator[,limit]) 使用separator分隔符将字符串分隔成数组，limit用于限制数量 replace(str1,str2) 使用str2替换字符串中的str1，返回替换结果 1234567var name=&#x27;Administrator&#x27;;if(name.length&lt;3||name.length&gt;10)&#123; alert(&#x27;用户名必须在3~10之间&#x27;);&#125;if(name.toLowerCase().indexOf(&#x27;admini&#x27;)!== -1)&#123; //indexOf查找失败返回-1 alert(&#x27;用户名中不能包含敏感词：admin&#x27;);&#125; Number对象 Number对象用于处理整数、浮点数等数值，常用的属性和方法如下。 成员 作用 MAX_VALUE 在JavaScript中所能表示的最大数值（静态成员） MIN_VALUE 在JavaScript中所能表示的最小正值（静态成员） toFixed(digits) 使用定点表示法来格式化一个数值 123456var num=12345.6789;num.toFixed(); //四舍五入，不包括小数部分，返回结果：12345num.toFixed(1); //四舍五入，保留1位小数，返回结果：12345.7num.toFixed(6); //用0填充不足的小数位，返回结果：12345.678900num.MAX_VALUE;num.MIN_VALUE; Math对象 Math对象用于对数值进行数学运算。 成员 作用 PI 获取圆周率，结果为3.141592653589793 abs(x) 获取x的绝对值，可传入普通数值或是用字符串表示的数值 pow(base,xponent) 获取基数(base)的指数(exponent)次幂，即baseexponnet sqrt(x) 获取x的平方根 ceil(x) 获取大于或等于x的最小整数，即向上取整 floor(x) 获取小于或等于x的最大整数，即向下取整 round(x) 获取x的四舍五入后的整数值 random() 获取大于或等于0.0且小于1.0的随机值 123456var num=10.88;Math.ceil(num);Math.random();//Math.floor( Math.random() * (max-min+1) + min)，生成[min,max]的随机整数。Math.random()*(3-1+1)+1; //[1,3] //Math.random()*(Max-Min+1)+MinMath.random()*(99-88)+88; //[88,99) //Math.random()*(Max-Min)+Min Date对象 Date对象用于处理日期和时间。 成员 作用 getFullYear() 获取表示年份的4位数字，如2020 setFullYear(value) 设置年份 getMonth() 获取月份，范围0~11（0表示一月，1表示二月，依次类推） setMonth(value) 设置月份 getDate() 获取月份中的某一天，范围1~31 setDate(value) 设置月份中的某一天 getDay() 获取星期，范围0~6（0表示星期日，1表示星期一，依次类推） getHours() 获取小时数，返回0~23 setHours(value) 设置小时数 getMinutes() 获取分钟数，范围0~59 setMinutes(value) 设置分钟数 getSeconds() 获取秒数，范围0~59 setSeconds(value) 设置秒数 getMilliseconds() 获取毫秒数，范围0~999 getMilliseconds(value) 设置毫秒数 getTime() 获取从1970-01-01 00:00:00 距离Date对象所代表时间 12345678910var date=new Date();document.write(date+&quot;&lt;br&gt;&quot;);console.log(&quot;年：&quot;+date.getYear()); //年：120console.log(&quot;年：&quot;+date.getFullYear()); //年：2020console.log(&quot;月：&quot;+date.getMonth()); //月：9console.log(&quot;日：&quot;+date.getDate()); //日：15console.log(&quot;时：&quot;+date.getHours()); //时：8console.log(&quot;分：&quot;+date.getMinutes()); //分：52console.log(&quot;秒：&quot;+date.getSeconds()); //秒：54console.log(&quot;周几：&quot;+date.getDay()); //周几：4 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;制作年历&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body&#123; text-align:center; &#125; .box&#123; margin:0 auto; width:880px; &#125; .title&#123; background:#ccc; &#125; table&#123; height:200px; width:200px; font-size:12px; text-align:center; float:left; /*浮动属性，脱离文档流，向左移动，直至遇到父元素或另一个浮动元素的边缘*/ margin:10px; font-family:Arial; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; /*定义年历生成函数*/ function calendar(y)&#123; //y：从网页获取到的年份 //获取指定年份1月1日的星期数值 var w = new Date(y,0).getDay(); //Date创建方式1： var date1 = new Date(2017,9,1,11,53,4);年月日时分秒，至少给出年和月；另外月的范围是0~11，即参数为0，实际月份为1月；//Date创建方式2： var date2 = new Date(&#x27;2017-10-01 11:53:04&#x27;); //getDay() 获取星期，范围0~6 var html=&#x27;&lt;div class=&quot;box&quot;&gt;&#x27;; //拼接每个月份的表格 for(var m=1;m&lt;=12;m++)&#123; html += &#x27;&lt;table&gt;&#x27;; html += &#x27;&lt;tr class=&quot;title&quot;&gt;&lt;th colspan=&quot;7&quot;&gt;&#x27; + y + &#x27; 年 &#x27; + m + &#x27; 月&lt;/th&gt;&lt;/tr&gt;&#x27;; html += &#x27;&lt;tr&gt;&lt;td&gt;日&lt;/td&gt;&lt;td&gt;一&lt;/td&gt;&lt;td&gt;二&lt;/td&gt;&lt;td&gt;三&lt;/td&gt;&lt;td&gt;四&lt;/td&gt;&lt;td&gt;五&lt;/td&gt;&lt;td&gt;六&lt;/td&gt;&lt;/tr&gt;&#x27;; //获取月份m共有多少天？ var max = (new Date(y,m,0)).getDate(); //getDate获取月份中的某一天，范围1~31；当日为0时，可获得该月的天数。 //开始tr标签 html = html+&#x27;&lt;tr&gt;&#x27;; for(var d=1;d&lt;=max;d++)&#123; if((w!=0) &amp;&amp; (d==1))&#123; //如果该月的第一天不是星期日，则填充空白 html = html+&#x27;&lt;td colspan=&quot;&#x27; + w + &#x27;&quot;&gt;&lt;/td&gt;&#x27;; &#125; html = html + &#x27;&lt;td&gt;&#x27; + d + &#x27;&lt;/td&gt;&#x27;; if(w==6 &amp;&amp; d!=max)&#123; //如果星期六不是该月的最后一天，则换行 html = html + &#x27;&lt;/tr&gt;&lt;tr&gt;&#x27;; &#125;else if(d==max)&#123; //该月的最后一天，闭合&lt;tr&gt;标签 html = html + &#x27;&lt;/tr&gt;&#x27;; &#125; w = (w+1&gt;6)?0:w+1; &#125; html = html + &#x27;&lt;/table&gt;&#x27;; &#125; html = html + &#x27;&lt;/div&gt;&#x27;; return html; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var year = parseInt(prompt(&#x27;输入年份:&#x27;,&#x27;2019&#x27;)); document.write(calendar(year)); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JSON JSON: JavaScript Object Notation(JavaScript 对象表示法)。 JSON 是轻量级的文本数据交换格式，类似 XML，但 比 XML 更小、更快，更易解析。 JSON 独立于语言和平台，目前非常多的动态（PHP，JSP，.NET）编程语言都支持JSON。 JSON对象123456//JSON对象var obj = &#123;“name”:“Jerry”，“age”:15&#125; //JS对象var obj = &#123;name:“Jerry”，age:15， sayHello:function&#123;……&#125;&#125; JSON对象的属性名（key）必须被包含在双引号之中，而JavaScript对象除了有空格的属性名、中间有连字符-的属性名必须在双引号之中外，其它随意； 不能在JSON对象中定义方法，而在JavaScript对象中可以； JSON对象可以被很多语言操作，而JavaScript对象只有JS自己可以识别。 JSON数组1234567var myJson =&#123; &quot;country&quot;:&quot;China&quot;, &quot;population&quot;:&quot;1.3billion&quot;, &quot;bigCity&quot;:[&quot;Peking&quot;,&quot;Shanghai&quot;,&quot;ShenZhen&quot;,&quot;HongKong&quot;] &#125; myJson .bigCity[0] = &quot;GuangZhou&quot;;&#125;","path":"page/js04.html","date":"01-15","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xiaoliblog.cn/tags/JavaScript/"}]},{"title":"JavaScript🌞函数","text":"函数 函数封装一段完成特定功能的代码。 12345678910function 函数名([参数1, 参数2, ……])&#123; 函数体……&#125;function maxNum(a, b) &#123; a = parseInt(a); b = parseInt(b); return a &gt;= b ? a : b;&#125; 123456789101112131415161718192021222324252627282930&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;大小写转换&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;大小写转换&lt;/h2&gt;&lt;p&gt;原数据:&lt;input id=&quot;old&quot; type=&quot;text&quot;&gt;&lt;/p&gt;&lt;p&gt;操&amp;nbsp;&amp;nbsp;作&lt;input type=&quot;button&quot; value=&quot;转大写&quot; onClick=&quot;deal(&#x27;upper&#x27;)&quot;&gt;&lt;input type=&quot;button&quot; value=&quot;转小写&quot; onClick=&quot;deal(&#x27;lower&#x27;)&quot;&gt;&lt;/p&gt;&lt;p&gt;新数据:&lt;input id=&quot;new&quot; type=&quot;text&quot;&gt;&lt;/p&gt;&lt;script&gt;function deal(opt)&#123; var str=document.getElementById(&#x27;old&#x27;).value; //取元数据的值 switch(opt)&#123; case &#x27;upper&#x27;: str=str.toUpperCase(); break; case &#x27;lower&#x27;: str=str.toLowerCase(); break; &#125; document.getElementById(&#x27;new&#x27;).value=str; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 参数 开发时若不能确定函数的形参个数，可以不设置形参；之后通过arguments对象获取调用时传递的实参。 123456789function sum()&#123; console.log(arguments); var sum=0; for(var i in arguments)&#123; sum+=arguments[i]; &#125; return sum; &#125; document.write(sum(1,2,3,4,5)); 变量的作用域 全局变量：函数外声明，或者函数内省略var声明； 局部变量：函数体内用var声明。 块级变量：ES6提供的let关键字声明，仅在”{}”内有效。 匿名函数 匿名函数指没有函数名称的函数，可以避免全局变量的污染以及函数名的冲突问题。 12345678910111213141516//方式1：函数表达式中省略函数名var fn=function(num1,num2)&#123; return num1+num2;&#125;;fn(1,2);//方式2：自调用方式(function (num1,num2)&#123; return num1+num2;&#125;)(2,3);//方式3：处理事件document.body.onclick=function()&#123; alert(&#x27;Hi&#x27;);&#125;; 回调函数 回调函数指一个函数A作为参数传递给一个函数B，然后在B的函数体内调用函数A，称A为回调函数。其中，匿名函数常作为函数的参数传递，实现回调函数。 123456789101112131415&lt;script&gt; function cal(num1,num2,fn)&#123; return fn(num1,num2); &#125; console.log(cal(10,20,function(a,b)&#123; return a+b; &#125;) ); console.log(cal(10,20,function(a,b)&#123; return a*b; &#125;) );&lt;/script&gt; 闭包函数 JavaScript中内部函数可引用外部函数的变量，但是在函数外部则不能访问函数的内部变量和嵌套函数，此时就需要使用”闭包“。 ”闭包“指有权访问另一函数作用域内变量(局部变量)的函数。它主要的用途是以下两点： 可以在函数外部读取函数内部的变量 可以让变量的值始终保持在内存中 1234567891011121314151617&lt;script&gt;function fn()&#123; var times=0; var c=function()&#123; return ++times; &#125;; return c; &#125; var count=fn(); //保存fn()返回的函数，此时count就是一个闭包 console.log(count()); console.log(count()); console.log(count()); console.log(count()); console.log(count());//使用闭包函数实现了在全局作用域中访问局部变量times，并让其始终存储在内存中//运行结果：1，2，3，4，5&lt;/script&gt;","path":"page/js03.html","date":"01-15","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xiaoliblog.cn/tags/JavaScript/"}]},{"title":"JavaScript🌞数组","text":"数组创建数组1234567891011// 元素值类型为字符串var area = new Array(&#x27;Beijing&#x27;, &#x27;Shanghai&#x27;, &#x27;Shenzhen&#x27;);// 元素值类型为数值型var score = new Array(56, 68, 98, 44);// 元素值类型为混合型var mix = new Array(123, &#x27;abc&#x27;, null, true, undefined);// 空数组var arr1 = new Array(); 或 var arr2 = new Array;//使用“[]”创建数组var weather = [&#x27;wind&#x27;, &#x27;fine&#x27;]; var empty = []; 获取数组长度JavaScript数组长度可以动态改变 1234567// 获取数组长度var area = new Array(&#x27;Beijing&#x27;, &#x27;Shanghai&#x27;, &#x27;Shenzhen&#x27;);console.log(area.length);// 修改数组长度var area = new Array(&#x27;Beijing&#x27;, &#x27;Shanghai&#x27;, &#x27;Shenzhen&#x27;);area.length = 5; console.log(area);area.length = 1; console.log(area); 数组的遍历123456789// 元素值类型为字符串var area = new Array(&#x27;Beijing&#x27;, &#x27;Shanghai&#x27;, &#x27;Shenzhen&#x27;);// 遍历for(var i=0;i&lt;area.length;i++)&#123; console.log(area[i]);&#125;for(var i in area)&#123; console.log(area[i]);&#125; 数组元素的添加与删除 添加数组元素 1234var arr = [&#x27;Asa&#x27;,&#x27;Taylor&#x27;];arr[2] = &#x27;Tom&#x27;;arr[3] = &#x27;Jack&#x27;;console.log(arr); 修改数组元素 1234var arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;];arr[2] = 123;arr[3] = 456;console.log(arr); 元素的删除 123456var stu = [&#x27;Tom&#x27;, &#x27;Jimmy&#x27;, &#x27;Lucy&#x27;];console.log(stu); // 输出结果：(3) [&quot;Tom&quot;, &quot;Jimmy&quot;, &quot;Lucy&quot;]delete stu[1]; // 删除数组中第2个元素console.log(stu); // 输出结果：(3) [&quot;Tom&quot;, empty, &quot;Lucy&quot;] 二维数组 创建二维数组 1234// 使用Array对象创建数组var info = new Array(new Array(&#x27;Tom&#x27;, 13, 155),new Array(&#x27;Lucy&#x27;, 11, 152) );// 使用“[]”创建数组var num = [[1, 3], [2, 4]]; 遍历二维数组 1234567// 使用“[]”创建数组var num = [[1, 3], [2, 4]];//遍历数组for(var i in num)&#123; for(var j in num[i])&#123; console.log(num[i][j])); &#125;&#125; 常见数组方法栈和队列方法 方法名称 功能描述 push() 将一个或多个元素添加到数组的末尾，并返回数组的新长度。 unshift() 将一个或多个元素添加到数组的开头，并返回数组的新长度。 pop() 从数组的末尾移出并返回一个元素，若是空数组则返回undefined。 shift() 从数组的开头移出并返回一个元素，若是空数组则返回undefined。 push()和unshift()方法的返回值是新数组的长度。pop()和shift()方法返回的是移出的数组元素。 1234567var arr = [1,2,3,4];console.log(&quot;原数组：&quot; + arr);var last = arr.pop();console.log(&quot;末尾元素：&quot; + last + &quot;,移除后数组：&quot; + arr);var first = arr.shift();arr.push(5);arr.unshift(0); 检索方法 方法名称 功能描述 includes() 用于确定数组中是否含有某个元素，含有返回true，否则返回false。 Array.isArray() 用于确定传递的值是否是一个 Array，是返回true，不是返回false。 indexOf() 返回在数组中可以找到给定值的第一个索引，如果不存在，则返回-1 lastIndexOf() 返回指定元素在数组中的最后一个的索引，如果不存在则返回 -1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--首先：编写HTML页面，准备3个下拉菜单--&gt; &lt;form&gt; &lt;select id=&quot;sheng&quot;&gt; &lt;option value=&quot;-1&quot;&gt;请选择&lt;/option&gt; &lt;/select&gt; &lt;select id=&quot;shi&quot;&gt;&lt;/select&gt; select id=&quot;qu&quot;&gt;&lt;/select&gt; &lt;/form&gt; &lt;script type=&quot;text/javascript&quot;&gt; //省份数组 var shengArr=[&#x27;上海&#x27;, &#x27;江苏&#x27;, &#x27;河北&#x27;]; //市数组 var shiArr = [ [&#x27;上海市&#x27;], [&#x27;苏州市&#x27;, &#x27;南京市&#x27;, &#x27;扬州市&#x27;], [&#x27;石家庄&#x27;, &#x27;秦皇岛&#x27;, &#x27;张家口&#x27;]]; //区数组 var quArr=[ [ [&#x27;黄浦区&#x27;, &#x27;静安区&#x27;, &#x27;长宁区&#x27;, &#x27;浦东区&#x27;] ], [ [&#x27;虎丘区&#x27;, &#x27;吴中区&#x27;, &#x27;相城区&#x27;, &#x27;姑苏区&#x27;, &#x27;吴江区&#x27;], [&#x27;玄武区&#x27;, &#x27;秦淮区&#x27;, &#x27;建邺区&#x27;, &#x27;鼓楼区&#x27;, &#x27;浦口区&#x27;], [&#x27;邗江区&#x27;, &#x27;广陵区&#x27;, &#x27;江都区&#x27;] ], [ [&#x27;长安区&#x27;, &#x27;桥西区&#x27;, &#x27;新华区&#x27;, &#x27;井陉矿区&#x27;], [&#x27;海港区&#x27;, &#x27;山海关区&#x27;, &#x27;北戴河区&#x27;, &#x27;抚宁区&#x27;], [&#x27;桥东区&#x27;, &#x27;桥西区&#x27;, &#x27;宣化区&#x27;, &#x27;下花园区&#x27;] ] ]; //1. 定义函数，将data数组中的值，添加到obj这个select中 function createOption(obj,data)&#123; for(var i in data)&#123; //遍历数组 var op = new Option(data[i],i); //创建Option，data[i]为显示的文本，i为value obj.options.add(op); //将Option（op）添加到Select（obj） &#125; &#125; //2.调用函数，设置省份下拉菜单的值 var sheng = document.getElementById(&quot;sheng&quot;); createOption(sheng,shengArr); //3.调用函数，设置市下拉菜单的值 -- 联动 var shi = document.getElementById(&quot;shi&quot;); sheng.onchange=function()&#123; //清空市原有数据 shi.options.length = 0; //调用函数，设置市下拉菜单，注意下标为当前省的value createOption(shi,shiArr[sheng.value]); //5.省修改时，市修改（代码如上），区也应该随着修改，即需要调用第四步的函数 if(sheng.value!=-1)&#123; //编码严谨，考虑省选择的“请选择”，此时：区清空 shi.onchange(); &#125;else&#123; qu.options.length=0; &#125; &#125; //4.调用函数，设置区下拉菜单的值 -- 联动 var qu = document.getElementById(&#x27;qu&#x27;); shi.onchange=function()&#123; //清空区原有数据 qu.options.length = 0; //调用函数，设置区下拉菜单，注意下标为：一维sheng.value，二维shi.value createOption(qu,quArr[sheng.value][shi.value]); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 集合Map集合1234567891011//ES6 Map//学生的成绩，学生的名字//var name = [&quot;tom&quot;,&quot;jack&quot;,&quot;haha&quot;];//var score = [100,90,80]; &#x27;use strict&#x27;var map = new Map([&#x27;tom&#x27;,100],[&#x27;jack&#x27;,90],[&#x27;haha&#x27;,80])var name = mapp.get(&#x27;tom&#x27;) //通过key获得valuemap.set(&#x27;admin&#x27;,123); //增加一个值map.delete(&quot;tom&quot;); //删除一个值console.log(name); Set集合 Set：无序不重复的集合 12345&#x27;use strict&#x27;var set = new set([3,1,1,1,1]); //set可以去重set.add(2) //添加set.delete(1) //删除console.log(set.has(3)) //判断存在3 遍历 遍历数组 12345678 &#x27;use strict&#x27;var arr = [3,4,5]for(var x in arr)&#123; console.log(x) //打印出下标&#125;for(var x of arr)&#123; console.log(x) //打印出具体的值&#125; 遍历map 12345 &#x27;use strict&#x27;var map = new Map([&#x27;tom&#x27;,100],[&#x27;jack&#x27;,90],[&#x27;haha&#x27;,80])for(let x of map)&#123; console.log(x)&#125; 遍历set 1234var set = new Set([5,6,7])for(let x of set)&#123; console.log(x)&#125;","path":"page/js02.html","date":"01-15","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xiaoliblog.cn/tags/JavaScript/"}]},{"title":"JavaScript🌞语法基础","text":"JavaScript 网站推荐：JavaSript教程 || W3school||JavaScript 教程||JavaScript 标准参考教程（alpha） JavaScript是一种运行在浏览器中的解释型的编程语言。 在Web世界里，只有JavaScript能跨平台、跨浏览器驱动网页，与用户交互. JavaScript内嵌于HTML网页中,通过浏览器内置的JavaScript引擎直接编译，使静态转变成支持用户交互的页面程序。 语言 作用 说明 HTML 结构 从语义的角度，描述页面结构 CSS 样式 从审美的角度，美化页面 JavaScript 行为 从交互的角度，提升用户体验 引入方式 嵌入式直接编写在HTML文件中 123&lt;script type=&quot;text/javascript&quot;&gt; JavaScript语句&lt;/script&gt; 外链式保存在一个单独的文件中，用“js”作为文件扩展名,最好放在body标签的底部，可以减少对整个页面的下载影响 1&lt;script src=&quot;js/test.js&quot;&gt;&lt;/script&gt; 行内式将Javascript代码作为HTML标签的属性值使用 1&lt;a href=&quot;javascript:alert(&#x27;Hello&#x27;);&quot;&gt;test&lt;/a&gt; 异步加载 无论使用内嵌式还是外链式，页面的下载和渲染都会暂停，等待脚本执行完成后才会继续。为了降低阻塞问题对页面造成的影响，可以使用可选属性：async和defer,添加后，即使文件下载失败，也不会阻塞javascript代码的执行 asyncasync用于异步加载，即先下载文件，不阻塞其他代码执行，下载完成后再执行 1&lt;script src=&quot;http://js.test/file.js&quot; async&gt;&lt;/script&gt; deferdefer用于延后执行，即先下载文件，直到网页加载完成后再执行 1&lt;script src=&quot;http://js.test/file.js&quot; defer&gt;&lt;/script&gt; 输出语句 alert()弹出一个警告框 1alert(&quot;提示信息&quot;); console.log()在浏览器的控制台中输出内容(按F12) 1console.log(&#x27;你好！&#x27;); document.write()在HTML文档页面输出内容，也可以输出标签 1document.write(&#x27;&lt;b&gt;加粗文本&lt;/b&gt;&#x27;); prompt()弹出一个输入框 1var value=prompt(&quot;提示输入&quot;,&quot;默认值&quot;); 数据类型 JavaScript 只有五种基本数据类型（boolean null undefined number string）和一种复杂数据类型 Object 关于各种数据类型对布尔类型的转换关系。 数据类型 转换为 true 转换为 false boolean 类型 true false string 类型 任何非空字符串 “”(空字符串) number 类型 任何非零数字值（包括无穷大） 0、0.0 和 NaN Object 类型 任何对象 null undefined undefined NaN 表示不是一个数字 但是属于 number 类型，与任何值不相等包括自身 包装类型 在 JavaScript 语言中，原始类型与包装类型创建的数据在使用上没有任何差异 定义变量的两种方式 1234// 直接/字面量 量方式定义var bool = true;//构造函数方式var Bool = new Boolean(true); 三种包装类型分别是 布尔类型、数字类型、字符串类类型 123var Bool = new Boolean(true);var Num = new Number(100);var Str = new String(&quot;this is message&quot;); 判断包装类型不能使用 typeof 而是使用 instanceof 。语法结构变量名/对象名 instanceof 构造函数/数据类型 1console.log(Str instanceof String); 特殊类型undefined 得到 undefined 这个值的情况 声明变量但未初始化值时 12var msg;console.log(msg); 声明变量并初始化值为 undefined 时 12var msg1 = undefined;console.log(msg1); 函数中的 return 语句的默认返回值 函数中的 return 语句的返回值的设置为 undefined 访问某一对象中不存在的属性时 null null 是 5 个基本类型的一个，但是得到的类型是 object。这是 JavaScript 语言的历史遗留问题 / 当初设计的纰漏。所以当我们判断 null 类型时可以使用特殊方法 1console.log(Object.prototype.toString.call(null)); undefined 派生于 null。他们两个值相等但类型不等。 12console.log(undefined == null); // 结果true 说明值相等console.log(undefined === null); // 结果false 说明类型不等 类型转换 关键点 隐式类型转换 显式类型转换 JavaScript 官方规范 官方未提及 明确表明 执行效率 / 性能 优于显式转换 弱于隐式转换 难易程度 不易 容易 隐式类型转换 欲转换为 转换符号 说明 示例 布尔 !! 将数据转换为布尔类型，在数据前加 !! 即可 !!&quot;this is message&quot; 数字 + 将数据转换为数字类型，在数据前加 + 即可 +&quot;this is message&quot; 字符串 &quot;&quot;+ 将数据转换为字符串类型，与空字符串相加即可 (位置无关) &quot;&quot; + 100 如果存在字符串的话，按照字符串的拼接操作 没有字符串，而存在数字值的话，按照算数运算操作 显式类型转换 显示类型转换则是利用类型的构造方法 123456789// 转化为 boolean 类型console.log(typeof Boolean(&quot;this is message&quot;));console.log(typeof Boolean(100));// 转化为number类型console.log(typeof Number(&quot;100&quot;));console.log(typeof Number(true));// 转化为 string 类型console.log(typeof String(100));console.log(typeof String(true)); 关于转换为数字时 JavaScript 提供了提供了两个函数用户转换为 number 类型的整数和浮点数。 12console.log(parseInt(11.11));console.log(parseFloat(11.11)); 但需要注意的是：转换为整型即 parseInt 函数，如果包含小数则将小数部分舍掉，并不会四舍五入计算。 1234567891011console.log(&quot;100转化为&quot;, parseInt(&quot;100&quot;));console.log(&quot;100.55转化为&quot;, parseInt(&quot;100.55&quot;));console.log(&quot;100转化为&quot;, parseFloat(&quot;100&quot;));console.log(&quot;100.55转化为&quot;, parseFloat(&quot;100.55&quot;));/*输出结果为：100转化为 100100.55转化为 100100转化为 100100.55转化为 100.55*/ 关于转换为 string 类型 JavaScript 还提供一个 toString 方法。 1234var num = 100;var bool = true;console.log(typeof num.toString());console.log(typeof bool.toString()); 运算符基本运算 当数字与任意字符串都相加时相当于字符串拼接 1234console.log(100 + &quot;100&quot;);//结果为 100100console.log(100 + &quot;test&quot;);//结果为 100test 当数字与一个字符串类型的数字相减时就返回正确的结果，与非数字的字符串相见返回 NAN 1234console.log(100 - &quot;10&quot;);//结果为 90console.log(100 - &quot;test&quot;);//结果为NaN 乘法、除法与减法类似 12345678console.log(100 * &quot;test&quot;);//结果为 NaNconsole.log(100 * &quot;10&quot;);//结果为 1000console.log(100 / &quot;test&quot;);//结果为 NaNconsole.log(100 / &quot;10&quot;);//结果为 10 加法运算时，无论字符串是什么都会进行拼接；而减法、除法、乘法则会尽力转换字符串为 number 类型，如果无法转换结果为 NaN，否则返回运算结果 取余运算 当左边的操作数位正数时，那么结果也为正数 当左边的操作数位负数时，那么结果也为负数 12345678console.log(10 % 3);//结果为 1console.log(-10 % 3);//结果为 -1console.log(10 % -3);//结果为 1console.log(-10 % -3);//结果为 -1 自增运算 自增 (自减) 运算结果的确定其实很简单，因为 n++ 是 n=n+1 的简写，所以当加号在后边的时候 n++ 那么返回的是n，也就是直接返回结果在计算。反之，当 ++n 时返回的就是运算结果` 12345var n = 100;var result1 = n++;//result 的值为n的值 因为加号在后边，所以返回n而不是返回运算后的值console.log(result1, n);// result1为100 n为101 12345var n = 100;var result = ++n;//result 的值为n运算后的结果 因为加号在前边，所以返回n运算的结果console.log(result, n);// result为101 n为101 全等与不等运算 判断是否为 NaN 12console.log(isNaN(&#x27;test&#x27;));//NaN 只判断值而不判断类型 1234// 只判断值是否相等 相等返回true 不等返回falseconsole.log(2 == &quot;2&quot;); //true// 只判断值是否不等于 不等于返回true 等于返回falseconsole.log(2 != &quot;2&quot;); //false 即判断值也判断类型 1234// 判断值与类型是否全相同 全相同返回true 不全相同返回falseconsole.log(2 === &quot;2&quot;); //false// 判断值与类型是否不相同 不相同返回true 相同返回falseconsole.log(2 !== &quot;2&quot;); //true 流程控制选择结构 单分支结构 1234//单分支if(判断条件)&#123; 代码段&#125; 双分支结构 123456//双分支if(判断条件)&#123; 代码段1&#125;else&#123; 代码段2&#125; 多分支结构 123456//多分支if(条件1)&#123; 代码段1;&#125;else if(条件2)&#123; 代码段2;&#125; 1234567891011switch(表达式)&#123; case 值1: 代码段1; break; case 值1: 代码段1; break; ... default: 代码段n; &#125; 循环结构 while循环 123while(循环条件)&#123; 循环体&#125; do…while循环 123do&#123; 循环体&#125;while(循环条件); for循环 123for(初始条件;循环条件;迭代条件)&#123; 代码块&#125; froEach循环 1234var age = [12,3,4,5,12,3,14,213];age.forEach(function(value)&#123; console.log(value);&#125;) 跳转语句 break语句和continue语句 123456789101112131415//实现九九乘法表&lt;script&gt;document.write(&quot;&lt;h1&gt;九九乘法表&lt;/h1&gt;&quot;)document.write(&quot;&lt;table border=1px&gt;&quot;)for(var i=1;i&lt;10;i++)&#123; document.write(&quot;&lt;tr&gt;&quot;) for( var j=1;j&lt;i;j++)&#123; document.write(&quot;&lt;td&gt;&quot;) document.write(j+&quot;*&quot;+i+&quot;=&quot;+i*j); document.write(&quot;&lt;/td&gt;&quot;) &#125; document.write(&quot;&lt;/tr&gt;&quot;) &#125;&lt;/script&gt; 严格检查模式 ES6的特性 12345678910&#x27;use strict&#x27;// ES6局部变量，合法let str1 = &quot;我是合法的&quot;;// 非ES6局部变量，合法console.log(&quot;我是合法的&quot;)var str = &quot;我也是合法的&quot;;console.log(&quot;我也是合法的&quot;);// 全局变量，不合法，会被严格检查模式检查出来i = 6;console.log(&quot;严格检查模式可以检查全局变量&quot;)","path":"page/js01.html","date":"01-15","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://xiaoliblog.cn/tags/JavaScript/"}]},{"title":"JavaWeb🌍分页功能","text":"分页功能项目GitHub源码分享，源码下载后，需要修改对应的数据库和表名！ 对于MySQL8.*以上可能无法运行，需要进行相关操作 换成最近MySQL驱动包 url地址增加 参数 serverTimezone=UTC url地址 ；不识别，需要改成 &amp; mysql驱动包改com.mysql.cj.jdbc.Driver 设置MySQL时区： set global time_zone = ‘+8:00’; 项目总览 ORM映射数据库123create database student;use student;create table user(id int primary key auto_increment,name varchar(255),password varchar(255)); 实体类 Page实体类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//封装了页面Page信息package com.cheng.Bean;import java.util.List;public class Page &#123; // 页码索引 private int pageIndex; // 每页的容量 private int pageSize; // 总页数 private int pageCount; // 分页后的数据集合 private List&lt;?&gt; dataList; // 数据总条数 private int total; // 准备一个集合显示分页条数 private int[] bar; public int getPageIndex() &#123; return pageIndex; &#125; public void setPageIndex(int pageIndex) &#123; this.pageIndex = pageIndex; &#125; public int getPageSize() &#123; return pageSize; &#125; public void setPageSize(int pageSize) &#123; this.pageSize = pageSize; &#125; public int getPageCount() &#123; return pageCount; &#125; public void setPageCount(int pageCount) &#123; this.pageCount = pageCount; &#125; public List&lt;?&gt; getDataList() &#123; return dataList; &#125; public void setDataList(List&lt;?&gt; dataList) &#123; this.dataList = dataList; &#125; public int getTotal() &#123; return total; &#125; public void setTotal(int total) &#123; this.total = total; &#125; public int[] getBar() &#123; return bar; &#125; public void setBar(int[] bar) &#123; this.bar = bar; &#125; &#125; User实体类 1234567891011121314151617181920212223242526272829303132333435363738//封装了用户User的信息package com.cheng.Bean;public class User &#123; private int id ; private String name ; private String password ; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; &#125; Dao持久层接口 PageDao页面DAO接口 1234567891011//PageDao页面DAO接口package com.cheng.dao;import java.util.List;import com.cheng.Bean.User;public interface PageDao &#123; public int getCount(); public List&lt;User&gt; selectUserByPage(int begin, int pageSize);&#125; UserDao用户DAO接口 123456789101112131415//UserDao用户DAO接口package com.cheng.dao;import java.sql.SQLException;import com.cheng.Bean.User;public interface UserDao &#123; ////檢查用戶名和密碼是否匹配 public boolean selectPasswordByName(User user) ; //插入数据 public Boolean insert(User user) throws SQLException ; // 根据用户名称返回对象 public User selectUserByName(String name) throws SQLException ;&#125; 接口实现 PageDaoImpl 页面DAO实现类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//PageDaoImpl 页面DAO实现类package com.cheng.daoImpl;import java.sql.SQLException;import java.util.List;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanListHandler;import org.apache.commons.dbutils.handlers.ScalarHandler;import com.cheng.Bean.User;import com.cheng.dao.PageDao;import com.cheng.utils.C3p0Utils;import com.sun.org.apache.bcel.internal.generic.NEW;public class PageDaoImpl implements PageDao &#123; @Override public int getCount() &#123; int pageCount = 0; // // 创建QueryRunner对象 QueryRunner runner = new QueryRunner(C3p0Utils.getDataSource()); // 写SQL语句 String sql = &quot;select * from user&quot;; // 调用方法 List&lt;User&gt; list = null; try &#123; list = (List&lt;User&gt;) runner.query(sql, new BeanListHandler&lt;User&gt;(User.class)); pageCount = list.size() ; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return pageCount; &#125; public List&lt;User&gt; selectUserByPage(int begin, int pageSize) &#123; // 创建QueryRunner对象 QueryRunner runner = new QueryRunner(C3p0Utils.getDataSource()); // 写SQL语句 String sql = &quot;select * from user limit ?, ?&quot;; // 调用方法 List&lt;User&gt; list = null; try &#123; list = (List&lt;User&gt;) runner.query(sql, new BeanListHandler&lt;User&gt;(User.class),new Object[]&#123;begin, pageSize&#125;); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return list;&#125;&#125; UserDaoImpl 用户DAO接口实现类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//UserDaoImpl 用户DAO接口实现类package com.cheng.daoImpl;import java.sql.SQLException;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import com.cheng.Bean.User;import com.cheng.dao.UserDao;import com.cheng.utils.C3p0Utils;public class UserDaoImpl implements UserDao &#123; @Override public User selectUserByName(String name) throws SQLException &#123; // 创建QueryRunner对象 QueryRunner runner = new QueryRunner(C3p0Utils.getDataSource()); // 写SQL语句 String sql = &quot;select * from user where name=?&quot;; // 调用方法 User user = (User) runner.query(sql, new BeanHandler(User.class), new Object[] &#123; name &#125;); return user; &#125; @Override public Boolean insert(User user) throws SQLException &#123; // 创建QueryRunner对象 QueryRunner runner = new QueryRunner(C3p0Utils.getDataSource()); // 写SQL语句 String sql = &quot;insert into user (name,password) values (?,?)&quot;; // 调用方法 int num = runner.update(sql, new Object[] &#123; user.getName(), user.getPassword() &#125;); if (num &gt; 0) return true; return false; &#125; @Override public boolean selectPasswordByName(User user) &#123; // 创建QueryRunner对象 QueryRunner runner = new QueryRunner(C3p0Utils.getDataSource()); // 写SQL语句 String sql = &quot;select * from user where name=? and password=?&quot;; // 调用方法 User user_ = null; try &#123; user_ = (User) runner.query(sql, new BeanHandler(User.class),user.getName(),user.getPassword()); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; if(user_!=null) &#123; return true; &#125; return false; &#125;&#125; Service业务层接口 PageService 页面业务接口 12345678//PageService 页面业务接口package com.cheng.service;import com.cheng.Bean.Page;public interface PageService &#123; public Page findUserByPage(int pageIndex) ;&#125; UserService 用户业务接口 12345678910//UserService 用户业务接口package com.cheng.service;import com.cheng.Bean.User;public interface UserService &#123; public boolean registerUser(User st) ; public User findUserByName(String name) ; public boolean login(User user) ;&#125; 接口实现 PageServiceImpl 页面业务接口实现类 1234567891011121314151617181920212223242526272829303132333435363738//PageServiceImpl 页面业务接口实现类package com.cheng.serviceImpl;import java.util.List;import com.cheng.Bean.Page;import com.cheng.Bean.User;import com.cheng.dao.PageDao;import com.cheng.daoImpl.PageDaoImpl;import com.cheng.service.PageService;public class PageServiceImpl implements PageService &#123; @Override public Page findUserByPage(int pageIndex) &#123; PageDao pageDao = new PageDaoImpl() ; // 1、total总记录数 int total = 0; List&lt;User&gt; dataList = null; total = pageDao.getCount(); // 2、一页显示多少个数据 int pageSize = 3; // 3、计算总页数 int pageCount = total % pageSize == 0 ? (total / pageSize) : (total / pageSize) + 1; System.out.println(&quot;pageCount=&quot;+pageCount); // 当前页的开始检索的数据索引（start）为 （当前页码-1）*每页数据容量 dataList = pageDao.selectUserByPage((pageIndex - 1) * pageSize, pageSize); // 封装数据 Page page = new Page(); page.setTotal(total); page.setPageCount(pageCount); page.setPageIndex(pageIndex); page.setDataList(dataList); page.setPageSize(pageSize); return page; &#125;&#125; UserService 用户业务接口实现类 1234567891011121314151617181920212223242526272829303132333435363738394041424344//UserService 用户业务接口实现类package com.cheng.serviceImpl;import java.sql.SQLException;import com.cheng.Bean.User;import com.cheng.dao.UserDao;import com.cheng.daoImpl.UserDaoImpl;import com.cheng.service.UserService;public class UserServiceImpl implements UserService &#123; public boolean registerUser(User user) &#123; boolean flag = false ; UserDao stDao = new UserDaoImpl() ; try &#123; flag = stDao.insert(user) ; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return flag; &#125; @Override public User findUserByName(String name) &#123; UserDao userDao = new UserDaoImpl() ; User user = new User() ; try &#123; user = userDao.selectUserByName(name) ; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return user; &#125; @Override public boolean login(User user) &#123; // TODO Auto-generated method stub UserDao userDao = new UserDaoImpl() ; Boolean flag = userDao.selectPasswordByName(user); return flag; &#125;&#125; Servlet控制层 loginServlet 登录请求信息页面 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//loginServlet 登录请求信息页面package com.cheng.servlet;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import com.cheng.Bean.User;import com.cheng.service.UserService;import com.cheng.serviceImpl.UserServiceImpl;@WebServlet(&quot;/loginServlet&quot;)public class loginServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public loginServlet() &#123; super(); &#125; public void destroy() &#123; super.destroy(); // Just puts &quot;destroy&quot; string in log // Put your code here &#125; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(&quot;utf-8&quot;); User st = new User(); HttpSession session = request.getSession(); UserService ss = new UserServiceImpl(); st.setName(request.getParameter(&quot;name&quot;)); st.setPassword(request.getParameter(&quot;password&quot;)); boolean flag = ss.login(st); if(!flag) &#123; session.setAttribute(&quot;msg&quot;, &quot;Ture&quot;); request.getRequestDispatcher(&quot;/msg.jsp&quot;).forward(request, response); &#125; else &#123; session.setAttribute(&quot;msg&quot;, &quot;false&quot;); request.getRequestDispatcher(&quot;/msg.jsp&quot;).forward(request, response); &#125; &#125; public void init() throws ServletException &#123; // Put your code here &#125;&#125; LogoutServlet 注销处理 1234567891011121314151617181920212223242526272829303132333435//LogoutServlet 注销处理package com.cheng.servlet;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;public class LogoutServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public LogoutServlet() &#123; super(); // TODO Auto-generated constructor stub &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; HttpSession session = request.getSession() ; session.removeAttribute(&quot;st&quot;); response.sendRedirect(&quot;success.jsp&quot;); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub doGet(request, response); &#125;&#125; PageServlet 页面处理 12345678910111213141516171819202122232425262728293031323334353637//PageServlet 页面处理package com.cheng.servlet;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.cheng.Bean.Page;import com.cheng.service.PageService;import com.cheng.serviceImpl.PageServiceImpl;@WebServlet(&quot;/pageServlet&quot;)public class PageServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 接收页码 int pageIndex = Integer.parseInt(request.getParameter(&quot;pageIndex&quot;)); PageService productService = new PageServiceImpl(); Page page = productService.findUserByPage(pageIndex); request.setAttribute(&quot;page&quot;, page); try &#123; request.getRequestDispatcher(&quot;/list.jsp&quot;).forward(request, response); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; registerServlet 注册处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//registerServlet 注册处理package com.cheng.servlet;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import com.cheng.Bean.User;import com.cheng.service.UserService;import com.cheng.serviceImpl.UserServiceImpl;@WebServlet(&quot;/registerServlet&quot;)public class registerServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public registerServlet() &#123; super(); &#125; public void destroy() &#123; super.destroy(); // Just puts &quot;destroy&quot; string in log // Put your code here &#125; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(&quot;utf-8&quot;); User st = new User(); HttpSession session = request.getSession(); UserService ss = new UserServiceImpl(); st.setName(request.getParameter(&quot;name&quot;)); st.setPassword(request.getParameter(&quot;password&quot;)); ss.registerUser(st); session.setAttribute(&quot;st&quot;, st); request.getRequestDispatcher(&quot;/success.jsp&quot;).forward(request, response); &#125; public void init() throws ServletException &#123; // Put your code here &#125;&#125; validateServlet 验证处理 12345678910111213141516171819202122232425262728293031323334353637383940//validateServlet 验证处理package com.cheng.servlet;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.cheng.Bean.User;import com.cheng.service.UserService;import com.cheng.serviceImpl.UserServiceImpl;public class validateServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setCharacterEncoding(&quot;UTF-8&quot;); String name = request.getParameter(&quot;name&quot;); UserService us = new UserServiceImpl(); User user = us.findUserByName(name); if (user != null) &#123; // 表示已经存在这个用户 response.getWriter().print(&quot;&lt;font color=&#x27;red&#x27;&gt;用户名已经存在&lt;/font&gt; &quot;); &#125; else &#123; // 表示该用户不存在，可以注册 response.getWriter().println(&quot;&lt;font color=&#x27;green&#x27;&gt;用户名可以使用&lt;/font&gt; &quot;); &#125; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 数据库连接 创建C3p0类 12345678910111213//创建C3p0类package com.cheng.utils;import javax.sql.DataSource;import com.mchange.v2.c3p0.ComboPooledDataSource;public class C3p0Utils &#123; private static DataSource ds; static &#123; ds = new ComboPooledDataSource(); &#125; public static DataSource getDataSource() &#123; return ds; &#125;&#125; c3p0-config.xml配置 12345678910111213141516171819202122232425262728&lt;!--c3p0-config.xml--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;c3p0-config&gt; &lt;default-config&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt; jdbc:mysql://localhost:3306/student?characterEncoding=utf8 &lt;/property&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;checkoutTimeout&quot;&gt;30000&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;maxIdleTime&quot;&gt;30&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;100&lt;/property&gt; &lt;property name=&quot;minPoolSize&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;maxStatements&quot;&gt;200&lt;/property&gt; &lt;/default-config&gt; &lt;named-config name=&quot;itcast&quot;&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt; jdbc:mysql://localhost:3306/student?characterEncoding=utf8 &lt;/property&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;5&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;15&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; 前端界面1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!--list交互页面--&gt;&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;用户列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt;onload=function()&#123;// 如果当前页码为空，则首先查询一次if(&quot;$&#123;page.pageIndex&#125;&quot; == &quot;&quot; || &quot;$&#123;page.pageIndex&#125;&quot; == null)&#123;window.location.href=&quot;$&#123;pageContext.servletContext.contextPath&#125;/pageServlet?pageIndex=1&quot;;&#125;&#125;&lt;/script&gt;&lt;!-- 遍历显示用户信息 --&gt;&lt;table border=&quot;1&quot;&gt;&lt;c:forEach var=&quot;user&quot; items=&quot;$&#123;page.dataList&#125;&quot;&gt;&lt;tr&gt;&lt;td&gt; 用户名：$&#123;user.name&#125;&lt;/td&gt;&lt;/tr&gt;&lt;/c:forEach&gt;&lt;tr&gt;&lt;/tr&gt;&lt;/table&gt; &lt;!-- 上一页 --&gt;&lt;!-- 判断是否是第一页 --&gt;&lt;c:if test=&quot;$&#123;page.pageIndex == 1&#125;&quot;&gt;&lt;a href=&quot;javascript:void(0)&quot; aria-label=&quot;Previous&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;laquo;&lt;/span&gt;&lt;/a&gt;&lt;/c:if&gt;&lt;c:if test=&quot;$&#123;page.pageIndex != 1&#125;&quot;&gt;&lt;a href=&quot;$&#123;pageContext.servletContext.contextPath&#125;/pageServlet?pageIndex=$&#123;page.pageIndex-1&#125;&quot; aria-label=&quot;Previous&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;laquo;&lt;/span&gt;&lt;/a&gt;&lt;/c:if&gt; &lt;c:forEach begin=&quot;1&quot; end=&quot;$&#123;page.pageCount&#125;&quot; var=&quot;pageNum&quot;&gt;&lt;!-- 判断当前页 --&gt;&lt;c:if test=&quot;$&#123;page.pageIndex == pageNum&#125;&quot;&gt;&lt;a href=&quot;javascript:void(0)&quot;&gt;$&#123;pageNum&#125;&lt;/a&gt;&lt;/c:if&gt;&lt;c:if test=&quot;$&#123;page.pageIndex != pageNum&#125;&quot;&gt;&lt;a href=&quot;$&#123;pageContext.servletContext.contextPath&#125;/pageServlet?pageIndex=$&#123;pageNum&#125;&quot;&gt;$&#123;pageNum&#125;&lt;/a&gt;&lt;/c:if&gt;&lt;/c:forEach&gt; &lt;!-- 下一页 --&gt;&lt;!-- 判断当前页是否是最后一页 --&gt;&lt;c:if test=&quot;$&#123;page.pageIndex == page.pageCount&#125;&quot;&gt;&lt;a href=&quot;javascript:void(0)&quot; aria-label=&quot;Next&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;raquo;&lt;/span&gt;&lt;/a&gt;&lt;/c:if&gt;&lt;c:if test=&quot;$&#123;page.pageIndex != page.pageCount&#125;&quot;&gt;&lt;a href=&quot;$&#123;pageContext.servletContext.contextPath&#125;/pageServlet?pageIndex=$&#123;page.pageIndex+1&#125;&quot; aria-label=&quot;Next&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;raquo;&lt;/span&gt;&lt;/a&gt;&lt;/c:if&gt;&lt;!-- 分页结束 --&gt;&lt;/body&gt;&lt;/html&gt;","path":"page/JavaWeb13.html","date":"01-15","excerpt":"","tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://xiaoliblog.cn/tags/JavaWeb/"}]},{"title":"JavaWeb🌍文件上传和下载","text":"文件上传文件上传概述 实现web开发中的文件上传功能，需完成如下二步操作： 在web页面中添加上传输入项 在servlet中读取上传文件的数据，并保存到本地硬盘中 如何在web页面中添加上传输入项?&lt;input type=&quot;file&quot;&gt;标签用于在web页面中添加文件上传输入项，设置文件上传输入项时须注意： 必须要设置input输入项的name属性，否则浏览器将不会发送上传文件的数据； 必须把form的enctype属值设为multipart/form-data，设置该值后，浏览器在上传文件时，将把文件数据附带在http请求消息体中，并使用ＭＩＭＥ协议对上传的文件进行描述，以方便接收方对上传数据进行解析和处理。 如何在Servlet中读取文件上传数据，并保存到本地硬盘中? Request对象提供了一个getInputStream方法，通过这个方法可以读取到客户端提交过来的数据。但由于用户可能会同时上传多个文件，在servlet端编程直接读取上传数据，并分别解析出相应的文件数据是一项非常麻烦的工作； 为方便用户处理文件上传数据，Apache 开源组织提供了一个用来处理表单文件上传的一个开源组件（ Commons-fileupload ），该组件性能优异，并且其API使用极其简单，可以让开发人员轻松实现web文件上传功能，因此在web开发中实现文件上传功能，通常使用Commons-fileupload组件实现 使用Commons-fileupload组件实现文件上传，需要导入该组件相应的支撑jar包：Commons-fileupload和commons-io。commons-io 不属于文件上传组件的开发jar文件，但Commons-fileupload 组件从1.1 版本开始，它工作时需要commons-io包的支持。 准备工作 对于文件上传，浏览器在上传的过程中是将文件以流的形式提交到服务器端的 一般采用Apache的开源工具common-fileupload这个文件上传组件 common-fileupload是依赖于common-io这个包的，所以还需要下载这个包 Maven导入jar依赖 12345678910111213&lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt; 其他依赖 12345678910111213141516171819&lt;!--Servlet--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;!--JSP--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt; 文件上传对页面的要求 必须使用表单，而不能是超链接 表单的method必须是POST，而不能是GET，因为GET上传大小有限制 表单的enctype必须是multipart/form-data 在表单中添加file表单字段，即&lt;input type=&quot;file&quot; name=&quot;xxx&quot;/&gt; 12345678&lt;form action=&quot;$&#123;pageContext.request.contextPath &#125;/FileUploadServlet&quot;method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;br/&gt;文件1：&lt;input type=&quot;file&quot; name=&quot;file1&quot;/&gt;&lt;br/&gt;文件2：&lt;input type=&quot;file&quot; name=&quot;file2&quot;/&gt;&lt;br/&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/form&gt; fileupload工作流程 ServletFileUpload负责处理上传的文件数据，并将表单中的每个输入项封装成一个FileItem对象，在使用ServletFileUpload对象解析请求时需要DiskFileItemFactory对象 所以，我们需要在进行解析工作前构造好DiskFileItemFactory对象，通过ServletFileItem对象的构造方法或setFileItemFactory()设置ServletFileUpload对象的fileItemFactory属性 fileupload核心API DiskFileItemFactory工厂类 DiskFileItemFactory 是创建 FileItem 对象的工厂，这个工厂类常用方法： public DiskFileItemFactory(int sizeThreshold, java.io.File repository) 构造方法； public void setSizeThreshold(int sizeThreshold) 设置内存缓冲区的大小，默认值为10K。当上传文件大于缓冲区大小时， fileupload组件将使用临时文件缓存上传文件。 public void setRepository(java.io.File repository) 指定临时文件目录，默认值为当前用户的系统临时文件目录，可通过System.getProperty(“java.io.tmpdir”)打印查看； ServletFileUpload解析器 ServletFileUpload负责处理上传的文件数据，并将表单中的每个输入项封装成一个FileItem对象中，使用其parseRequest(HttpServletRequest)方法可以将通过表单中每一个HTML标签提交的数据封装成一个FileItem对象，然后以List列表的形式返回。使用该方法处理上传文件简单易用 常用方法有： boolean isMultipartContent(HttpServletRequest request) 判断上传表单是否为multipart/form-data类型； List parseRequest(HttpServletRequest request) 解析request对象，并把表单中的每一个输入项包装成一个fileItem 对象，并返回一个保存了所有FileItem的list集合； setFileSizeMax(long fileSizeMax) 设置上传文件的最大值； setSizeMax(long sizeMax) 设置上传文件总量的最大值； setHeaderEncoding(java.lang.String encoding) 设置编码格式； FileItem表单字段域对象 处理普通字段方法 说明 boolean isFormField() 判断是否为普通字段 String getFieldName() 返回表单字段（普通字段）名称 String getString() 返回普通字段的值 String getString(String encoding) 返回普通字段的值，并设置请求参数编码，常用于get提交 处理上传字段方法 说明 String getContentType() 返回表单请求类型，即request请求头中的Content-type的内容，可用来限制文件上传的类型 String getName() 返回文件名(全路径名：例如C:\\a.txt) InputStream getInputStream() 返回表单输入流对象 void write(File file) 将上传文件写入到磁盘 void delete() 删除该上传字段存储在磁盘上的临时文件 文件上传案例实现步骤 判断上传的文件是否为文件表单 创建文件保存路径和临时文件 创建DiskFileItemFactory对象，设置缓冲区大小和临时文件目录； 使用DiskFileItemFactory 对象创建ServletFileUpload对象，并设置上传文件的大小限制； 调用ServletFileUpload.parseRequest方法解析request对象，得到一个保存了所有上传内容的List对象； 对list进行迭代，每迭代一个FileItem对象，调用其isFormField方法判断是否是上传文件；如果为普通表单字段，则调用getFieldName、getString方法得到字段名和字段值；如果为上传文件，则调用getInputStream方法得到数据输入流，从而读取上传数据 细节处理 中文文件乱码问题 文件名中文乱码问题，可调用ServletUpLoader的setHeaderEncoding方法，或者设置request的setCharacterEncoding属性 临时文件的删除问题 由于文件大小超出DiskFileItemFactory.setSizeThreshold方法设置的内存缓冲区的大小时，Commons-fileupload组件将使用临时文件保存上传数据，因此在程序结束时，务必调用FileItem.delete方法删除临时文件； Delete方法的调用必须位于流关闭之后，否则会出现文件占用，而导致删除失败的情况； 文件上传注意事项 为保证服务器的安全，上传的文件应放在外界无法访问的目录下，如WEN-INF 为防止同名文件产生覆盖现象，要为文件指定一个唯一的文件名 要对上传文件的大小进行限制 限制上传文件的类型，收到文件时，判断文件名十分合法 显示上传进度 ProgressListener显示上传进度 1234567ProgressListener progressListener = new ProgressListener() &#123; public void update(long pBytesRead, long pContentLength, int pItems) &#123; System.out.println(&quot;到现在为止, &quot; + pBytesRead + &quot; 字节已上传，总大小为 &quot; + pContentLength); &#125;&#125;;upload.setProgressListener(progressListener); 以KB为单位显示上传进度 12345long temp = -1; //temp注意设置为类变量long ctemp = pBytesRead /1024; if (mBytes == ctemp) return; temp = mBytes; 编码实现 fileupload.jsp前端页面 12345678910111213141516171819202122&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page isELIgnored=&quot;false&quot;%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%-- 通过表单上传文件 get：上传文件的大小有限制 post：上传文件的大小没有限制--%&gt;&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/FileUploadServlet&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 上传用户：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;br/&gt; &lt;p&gt;&lt;input type=&quot;file&quot; name=&quot;file1&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;file&quot; name=&quot;file2&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=&quot;submit&quot;&gt; | &lt;input type=&quot;reset&quot;&gt;&lt;/p&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 主方法 FileUploadServlet用于处理发送的请求 采用封装的思想，把每一步的实现用方法封装，然后调用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.lzy.file;import org.apache.commons.fileupload.FileItem;import org.apache.commons.fileupload.FileUploadException;import org.apache.commons.fileupload.ProgressListener;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.commons.fileupload.servlet.ServletFileUpload;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.*;import java.util.List;import java.util.UUID;public class FileUploadServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //创建上传文件的保存路径，建议保存在WEB-INF路径下，安全，用户无法直接访问上传的文件； String uploadPath = this.getServletContext().getRealPath(&quot;WEB-INF/upload&quot;); File uploadFile = new File(uploadPath); if (!uploadFile.exists()) &#123; uploadFile.mkdir(); //创建这个目录 &#125; //缓存，临时文件 //临时路径，假如文件超过了预期大小，我们就该把他放到一个临时的文件中，过几天自动删除，或者提醒用户转存为永久 String tmpPath = this.getServletContext().getRealPath(&quot;WEB-INF/tmp&quot;); File tmpFile = new File(tmpPath); if (!tmpFile.exists()) &#123; tmpFile.mkdir(); //创建这个目录 System.out.println(&quot;创建了没有==============&quot;); &#125; try &#123; //1.创建DiskFileItemFactory对象,处理文件上传路径或者大小限制的 DiskFileItemFactory factory = getDiskFileItemFactory(tmpFile); //2.获取ServletFileUpload,设置上传文件的大小限制； ServletFileUpload upload = getServletFileUpload(factory); //处理上传文件 String msg = uploadParseRequest(upload, req, uploadPath); //servlet请求消息转发,用于发送结果信息 req.setAttribute(&quot;msg&quot;, msg); req.getRequestDispatcher(&quot;info.jsp&quot;).forward(req, resp); &#125; catch (FileUploadException e) &#123; e.printStackTrace(); &#125; &#125;&#125; getDiskFileItemFactory1234567public static DiskFileItemFactory getDiskFileItemFactory(File file) &#123; DiskFileItemFactory factory = new DiskFileItemFactory(); //通过这个工厂设置一个缓冲区，当上传的文件大于这个缓冲区的时候，将它放到临时文件中； factory.setSizeThreshold(1024 * 1024); //缓存区大小为1M factory.setRepository(file); //临时目录的保存目录，需要一个tmpFile return factory; &#125; getServletFileUpload(123456789101112131415161718public static ServletFileUpload getServletFileUpload(DiskFileItemFactory factory) &#123; ServletFileUpload upload = new ServletFileUpload(factory); //监听文件上传进度： upload.setProgressListener(new ProgressListener() &#123; public void update(long pBytesRead, long pContentLength, int pItems) &#123; System.out.println(&quot;总大小：&quot; + pContentLength + &quot;已上传：&quot; + pBytesRead); &#125; &#125;); //处理乱码问题 upload.setHeaderEncoding(&quot;UTF-8&quot;); //设置单个文件的最大值 upload.setFileSizeMax(1024 * 1024 * 10); //设置总共能够上传文件的大小 upload.setFileSizeMax(1024 * 1024 * 10); return upload; &#125; uploadParseRequest123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public static String uploadParseRequest(ServletFileUpload upload, HttpServletRequest req, String uploadPath) throws IOException, FileUploadException &#123; String msg = &quot;&quot;; //把前端请求解析，封装成一个FileItem对象 List&lt;FileItem&gt; fileItems = upload.parseRequest(req); //fileItem每一个表单对象 for (FileItem fileItem : fileItems) &#123; if (fileItem.isFormField()) &#123; //判断上传的文件是普通的表单还是带文件的表单 //getFileName指的是前端表单控件的name String name = fileItem.getFieldName(); String value = fileItem.getString(&quot;UTF-8&quot;); //处理乱码问题 System.out.println(name + &quot;:&quot; + value); &#125; else &#123; //判断它是上传的文件 //====================处理文件=================// //拿到文件名字 String uploadFileName = fileItem.getName(); System.out.println(&quot;上传的文件名：&quot; + uploadFileName); //可能存在文件名不合法的情况 if (uploadFileName.trim().equals(&quot;&quot;) || uploadFileName == null) &#123; continue; &#125; //获得上传的文件名 /images/girl/bilibili.png String fileName = uploadFileName.substring(uploadFileName.lastIndexOf(&quot;/&quot;) + 1); //获得文件的后缀名 String fileExtName = uploadFileName.substring(uploadFileName.lastIndexOf(&quot;.&quot;) + 1); /* 如果文件后缀名 fileExtName 不是我们所需要的 就直接return，不处理，告诉用户文件类型不对 */ System.out.println(&quot;文件信息[件名：&quot; + fileName + &quot;---文件类型&quot; + fileExtName + &quot;]&quot;); //可以使用UUID（唯一识别的通用码），保证文件名唯一； //UUID.randomUUID()，随机生成一个唯一识别的通用码； //网络传输中的东西，都需要序列化 //POJO，实体类，如果想要在多个点奶上运行， 传输==&gt;需要把对象都序列化了 //JNI = Java Native Interface //implement Serializable ： 标记接口， JVM---&gt;本地方法栈 native --&gt; C++ String uuidPath = UUID.randomUUID().toString(); //====================处理文件完毕=================// //====================存放地址=================// //存到哪？ uploadPath //文件真实存在的路径 realPath String realPath = uploadPath + &quot;/&quot; + uuidPath; //给每个文件创建一个对应的文件夹 File realPathFile = new File(realPath); if (!realPathFile.exists()) &#123; realPathFile.mkdir(); &#125; //====================文件传输=================// //获得文件上传的流 InputStream inputStream = fileItem.getInputStream(); //创建一个文件输出流 //realPath = 真实的文件夹 //差了一个文件；加上输出文件的名字 + &quot;/&quot; + uuidFileName FileOutputStream fos = new FileOutputStream(realPath + &quot;/&quot; + fileName); //创建一个缓冲区 byte[] buffer = new byte[1024 * 1024]; //判断是否读取完毕 int len = 0; //如果大于0说明还在存数据 while ((len = inputStream.read(buffer)) &gt; 0) &#123; fos.write(buffer, 0, len); &#125; //关闭流 fos.close(); inputStream.close(); msg = &quot;文件上传成功！&quot;; fileItem.delete(); //上传成功，清除临时文件 &#125; &#125; return msg; &#125; 运行结果 文件下载文件下载概述 程序实现下载需设置两个响应头， 设置Content-Typ 的值为：application/x-msdownload Web 服务器需要告诉浏览器其所输出的内容的类型不是普通的文本文件或 HTML 文件，而是一个要保存到本地的下载文件； Web 服务器希望浏览器不直接处理相应的实体内容，而是由用户选择将相应的实体内容保存到一个文件中，这需要设置 Content-Disposition 报头 该报头指定了接收程序处理数据内容的方式，在 HTTP 应用中只有 attachment 是标准方式，attachment 表示要求用户干预。在 attachment 后面还可以指定 filename 参数，该参数是服务器建议浏览器将实体内容保存到文件中的文件名称。在设置 Content-Dispostion 之前一定要指定 Content-Type 因为要下载的文件可以是各种类型的文件，所以要将文件传送给客户端，其相应内容应该被当做二进制来处理，所以应该调用response.getOutputStream()方法返回 ServeltOutputStream 对象来向客户端写入文件内容 123response.setContentType(&quot;application/x-msdownload&quot;) ;String str = &quot;attachment;filename=&quot; + java.net.URLEncoder.encode(fileName, &quot;UTF-8&quot;) ;response.setHeader(&quot;Content-Disposition&quot;, str) ; 12345678910InputStream is = new FileInputStream(file) ;OutputStream os = response.getOutputStream() ;int len = -1 ;byte[] buf = new byte[1024] ;while((len = is.read(buf)) != -1) &#123; os.write(buf, 0, len) ; os.flush() ;&#125;is.close() ;os.close() ; 下载案例 在开发项目中，有时候需要从服务端下载一个文件到本地，以此对这需求可以使用Response对象（HttpServletResponse）就可以实现文件的下载。（注：使用的服务器是tomcat） 下载文件实现思路 要获取下载文件的路径（用ServletContext的getRealPath方法获取+resources/Student.txt） 获取下载的文件名 再设置响应头(content-disposition)控制浏览器以下载的形式打开文件 然后使用InputStream获取下载的文件的输入流 创建数据缓冲区 通过response对象获取OutputStream流 将FileInputStream流写入byte数组即buffer缓存区 使用OutpuStream将byte数组的数据输出到浏览器 在resources文件夹下创建一个Student.txt的文件· 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.lzy.JavaWeb;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;public class FileServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.获取下载的文件路径（注意获取这里获取的是绝对路径，先获取ServletContext再使用ServletContext的getRealPath方法获取绝对路径） String realPath = this.getServletContext().getRealPath(&quot;/resources/Student.txt&quot;); System.out.println(&quot;下载文件第路径:&quot;+realPath); //2. 获取下载的文件名，通过字符串截取 String fileName = realPath.substring(realPath.lastIndexOf(&quot;\\\\&quot;) + 1); System.out.println(fileName); //3. 再设置响应头(content-disposition)控制浏览器以下载的形式打开文件 resp.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=&quot;+ fileName); InputStream in=null; OutputStream out=null; try &#123; //4. 然后使用InputStream获取下载的文件的输入流 in=new FileInputStream(realPath); //5. 创建数据缓冲区 int len=0; byte buffer[]=new byte[1024]; //6. 通过response对象获取OutputStream流 out=resp.getOutputStream(); //7. 将FileInputStream流写入byte数组即buffer缓存区 while((len=in.read(buffer))!=-1)&#123; //8. 使用OutpuStream将byte数组的数据输出到浏览器 out.write(buffer,0,len); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; if(in!=null)&#123; in.close(); &#125; &#125; &#125;&#125; 运行结果 参考👉JavaWeb之文件上传与下载详解👉JavaWeb实现文件上传下载功能实例详解","path":"page/JavaWeb12.html","date":"01-15","excerpt":"","tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://xiaoliblog.cn/tags/JavaWeb/"}]},{"title":"JavaWeb🌍Frame框架","text":"Frameset和Frame1234567&lt;frameset rows=&quot;20%,80%&quot; frameborder=yes bordercolor=&quot;green&quot;&gt; //top页面占20%，剩余页面占80% &lt;frame src=&quot;top.html&quot; noresize/&gt; //顶层页面，不可推动 &lt;frameset cols=&quot;20%,*&quot; &gt; //左页面占20%，余下为右页面 &lt;frame src=&quot;left.html&quot;/&gt; &lt;frame src=&quot;right.html&quot; /&gt; &lt;/frameset&gt;&lt;/frameset&gt; Frameset属性 说明 border 设置框架的边框粗细 bordercolor 设置框架的边框颜色 frameborder 设置是否显示框架边框。设定值只有0、1；0 表示不要边框，1 表示要显示边框。 cols 纵向分割页面。其数值表示方法有三种：“30%、30（或者30px）、*”；数值的个数代表分成的视窗数目且数值之间用“,”隔开。“30%”表示该框架区域占全部浏览器页面区域的30%；“30”表示该区域横向宽度为30像素；“*”表示该区域占用余下页面空间。例如：cols=”25%,200,*“ 表示将页面分为三部分，左面部分占页面30%，中间横向宽度为200像素，页面余下的作为右面部分。 rows 横向分割页面。数值表示方法与意义与cols相同 framespacing 设置框架与框架间的保留的空白距离 注意: 在使用frameset的使用就不要用body标签包裹了,一定要记住呀 Frame属性 说明 name 设置框架名称。此为必须设置的属性 src 设置此框架要显示的网页名称或路径,此为必须设置的属性 scrolling 设置是否要显示滚动条。设定值为auto, yes, no bordercolor 设置框架的边框颜色 frameborder 设置是否显示框架边框。设定值只有0、1；0 表示不要边框，1 表示要显示边框 noresize 设置框架大小是否能手动调节 marginwidth 设置框架边界和其中内容之间的宽度 marginhight 设置框架边界和其中内容之间的高度 width 设置框架宽度 height 设置框架高度 IFrame1234&lt;a href=&quot;http://www.sina.com.cn&quot; target=&quot;iframe1&quot;&gt;sina&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.163.com&quot; target=&quot;iframe1&quot;&gt;163&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.sohu.com&quot; target=&quot;iframe1&quot;&gt;sohu&lt;/a&gt;&lt;br/&gt;&lt;iframe name=&quot;iframe1&quot; src=&quot;http://www.sina.com.cn&quot; width=500 height=500/&gt; 区别 frame不能脱离frameSet单独使用，iframe可以； frame不能放在body中； 如下可以正常显示： 123456&lt;!--&lt;body&gt;--&gt; &lt;frameset rows=&quot;50%,*&quot;&gt; &lt;frame name=&quot;frame1&quot; src=&quot;test1.htm&quot;/&gt; &lt;frame name=&quot;frame2&quot; src=&quot;test2.htm&quot;/&gt; &lt;/frameset&gt; &lt;!--&lt;body&gt;--&gt; 如下不能正常显示： 123456&lt;body&gt; &lt;frameset rows=&quot;50%,*&quot;&gt; &lt;frame name=&quot;frame1&quot; src=&quot;test1.htm&quot;/&gt; &lt;frame name=&quot;frame2&quot; src=&quot;test2.htm&quot;/&gt; &lt;/frameset&gt; &lt;body&gt; 相反，假如iframe放在frameSet属性下面，则必需放在body中 123456&lt;body&gt; &lt;frameset&gt; &lt;iframe name=&quot;frame1&quot; src=&quot;test1.htm&quot;/&gt; &lt;iframe name=&quot;frame2&quot; src=&quot;test2.htm&quot;/&gt; &lt;/frameset&gt; &lt;/body&gt; iframe是一个html标签，在html中任何地方，都可以随意使用，而frame不可以。 123456789&lt;body&gt; &lt;iframe name=&quot;frame1&quot; src=&quot;test1.htm&quot;/&gt; &lt;iframe name=&quot;frame2&quot; src=&quot;test2.htm&quot;/&gt; &lt;/body&gt;&lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;iframe id=&quot;&quot; src=&quot;&quot;&gt;&lt;/iframe&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 而frame必须嵌套在frameSet中，且不能再table等标签中使用。 frame的高度只能通过frameSet控制；iframe可以自己控制，不能通过frameSet控制 123456789101112&lt;!--&lt;body&gt;--&gt; &lt;frameset rows=&quot;50%,*&quot;&gt; &lt;frame name=&quot;frame1&quot; src=&quot;test1.htm&quot;/&gt; &lt;frame name=&quot;frame2&quot; src=&quot;test2.htm&quot;/&gt; &lt;/frameset&gt; &lt;!--&lt;/body&gt;--&gt; &lt;body&gt; &lt;frameset&gt; &lt;iframe height=&quot;30%&quot; name=&quot;frame1&quot; src=&quot;test1.htm&quot;/&gt; &lt;iframe height=&quot;100&quot; name=&quot;frame2&quot; src=&quot;test2.htm&quot;/&gt; &lt;/frameset&gt; &lt;/body&gt; 如果在同一个页面使用了两个以上的iframe，在IE中可以正常显示，在firefox中只能显示出第一个；使用两个以上的frame在IE和firefox中均可正常 实例 FrameDemo_A.html 12345678910111213&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt; &lt;title&gt;FrameDemo_A.html&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor = &quot;silver&quot;&gt;这里是 AAAAAAAAAAAAAAAAAA&lt;/body&gt;&lt;/html&gt; FrameDemo_B.html 12345678910111213&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt; &lt;title&gt;FrameDemo_B.html&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor = &quot;silver&quot;&gt;这里是 BBBBBBBBBBBBBBBBBBB&lt;/body&gt;&lt;/html&gt; FrameDemo_left.html 12345678910111213141516171819202122&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt; &lt;title&gt;FrameDemo_left.html&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor = &quot;pink&quot;&gt;&lt;ul&gt;&lt;li&gt;&lt;a href = &quot;A.html&quot; target = &quot;myframe&quot;&gt;A&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href = &quot;B.html&quot; target = &quot;myframe&quot;&gt;B&lt;/a&gt;&lt;/li&gt;&lt;!--这里target的属性值是 frame中的name值--&gt;&lt;/ul&gt;&lt;/body&gt;&lt;!--_blank:新窗口_self:本窗口_parent:父窗口_top: 整个浏览器窗口--&gt;&lt;/html&gt; FrameDemo_right.html 12345678910111213&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt; &lt;title&gt;FrameDemo_right.html&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor = &quot;silver&quot;&gt;Right&lt;/body&gt;&lt;/html&gt; FrameDemo_top.html 12345678910&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt; &lt;title&gt;FrameDemo_top.html&lt;/title&gt;&lt;/head&gt;&lt;b&gt;这里是Top&lt;/b&gt;&lt;/html&gt; FrameDemo_iframe.html 12345678910111213141516&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt; &lt;title&gt;FrameDemo_iframe.html&lt;/title&gt;&lt;/head&gt;&lt;frameset rows = &quot;10%,*&quot;&gt; &lt;frame src = &quot;top.html&quot; /&gt; &lt;frameset cols = &quot;20%,*&quot;&gt; &lt;frame src = &quot;left.html&quot; frameborder = &quot;1&quot;&gt; &lt;frame src = &quot;right.html&quot; name = &quot;myframe&quot; frameborder = &quot;0&quot;&gt; &lt;/frameset&gt;&lt;/frameset&gt;&lt;/html&gt;","path":"page/JavaWeb11.html","date":"01-15","excerpt":"","tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://xiaoliblog.cn/tags/JavaWeb/"}]},{"title":"JavaWeb🌍Ajax异步检测","text":"Ajax异步检测 Ajax异步检测用户名是否存在 项目总览： ORM映射数据库搭建123create database student;use student;create table user(id int primary key auto_increment,name varchar(255),password varchar(255)); 实体类1234567891011121314151617181920212223242526272829303132333435363738//封装User信息package com.cheng.Bean;public class User &#123; private int id ; private String name ; private String password ; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; &#125; Dao持久层接口12345678910111213//创建Dao接口package com.cheng.dao;import java.sql.SQLException;import com.cheng.Bean.User;public interface UserDao &#123; // 插入数据 public Boolean insert(User user) throws SQLException ; // 根据用户名称返回对象 public User selectUserByName(String name) throws SQLException ;&#125; 接口实现123456789101112131415161718192021222324252627282930313233343536373839//创建Dao实现类package com.cheng.daoImpl;import java.sql.SQLException;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import com.cheng.Bean.User;import com.cheng.dao.UserDao;import com.cheng.utils.C3p0Utils;public class UserDaoImpl implements UserDao &#123; @Override public User selectUserByName(String name) throws SQLException &#123; // 创建QueryRunner对象 QueryRunner runner = new QueryRunner(C3p0Utils.getDataSource()); // 写SQL语句 String sql = &quot;select * from user where name=?&quot;; // // 调用方法 User user = (User) runner.query(sql, new BeanHandler(User.class), new Object[] &#123; name &#125;); return user; &#125; @Override public Boolean insert(User user) throws SQLException &#123; // 创建QueryRunner对象 QueryRunner runner = new QueryRunner(C3p0Utils.getDataSource()); // 写SQL语句 String sql = &quot;insert into user (name,password) values (?,?)&quot;; // 调用方法 int num = runner.update(sql, new Object[] &#123; user.getName(), user.getPassword() &#125;); if (num &gt; 0) return true; return false; &#125;&#125; Service业务层接口123456789//创建Service业务层接口package com.cheng.service;import com.cheng.Bean.User;public interface UserService &#123; public boolean registerUser(User st) ; public User findUserByName(String name) ;&#125; 接口实现12345678910111213141516171819202122232425262728293031323334353637//创建Service业务接口实现类package com.cheng.serviceImpl;import java.sql.SQLException;import com.cheng.Bean.User;import com.cheng.dao.UserDao;import com.cheng.daoImpl.UserDaoImpl;import com.cheng.service.UserService;public class UserServiceImpl implements UserService &#123; public boolean registerUser(User user) &#123; boolean flag = false ; UserDao stDao = new UserDaoImpl() ; try &#123; flag = stDao.insert(user) ; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return flag; &#125; @Override public User findUserByName(String name) &#123; UserDao userDao = new UserDaoImpl() ; User user = new User() ; try &#123; user = userDao.selectUserByName(name) ; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return user; &#125;&#125; Servlet控制层 注销Servlet程序 1234567891011121314151617181920212223242526272829303132//注销Servlet程序package com.cheng.servlet;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;public class LogoutServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public LogoutServlet() &#123; super(); // TODO Auto-generated constructor stub &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; HttpSession session = request.getSession() ; session.removeAttribute(&quot;st&quot;); response.sendRedirect(&quot;success.jsp&quot;); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub doGet(request, response); &#125;&#125; 注册Servlet程序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//注册Servlet程序package com.cheng.servlet;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import com.cheng.Bean.User;import com.cheng.service.UserService;import com.cheng.serviceImpl.UserServiceImpl;public class registerServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public registerServlet() &#123; super(); &#125; public void destroy() &#123; super.destroy(); // Just puts &quot;destroy&quot; string in log // Put your code here &#125; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(&quot;utf-8&quot;); User st = new User(); HttpSession session = request.getSession(); UserService ss = new UserServiceImpl(); st.setName(request.getParameter(&quot;name&quot;)); st.setPassword(request.getParameter(&quot;password&quot;)); ss.registerUser(st); session.setAttribute(&quot;st&quot;, st); request.getRequestDispatcher(&quot;/success.jsp&quot;).forward(request, response); &#125; public void init() throws ServletException &#123; // Put your code here &#125;&#125; 验证用户名validateServlet程序 12345678910111213141516171819202122232425262728293031323334353637383940//验证用户名validateServlet程序package com.cheng.servlet;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.cheng.Bean.User;import com.cheng.service.UserService;import com.cheng.serviceImpl.UserServiceImpl;public class validateServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setCharacterEncoding(&quot;UTF-8&quot;); String name = request.getParameter(&quot;name&quot;); UserService us = new UserServiceImpl(); User user = us.findUserByName(name); if (user != null) &#123; // 表示已经存在这个用户 response.getWriter().print(&quot;&lt;font color=&#x27;red&#x27;&gt;用户名已经存在&lt;/font&gt; &quot;); &#125; else &#123; // 表示该用户不存在，可以注册 response.getWriter().println(&quot;&lt;font color=&#x27;green&#x27;&gt;用户名可以使用&lt;/font&gt; &quot;); &#125; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 数据库连接 C3p0Utils类 12345678910111213//创建C3p0Utils类package com.cheng.utils;import javax.sql.DataSource;import com.mchange.v2.c3p0.ComboPooledDataSource;public class C3p0Utils &#123; private static DataSource ds; static &#123; ds = new ComboPooledDataSource(); &#125; public static DataSource getDataSource() &#123; return ds; &#125;&#125; c3p0-config.xml文件 12345678910111213141516171819202122232425262728&lt;!--c3p0-config.xml文件--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;c3p0-config&gt; &lt;default-config&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt; jdbc:mysql://localhost:3306/student?characterEncoding=utf8 &lt;/property&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;checkoutTimeout&quot;&gt;30000&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;maxIdleTime&quot;&gt;30&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;100&lt;/property&gt; &lt;property name=&quot;minPoolSize&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;maxStatements&quot;&gt;200&lt;/property&gt; &lt;/default-config&gt; &lt;named-config name=&quot;itcast&quot;&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt; jdbc:mysql://localhost:3306/student?characterEncoding=utf8 &lt;/property&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;5&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;15&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; 1234567891011121314151617181920212223242526&lt;servlet&gt; &lt;servlet-name&gt;registerServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.cheng.servlet.registerServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;registerServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/registerServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;LogoutServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.cheng.servlet.LogoutServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;LogoutServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/LogoutServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;validateServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.cheng.servlet.validateServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;validateServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/validateServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 前端页面 register.jsp注册页面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!--register.jsp注册页面--&gt;&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;utf-8&quot;%&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path+&quot;/&quot;;%&gt;&lt;%=basePath %&gt;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt;&lt;title&gt;注册页面&lt;/title&gt;&lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot;&gt;&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt;&lt;meta http-equiv=&quot;expires&quot; content=&quot;0&quot;&gt;&lt;meta http-equiv=&quot;keywords&quot; content=&quot;keyword1,keyword2,keyword3&quot;&gt;&lt;meta http-equiv=&quot;description&quot; content=&quot;This is my page&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;registerServlet&quot; method=&quot;post&quot;&gt; 用户名：&lt;input id=&quot;name&quot; type=&quot;text&quot; name=&quot;name&quot; onblur=&quot;checkUsername()&quot; /&gt;&lt;span id=&quot;msg&quot;&gt;&lt;/span&gt; &lt;br/&gt; 密&amp;nbsp;&amp;nbsp;码:&lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;注册&quot;/&gt; &lt;/form&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt;function checkUsername()&#123; // 获得文本框值: var name = document.getElementById(&quot;name&quot;).value; // 1.创建异步交互对象 var xhr = createXmlHttp(); // 2.设置监听 xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; if(xhr.status == 200)&#123; document.getElementById(&quot;msg&quot;).innerHTML = xhr.responseText; &#125; &#125; &#125; // 3.打开连接 xhr.open(&quot;GET&quot;,&quot;$&#123;pageContext.request.contextPath&#125;/validateServlet?time=&quot;+new Date().getTime()+&quot;&amp;name=&quot;+name,true); // 4.发送 xhr.send(null);&#125;function createXmlHttp()&#123; var xmlHttp; try&#123; // Firefox, Opera 8.0+, Safari xmlHttp=new XMLHttpRequest(); &#125; catch (e)&#123; try&#123;// Internet Explorer xmlHttp=new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); &#125; catch (e)&#123; try&#123; xmlHttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; catch (e)&#123;&#125; &#125; &#125; return xmlHttp; &#125;&lt;/script&gt;&lt;/html&gt; success.jsp登陆成功页面 123456789101112131415161718192021222324&lt;!--success.jsp登陆成功页面--&gt;&lt;%@ page language=&quot;java&quot; pageEncoding=&quot;utf-8&quot;%&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path+&quot;/&quot;;%&gt;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt; &lt;title&gt;注册成功&lt;/title&gt; &lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot;&gt; &lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt; &lt;meta http-equiv=&quot;expires&quot; content=&quot;0&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;CSS/style.css&quot;&gt; &lt;/head&gt; &lt;body&gt; 注册成功！当前用户是：$&#123;st.name&#125; &lt;a href=&quot;/AjaxDemo/LogoutServlet&quot;&gt;退出登录&lt;/a&gt; &lt;/body&gt;&lt;/html&gt;","path":"page/JavaWeb10.html","date":"01-15","excerpt":"","tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://xiaoliblog.cn/tags/JavaWeb/"}]},{"title":"JavaWeb🌍数据库技术","text":"JDBC简介 JDBC全称是Java数据库连接（Java Database Connectivity），它是一套用于执行SQL语句的Java API。应用程序可通过这套API连接到关系数据库，并使用SQL语句来完成对数据库中数据的查询、更新、新增和删除的操作 应用程序使用JDBC访问特定的数据库时，需要与不同的数据库驱动进行连接。由于不同数据库厂商提供的数据库驱动不同，因此，为了使应用程序与数据库真正建立连接，JDBC不仅需要提供访问数据库的API，还需要封装与各种数据库服务器通信的细节 需要jar包的支持 java.sql javax.sql mysql-conneter-java..连接驱动 123456&lt;!-- 连接MySQL数据--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt;&lt;/dependency&gt; 在IDEA中连接数据库 常用SQL语句创建表和数据库 创建数据库 1Create database-name 创建表 1create table student(sno int primary key); CRUD 增加一个列 1alter table student add sname varchar(10); 插入数据 1insert into student (sno,sname) values(10,&#x27;程子为&#x27;); 查询数据 1select * from student; 解决中文乱码 1set names gbk; 修改数据（如果出现中文不能插入的情况，需要设置编码） 1update student set sno=1 where sname=&#x27;程子为&#x27;; 删除数据 1delete from student where sno=2; 在某一行的指定列添加数据（更新和插入的区别） 123alter table student add sage int;alter table student add ssex varchar(5);update student set sage=20,ssex=&#x27;男&#x27; where sno=1; 对列的操作 12345查看列：desc 表名;修改表名：alter table t_book rename to bbb;添加列：alter table 表名 add column 列名 varchar(30);删除列：alter table 表名 drop column 列名;改列名MySQL： alter table bbb change nnnnn hh int; 查询条件 排序 12降序： select * from student order by sage desc;升序： select * from student order by sage asc; 求总数 12select count（*） from student;select count(*) from student where sage=20; 求和 1select sum(sage) as age from student; 求平均 1select avg(sage) as 平均年龄 from student; 最大值 1select max(sage) as 最大年龄 from student; 最小值 1select min(sage) as 最大年龄 from student; 分组 1select sage,count(*) from student group by sage; 多条件查询 1select * from student where sname=&#x27;小红&#x27; and sno=5; 多表查询 1select * from student,course where student.sno=course.sno and student.sno=6; JDBC常用API Driver接口：所有JDBC驱动必须实现的接口。该接口专门提供给数据库厂商使用。在编写JDBC程序时，必须要把指定数据库驱动程序或类库加载到项目的classpath中。 DriverManager类：加载JDBC驱动并创建与数据库的连接。 Connection接口：代表Java程序和数据库的连接。 Statement接口：执行静态的SQL语句，并返回一个结果对象。 PreparedStatement接口：执行预编译的SQL语句。 ResultSet接口：保存JDBC执行查询时返回的结果集。 实现JDBC程序 配置信息 12345//配置信息//useUnicode=true&amp;characterEncoding=UTF-8 解决中文乱码问题String url = &quot;jdbc:mysql://localhost:3306/DataBase_Name?useUnicode=true&amp;characterEncoding=UTF-8&quot;;String username = &quot;root&quot;;String password = &quot;root&quot;; 加载并注册数据库驱动 1Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 通过DriverManager获取数据库连接 1Connection connection = DriverManager.getConnection(url, username, password); 通过Connection对象获取向数据库发送SQL的对象statement 1Statement statement = connection.createStatement(); 编写SQL语句 1String sql = &quot;select * from user&quot;; 使用Statement执行SQL语句 1ResultSet rs = statement.executeQuery(sql); 操作ResultSet结果集 1234567while(rs.next())&#123; //不知道数据类型就使用Object int id = rs.getObject(&quot;id&quot;); // 通过列名获取指定字段的值 String name = rs.getObject(&quot;name&quot;); String psd =rs.getObject(&quot;pwd&quot;); System.out.println(&quot;| &quot;+id + &quot; | &quot; + name + &quot; | &quot; + psd + &quot; | &quot;);&#125; 关闭连接,释放资源（先开后关） 12rs.close();statement.close(); 搭建数据库 1234567891011CREATE DATABASE `mybatis`;USE `mybatis`;DROP TABLE IF EXISTS `user`;CREATE TABLE `user` (`id` INT(20) NOT NULL PRIMARY KEY,`name` VARCHAR(30) DEFAULT NULL,`pwd` VARCHAR(30) DEFAULT NULL) ENGINE=INNODB DEFAULT CHARSET=utf8;INSERT INTO `user`(`id`,`name`,`pwd`) VALUES (1,&#x27;狂神&#x27;,&#x27;123456&#x27;),(2,&#x27;张三&#x27;,&#x27;abcdef&#x27;),(3,&#x27;李四&#x27;,&#x27;987654&#x27;); 1234567891011121314151617181920212223242526272829303132333435package com.lzy.jdbc;import java.sql.*;public class TestJdbc &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; //配置信息 //useUnicode=true&amp;characterEncoding=UTF-8 解决中文乱码问题 String url = &quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=UTF-8&quot;; String username = &quot;root&quot;; String password = &quot;root&quot;; //1. 加载驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2. 连接数据库，connection代表数据库 Connection connection = DriverManager.getConnection(url, username, password); //3.向数据库发送SQL的对象statement Statement statement = connection.createStatement(); //4. 编写SQL String sql = &quot;select * from user&quot;; //5. 执行查询SQL,返回一个ResultSet结果集 ResultSet rs = statement.executeQuery(sql); //6. 处理结果集 while(rs.next())&#123; Object id = rs.getObject(&quot;id&quot;); Object name = rs.getObject(&quot;name&quot;); Object psd =rs.getObject(&quot;pwd&quot;); System.out.println(&quot;| &quot;+id + &quot; | &quot; + name + &quot; | &quot; + psd + &quot; | &quot;); &#125; //6. 关闭连接,释放资源（先开后关） rs.close(); statement.close(); connection.close(); &#125;&#125; PreparedStatement对象 PreparedStatement对象可以对SQL语句进行预编译，预编译的信息会存储在该对象中 当相同的SQL语句再次执行时，程序会使用PreparedStatement对象中的数据，而不需要对SQL语句再次编译去查询数据库，这样就大大的提高了数据的访问效率 123456789101112131415161718192021222324252627282930313233package com.lzy.jdbc;import java.sql.*;public class TestJdbc &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; //配置信息 //useUnicode=true&amp;characterEncoding=UTF-8 解决中文乱码问题 String url = &quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=UTF-8&quot;; String username = &quot;root&quot;; String password = &quot;root&quot;; //1. 加载驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2. 连接数据库，connection代表数据库 Connection connection = DriverManager.getConnection(url, username, password); //3. 编写SQL String sql = &quot;insert into user(id,name,pwd) values (?,?,?)&quot;; //4.预编译 PreparedStatement preparedStatement = connection.prepareStatement(sql); preparedStatement.setInt(1,1); //给第一个问号占位符赋值 preparedStatement.setString(2,&quot;李白&quot;); //给第二个问号占位符赋值 preparedStatement.setString(3,&quot;123ff&quot;); //给第三个问号占位符赋值 //5. 执行SQL int i = preparedStatement.executeUpdate(); if(i&gt;0)&#123; System.out.println(&quot;插入成功&quot;); &#125; //6. 关闭连接,释放资源（先开后关） preparedStatement.close(); connection.close(); &#125;&#125; ResultSet对象 ResultSet主要用于存储结果集，可以通过next()方法由前向后逐个获取结果集中的数据，如果想获取结果集中任意位置的数据，则需要在创建Statement对象时，设置两个ResultSet定义的常量，具体设置方式如下： 12345Statement st = conn.createStatement( ResultSet.TYPE_SCROLL_INSENITIVE, ResultSet.CONCUR_READ_ONLY);ResultSet rs = st.excuteQuery(sql); 常量Result.TYPE_SCROLL_INSENITIVE表示结果集可滚动 常量ResultSet.CONCUR_READ_ONLY表示以只读形式打开结果集 123456789101112131415161718192021222324252627282930313233343536373839404142package com.lzy.jdbc;import java.sql.*;public class TestJdbc &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; //配置信息 //useUnicode=true&amp;characterEncoding=UTF-8 解决中文乱码问题 String url = &quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=UTF-8&quot;; String username = &quot;root&quot;; String password = &quot;root&quot;; //1. 加载驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2. 连接数据库，connection代表数据库 Connection connection = DriverManager.getConnection(url, username, password); //3. 编写SQL String sql = &quot;select * from user&quot;; //4. 创建Statement对象并设置常量 Statement st =connection.createStatement( ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY); //5. 执行SQL并将获取的数据信息存放在ResultSet中 ResultSet rs = st.executeQuery(sql); //6. 取出ResultSet中指定数据的信息 System.out.print(&quot;第2条数据的name值为:&quot;); rs.absolute(2); //将指针定位到结果集中第2行数据 System.out.println(rs.getString(&quot;name&quot;)); System.out.print(&quot;第1条数据的name值为:&quot;); rs.beforeFirst(); //将指针定位到结果集中第1行数据之前 rs.next(); //将指针向后滚动 System.out.println(rs.getString(&quot;name&quot;)); System.out.print(&quot;第4条数据的name值为:&quot;); rs.afterLast(); //将指针定位到结果集中最后一条数据之后 rs.previous(); //将指针向前滚动 System.out.println(rs.getString(&quot;name&quot;)); //6. 关闭连接,释放资源（先开后关） rs.close(); st.close(); connection.close(); &#125;&#125; JDBC事务 数据库事务（Transaction）是由若干个SQL语句构成的一个操作序列，有点类似于Java的synchronized同步。数据库系统保证在一个事务中的所有SQL要么全部执行成功，要么全部不执行，即数据库事务具有ACID特性 Atomicity：原子性 Consistency：一致性 Isolation：隔离性 Durability：持久性 事务概述 对应用程序来说，数据库事务非常重要，很多运行着关键任务的应用程序，都必须依赖数据库事务保证程序的结果正常。 举个例子：假设A准备给B支付100，那么用两条SQL语句操作如下： 12update account set money = money-100 where name = &#x27;A&#x27; ;update account set money = money+100 where name = &#x27;B&#x27; ; 这两条语句必须以事务方式执行才能保证业务的正确性，因为一旦第一条SQL执行成功而第二条SQL失败的话，系统的钱就会凭空减少100，而有了事务，要么这笔转账成功，要么转账失败，双方账户的钱都不变 要在JDBC中执行事务，本质上就是如何把多条SQL包裹在一个数据库事务中执行。我们来看JDBC的事务代码 123456789101112131415Connection conn = openConnection();try &#123; // 关闭自动提交: conn.setAutoCommit(false); // 执行多条SQL语句: insert(); update(); delete(); // 提交事务: conn.commit();&#125; catch (SQLException e) &#123; // 回滚事务: conn.rollback();&#125; finally &#123; conn.setAutoCommit(true); conn.close();&#125; 其中，开启事务的关键代码是conn.setAutoCommit(false)，表示关闭自动提交 提交事务的代码在执行完指定的若干条SQL语句后，调用conn.commit() 要注意事务不是总能成功，如果事务提交失败，会抛出SQL异常（也可能在执行SQL语句的时候就抛出了），此时我们必须捕获并调用conn.rollback()回滚事务 最后，在finally中通过conn.setAutoCommit(true)把Connection对象的状态恢复到初始值 测试事务 Junit单元测试工具可以不需要main方法就可以执行，只需要一个注解就可以随时测试 首先引入Junit测试工具依赖 123456&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 使用：在方法上使用注解@Test，且只在方法上使用 1234@Testpublic void Test()&#123; System.out.println(&quot;不需要main方法也可以执行！&quot;);&#125; 创建数据库 123456789USE mybatisCREATE TABLE account( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(40), money FLOAT);INSERT INTO account(NAME,money) VALUES(&#x27;A&#x27;,1000);INSERT INTO account(NAME,money) VALUES(&#x27;B&#x27;,1000);INSERT INTO account(NAME,money) VALUES(&#x27;C&#x27;,1000); Java完成数据库事务操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.lzy.jdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;public class JDBC_Commit &#123; public static void main(String[] args) throws ClassNotFoundException, SQLException &#123; //配置信息 //useUnicode=true&amp;characterEncoding=UTF-8 解决中文乱码问题 String url = &quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;characterEncoding=UTF-8&quot;; String username = &quot;root&quot;; String password = &quot;root&quot;; Connection connection = null; try &#123; //1. 加载驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2. 连接数据库，connection代表数据库 connection = DriverManager.getConnection(url, username, password); //3. 通知数据库开启事务,false开启 connection.setAutoCommit(false); String sql1 = &quot;update account set money = money-100 where name = &#x27;A&#x27;&quot;; connection.prepareStatement(sql1).executeUpdate(); //制造错误 //int i = 1 / 0; String sql2 = &quot;update account set money = money+100 where name = &#x27;B&#x27;&quot;; connection.prepareStatement(sql2).executeUpdate(); //提交事务 connection.commit(); //以上两条SQL都提交成功了就提交事务 System.out.println(&quot;success&quot;); &#125;catch (Exception e)&#123; try&#123; //如果出现移除，就通知数据库回滚事务 connection.rollback(); &#125;catch(SQLException e1)&#123; e1.printStackTrace(); &#125; &#125; &#125;&#125; 出现错误时，数据库数据如下 未出现错误，数据库如下，可以发现转账成功未出现错误 数据库连接池 在JDBC编程中，每次创建和断开Connection对象都会消耗一定的时间和IO资源。频繁地创建、断开数据库连接势必会影响数据库的访问效率，甚至导致数据库崩溃。为了避免频繁的创建数据库连接，工程师们提出了数据库连接池技术 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用现有的数据库连接，而不是重新建立。下面通过一张图来简单描述应用程序如何通过连接池连接数据库 DataSource接口 为了获取数据库连接对象（Connection），JDBC提供了javax.sql.DataSource接口，它负责与数据库建立连接，并定义了返回值为Connection对象的方法： 12Connection getConnection() Connection getConnection(String username, String password) 我们习惯性的把实现了javax.sql.DataSource接口的类称为数据源，顾名思义，数据源即数据的来源。在数据源中存储了所有建立数据库连接的信息。 DBCP数据源 DBCP是数据库连接池（DataBase Connection Pool）的简称，是Apache组织下的开源连接池实现，也是Tomcat服务器使用的连接池组件。单独使用DBCP数据源时，需要在应用程序中导入两个jar包。这两个包可以在Apache官网下载 Commons-dbcp.jar：连接池的实现 Commons-pool.jar：连接池实现的依赖库 commons-dbcp.jar包中包含两个核心类，分别是BasicDataSourceFactory和BasicDataSource，它们都包含获取DBCP数据源对象的方法。 BasicDataSource是DataSource接口的实现类，主要包括设置数据源对象的方法。 数据源对象创建的两种方式 使用BasicDataSource类创建一个数据源对象，手动给数据源对象设置属性值，然后获取数据库连接对象。 使用BasicDataSourceFactory工厂类读取配置文件，创建数据源对象，然后获取数据库连接对象。 C3P0数据源 C3P0是目前最流行的开源数据库连接池之一，它实现了DataSource数据源接口，支持JDBC2和JDBC3的标准规范，易于扩展并且性能优越，著名的开源框架Hibernate和 Spring使用的都是该数据源。编程之前需要导入c3p0-0.9.1.2jar包 我们在使用C3P0数据源开发时，需要了解C3P0中DataSource接口的实现类ComboPooledDataSource，它是C3P0的核心类，提供了数据源对象的相关方法。 数据源对象创建的两种方式 使用ComboPooledDataSource()构造方法创建数据源对象，需要手动给数据源对象设置属性值，然后获取数据库连接对象。2 使用ComboPooledDataSource(String configName)构造方法读取c3p0-config.xml配置文件，从而创建数据源对象，然后获取数据库连接对象。（推荐使用） 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;c3p0-config&gt; &lt;default-config&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt; jdbc:mysql://localhost:3306/student &lt;/property&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;checkoutTimeout&quot;&gt;30000&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;maxIdleTime&quot;&gt;30&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;100&lt;/property&gt; &lt;property name=&quot;minPoolSize&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;maxStatements&quot;&gt;200&lt;/property&gt; &lt;/default-config&gt; &lt;named-config name=&quot;itcast&quot;&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt; jdbc:mysql://localhost:3306/student &lt;/property&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;5&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;15&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; 12345678910111213141516package c3p0;import java.sql.SQLException;import javax.sql.DataSource;import com.mchange.v2.c3p0.ComboPooledDataSource;public class c3p0_test &#123; public static DataSource ds = null; // 初始化C3P0数据源 static &#123; // 使用c3p0-config.xml配置文件中的named-config节点中name属性的值 ComboPooledDataSource cpds = new ComboPooledDataSource(&quot;root&quot;); ds = cpds; &#125; public static void main(String[] args) throws SQLException &#123; System.out.println(ds.getConnection()); &#125;&#125; 注意，配置文件名必须为c3p0-config.xml或者c3p0.properties，并且位于该项目的src根目录下当传入的configName的值为空或者不存在时，则使用默认的配置方式创建数据源 DBUtils工具 为了更加简单地使用JDBC，Apache组织提供了一个工具类库commons-dbutils组件。该组件实现了对JDBC的简单封装，可以在不影响性能的情况下极大简化JDBC的编码工作量。编码前需要导入commons-dbutils-1.6.jar QueryRunner类 QueryRunner类简化了执行SQL语句的代码，它与ResultSetHandler组合在一起就能完成大部分的数据库操作，大大的减少了编码量。 QueryRunner类提供了带有一个参数的构造方法，该方法以javax.sql.DataSource作为参数传递到QueryRunner的构造方法中来获取Connection对象。针对不同的数据库操作，QueryRunner类提供了几种常见的方法，具体如下： 123query(String sql, ResultSetHandler rsh, Object… params)方法update(String sql, Object… params)方法update(String sql)方法 params用SQL语句中的参数(?)置换，当有多个参数时有如下两种方法 12update(sql,1,2,3); //直接用逗号隔开update(sql,new Object[]&#123;1,2,3&#125;); //创建一个数组 ResultSetHandler接口 ResultSetHandler接口用于处理ResultSet结果集，它可以将结果集中的数据转为不同的形式。根据结果集中数据类型的不同，ResultSetHandler提供了几种常见的实现类，具体如下： ResultSetHandler实现类 DBUtils实现CURD项目工程总览搭建数据库 123create database student;use student;create table user(id int primary key auto_increment,name varchar(255),password varchar(255)); 12345678910111213141516171819202122232425262728//封装用户信息package UserBean;public class User &#123; private int id; private String name; private String password; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; &#125; 1234567891011121314//创建C3p0类型package C3p0_Utils;import javax.sql.DataSource;import com.mchange.v2.c3p0.ComboPooledDataSource;public class C3p0Utils &#123; private static DataSource ds; static &#123; ds = new ComboPooledDataSource(); &#125; public static DataSource getDataSource() &#123; return ds; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//封装了对User表增删查改的方法package DBUtils_Dao;import java.sql.SQLException;import java.util.List;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import C3p0_Utils.C3p0Utils;import UserBean.User;public class DBUtilsDao &#123; // 查询所有，返回List集合 public List findAll() throws SQLException &#123; // 创建QueryRunner对象 QueryRunner runner = new QueryRunner(C3p0Utils.getDataSource()); // 写SQL语句 String sql = &quot;select * from user&quot;; // 调用方法 List list = (List) runner.query(sql, new BeanListHandler(User.class)); return list; &#125; // 查询单个，返回对象 public User find(int id) throws SQLException &#123; // 创建QueryRunner对象 QueryRunner runner = new QueryRunner(C3p0Utils.getDataSource()); // 写SQL语句 String sql = &quot;select * from user where id=?&quot;; // 调用方法 User user = (User) runner.query(sql, new BeanHandler(User.class), new Object[] &#123; id &#125;); return user; &#125; // 添加用户的操作 public Boolean insert(User user) throws SQLException &#123; // 创建QueryRunner对象 QueryRunner runner = new QueryRunner(C3p0Utils.getDataSource()); // 写SQL语句 String sql = &quot;insert into user (name,password) values (?,?)&quot;; // 调用方法 int num = runner.update(sql, new Object[] &#123; user.getName(), user.getPassword() &#125;); if (num &gt; 0) return true; return false; &#125; // 修改用户的操作 public Boolean update(User user) throws SQLException &#123; // 创建QueryRunner对象 QueryRunner runner = new QueryRunner(C3p0Utils.getDataSource()); // 写SQL语句 String sql = &quot;update user set name=?,password=? where id=?&quot;; // 调用方法 int num = runner.update(sql, new Object[] &#123; user.getName(), user.getPassword(),user.getId() &#125;); if (num &gt; 0) return true; return false; &#125; // 删除用户的操作 public Boolean delete(int id) throws SQLException &#123; // 创建QueryRunner对象 QueryRunner runner = new QueryRunner(C3p0Utils.getDataSource()); // 写SQL语句 String sql = &quot;delete from user where id=?&quot;; // 调用方法 int num = runner.update(sql, id); if (num &gt; 0) return true; return false; &#125;&#125; 1234567891011121314151617181920212223242526272829&lt;!--c3p0-config配置--&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;c3p0-config&gt; &lt;default-config&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt; jdbc:mysql://localhost:3306/student &lt;/property&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;checkoutTimeout&quot;&gt;30000&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;maxIdleTime&quot;&gt;30&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;100&lt;/property&gt; &lt;property name=&quot;minPoolSize&quot;&gt;10&lt;/property&gt; &lt;property name=&quot;maxStatements&quot;&gt;200&lt;/property&gt; &lt;/default-config&gt; &lt;named-config name=&quot;itcast&quot;&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt; jdbc:mysql://localhost:3306/student &lt;/property&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;5&lt;/property&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;15&lt;/property&gt; &lt;/named-config&gt;&lt;/c3p0-config&gt; 12345678910111213141516171819//插入数据package DBUtils_Test;import java.sql.SQLException;import DBUtils_Dao.DBUtilsDao;import UserBean.User;public class Insert_test &#123; private static DBUtilsDao dao = new DBUtilsDao(); public static void testInsert() throws SQLException &#123; User user = new User(); user.setName(&quot;zhaoliu&quot;); user.setPassword(&quot;666666&quot;); boolean b = dao.insert(user); System.out.println(b); &#125; public static void main(String[] args) throws SQLException &#123; testInsert(); &#125;&#125; 1234567891011121314151617181920//更新数据package DBUtils_Test;import java.sql.SQLException;import DBUtils_Dao.DBUtilsDao;import UserBean.User;public class Update_test &#123; private static DBUtilsDao dao = new DBUtilsDao(); public static void testupdate() throws SQLException &#123; User user = new User(); user.setName(&quot;zhaoliu&quot;); user.setPassword(&quot;666777&quot;); user.setId(2); boolean b = dao.update(user); System.out.println(b); &#125; public static void main(String[] args) throws SQLException &#123; testupdate(); &#125;&#125; 123456789101112131415//根据ID删除package DBUtils_Test;import DBUtils_Dao.DBUtilsDao;import UserBean.User;import java.sql.SQLException;public class Delete_Test &#123; private static DBUtilsDao dao = new DBUtilsDao(); public static void testdelete() throws SQLException &#123; boolean b = dao.delete(2); System.out.println(b); &#125; public static void main(String[] args) throws SQLException &#123; testdelete(); &#125;&#125; 12345678910111213141516//根据ID查询package DBUtils_Test;import java.sql.SQLException;import DBUtils_Dao.DBUtilsDao;import UserBean.User;public class Query_Test &#123; private static DBUtilsDao dao = new DBUtilsDao(); public static void testfind() throws SQLException &#123; User user = dao.find(3); System.out.println(user.getId() + &quot;,&quot; + user.getName() + &quot;,&quot; + user.getPassword()); &#125; public static void main(String[] args) throws SQLException &#123; testfind(); &#125;&#125;","path":"page/JavaWeb09.html","date":"01-15","excerpt":"","tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://xiaoliblog.cn/tags/JavaWeb/"}]},{"title":"JavaWeb🌍过滤/监听","text":"Filter过滤器 Filter被称作过滤器或者拦截器，其基本功能就是对Servlet容器调用Servlet的过程进行拦截，从而在Servlet进行响应处理前后实现一些特殊功能 当浏览器访问服务器中的目标资源时，会被Filter拦截，在Filter中进行预处理操作，然后再将请求转发给目标资源。当服务器接收到这个请求后会对其进行响应，在服务器处理响应的过程中，也需要先将响应结果发送给拦截器，在拦截器中对响应结果进行处理后，才会发送给客户端 实现Filter Filter过滤器就是一个实现了javax.servlet.Filter接口的类，在javax.servlet.Filter接口中定义了三个方法 init(Filterconfig)：代表filter对象初始化方法 filter对象创建时执行 doFilter(ServletRequest,ServletResponse,FilterChain)：代表filter执行过滤的核心方法，如果某资源在已经被配置到这个filter进行过滤的话，那么每次访问这个资源都会执行doFilter方法 destory()：代表是filter销毁方法 当filter对象销毁时执行该方法 Filter对象的生命周期： Filter何时创建：服务器启动时就创建该filter对象 Filter何时销毁：服务器关闭时filter销毁 Filter映射 Filter拦截的资源需要在web.xml文件中进行配置，即Filter映射。 Filter的映射方式可分为两种、 第一种：使用通配符*拦截用户所有请求 12345678910111213&lt;!--filter用于注册一个Filter--&gt; &lt;filter&gt; &lt;!--filter-name用于设置Filter名称--&gt; &lt;filter-name&gt;MyFilter&lt;/filter-name&gt; &lt;!--filter-class用于设置Filter完整名称--&gt; &lt;filter-class&gt;MyFilter.MyFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;!--filter-mapping用于设置一个过滤器所拦截的资源--&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;MyFilter&lt;/filter-name&gt; &lt;!--filter-pattern用于匹配用户请求的URL--&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 第二种：拦截不同方式请求 &lt;filter-mapping&gt;元素中有一个特殊的子元素&lt;dispatcher&gt;，该元素用于指定过滤器所拦截的资源被Servlet容器调用的方式 &lt;dispatcher&gt;元素的值共有四个：REQUEST、INCLUDE、FORWARD、ERROR。 REQUEST 当用户直接访问页面时，Web容器将会调用过滤器。如果目标资源是通过RequestDispatcher的include()或forward()方法访问的，那么该过滤器将不会被调用。 INCLUDE 如果目标资源是通过RequestDispatcher的include()方法访问的，那么该过滤器将被调用 FORWARD 如果目标资源是通过RequestDispatcher的forward()方法访问的，那么该过滤器将被调用 ERROR 如果目标资源是通过声明式异常处理机制调用的，那么该过滤器将被调用 Filter链 在一个Web应用程序中可以注册多个Filter程序，每个Filter程序都可以针对某一个URL进行拦截。如果多个Filter程序都对同一个URL进行拦截，那么这些Filter就会组成一个Filter链（也叫过滤器链）。 Filter链用FilterChain对象来表示，FilterChain对象中有一个doFilter()方法，该方法作用就是让Filter链上的当前过滤器放行，请求进入下一个Filter Filter接口 为了获取Filter程序在web.xml文件中的配置信息，Servlet API提供了一个FilterConfig接口，该接口封装了Filter程序在web.xml中的所有注册信息，并且提供了一系列获取这些配置信息的方法。 Listener监听器 在程序开发中，经常需要对某些事件进行监听，如监听鼠标点击事件、监听键盘按下事件等，此时就需要使用事件监听器。 事件监听器用于对程序中发生的事件进行监听，在监听的过程中会涉及几个重要组成部分: 组成部分 说明 事件（Event） 用户的一个操作，如点击一个按钮、调用一个方法、创建一个对象等 事件源 产生事件的对象 事件监听器（Listener） 负责监听发生在事件源上的事件 事件处理器 监听器的成员方法，当事件发生的时候会触发对应的处理器（成员方法） 事件监听器在进行工作时，可分为几个步骤，具体如下： 注册监听器 将监听器绑定到事件源，也就是注册监听器 传递事件对象 事件发生时会触发监听器的成员方法，即事件处理器，传递事件对象。 处理时间源 事件处理器通过事件对象获得事件源，并对事件源进行处理。 Listener接口 在开发Web应用程序时，也经常会使用事件监听器，这个事件监听器被称为Servlet事件监听器，Servlet事件监听器是一个实现特定接口的Java程序，专门用于监听Web应用程序，根据监听事件的不同可将这些接口分为三类。 用于监听域对象创建和销毁的事件监听器 ServletContextListener接口 HttpSessionListener接口 ServletRequestListener接口 用于监听域对象属性增加和删除的事件监听器 ServletContextAttributeListener接口 HttpSessionAttributeListener接口 ServletRequestAttributeListener接口 用于监听绑定到HttpSession域中某个对象状态的事件监听器 HttpSessionBindingListener接口 HttpSessionActivationListener接口 统计在线人数 创建OnlineCountListener监听器 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.lzy.Filter;import javax.servlet.ServletContext;import javax.servlet.http.HttpSession;import javax.servlet.http.HttpSessionEvent;import javax.servlet.http.HttpSessionListener;/ /统计网站在线人数，即统计Sessionpublic class OnlineCountListener implements HttpSessionListener &#123; @Override //创建Session监听，看你的一举一动 //一旦创建Session就会触发一次这个事件 public void sessionCreated(HttpSessionEvent httpSessionEvent) &#123; ServletContext session = httpSessionEvent.getSession().getServletContext(); System.out.println(httpSessionEvent.getSession().getId()); Integer onlineCount = (Integer) session.getAttribute(&quot;OnlineCount&quot;); if(onlineCount==null)&#123; //为空，赋值1 onlineCount = new Integer(1); &#125;else &#123; //不为空，自增1 int count = onlineCount.intValue(); onlineCount = new Integer(count+1); &#125; session.setAttribute(&quot;onlineCount&quot;,onlineCount); &#125; @Override //销毁Session监听 //一旦Session销毁就会触发一次这个事件 public void sessionDestroyed(HttpSessionEvent httpSessionEvent) &#123; ServletContext session = httpSessionEvent.getSession().getServletContext(); Integer onlineCount = (Integer) session.getAttribute(&quot;OnlineCount&quot;); if(onlineCount==null)&#123; //为空，赋值0 onlineCount = new Integer(0); &#125;else &#123; //不为空，自减1 int count = onlineCount.intValue(); onlineCount = new Integer(count-1); &#125; session.setAttribute(&quot;onlineCount&quot;,onlineCount); &#125;&#125; 在web.xml中注册监听器 1234&lt;!--注册监听器--&gt; &lt;listener&gt; &lt;listener-class&gt;com.lzy.Filter.OnlineCountListener&lt;/listener-class&gt; &lt;/listener&gt; test.jsp页面取值 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;当前有&lt;span&gt;&lt;%=request.getServletContext().getAttribute(&quot;onlineCount&quot;)%&gt;&lt;/span&gt;个用户在线&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; Filter实现全站编码 第一个Filter程序，解决中文乱码，通过过滤器可以减少代码冗余，不需要每一个Servlet都单独设置编码 123456public class ShowServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.getWriter().write(&quot;你好呀&quot;); &#125;&#125; 创建过滤器 123456789101112131415161718192021222324252627282930package com.lzy.Filter;import javax.servlet.*;import java.io.IOException;public class CharacterEncodingFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println(&quot;过滤器已经初始化&quot;); &#125; /*FilterChain为链的意思 * 1. 过滤中的所有代码，在过滤特定的请求时都会执行 *2. 必须要让过滤器继续执行 * filterChain.doFilter(servletRequest,servletResponse); * */ @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; servletRequest.setCharacterEncoding(&quot;utf-8&quot;); servletResponse.setCharacterEncoding(&quot;utf-8&quot;); servletResponse.setContentType(&quot;text/html;charset=UTF-8&quot;); System.out.println(&quot;CharacterEncodingFilter执行前...&quot;); //让我们的请求继续走，如果不写，程序到这里就停止了 filterChain.doFilter(servletRequest,servletResponse); System.out.println(&quot;CharacterEncodingFilter执行后...&quot;); &#125; @Override public void destroy() &#123; System.out.println(&quot;过滤器已经销毁&quot;); &#125;&#125; 在xml注册Servlet和Filter 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt;&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; version=&quot;3.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;ShowServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.lzy.Filter.ShowServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!--有过滤器支持--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ShowServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/servlet/ShowServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--无过滤器支持--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;ShowServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/ShowServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.lzy.Filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;!--只要是/servlet的任何请求，都会经过这个过滤器--&gt; &lt;url-pattern&gt;/servlet/*&lt;/url-pattern&gt;&lt;!-- &lt;url-pattern&gt;/*&lt;/url-pattern&gt;--&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 运行结果 修改了xml文件就需要重启服务器才能访问 自动登录的实现请参考：https://blog.csdn.net/qq_39494996/article/details/81637049 Filter实现权限拦截 权限拦截指已登录用户可以访问主页，而未登录用户不能访问主页 当用户点击【注销】后，就不能再访问主页了 用户登录之后，向Session中放入用户的数据，保存SessionID 进入主页的时候要判断用户是否已经登录，即判断SessionID是否为空 如果SessionID为空，说明用户已注销，无法访问主页 登录页面(login.jsp) 123456789101112131415&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;登录页面&lt;/h1&gt;&lt;form action=&quot;LoginServlet&quot; method=&quot;post&quot;&gt; 用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; 密码:&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 登录失败错误页面(error.jsp) 1234567891011&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;错误页面&lt;/h1&gt;&lt;h3&gt;没有权限，用户名错误&lt;/h3&gt;&lt;a href=&quot;/JavaWeb_Demo05/login.jsp&quot;&gt;返回登录页面&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 登录成功的主页，在sys/success.jsp下 12345678910111213141516171819202122232425&lt;%-- Created by IntelliJ IDEA. User: 朕爷专属pro Date: 2021/3/25 Time: 19:29 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%--页内解决方法不推荐，判断Session是否为空，如果为空就跳转到登录页面--%&gt;&lt;%--&lt;%--%&gt;&lt;%-- Object userSession = request.getSession().getAttribute(&quot;USER_SESSION&quot;);--%&gt;&lt;%-- if(userSession==null)&#123;--%&gt;&lt;%-- response.sendRedirect(&quot;/JavaWeb_Demo05/login.jsp&quot;);--%&gt;&lt;%-- &#125;--%&gt;&lt;%--%&gt;--%&gt;&lt;h1&gt;登录成功！当前为主页&lt;/h1&gt;&lt;a href=&quot;/JavaWeb_Demo05/LogoutServlet&quot;&gt;注销&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 创建一个常量类，因为很多地方用到USER_SESSION常量，单独创建一个常量类便于修改 1234package com.lzy.util;public class Constant &#123; public final static String USER_SESSION = &quot;USER_SESSION&quot;;&#125; 这是一种非常好的编码习惯，常量都放在常量类Contant里面，方便后期修改 处理登录信息的LoginServlet 123456789101112131415161718192021222324package com.lzy.servlet;import com.lzy.util.Constant;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class LoginServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取前端请求的参数 String username = req.getParameter(&quot;username&quot;); String password = req.getParameter(&quot;password&quot;); if(username.equals(&quot;admin&quot;)) &#123; //登陆成功 //把用户Session的ID存放到名称为Constant.USER_SESSION常量中 req.getSession().setAttribute(Constant.USER_SESSION,req.getSession().getId()); resp.sendRedirect(&quot;/JavaWeb_Demo05/sys/success.jsp&quot;); &#125;else&#123; //登录失败 resp.sendRedirect(&quot;/JavaWeb_Demo05/error.jsp&quot;); &#125; &#125;&#125; 处理注销的LogoutServlet 12345678910111213141516171819202122package com.lzy.servlet;import com.lzy.util.Constant;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class LogoutServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //实际开发中不推荐直接销毁Seesion Object user_session = req.getSession().getAttribute(Constant.USER_SESSION); if(user_session!=null)&#123; //只是移除Session的属性 req.getSession().removeAttribute(Constant.USER_SESSION); resp.sendRedirect(&quot;/JavaWeb_Demo05/login.jsp&quot;); &#125; &#125;&#125; 过滤器Sysfilter 123456789101112131415161718192021222324252627282930313233package com.lzy.Filter;import com.lzy.util.Constant;import javax.servlet.*;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class SysFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; //转为HttpServletRequest才能拿到Session Object user_session = request.getSession().getAttribute(Constant.USER_SESSION); if(user_session==null)&#123; response.sendRedirect(&quot;/JavaWeb_Demo05/error.jsp&quot;); &#125; //必写，让Filter链往下走 filterChain.doFilter(servletRequest,servletResponse); &#125; @Override public void destroy() &#123; &#125;&#125; 在web.xml中注册Servlet和监听器 123456789&lt;filter&gt; &lt;filter-name&gt;SysFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.lzy.Filter.SysFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;SysFilter&lt;/filter-name&gt; &lt;!--过滤sys下的文件--&gt; &lt;url-pattern&gt;/sys/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;","path":"page/JavaWeb08.html","date":"01-15","excerpt":"","tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://xiaoliblog.cn/tags/JavaWeb/"}]},{"title":"JavaWeb🌍JSTL标签","text":"JSTL标签库 从JSP1.1规范开始，JSP就支持使用自定义标签，使用自定义标签大大降低了JSP页面的复杂度，同时增强了代码的重用性。 为此，许多Web应用厂商都定制了自身应用的标签库，然而同一功能的标签由不同的Web应用厂商制定可能是不同的，这就导致市面上出现了很多功能相同的标签，令网页制作者无从选择。 为了解决同一功能标签的不统一问题，Sun公司制定了一套标准标签库（JavaServer Pages Standard Tag Library），简称JSTL。 JSTL虽然被称为标准标签库，而实际上这个标签库是由5个不同功能的标签库共同组成。在JSTL1.1规范中，为这5个标签库分别指定了不同的URI以及建议使用的前缀。 Core是一个核心标签库，它包含了实现Web应用中通用操作的标签。 I18N是一个国际化/格式化标签库，它包含实现Web应用程序的国际化标签和格式化标签。 SQL是一个数据库标签库，它包含了用于访问数据库和对数据库中的数据进行操作的标签。 XML是一个操作XML文档的标签库，它包含对XML文档中的数据进行操作的标签。 Function是一个函数标签库，它提供了一套自定义EL函数，包含了JSP网页制作用到的字符串操作 导入JSLT和Standard的依赖jar包 1234567891011&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt; Tomcat安装目录lib下放入jstl.jar和standard.jar包 蓝奏云链接：https://wws.lanzous.com/b0201ivcf ，密码：547l 官方下载链接：http://archive.apache.org/dist/jakarta/taglibs/standard/binaries/jakarta-taglibs-standard-1.1.2.zip 在Tomcat【配置】中添加jar包 Core标签库 需要在JSP页面引入核心标签库 12&lt;%--引入jstl核心标签库--%&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt; &lt;c:out&gt;标签 &lt;c:out&gt;标签可以将一段文本内容或表达式的结果输出到客户端。 语法1：没有标签体的情况 1234&lt;!--value属性：用于指定输出的文本内容--&gt;&lt;!--default属性：指定当value属性为null时所输出的默认值--&gt;&lt;c:out value=&quot;value&quot; [default=&quot;defaultValue&quot;] [escapeXml=&quot;&#123;true|false&#125;&quot;]/&gt; 语法2：有标签体的情况，在标签体中指定输出的默认值 1234&lt;!--escapeXml用于指定是否将&gt;、&lt;、&amp;、&#x27;、&quot; 等特殊字符进行HTML编码转换后再进行输出，默认值为true--&gt;&lt;c:out value=&quot;value&quot; [escapeXml=&quot;&#123;true|false&#125;&quot;]&gt; defaultValue &lt;/c:out&gt; 12345678910111213141516&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html;charset=utf-8&quot; pageEncoding=&quot;utf-8&quot;%&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;%--第1个out标签 --%&gt; userName属性的值为： &lt;c:out value=&quot;$&#123;param.username&#125;&quot; default=&quot;unknown&quot; /&gt; &lt;br /&gt; &lt;%--第2个out标签 --%&gt; userName属性的值为： &lt;c:out value=&quot;$&#123;param.username&#125;&quot;&gt; unknown &lt;/c:out&gt;&lt;/body&gt;&lt;/html&gt; &lt;c:if&gt;标签 在程序开发中，需要使用if语句进行条件判断，如果要在JSP页面中进行条件判断，就需要使用Core标签库提供的&lt;c:if&gt;标签，用于完成JSP页面中的条件判断 语法1：没有标签体的情况 1234&lt;!--test用于设置逻辑表达式--&gt;&lt;!--var用于用于指定逻辑表达式中变量的名字--&gt;&lt;c:if test=&quot;testCondition&quot; var=&quot;resulst&quot; [scope=&quot;&#123;page|request|session|application&#125;&quot;]/&gt; 语法2：有标签体的情况，在标签体中指定要输出的内容 12345&lt;!--scope用于指定var变量的作用范围，默认值为page--&gt;&lt;c:if test=&quot;testCondition&quot; var=&quot;resulst&quot; [scope=&quot;&#123;page|request|session|application&#125;&quot;]&gt; body content&lt;/c:if&gt; 实例：判断访问次数 123456789101112&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot;pageEncoding=&quot;utf-8&quot; import=&quot;java.util.*&quot;%&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;c:set value=&quot;1&quot; var=&quot;visitCount&quot; property=&quot;visitCount&quot; /&gt; &lt;c:if test=&quot;$&#123;visitCount==1 &#125;&quot;&gt; &lt;!--判断访问次数是否为1--&gt; This is you first visit. Welcome to the site! &lt;/c:if&gt;&lt;/body&gt;&lt;/html&gt; 实例：判断是否为管理员登录 123456789101112131415161718192021222324252627282930&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%--引入jstl核心标签库--%&gt;&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;&lt;%--EL表达式无法用可以添加以下语句--%&gt;&lt;%@ page isELIgnored=&quot;false&quot;%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h4&gt;if测试&lt;/h4&gt;&lt;hr&gt;&lt;%--转发到当前页面--%&gt;&lt;form action=&quot;Core_if.jsp&quot; method=&quot;get&quot;&gt; &lt;%--EL表达式获取表单中的数据 $&#123;param.参数名&#125;--%&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;$&#123;param.username&#125;&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;&lt;/form&gt;&lt;%--判断如果提交的是管理员，则登录成功--%&gt;&lt;%--var用于接收布尔值--%&gt;&lt;c:if test=&quot;$&#123;param.username == &#x27;admin&#x27;&#125;&quot; var =&quot;isAdmin&quot;&gt; &lt;c:out value=&quot;管理员欢迎您!&quot;/&gt;&lt;/c:if&gt;&lt;%--查看结果--%&gt;&lt;c:out value=&quot;$&#123;isAdmin&#125;&quot;/&gt;&lt;/body&gt;&lt;/html&gt; &lt;c:choose&gt;标签 Core标签库提供了&lt;c:choose&gt;标签，该标签用于指定多个条件选择的组合边界，它必须与&lt;c:when&gt;、&lt;c:otherwise&gt;标签一起使用。&lt;c:choose&gt;标签没有属性，在它的标签体中只能嵌套一个或多个&lt;c:when&gt;标签和零个或一个&lt;c:otherwise&gt;标签，并且同一个&lt;c:choose&gt;标签中所有的&lt;c:when&gt;子标签必须出现在&lt;c:otherwise&gt;子标签之前，其语法格式如下： 123&lt;c:choose&gt; Body content(&lt;when&gt; and &lt;otherwise&gt; subtags)&lt;/c:choose&gt; &lt;c:when&gt;标签只有一个test属性，该属性的值为布尔类型。test属性支持动态值，其值可以是一个条件表达式，如果条件表达式的值为true，就执行这个&lt;c:when&gt;标签体的内容，其语法格式如下： 1&lt;c:when test=&quot;testCondition&quot;&gt;Body content&lt;/c:when&gt; &lt;c:otherwise&gt;标签没有属性，它必须作为&lt;c:choose&gt;标签最后分支出现，当所有的&lt;c:when&gt;标签的test条件都不成立时，才执行和输出&lt;c:otherwise&gt;标签体的内容，其语法格式如下： 1&lt;c:otherwise&gt;conditional block&lt;/c:otherwise&gt; 12345678910111213141516171819&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot;pageEncoding=&quot;utf-8&quot; import=&quot;java.util.*&quot;%&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;c:choose&gt; &lt;c:when test=&quot;$&#123;empty param.username&#125;&quot;&gt; unKnown user. &lt;/c:when&gt; &lt;c:when test=&quot;$&#123;param.username==&#x27;itcast&#x27;&#125;&quot;&gt; $&#123; param.username&#125; is manager. &lt;/c:when&gt; &lt;c:otherwise&gt; $&#123; param.username&#125; is employee. &lt;/c:otherwise&gt; &lt;/c:choose&gt;&lt;/body&gt;&lt;/html&gt; &lt;c:foreach&gt;标签 在JSP页面中，经常需要对集合对象进行循环迭代操作，为此，Core标签库提供了一个&lt;c:forEach&gt;标签，该标签专门用于迭代集合对象中的元素，如Set、List、Map、数组等，并且能重复执行标签体中的内容。 语法1：迭代包含多个对象的集合 1234&lt;c:forEach [var=&quot;varName&quot;] items=&quot;collection&quot;[varStatus=&quot;varStatusName&quot;][begin=&quot;begin&quot;] [end=&quot;end&quot;] [step=&quot;step&quot;]&gt; body content&lt;/c:forEach&gt; 参数 说明 var 用于指将当前迭代到的元素保存到page域中的名称 items 用于指定将要迭代的集合对象 varStatus 用于指定当前迭代状态信息的对象保存到page域中的名称 begin 用于指定从集合中第几个元素开始进行迭代，begin的索引值从0开始 step 用于指定迭代的步长，即迭代因子的增量 语法2：迭代指定范围内的集合 123&lt;c:forEach [var=&quot;varName&quot;] [varStatus=&quot;varStatusName&quot;] begin=&quot;begin&quot; end=&quot;end&quot; [step=&quot;step&quot;]&gt;body content&lt;/c:forEach&gt; 12345678910111213141516171819202122232425262728&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot; pageEncoding=&quot;utf-8&quot; import=&quot;java.util.*&quot;%&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;% String[] fruits = &#123; &quot;apple&quot;, &quot;orange&quot;, &quot;grape&quot;, &quot;banana&quot; &#125;; %&gt; String数组中的元素： &lt;br /&gt; &lt;c:forEach var=&quot;name&quot; items=&quot;&lt;%=fruits%&gt;&quot;&gt; $&#123;name&#125;&lt;br /&gt; &lt;/c:forEach&gt; &lt;% Map userMap = new HashMap(); userMap.put(&quot;Tom&quot;, &quot;123&quot;); userMap.put(&quot;Make&quot;, &quot;123&quot;); userMap.put(&quot;Lina&quot;, &quot;123&quot;); %&gt; &lt;hr/&gt; HashMap集合中的元素： &lt;br /&gt; &lt;c:forEach var=&quot;entry&quot; items=&quot;&lt;%=userMap%&gt;&quot;&gt; $&#123;entry.key&#125;&amp;nbsp;$&#123;entry.value&#125;&lt;br /&gt; &lt;/c:forEach&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot;pageEncoding=&quot;utf-8&quot; import=&quot;java.util.*&quot;%&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; colorsList集合（指定迭代范围和步长）&lt;br /&gt; &lt;% List colorsList=new ArrayList(); colorsList.add(&quot;red&quot;); colorsList.add(&quot;yellow&quot;); colorsList.add(&quot;blue&quot;); colorsList.add(&quot;green&quot;); colorsList.add(&quot;black&quot;); %&gt; &lt;c:forEach var=&quot;color&quot; items=&quot;&lt;%=colorsList%&gt;&quot; begin=&quot;1&quot; end=&quot;3&quot; step=&quot;2&quot;&gt; $&#123;color&#125;&amp;nbsp; &lt;/c:forEach&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot;pageEncoding=&quot;utf-8&quot; import=&quot;java.util.*&quot;%&gt;&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body style=&quot;text-align: center;&quot;&gt; &lt;% List userList = new ArrayList(); userList.add(&quot;Tom&quot;); userList.add(&quot;Make&quot;); userList.add(&quot;Lina&quot;); %&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;td&gt;序号&lt;/td&gt; &lt;td&gt;索引&lt;/td&gt; &lt;td&gt;是否为第一个元素&lt;/td&gt; &lt;td&gt;是否为最后一个元素&lt;/td&gt; &lt;td&gt;元素的值&lt;/td&gt; &lt;/tr&gt; &lt;c:forEach var=&quot;name&quot; items=&quot;&lt;%=userList%&gt;&quot; varStatus=&quot;status&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;status.count&#125;&lt;/td&gt; &lt;td&gt;$&#123;status.index&#125;&lt;/td&gt; &lt;td&gt;$&#123;status.first&#125;&lt;/td&gt; &lt;td&gt;$&#123;status.last&#125;&lt;/td&gt; &lt;td&gt;$&#123;name&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;","path":"page/JavaWeb07.html","date":"01-15","excerpt":"","tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://xiaoliblog.cn/tags/JavaWeb/"}]},{"title":"JavaWeb🌍EL表达式","text":"EL表达式 EL：Expression Language，一种简单的数据访问语言，可以在JSP页面中直接使用！ 是一种在JSP页面获取数据的简单方式（只能获取数据，不能设置数据） 在JSP页面的任何静态部分均可通过：$&#123;expression&#125;来获取到指定表达式的值 需要导入jar包 12345&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt; 如果出现EL表达式无效，需要在JSP页面引入如下语句 1&lt;%@ page isELIgnored=&quot;false&quot;%&gt; EL简单实例 定义一个MyServlet设置username和password参数的值，然后请求转发到myjsp.jsp页面，通过EL表达式取值 1234567public class MyServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setAttribute(&quot;username&quot;, &quot;itcast&quot;); request.setAttribute(&quot;password&quot;, &quot;123&quot;); RequestDispatcher dispatcher = request.getRequestDispatcher(&quot;/myjsp.jsp&quot;); dispatcher.forward(request, response); &#125; myjsp.jsp页面用于取值 123456789101112131415&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot; pageEncoding=&quot;utf-8&quot;%&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; 使用JSP表达式:&lt;br/&gt; 用户名：&lt;%=request.getAttribute(&quot;username&quot;)%&gt;&lt;br /&gt; 密 码：&lt;%=request.getAttribute(&quot;password&quot;)%&gt;&lt;br /&gt; &lt;hr&gt; 使用EL表达式:&lt;br /&gt; 用户名：$&#123;username&#125;&lt;br /&gt; 密 码：$&#123;password&#125;&lt;br /&gt; &lt;/body&gt;&lt;/html&gt; EL标识符 不能以数字开头 不能是EL中的保留字，如and、or、gt 不能是EL隐式对象，如pageContext 不能包含单引号（’）、双引号（”）、减号（-）和正斜线等特殊字符。 保留字就是编程语言里事先定义好并赋予了特殊含义的单词，和其他语言一样，EL表达式中也定义了许多保留字，如false、not等，接下来就列举EL中所有的保留字，具体如下： 123and eq gt true instanceof or ne le false empty not lt ge null div mod EL变量常量 EL表达式中的变量就是一个基本的存储单元，EL表达式可以将变量映射到一个对象上，具体示例如下所示： 1$&#123;product&#125; product就是一个变量。EL表达式中的变量不用事先定义就可以直接使用，例如，表达式${product}就可以访问变量product的值。 EL常量 说明 布尔常量 true和false 整型常量 （-2）63~263-1之间的整数 浮点型常量 4.9E-324~1.8E308之间的整数 字符串常量 用单引号或双引号引起来的一连串字符 Null常量 用于表示变量引用的对象为空，它只有一个值，用null表示 EL运算符 EL表达式支持简单的运算，例如，加（+）、减（-）、乘（*）、除（/）等。为此，在EL中提供了多种运算符，EL中的运算符包括以下几种： 运算符 说明 实例 点运算符. 访问某些对象的属性 ${people.name} 方括号运算符[ ] 与点运算符类似，应用于属性名中包含一些特殊符号时取值 ${user[“My-Name”]} 算术运算符 +、-、*、/、% 比较运算符 结果为布尔类型，==、！=、&lt;、&gt;、&lt;=、&gt;= 逻辑运算符 结果为布尔类型，&amp;&amp;、 empty运算符 判断某个对象是否为null或” ”，结果为布尔类型 ${empty var} 条件运算符 类似于Java语言中的if-else语句 ${A?B:C} ()运算符 EL表达式中的圆括号用于改变其它运算符的优先级 EL隐式对象 EL中11个隐式对象 pageContext对象 为了获取JSP页面的隐式对象，可以使用EL表达式中的pageContext隐式对象获取其他10个隐式对象。 pageContext隐式对象的示例代码如下： 1$&#123;pageContext.response.characterEncoding&#125; pageContext对象获取response对象中的characterEncoding属性 1234567891011&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot; pageEncoding=&quot;utf-8&quot;%&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; 请求URI为：$&#123;pageContext.request.requestURI&#125; &lt;br /&gt; Content-Type响应头：$&#123;pageContext.response.contentType&#125; &lt;br /&gt; 服务器信息为：$&#123;pageContext.servletContext.serverInfo&#125; &lt;br /&gt; Servlet注册名为：$&#123;pageContext.servletConfig.servletName&#125; &lt;br /&gt;&lt;/body&gt;&lt;/html&gt; Web域相关对象 HttpRequest对象存储的数据只在当前请求中可以获取到。习惯性的，我们把这些Map集合称为域，这些Map集合所在的对象称为域对象。在EL表达式中，为了获取指定域中的数据，提供了pageScope、requestScope、sessionScope和applicationScope(范围由小到大)四个隐式对象，示例代码如下 12$&#123;pageScope.userName&#125; $&#123;requestScope.userName&#125; $&#123;sessionScope.userName&#125; $&#123;applicationScope.userName&#125; 1234567891011121314151617&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot; pageEncoding=&quot;utf-8&quot;%&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;% pageContext.setAttribute(&quot;userName&quot;, &quot;itcast&quot;); %&gt; &lt;% request.setAttribute(&quot;bookName&quot;, &quot;Java Web&quot;); %&gt; &lt;% session.setAttribute(&quot;userName&quot;, &quot;itheima&quot;); %&gt; &lt;% application.setAttribute(&quot;bookName&quot;, &quot;Java 基础&quot;); %&gt; 表达式\\$&#123;pageScope.userName&#125;的值为：$&#123;pageScope.userName&#125; &lt;br /&gt; 表达式\\$&#123;requestScope.bookName&#125;的值为：$&#123;requestScope.bookName&#125; &lt;br /&gt; 表达式\\$&#123;sessionScope.userName&#125;的值为：$&#123;sessionScope.userName&#125; &lt;br /&gt; 表达式\\$&#123;applicationScope.bookName&#125;的值为：$&#123;applicationScope.bookName&#125; &lt;br /&gt; 表达式\\$&#123;userName&#125;的值为：$&#123;userName&#125;&lt;/body&gt;&lt;/html&gt; param和paramValues对象 param对象用于获取请求参数的某个值，它是Map类型，与request.getParameter()方法相同，在使用EL获取参数时，如果参数不存在，返回的是空字符串，而不是null，具体示例如下： 1$&#123;param.num&#125; 如果一个请求参数有多个值，可以使用paramValues对象来获取请求参数的所有值，该对象用于返回请求参数所有值组成的数组，如果要获取某个请求参数的第一个值，可以使用如下代码： 1$&#123;paramValues.nums[0]&#125; 123456789101112131415161718&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot; pageEncoding=&quot;utf-8&quot;%&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body style=&quot;text-align: center;&quot;&gt; &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/param.jsp&quot;&gt; num1：&lt;input type=&quot;text&quot; name=&quot;num1&quot;&gt;&lt;br /&gt; num2：&lt;input type=&quot;text&quot; name=&quot;num&quot;&gt;&lt;br /&gt; num3：&lt;input type=&quot;text&quot; name=&quot;num&quot;&gt;&lt;br /&gt; &lt;br /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;&amp;nbsp;&amp;nbsp; &lt;input type=&quot;submit&quot; value=&quot;重置&quot; /&gt; &lt;hr&gt; num1：$&#123;param.num1&#125;&lt;br /&gt; num2：$&#123;paramValues.num[0]&#125;&lt;br /&gt; num3：$&#123;paramValues.num[1]&#125;&lt;br /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; header和headerValues对象 header对象用于获取请求头字段的某个值，具体示例如下： 1$&#123;header[&quot;user-agent&quot;]&#125; 如果一个请求头字段有多个值，可以使用headerValues对象，该对象用于返回请求头字符的所有值组成的数组，如果要获取某个请求头字段的第一个值，可以使用如下代码： 1$&#123;headerValues[&quot;Accept-Language&quot;][0]&#125; Cookie对象 在JSP开发中，经常需要获取客户端的Cookie信息，为此，在EL表达式中，提供了Cookie隐式对象，该对象是一个代表所有Cookie信息的Map集合， Map集合中元素的关键字为各个Cookie的名称，值则为对应的Cookie对象，具体示例如下： 123获取cookie对象的信息：$&#123;cookie.userName&#125;获取cookie对象的名称：$&#123;cookie.userName.name&#125;获取cookie对象的值：$&#123;cookie.userName.value&#125; 123456789101112&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot; pageEncoding=&quot;utf-8&quot;%&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; Cookie对象的信息：&lt;br /&gt; $&#123;cookie.userName &#125; &lt;br /&gt; Cookie对象的名称和值：&lt;br /&gt; $&#123;cookie.userName.name &#125;=$&#123;cookie.userName.value &#125; &lt;% response.addCookie(new Cookie(&quot;userName&quot;, &quot;itcast&quot;)); %&gt;&lt;/body&gt;&lt;/html&gt; 第一次访问并不会显示信息，服务器会向浏览器回写一个Cookie，此时的Cookie信息存储在浏览器中，当刷新页面第二次访问时，浏览器会将此Cookie信息一同发送给服务器，使用表达式获取名称和值 initParam对象 在开发一个Web应用程序时，通常会在web.xml文件中配置一些初始化参数，为了方便获取这些参数，EL表达式提供了一个initParam隐式对象，该对象可以获取Web应用程序中全局初始化参数，具体示例如下所示： 1$&#123;initParam.count&#125;","path":"page/JavaWeb06.html","date":"01-15","excerpt":"","tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://xiaoliblog.cn/tags/JavaWeb/"}]},{"title":"JavaWeb🌍JSP技术","text":"JSP技术 JSP中文文档：https://www.vxzsk.com/2015.html JSP全名是Java Server Pages，它是建立在Servlet规范之上的动态网页开发技术。在JSP文件中，HTML代码与Java代码共同存在，其中，HTML代码用来实现网页中静态内容的显示，Java代码用来实现网页中动态内容的显示。 JSP特征 跨平台：当从一个平台移植到另一个平台时，JSP和JavaBean的代码并不需要重新编译，这是因为Java的字节码是与平台无关的。 业务代码相分离：在使用JSP技术开发Web应用时，可以将界面的开发与应用程序的开发分离开。 预编译：预编译就是在用户第一次通过浏览器访问JSP页面时，服务器将对JSP页面代码进行编译，并且仅执行一次编译。编译好的代码将被保存，在用户下一次访问时，会直接执行编译好的代码。 组件重用：JSP中可以使用JavaBean编写业务组件，也就是使用一个JavaBean类封装业务处理代码或者作为一个数据存储模型。 JSP运行原理 客户端发出请求，请求访问JSP文件 JSP容器先将JSP文件转换成一个Java源文件(Java Servlet源程序)，在转换过程中，如果发现JSP文件中存在错误，则中断转换过程，并向服务器和客户端返回错误信息 如果转换成功，将Java源文件编译成字节码文件.class，该class文件就是一个Servlet 由Servlet容器加载转换后的Serlvet类（.class文件）创建该类对象，即Servlet实例，并执行Servlet的jspInit()方法，只调用一次 执行jspService()方法来处理客户端的请求，对于每一个请求，JSP容器都会创建一个新的线程来处理它 当请求处理完成后，响应对象由JSP容器接收，并将HTML格式的响应信息发送回客户端 浏览器向服务器发送请求，不管访问什么资源，其实都是在访问Servlet，JSP最终也会被转换成一个Java类，可以说JSP本身就是一个Servlet！ JSP源码分析 在Tomcat安装目录下找到index_jsp.java文件 1C:\\JavaWeb\\tomcat\\work\\Catalina\\localhost\\ROOT\\org\\apache\\jsp 可以看到JSP最终还是一个Java文件，打开index_jsp.java文件即可查看JSP源码 源码分析 12345678910111213//初始化 public void _jspInit() &#123; &#125;//销毁public void _jspDestroy() &#123; &#125;//JSP服务pub1ic void_ jspservice(HttpservletRequest request,HttpservletResponse response)&#123;&#125; 内置对象 12345678final javax.servlet.jsp.PageContext pageContext; //页面上下文javax.servlet.http.Httpsession session = nu11; //Sessionfinal javax.servlet.ServletContext application; //applicationfinal javax.servlet.ServletConfig config; //configjavax.servlet.jsp.JspWriter out = null; //outfinal java.lang.Object page = this; //page 当前HttpservletRequest request; //请求HttpservletResponse response; //响应 输出页面前增加的代码 1234567 response.setContentType(&quot;text/html; charset=UTF-8&quot;); pageContext = _jspxFactory.getPageContext(this, request, response,null, false, 8192, true);_jspx_page_context = pageContext;application = pageContext.getServletContext();config = pageContext.getServletConfig();out = pageContext.getOut();_jspx_out = out; 以上的这些对象可以直接在JSP页面中使用！ JSP依赖搭建 新建项目后，需要导入Servlet、JSP、JSTL、StandardLib的jar包 1234567891011121314151617181920212223242526&lt;!--Servlet依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;!--JSP依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;!--JSTL依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--Standardlib依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt; JSP基本语法 JSP脚本元素是指嵌套在&lt;% %&gt;之中的一条或多条Java程序代码。通过JSP脚本元素可以将Java代码嵌入HTML页面中，所有可执行的Java代码，都可以通过JSP脚本来执行。 JSP注释1&lt;%-- 注释信息 --%&gt; 注意：Tomcat在将JSP页面编译成Servlet程序时，会忽略JSP页面中被注释的内容，不会将注释信息发送到客户端 SP表达式 JSP表达式（expression）用于将程序数据输出到客户端，不能定义变量，它将要输出的变量或者表达式直接封装在“&lt;%” 开头和以“%&gt;”结尾的标记中，其基本的语法格式如下所示： 1&lt;%= 变量或者表达式 %&gt; 比如输出时间 12&lt;%-- JSP表达式：用于输出数据到客户端--%&gt;&lt;%= new java.util.Date()%&gt; JSP脚本片段 JSP脚本片段也叫JSP Scriptlets 是一段代码段。可以定义变量，调用表达式，输出内容，但不能定义方法，因为其本身就是一个方法。JSP Scriptlets的语法格式如下所示： 1&lt;% java 代码（变量、方法、表达式等）%&gt; 在 JSP Scriptlets中声明的变量是JSP页面的局部变量，调用 JSP Scriptlets时，会为局部变量分配内存空间，调用结束后，释放局部变量占用的内存空间 例如 1234567&lt;% int sum = 0; for (int i = 1; i &lt; 100; i++) &#123; sum+=i; &#125; out.println(&quot;&lt;h1&gt;Sum=&quot;+sum+&quot;&lt;/h1&gt;&quot;);%&gt; 运行结果 代码可以进行拆分，比如循环输出五个Hello 12345678&lt;%--嵌入HTML元素--%&gt;&lt;% for (int i = 0; i &lt; 5; i++) &#123;%&gt;&lt;h1&gt;Hello &lt;%=i%&gt;&lt;/h1&gt;&lt;% &#125;%&gt; JSP声明语句 JSP的声明语句用于声明变量和方法，其定义的变量为全局变量，它以“&lt;%!”开始，以“%&gt;”结束，其语法格式如下所示： 123&lt;%! 定义的变量或方法等%&gt; 123456789&lt;%! static&#123; System.out.println(&quot;Loading Servlet!&quot;); &#125; private int globalVar = 0; public void test() &#123; System.out.println(&quot;进入了方法test&quot;); &#125;%&gt; JSP声明会被编译到Java的类中！其他的，就会被生成到_jspServlet方法中 JSP指令page指令 page指令用于对页面的某些特性进行描述，例如，页面的编码方式，JSP页面采用的语言等。其语法为： 1&lt;%@ page 属性名= &quot;属性值&quot;%&gt; 在page指令的语法格式中，page用于声明指令名称，属性用来指定JSP页面的某些特性。page指令提供了一系列与JSP页面相关的属性。 注意：page指令对整个页面都有效，而与其书写的位置无关，但是习惯上把page指令写在JSP页面的最前面 其中import属性可以多次使用，其他属性只能出现一次 123&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%@ page import=&quot;java.awt.*&quot;%&gt;&lt;%@ page import=&quot;java.util.*&quot;,&quot;java.awt.*&quot;%&gt; 自定义错误页面 errorPage 指定发生错误的页面，当前页面如果抛出异常，那么要转发到哪一个页面，由errorPage来指定 isErrorPage 它指定当前页面是否为处理错误的页面即显示异常信息！当该属性为true时，这个页面会设置状态码为500！而且这个页面可以使用9大内置对象中的exception! 123456789101112131415&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%--定制错误页面，发生错误就跳转到errot目录下的500.jsp页面--%&gt;&lt;%@ page errorPage=&quot;error/500.jsp&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;错误页面&lt;/title&gt;&lt;/head&gt;&lt;% int x = 1/0;%&gt;&lt;/body&gt;&lt;/html&gt; error/500.jsp页面 12345678910&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page isErrorPage=&quot;true&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;500错误页面&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 运行结果 除了以上方法外，还可以通过配置web.xml来自定义错误页面 在webapp/error下新建404.jsp和500.jsp，可以在里面自定义错误页面 配置web.xml文件 12345678910&lt;web-app&gt; &lt;error-page&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/error/500.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/error/404.jsp&lt;/location&gt; &lt;/error-page&gt;&lt;/web-app&gt; 访问ErrorPage.jsp页面 12345678910111213&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;错误页面&lt;/title&gt;&lt;/head&gt;&lt;% int x = 1/0;%&gt;&lt;/body&gt;&lt;/html&gt; 开始访问为500错误页面 随便访问一个不存在的页面，会报404错误 include指令 include指令用于在JSP页面静态包含一个文件，例如HTML文件，文本文件等。其语法为： 1&lt;%@ include file=&quot;被包含的文件地址&quot;%&gt; include指令只有一个file属性，该属性用来指定插入到JSP页面目标位置的文件资源。需要注意的是，插入文件的路径一般不以“/”开头，而是使用相对路径。 需要注意的问题 被引入的文件必须遵循JSP语法，其中的内容可以包含静态HTML、JSP脚本元素和JSP指令等普通JSP页面所具有的一切内容。 除了指令元素之外，被引入的文件中的其他元素都被转换成相应的Java源代码，然后插入进当前JSP页面所翻译成的Servlet源文件中，插入位置与include指令在当前JSP页面中的位置保持一致。 file属性的设置值必须使用相对路径，如果以“/”开头，表示相对于当前Web应用程序的根目录（注意不是站点根目录8080），否则，表示相对于当前文件。需要注意的是，这里的file属性指定的相对路径是相对于文件（file），而不是相对于页面（page）。 超链接、重定向、action地址不用加”/“ 合并网页结构 测试：创建一个strcut文件夹下新建footer.jsp和header.jsp文件 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;footer.jsp&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;我是Footer&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;header.jsp&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;我是Header&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 创建一个Body.jsp使用includ指令把上面两页面包含进来 1234567891011&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Body.jsp&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;%@ include file=&quot;struct/header.jsp&quot;%&gt; &lt;h3&gt;我是Body&lt;/h3&gt; &lt;%@ include file=&quot;struct/footer.jsp&quot;%&gt;&lt;/body&gt;&lt;/html&gt; 运行结果 也可以使用JSP动作标签，只是路径不一样 12345678910111213&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;%--JSP标签--%&gt; &lt;jsp:include page=&quot;/struct/header.jsp&quot;/&gt; &lt;h3&gt;我是Body&lt;/h3&gt; &lt;jsp:include page=&quot;/struct/footer.jsp&quot;/&gt;&lt;/body&gt;&lt;/html&gt; inlcude指令是静态包含：其处理是先合并再编译，所以两个页面中不能重复定义变量&lt;jsp: inlcude&gt;是动态包含：其处理是先编译再合并，所以两个页面可以重复定义变量 taglib指令 JSP API允许用户自定义标签，一个自定义标签库就是自定义标签的集合 Taglib指令引入一个自定义标签集合的定义，包括库路径、自定义标签 12&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;&lt;c:out value=&quot;renliang&quot;&gt;&lt;/c:out&gt; &lt;!--使用标签库--&gt; prefix：指定标签库在本页面中的前缀！由我们自己来起名称！ uri: 指定标签库的位置！ JSP内置对象 为了简化Web应用程序的开发，JSP 2.0规范中提供了9个内置（隐式）对象，它们是JSP默认创建的，可以直接在JSP页面中使用 隐式对象的名称、类型和描述信息如下所示： out对象 out对象是java.servlet.jsp.JspWriter类的实例对象，其作用是用来向客户端发送文本形式的实体内容。out对象的类型为JspWriter，它相当于一种带缓存功能的PrintWriter。 从图中可以看出，在JSP页面中，通过out隐式对象写入数据相当于将数据插入到JspWriter对象的缓冲区中，只有调用了ServletResponse.getWriter()方法，缓冲区的数据才能真正写入到Servlet引擎所提供的缓冲区中 12345678910111213&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; buffer=&quot;0kb&quot;%&gt;&lt;!--buffer属性用于设置out对象的缓冲区大小--&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;% out.println(&quot;first line&lt;br /&gt;&quot;); response.getWriter().println(&quot;second line&lt;br /&gt;&quot;); %&gt;&lt;/body&gt;&lt;/html&gt; 设置buffer=&quot;0kb&quot; 可以不经过缓冲区，此字段用于设置缓冲区大小 exception对象 在JSP页面中，经常需要处理一些异常信息，这时，可以通过exception对象来实现 exception对象是java.lang.Exception类的实例对象，用于封装JSP中抛出的异常信息。 需要注意的是，exception对象只有在错误处理页面才可以使用，即page指令中指定了属性&lt;%@ page isErrorPage=&quot;true&quot;%&gt;的页面 exception.jsp，发送异常的页面，跳转到error.jsp 123456789101112131415&lt;!--exception.jsp--&gt;&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; errorPage=&quot;error.jsp&quot;%&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;exception object test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% int a = 3; int b = 0;%&gt;输出结果为：&lt;%=(a / b)%&gt;&lt;!--此处会产生异常 --&gt;&lt;/body&gt;&lt;/html&gt; error.jsp用于处理exception.jsp的异常信息 123456789101112&lt;!--error.jsp--&gt;&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; isErrorPage=&quot;true&quot;%&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;error page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 显示异常信息 --&gt; &lt;%=exception.getMessage() %&gt;&lt;br /&gt;&lt;/body&gt;&lt;/html&gt; 运行exception.jsp页面，浏览器将错误显示了出来，说明当exception.jsp页面发生错误时，会自动调用error.jsp页面进行错误处理 pageContext对象 pageContext对象是javax.servlet.jsp.PageContext类的实例对象，它代表当前JSP页面的运行环境，并提供了一系列用于获取其他隐式对象的方法 pageContext对象不仅提供了获取隐式对象的方法，还提供了存储数据的功能。pageContext对象存储数据是通过操作属性来实现的，其操作属性的一系列方法如下 Scope取值 说明 pageContext.PAGE_SCOPE 表示页面范围 pageContext.REQUEST_SCOPE 表示请求范围 pageContext.SESSION_SCOPE 表示会话范围 pageContext.APPLICATION_SCOPE 表示Web应用程序范围 12345678910111213141516171819202122232425&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;%&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;pageContext&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% //获取request对象 HttpServletRequest req = (HttpServletRequest) pageContext.getRequest(); //设置page范围内属性 pageContext.setAttribute(&quot;str&quot;, &quot;Java&quot;,pageContext.PAGE_SCOPE); //设置request范围内属性 req.setAttribute(&quot;str&quot;, &quot;Java Web&quot;); //获得的page范围属性 String str1 = (String)pageContext.getAttribute(&quot;str&quot;,pageContext.PAGE_SCOPE); //获得的request范围属性 String str2 =(String)pageContext.getAttribute(&quot;str&quot;,pageContext.REQUEST_SCOPE);%&gt; &lt;%=&quot;page范围：&quot;+str1 %&gt;&lt;br /&gt; &lt;%=&quot;request范围：&quot;+str2 %&gt;&lt;br /&gt;&lt;/body&gt;&lt;/html&gt;&lt;!--page范围:Javarequest范围:Java Web--&gt; pageContext的特点(一个顶9个！) pageContext：一个jsp页面！这个域是在当前jsp页面和当前jsp页面中使用的标签之间共享数据！ 域对象 代理其他域：pageContext.setAttribute(“xxx”, “XXX”, PageContext.SESSION_SCOPE); 全域查找：pageContext.findAttribute(“xxx”);从小到大，依赖查找！ 获取其他8个内置对象 四大作用域 Servlet中有三大域，而JSP中有四大域！ 对象 域 范围 ServletContext application 整个Web应用程序 HttpServletRequet session 整个会话(一个会话中只有一个用户) HttpSession request 保存的数据只在同一个请求中有效，请求转发会携带这个数据 PageContext page 只能在当前jsp页面使用！ 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;web-app version=&quot;2.5&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ page isELIgnored=&quot;false&quot;%&gt; &lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%--四大存信息的对象--%&gt;&lt;% //保存的数据只在一个页面中有效 pageContext.setAttribute(&quot;name1&quot;,&quot;one&quot;); //保存的数据只在一个请求中有效，请求转发会携带这个数据 request.setAttribute(&quot;name2&quot;,&quot;two&quot;); //保存的数据只在一个会话中有效，从打开浏览器到关闭浏览器 session.setAttribute(&quot;name3&quot;,&quot;three&quot;); //保存的数据只在服务器中有效，从打开服务器到关闭服务器 application.setAttribute(&quot;name4&quot;,&quot;four&quot;);%&gt;&lt;%--通过pageContext取出保存的值--%&gt;&lt;% String name1 = (String) pageContext.findAttribute(&quot;name1&quot;); String name2 = (String) pageContext.findAttribute(&quot;name2&quot;); String name3 = (String) pageContext.findAttribute(&quot;name3&quot;); String name4 = (String) pageContext.findAttribute(&quot;name4&quot;);%&gt;&lt;%--通过EL表达式取出,为空的会输出null--%&gt;&lt;h1&gt;取出的值为:&lt;/h1&gt;&lt;h3&gt;$&#123;name1&#125;&lt;/h3&gt;&lt;h3&gt;$&#123;name2&#125;&lt;/h3&gt;&lt;h3&gt;$&#123;name3&#125;&lt;/h3&gt;&lt;h3&gt;$&#123;name4&#125;&lt;/h3&gt;&lt;%--也可以通过JSP表达式取出,为空的会输出null--%&gt;&lt;h3&gt;&lt;%=name1%&gt;&lt;/h3&gt;&lt;h3&gt;&lt;%=name2%&gt;&lt;/h3&gt;&lt;h3&gt;&lt;%=name3%&gt;&lt;/h3&gt;&lt;h3&gt;&lt;%=name4%&gt;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 如果无法使用EL表达式，可以引入&lt;%@ page isELIgnored=&quot;false&quot;%&gt;，或者在模块中手动添加JSP的jar包 JavaBean JavaBean 是Java开发语言中一个可以重复使用的软件组件，本质是一个Java类 编码规范：具有一个公共的、无参的构造方法，提供公共的setter方法和getter方法 如果属性的类型为boolean，它的命名方式应该使用is/set而不是get/set JavaBean的作用 一般用来和数据库的字段做映射ORM（对象关系映射） 表–&gt;类 字段—&gt;属性 行记录—-&gt;对象 比如一个People表如下 id name age address 1 小李1 21 长沙 2 小李2 22 长沙 3 小李3 23 长沙 对应一个JavaBean 123456789101112131415161718public class People&#123; private int id; private String name; private int age; private String address; public int getId()&#123; return id; &#125; publice void setId(int id)&#123; this.id=id; &#125; //其他方法省略....&#125;class A&#123; new People(1,&quot;小李1&quot;,21,&quot;长沙&quot;);&#125; BeanUtils 由于各种Java工具和框架层出不穷，并不能保证属性对应的getter和setter方法总能被调用，因此动态访问Java对象的属性是十分必要的，为此，Apache软件基金会提供了一套简单、易用的API——BeanUtils工具。 需要注意的是，除了BeanUtils工具包外还需要一个logging包来配合使用，logging包中包装了各种日志API的实现 下载引入第三方包 戳Apache官网链接 戳配置教程 BeanUtils类的常用方法 1234567891011121314151617package beanutils;public class Person &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 1234567891011121314151617181920212223242526272829package beanutils;import java.util.HashMap;import java.util.Map;import org.apache.commons.beanutils.BeanUtils;public class BeanUtilsDemo &#123; public static void main(String[] args) throws Exception &#123; Person p = new Person(); // 使用BeanUtils为属性赋值 BeanUtils.setProperty(p, &quot;name&quot;, &quot;Jack&quot;); BeanUtils.setProperty(p, &quot;age&quot;, 10); // 使用BeanUtils获取属性值 String name = BeanUtils.getProperty(p, &quot;name&quot;); String age = BeanUtils.getProperty(p, &quot;age&quot;); System.out.println(&quot;我的名字是&quot; + name + &quot;,我今年&quot; + age + &quot;岁了！&quot;); // 创建map集合，用于存放属性及其属性值 Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;name&quot;, &quot;张三&quot;); map.put(&quot;age&quot;, 10); // 使用populate()方法为对象的属性赋值 BeanUtils.populate(p, map); // 打印赋值后对象的信息 System.out.println(&quot;姓名：&quot; + p.getName() + &quot;, 年龄：&quot; + p.getAge()); &#125;&#125;/*运行结果我的名字是Jack，我今年10岁了姓名：张三，年龄：10*/ JSP动作元素 JSP动作元素用来控制JSP的行为，执行一些常用的JSP页面动作 动作标签是由tomcat(服务器)来解释执行！而html标签由浏览器来执行！ &lt;jsp:include&gt;动作元素 在JSP页面中，为了把其他资源的输出内容插入到当前JSP页面的输出内容中，JSP技术提供了&lt;jsp:include&gt;动作元素 其语法格式为： 1&lt;jsp:include page=&quot;relativeURL&quot; flush=&quot;true|false&quot; /&gt; page指定被引入的相对路径，flush指定是否将当前页面的输出内容刷新到客户端，默认false &lt;jsp:include&gt;包含的原理是将被包含的页面编译处理后将结果包含在页面中。当浏览器第一次请求一个使用&lt;jsp:include&gt;包含其他页面的页面时，Web容器首先会编译被包含的页面，然后将编译处理后的返回结果包含在页面中，之后编译包含页面，最后将两个页面组合的结果回应给浏览器 123456789101112131415&lt;!--included.jsp--&gt;&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;include&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;%Thread.sleep(5000);%&gt; included.jsp内的中文&lt;br /&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021&lt;!--dynamicInclude.jsp--&gt;&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;dynamicInclude page&lt;/title&gt;&lt;/head&gt;&lt;body&gt; dynamicInclude.jsp内的中文 &lt;br&gt; &lt;jsp:include page=&quot;included.jsp&quot; flush=&quot;false&quot; /&gt;&lt;/body&gt;&lt;/html&gt;&lt;!--dynamicInclude.jsp内的中文included.jsp内的中文--&gt; 浏览器首先显示dynamicInclude.jsp页面的输出内容，等待5秒后，才会显示include.jsp页面的输出内容。说明被引用的资源included.jsp在当前JSP页面输出内容后才被调用。 &lt;jsp:include page=&quot;xxx&quot;/&gt;，用来包含指定的页面。假如有两个jsp. 分别为a.jsp和b.jsp,他们分别编码成Servlet，然后在执行Servlet时才会执行包含过程。这也是include指令与include标签的区别 该标签内部使用的是RequestDispatcher.include()方法完成的包含 &lt;jsp:forward&gt;动作元素 &lt;jsp:forward&gt;动作元素将当前请求转发到其他Web资源（HTML页面、JSP页面和Servlet等） 在执行请求转发之后的当前页面将不再执行(后面的代码不再执行)，而是执行该元素指定的目标页面 其语法格式为： 12&lt;jsp:forward page=&quot;relativeURL&quot; /&gt;//page指定请求转发到的资源的相对路径 1234567891011121314&lt;!--jspforward.jsp--&gt;&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;forword page&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;jsp:forward page=&quot;welcome.jsp&quot; /&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718&lt;!--welcome.jsp--&gt;&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;welcome page&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 你好，欢迎进入首页，当前访问时间是： &lt;% out.print(new java.util.Date()); %&gt;&lt;/body&gt;&lt;/html&gt; 运行后，地址栏中显示的是jspforward.jsp，但浏览器显示出welcome.jsp的输出内容。由于请求转发是服务器端的操作，浏览器并不知道请求的页面，所以地址栏不会发生改变 &lt;jsp:forward page=&quot;xxx&quot;/&gt;，用来转发到指定页面。例如在a.jsp中存在如下内容：&lt;jsp:fowrad page=&quot;b.jsp&quot;/&gt;，a.jsp中的内容不会显示在浏览器上，而只是显示b.jsp的内容。而且在&lt;jsp:forwad&gt;标签下面的内容不会被执行。 &lt;jsp:param&gt;动作元素 标签是和的子标签，用来向其他页面传递参数。 123&lt;jsp:include page=&quot;/b.jsp&quot;&gt; &lt;jsp:param value=&quot;zhangSan&quot; name=&quot;username&quot;/&gt; &lt;/jsp:include&gt; 在b.jsp中可以使用表达式来获取参数值。 1&lt;%=request.getParameter(&quot;username&quot;)=&gt; 比如创建了jsptag01.jsp页面，设置参数转发到jsptag02.jsp页面 123456789101112131415&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;1号页面&lt;/h1&gt;&lt;%--http://localhost:8080/jsptag.jsp?name=xiaoli&amp;age=21--%&gt; &lt;%--设置参数--%&gt; &lt;jsp:forward page=&quot;jsptag02.jsp&quot;&gt; &lt;jsp:param name=&quot;name&quot; value=&quot;xiaoli&quot;/&gt; &lt;jsp:param name=&quot;age&quot; value=&quot;21&quot;/&gt; &lt;/jsp:forward&gt;&lt;/body&gt;&lt;/html&gt; 在jsptag02.jsp页面中取得参数 123456789101112&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;2号页面&lt;/h1&gt; &lt;%--取参数--%&gt; 名字:&lt;%=request.getParameter(&quot;name&quot;)%&gt; 年龄:&lt;%=request.getParameter(&quot;age&quot;)%&gt;&lt;/body&gt;&lt;/html&gt; &lt;jsp:useBean&gt;动作元素 假设有一个JavaBean，如下所示 123456789101112131415161718192021222324package UserBean;public class User &#123; private int id ; private String username ; private String password ; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getUserame() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 创建JavaBean对象 &lt;jsp:useBean&gt; 标签可以在 JSP 中声明一个 JavaBean，然后使用。声明后，JavaBean 对象就成了脚本变量，可以通过脚本元素或其他自定义标签来访问 &lt;jsp:useBean&gt; 标签的语法格式如下： 123&lt;!--id表示对象名为user，class表示完整路径在UserBean.User--&gt;&lt;!--等价于User user=new User()--&gt;&lt;jsp:useBean id=&quot;user&quot; class=&quot;UserBean.User&quot; scope=&quot;page&quot;/&gt; scope表示作用域范围，可以有如下取值： application作用域当指定JavaBean的作用域为application表示在整个项目的生命周期中都有效，服务器重启后失效 session作用域session作用域表示在当前会话周期内有效，只要仍在当前的会话生命周期内，就可以获取到相应的属性值。 request作用域request作用域表示在当前用户的请求内有效，如果超过了当前请求，则获取不到相应的JavaBean的值。 page作用域page作用域表示只在当前的页面有效，所以不管是请求重定向还是服务器内部转发，当发生页面跳转时都不能获取到JavaBean的属性值信息。page作用域是jsp:useBean的默认作用域。 访问 JavaBean对象 在 &lt;jsp:useBean&gt; 标签主体中使用 &lt;jsp:getProperty/&gt;标签来调用 getter 方法，使用&lt;jsp:setProperty/&gt; 标签来调用 setter 方法，语法格式如下： 12345678910111213141516&lt;jsp:useBean id=&quot;user&quot; class=&quot;UserBean.User&quot; scope=&quot;page&quot;&gt;&lt;!--name是Bean的id属性,property表示需要访问的Bean属性，value表示默认值--&gt; &lt;jsp:setProperty name=&quot;user&quot; property=&quot;usename&quot; value=&quot;张三&quot;&gt; &lt;jsp:setProperty name=&quot;user&quot; property=&quot;password&quot; value=&quot;123&quot;&gt;&lt;/jsp:useBean&gt; &lt;p&gt;用户名: &lt;jsp:getProperty name=&quot;user&quot; property=&quot;username&quot;&gt;&lt;/p&gt;&lt;p&gt;用户密码:&lt;jsp:getProperty name=&quot;user&quot; property=&quot;password&quot;&gt;&lt;/p&gt;&lt;!--用户名: 张三密码: 123--&gt; 实例：用户提交用户名和密码后，显示信息 123456789101112131415161718192021&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--传了一个myName的参数，在另一页面用param取--&gt; &lt;form action=&quot;test.jsp?myName=lisi&quot; method=&quot;post&quot;&gt; &lt;label for=&quot;userName&quot;&gt;用户名:&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;userName&quot; value=&quot;&quot; /&gt; &lt;br/&gt; &lt;label for=&quot;password&quot;&gt;密码：&lt;/label&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot; value=&quot;&quot; /&gt; &lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot; /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;jsp:useBean id=&quot;user&quot; class=&quot;UserBean.User&quot; scope=&quot;page&quot;&gt;&lt;/jsp:useBean&gt; &lt;h2&gt;跟表单关联，设置所有的属性值&lt;/h2&gt; &lt;hr/&gt; &lt;%--*表示取所有属性&lt;jsp:setProperty property=&quot;*&quot; name=&quot;user&quot;/&gt;--%&gt; &lt;%--设置默认值value&lt;jsp:setProperty property=&quot;username&quot;name=&quot;user&quot;value=&quot;zhangsan&quot;/&gt;--%&gt; &lt;%--param用于取参数 &lt;jsp:setProperty property=&quot;username&quot; name=&quot;user&quot; param=&quot;myName&quot;/&gt; --%&gt;&lt;jsp:setProperty property=&quot;username&quot; name=&quot;user&quot;/&gt;&lt;jsp:setProperty property=&quot;password&quot; name=&quot;user&quot;/&gt; 用户名：&lt;jsp:getProperty property=&quot;username&quot; name=&quot;user&quot;/&gt;&lt;br/&gt; 密码：&lt;jsp:getProperty property=&quot;password&quot; name=&quot;user&quot;/&gt; &lt;/body&gt;&lt;/html&gt;","path":"page/JavaWeb05.html","date":"01-15","excerpt":"","tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://xiaoliblog.cn/tags/JavaWeb/"}]},{"title":"JavaWeb🌍会话技术","text":"会话技术 两个人你问我答的过程就是一个会话，在Web开发中，服务器跟踪用户信息的技术称为会话技术 Web应用中的会话过程类似于生活中的打电话过程，它指的是一个客户端（浏览器）与Web服务器之间连续发生的一系列请求和响应过程。 在Servlet技术中，提供了两个用于保存会话数据的对象，分别是Cookie和Session 通俗点说，一个网站要怎样证明你来过？ 服务端给客户端-个信件，客户端下次访问服务端带上信件就可以了; cookie 服务器登记你来过了，下次你来的时候我来匹配你; seesion Cookie对象 Cookie是一种会话技术，它用于将会话过程中的数据保存到用户的浏览器中，从而使浏览器和服务器可以更好地进行数据交互 Cookie原理 Cookie在浏览器和服务器之间的传输 首次访问，服务器给客户端Cookie 第二次访问，客户端带上Cookie 第一次访问服务器，服务器会增加Set-Cookie头字段，将Cookie信息发送给浏览器，并保存在客户端 1Set-Cookie: user=lzy; Path=/; user表示Cookie的名称，lzy表示Cookie的值，Path表示Cookie的属性。需要注意的是，Cookie必须以键值对的形式出现，其属性可以有多个，属性之间必须用分号和空格隔开 当后续访问服务器时，会在请求消息中将用户信息以Cookie的形式发送给服务器，从而使服务器端分辨出当前请求是由哪个用户发出的 Cookie API 在Servlet API中提供了javax.servlet.http.Cookie类，它包含了生成Cookie信息和提取Cookie信息各个属性的方法。 构造方法 1public Cookie(java.lang.String name,java.lang.String value) 注意 ：Cookie一旦被创建，它的名称就不能更改，值可以为任何值，创建后允许被修改。 Cookie类的常用方法 setMaxAge(int expiry) 这两个方法用于设置返回Cookie在浏览器上保持有效的秒数 如果设置的值为一个正整数时，浏览器会将Cookie信息保存在本地硬盘中 如果设置值为负整数时，浏览器会将Cookie信息保存在的缓存中，当浏览器关闭时，Cookie信息会被删除 如果设置值为0时，则表示通知浏览器立即删除这个Cookie信息。默认情况下，Max-Age属性的值是-1 一个网站cookie是否存在上限： 一个Cookie只能保存一 个信息; 一个web站点可以给浏览器发送多个cookie，最多存放20个cookie; Cookie大小有限制4kb; 300个cookie浏览器上限 上次访问时间 实现思路 当年第一次访问时，服务器告诉你来的时间，把这个时间封装成一个信件Cookie，下次来的时候带来，就知道你来过 编码实现 1234567891011121314151617181920212223242526272829303132333435public class CookieDemo01 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //解决编码 response.setContentType(&quot;text/html;charset=utf-8&quot;); //保存输出访问时间的变量 String lastAccessTime=null; //Cookie，服务器从客户端获取 //获取所有的cookie，并将这些cookie存放在数组中 Cookie[] cookies=request.getCookies(); //判断Cookie是否存在，如果第一次访问不存在则跳过 for(int i=0;cookies!=null&amp;&amp;i&lt;cookies.length;i++) &#123; ////如果cookie的名称为lastAccess,则获取该cookie的值 if(&quot;lastAccess&quot;.equals(cookies[i].getName())) &#123; //将上次访问数据赋值给 lastAccessTime lastAccessTime=cookies[i].getValue(); break; &#125; &#125; //判断是否存在名称为lastAccess的cookie if(lastAccessTime==null) &#123; response.getWriter().print(&quot;您是首次访问本站!&quot;); &#125;else &#123; response.getWriter().print(&quot;您上次的访问时间是:&quot;+lastAccessTime); &#125; //获取系统时间 String currentTime=new SimpleDateFormat(&quot;yyyy-MM-dd-hh:mm:ss&quot;).format(new Date()); //创建cookie,将当前时间作为cookie的值发给客户端 Cookie cookie=new Cookie(&quot;lastAccess&quot;,currentTime); //设置Cookie在浏览器上保持有效的秒 cookie.setMaxAge(60*60); //发送cookie给客户端 response.addCookie(cookie); &#125;&#125; 配置web.xml文件并运行结果 Session对象 Cookie可以将用户信息保存在各自的浏览器中，但Cookie传递的数据量很小，通常只有4KB，如果数据量过大，会加大服务器端的处理难度 所以引入Session技术，Session是一种将会话数据保存到服务器端的技术，服务器会给每一个用户创建一个Session对象 一个Session独占一个浏览器，只要浏览器没有关闭，这个Session就存在 用户登录之后，整个网站它都可以访问！即保存用户的信息或者保存购物车的信息 Session原理 当浏览器访问Web服务器时，Servlet容器就会创建一个Session对象和ID属性，Session对象的ID属性以以下这种形式存在 1Cookie(Set-Cookie:JSESSIONID=111) 当客户端后续访问服务器时，只要将标识号传递给服务器，服务器就能判断出该请求是哪个客户端发送的，从而选择与之对应的Session对象为其服务。 通常情况下，Session是借助Cookie技术来传递ID属性的。 第一次请求，请求头中没有jsessionid的cookie，当访问到对应的servlet资源时，执行到getSession()会创建HttpSession对象；进而响应时就将session的id作为cookie的value，响应到浏览器 Set-cookie:jsessionid=xxxx; 再一次请求时，http请求中就有一个cookie:jsessionid=xxxx信息，那么该servlet就可以通过getSession()获取到jsessionid在服务器内查找对应的session对象，有就使用，无就创建 Session API HttpServletRequest定义了用于获取Session对象的getSession()方法 12public HttpSession getSession(boolean create)public HttpSession getSession() 测试代码 12345678910111213141516171819public class SessionDemo01 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType(&quot;text/html;charset=utf-8&quot;); //得到Session HttpSession session = req.getSession(); //给Session中存数据 session.setAttribute(&quot;name&quot;,&quot;李白&quot;); //获取Session的ID String sessionId = session.getId(); //判断是不是新创建的Session if(session.isNew())&#123; resp.getWriter().write(&quot;Session创建成功,ID:&quot;+sessionId); &#125;else&#123; resp.getWriter().write(&quot;Session已经在服务器中存在了,ID:&quot;+sessionId); &#125; &#125;&#125; 配置web.xml后运行结果 取得SessionDemo01里面Session的值 123456789101112public class SessionDemo02 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType(&quot;text/html;charset=utf-8&quot;); //得到Session HttpSession session = req.getSession(); //返回的是对象，需要强转 String name = (String) session.getAttribute(&quot;name&quot;); resp.getWriter().write(name); &#125;&#125; 配置web.xml后运行结果 Session注销 通常用于客户手动注销账户等操作 创建一个Session，并设置了值 1234 //得到SessionHttpSession session = req.getSession();//给Session中存数据session.setAttribute(&quot;name&quot;,&quot;李白&quot;); 使用invalidate()注销Session 123HttpSession session = req.getSession();session.removeAttribute(&quot;name&quot;);session.invalidate(); 除了手动注销外，还可以通过以下超时管理进行注销，在web.xml中配置 1234&lt;session-config&gt; &lt;!--超时的时间值，单位为分钟，Tomcat的默认超时间隔为30分种--&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt;&lt;/session-config&gt; 注意：如果将&lt;session-timeout&gt;元素中的时间值设置成0或负数，则表示会话永不超时！ Session生命周期结束时机 浏览器关闭：销毁Cookie中的jsessionid=xxx，原session对象会保留默认30min后才销毁，30分钟后为新的session; session销毁：主动调用 session.invalidate() 方法后，立即将session对象销毁，再次访问时会创建新的session。 四大共享数据方式 HTTP请求中 四大共享数据方式对比 一次性验证码 在实际开发中，为了保证用户信息的安全，都会在网站登录的界面中添加一次性验证码，从而限制人们使用软件来暴力猜测密码。一次性验证码的功能同样可以使用Session来实现。12345678910111213141516171819202122package CheckCode;public class User &#123; private String username; private String password; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 1234567891011121314151617package CheckCode;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.*;public class LogoutServlet extends HttpServlet &#123;public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 将Session对象中的User对象移除 request.getSession().removeAttribute(&quot;user&quot;); response.sendRedirect(&quot;/CheckCode/IndexServlet&quot;); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package CheckCode;import java.io.*;import javax.servlet.ServletException;import javax.servlet.http.*;public class LoginServlet extends HttpServlet &#123; /** * 未添加验证码 */// public void doGet(HttpServletRequest request, // HttpServletResponse response)// throws ServletException, IOException &#123;// response.setContentType(&quot;text/html;charset=utf-8&quot;);// String username = request.getParameter(&quot;username&quot;);// String password = request.getParameter(&quot;password&quot;);// PrintWriter pw = response.getWriter();// //假设正确的用户名 是itcast 密码是123// if ((&quot;itcast&quot;).equals(username) &amp;&amp; (&quot;123&quot;).equals(password)) &#123;// User user = new User();// user.setUsername(username);// user.setPassword(password);// request.getSession().setAttribute(&quot;user&quot;, user);// response.sendRedirect(&quot;/Servlet_Project/IndexServlet&quot;);// &#125; else &#123;// pw.write(&quot;用户名或密码错误，登录失败&quot;);// &#125;// &#125; /** * 添加了验证码 */ public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/html;charset=utf-8&quot;); String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); String checkCode = request.getParameter(&quot;check_code&quot;); String savedCode = (String) request.getSession().getAttribute( &quot;check_code&quot;); PrintWriter pw = response.getWriter(); if ((&quot;lzy&quot;).equals(username) &amp;&amp; (&quot;123&quot;).equals(password) &amp;&amp; checkCode.equals(savedCode)) &#123; User user = new User(); user.setUsername(username); user.setPassword(password); request.getSession().setAttribute(&quot;user&quot;, user); response.sendRedirect(&quot;/CheckCode/IndexServlet&quot;); &#125; else if (checkCode.equals(savedCode)) &#123; pw.write(&quot;用户名或密码错误，登录失败&quot;); &#125; else &#123; pw.write(&quot;验证码错误&quot;); &#125; &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 123456789101112131415161718192021222324252627282930313233package CheckCode;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.*;public class IndexServlet extends HttpServlet &#123;public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException &#123; // 解决乱码问题 response.setContentType(&quot;text/html;charset=utf-8&quot;); // 创建或者获取保存用户信息的Session对象 HttpSession session = request.getSession(); User user = (User) session.getAttribute(&quot;user&quot;); if (user == null) &#123; response.getWriter().print( &quot;您还没有登录，请&lt;a href=&#x27;/CheckCode/login.html&#x27;&gt;登录&lt;/a&gt;&quot;); &#125; else &#123; response.getWriter().print(&quot;您已登录，欢迎你，&quot; + user.getUsername() + &quot;！&quot;); response.getWriter().print( &quot;&lt;a href=&#x27;/CheckCode/LogoutServlet&#x27;&gt;退出&lt;/a&gt;&quot;); // 创建Cookie存放Session的标识号 Cookie cookie = new Cookie(&quot;JSESSIONID&quot;, session.getId()); cookie.setMaxAge(60 * 30); cookie.setPath(&quot;/CheckCode&quot;); response.addCookie(cookie); &#125; &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 123456789101112131415161718192021222324252627282930313233package CheckCode;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.*;public class IndexServlet extends HttpServlet &#123;public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException &#123; // 解决乱码问题 response.setContentType(&quot;text/html;charset=utf-8&quot;); // 创建或者获取保存用户信息的Session对象 HttpSession session = request.getSession(); User user = (User) session.getAttribute(&quot;user&quot;); if (user == null) &#123; response.getWriter().print( &quot;您还没有登录，请&lt;a href=&#x27;/CheckCode/login.html&#x27;&gt;登录&lt;/a&gt;&quot;); &#125; else &#123; response.getWriter().print(&quot;您已登录，欢迎你，&quot; + user.getUsername() + &quot;！&quot;); response.getWriter().print( &quot;&lt;a href=&#x27;/CheckCode/LogoutServlet&#x27;&gt;退出&lt;/a&gt;&quot;); // 创建Cookie存放Session的标识号 Cookie cookie = new Cookie(&quot;JSESSIONID&quot;, session.getId()); cookie.setMaxAge(60 * 30); cookie.setPath(&quot;/CheckCode&quot;); response.addCookie(cookie); &#125; &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 1234567891011121314151617&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form name=&quot;reg&quot; action=&quot;/CheckCode/LoginServlet&quot; method=&quot;post&quot;&gt; 用户名: &lt;input name=&quot;username&quot; type=&quot;text&quot; /&gt;&lt;br/&gt; 密&amp;nbsp;&amp;nbsp;码：&lt;input name=&quot;password&quot; type=&quot;password&quot; /&gt;&lt;br/&gt; 验证码：&lt;input type=&quot;text&quot; name=&quot;check_code&quot;&gt; &lt;img src=&quot;/CheckCode/CheckServlet&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; id=&quot;bt&quot; /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;servlet&gt; &lt;servlet-name&gt;CheckServlet&lt;/servlet-name&gt; &lt;servlet-class&gt; CheckCode.CheckServlet &lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;CheckServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/CheckServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;IndexServlet&lt;/servlet-name&gt; &lt;servlet-class&gt; CheckCode.IndexServlet &lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;IndexServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/IndexServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;LogoutServlet&lt;/servlet-name&gt; &lt;servlet-class&gt; CheckCode.LogoutServlet &lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;LogoutServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/LogoutServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;servlet-class&gt; CheckCode.LoginServlet &lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/LoginServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;","path":"page/JavaWeb04.html","date":"01-15","excerpt":"","tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://xiaoliblog.cn/tags/JavaWeb/"}]},{"title":"JavaWeb🌍请求与响应","text":"请求和响应 Servlet最主要的作用就是处理客户端请求，并向客户端做出响应。为此，针对Servlet的每次请求，Web服务器在调用service()之前，都会创建两个对象，分别是HttpServletRequest和HttpServletResponse。 web服务器接收到客户端的HTTP请求，针对这个请求，分别创建一个代表请求HttpServletRequest对象，代表响应的一个HttpServletResponse 如果要获取客户端请求过来的参数：找HttpServletRequest 如果要给客户端响应一些信息:：找HttpServletResponse HttpServletResponse对象发送响应消息头相关方法 设置各种头字段 设置字符编码 向浏览器输出内容 可以使用以下两种方法： 1234//字节输出流ServletOutputStream getOutStreawm() throws java.io.IOException//字符输出流public java.io.PrintWriter getWriter() throws java.io.IOException getOutputStram()和getWriter这两个方法互相排斥，调用了其中的任何一个方法后，就不能调用另外一个 浏览器和服务器端获取响应输出流图示： getOutputStream() 在ServletOutputStream类中提供了一个方法getOutputStream()，调用可以返回一个ServletOutputStream()实例对象,这个实例对象用于输出字符流数据或者二进制的字节流数据 12response.getOutputStream().write();response.getOutputStream().print(); 注意：响应调用该方法，输出的二进制流数据只适用于ISO 8859-1编码，所以在输出中文的时候会报500错误 getWriter() 响应调用getWriter()方法会获取一个PrintWriter()实例对象，该实例对象用于处理字符流数据 1234//print方法可以将各种类型的数据转换成字符串的形式输出response.getWriter().print(&quot;Hello&quot;);//write方法只能输出字符、字符数组、字符串等与字符相关的数据response.getWriter().write(&quot;Hello&quot;); 中文乱码问题 由于计算机中的数据都是以二进制形式存储的，因此，当传输文本时，就会发生字符和字节之间的转换。字符与字节之间是通过查码表完成的，字符转换成字节的过程为编码，字节转换成字符的过程为解码 Response对象的字符输出流在编码时，采用的是ISO-8859-1的字符码表，不兼容中文，会将”中国”编码为“63 63”，当浏览器接收解码时，会采用默认的码表GB2312，将”63”解码为”?”。 所有需要设置编码 123456//设置HttpServletResponse使用utf-8response.setCharacterEncoding(&quot;utf-8&quot;);//设置浏览器使用utf-8response.setHeader(&quot;Content-Type&quot;,&quot;text/html;charset=utf-8&quot;);//包含以上两种方式的写法【推荐】response.setContentType(&quot;text/html;charset=utf-8&quot;); 定时刷新跳转 在HTTP协议中，定义了一个Refresh头字段，可以通知浏览器在指定的时间内自动刷新并跳转到其他页面 12345678910public class RefreshServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //2秒后跳转到我的博客 response.setHeader(&quot;Refresh&quot;, &quot;2;URL=http://www.xiaoliblog.cn&quot;); //每隔3秒定时刷新当前页面 // reponse.setHeader(&quot;Refresh&quot;,&quot;3&quot;); // response.getWriter().println(new java.util.Date());//输出当前时间 &#125;&#125; 请求重定向 Web服务器接受到客户端的请求后，由于某些条件限制，不能访问当前请求URL所指向的Web资源，而是指定了一个新的资源路径，让客户端重新发送请求。 为了实现请求重定向，在HttpServletResponse接口中，定义了一个sendRedirect()方法，该方法用于生成302响应码和Location响应头，从而通知客户端重新访问Location响应头中指定的URL，sendRedirect()方法的完整语法如下: 123public void sendRedirect(java.lang.String Location) throws java.io.IOException&#123; //代码&#125; 以下模拟用户登录来帮助理解，创建login.jsp登录表单和welcome.jsp欢迎界面(在WebContent下建立)，再创一个LoginServlet的类用于处理用户登录请求。Servlet_Project为包名 LoginServlet类 12345678910111213141516public class LoginServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;utf-8&quot;); //用HttpServletRequest对象的getParameter()方法获取用户名和密码; String username=request.getParameter(&quot;username&quot;); String password=request.getParameter(&quot;password&quot;); //假设用户名和密码分别为：itcase和123 if((&quot;itcast&quot;).equals(username)&amp;&amp;(&quot;123&quot;).equals(password)) &#123; //如果用户名和密码正确，重定位到welcome.html response.sendRedirect(&quot;/Servlet_Poject/welcome.html&quot;); &#125;else &#123; //如果用户名和密码错误，重定位到login.html response.sendRedirect(&quot;/Servlet_Poject/login.html&quot;); &#125; &#125;&#125; welcome.jsp 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--这里提交的路径，需要寻找到项目的路径(JSP文件)--&gt; &lt;!-- $&#123;pageContext.request.contextPath&#125; 代表当前的项目--&gt; &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/LoginServlet&quot; method=&quot;post&quot;&gt; 用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;br&gt; 密&amp;nbsp;&amp;nbsp;&amp;nbsp;码:&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; login.jsp 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 欢迎您,登陆成功！&lt;/body&gt;&lt;/html&gt; 验证码实现 验证码实现有两种方式 前端实现，JS，Canvas 后端实现，需要用到Java的图片类，生成一个图片 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.lzy.JavaWeb;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.awt.*;import java.awt.image.BufferedImage;import java.io.IOException;import java.util.Random;public class ImageServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //如何让浏览器3秒自动刷新一次 resp.setHeader(&quot;refresh&quot;,&quot;3&quot;); //在内存中创建一个图片,参数为(宽,高,RGB) BufferedImage bufferedImage = new BufferedImage(80,20,BufferedImage.TYPE_INT_RGB); //得到图片使用2D画笔 Graphics2D graphics = (Graphics2D) bufferedImage.getGraphics(); //设置图片背景颜色 graphics.setColor(Color.white); //填充(x,y,width,height) graphics.fillRect(0,0,80,80); //给图片写数据 graphics.setColor(Color.blue); graphics.setFont(new Font(null,Font.BOLD,20)); graphics.drawString(randomNum(),0,20); //告诉浏览器这个请求用图片的方式打开 resp.setContentType(&quot;image/jpeg&quot;); //网站存在缓存，不让浏览器缓存 resp.setDateHeader(&quot;expires&quot;,-1); resp.setHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;); resp.setHeader(&quot;Pragma&quot;,&quot;no-cache&quot;); //把图片写给浏览器 ImageIO.write(bufferedImage,&quot;jpg&quot;, resp.getOutputStream()); &#125; //生成随机数 private String randomNum()&#123; Random randm = new Random(); //+&quot;&quot; 可以转为字符串,七位数 String num = randm.nextInt(9999999) + &quot;&quot;; StringBuffer stringBuffer = new StringBuffer(); for (int i = 0; i &lt; 7-num.length(); i++) &#123; stringBuffer.append(&quot;0&quot;); &#125; String str = stringBuffer.toString()+num; return num; &#125;&#125; 运行结果，每3秒会刷新下页面 HttpServletRequest对象HttpServletRequest接口中定义了获取请求行、请求头、请求消息体的相关方法。 获取请求行信息 1234567891011121314151617181920212223242526272829303132333435package MyProject;import java.io.*;import java.util.*;import javax.servlet.*;import javax.servlet.http.*;public class RequestLineServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/html;charset=utf-8&quot;); PrintWriter out=response.getWriter(); //获取请求行的相关信息 out.println(&quot;getMethod:&quot;+request.getMethod()+&quot;&lt;br/&gt;&quot;); out.println(&quot;getRequestURI:&quot;+request.getRequestURI()+&quot;&lt;br/&gt;&quot;); out.println(&quot;getQueryString:&quot;+request.getQueryString()+&quot;&lt;br/&gt;&quot;); out.println(&quot;getProtocol:&quot;+request.getProtocol()+&quot;&lt;br/&gt;&quot;); out.println(&quot;getContextPath:&quot;+request.getContextPath()+&quot;&lt;br/&gt;&quot;); out.println(&quot;getPathInfo:&quot;+request.getPathInfo()+&quot;&lt;br/&gt;&quot;); out.println(&quot;getPathTranslated:&quot;+request.getPathTranslated()+&quot;&lt;br/&gt;&quot;); out.println(&quot;getServletPath:&quot;+request.getServletPath()+&quot;&lt;br/&gt;&quot;); out.println(&quot;getRemoteAddr:&quot;+request.getRemoteAddr()+&quot;&lt;br/&gt;&quot;); out.println(&quot;getRemoteHost:&quot;+request.getRemoteHost()+&quot;&lt;br/&gt;&quot;); out.println(&quot;getLocalAddr:&quot;+request.getLocalAddr()+&quot;&lt;br/&gt;&quot;); out.println(&quot;getLocalName:&quot;+request.getLocalName()+&quot;&lt;br/&gt;&quot;); out.println(&quot;getServerName:&quot;+request.getServerName()+&quot;&lt;br/&gt;&quot;); out.println(&quot;getServerPort:&quot;+request.getServerPort()+&quot;&lt;br/&gt;&quot;); out.println(&quot;getScheme:&quot;+request.getScheme()+&quot;&lt;br/&gt;&quot;); out.println(&quot;getRequestURL:&quot;+request.getRequestURL()+&quot;&lt;br/&gt;&quot;); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 获取请求消息头 1234567891011121314151617181920212223package MyProject;import java.io.*;import java.util.*;import javax.servlet.*;import javax.servlet.http.*;public class RequestHeadersServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/html;charset=utf-8&quot;); PrintWriter out=response.getWriter(); //获取请求消息中所有头字段 Enumeration headerNames =request.getHeaderNames(); //循环遍历所有请求头，并通过getHeader()方法获取一个指定名称的头字段 while(headerNames.hasMoreElements()) &#123; String headerName=(String)headerNames.nextElement(); out.print(headerName+&quot;:&quot;+request.getHeader(headerName)+&quot;&lt;br&gt;&quot;); &#125; &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; Referer防”盗链” Referer头字段可以用于网站的防盗链。什么是盗链呢？假如A网站并没有某些资源，而是通过HTMl文件中使用&lt;a&gt;&lt;/a&gt;标签链接到B网站的资源，将其展示给浏览者。A网站提高了自己网站的访问量，却加重了B网站服务器的负担，损害了合法利益。而当你单击一个网页上的超链接时，浏览器会使用Referer头字段标识发出请求的超链接所在网页的URL，从而阻止访问或者跳转到指定的页面 实例描述：在Servlet_Project项目下Myproject包中，编写一个DownManagertServlet的类负责提供下载内容，要求下载请求的链接必须是通过本网站进入的，否则会将请求转发给下载说明的HTML页面（download.html） 1234567891011121314151617181920212223242526272829package MyProject;import java.io.*;import java.util.*;import javax.servlet.*;import javax.servlet.http.*;public class DownManagertServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/html;charset=utf-8&quot;); PrintWriter out=response.getWriter(); //获取Referer头的值 String referer=request.getHeader(&quot;referer&quot;); //获取访问地址 String sitePart=&quot;http://&quot;+request.getServerName(); //判断referer头是否为空,这个头的地址是否以sitePart开始 if(referer !=null &amp;&amp; referer.startsWith(sitePart)) &#123; //处理正在下载的请求 out.println(&quot;dealing download....&quot;); &#125;else &#123; //非法下载请求跳转到download.html页面 RequestDispatcher rd=request.getRequestDispatcher(&quot;/download.html&quot;); rd.forward(request, response); &#125; &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;/Servlet_Project/DownManagertServlet&quot;&gt;download&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 当第一次请求DownManagerServlet时，请求消息中不含Referer请求头，所以DownMagaerServlet将下载请求转发给了download.html页面。 单击”download”链接后，请求信息中包含了Referer头字段，并且其值与DownManagerServlet位于同一个Web站点，因此接受下载请求。 获取请求参数 在实际开发中，经常需要获取用户提交的表单数据，例如，用户名、密码、电子邮件等 在HttpServletRequest接口中，定义了一系列获取请求参数的方法 12345678910111213141516171819202122232425package MyProject;import java.io.*;import java.util.*;import javax.servlet.*;import javax.servlet.http.*;public class ResquestParamsServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(&quot;utf-8&quot;); String name=request.getParameter(&quot;username&quot;); String password=request.getParameter(&quot;password&quot;); System.out.println(&quot;用户名:&quot;+name); System.out.println(&quot;密码:&quot;+password); //获取参数名为&quot;hobby&quot;的值 String hobby[]=request.getParameterValues(&quot;hobby&quot;); System.out.println(&quot;爱好:&quot;); for(int i=0;i&lt;hobby.length;i++) &#123; System.out.println(hobby[i]+&quot;,&quot;); &#125; &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;/Servlet_Project/ResquestParamsServlet&quot; method=&quot;POST&quot;&gt; 用户名:&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 密&amp;nbsp;&amp;nbsp;&amp;nbsp;码:&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;br&gt; 爱好:&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;sing&quot;&gt;唱歌 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;dance&quot;&gt;跳舞 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;football&quot;&gt;足球&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 由于HTML设置了浏览器在传递参数是采用utf-8编码，但在解码是采用默认的ISO-8859-1，会发生乱码问题。 解决方案： POST: request.setCharacterEncoding(“utf-8”); （只对POST有效） GET: name=new String(name.getBytes(&quot;iso8859-1&quot;),”utf-8“); （先使用错误码表ISO-8859-1将用户名重新编码，再使用UTF-8进行解码） Request对象传递数据 setAttriute()方法 用于将一个对象与一个名称关联后存储进ServletRequest对象中如果ServletRequest对象中已经存在指定名称的属性，会先删除原来的属性，再添加新的属性。 1public void setAttribute(java.lang.String name,java.lang.Object o); getAttribute()方法 从ServletRequest对象中返回指定名称的属性对象。 1public java.lang.Object getAttribute(java.lang.String name); removeAttribute()方法 从ServletRequest对象中删除指定名称的属性。 1public void removeAttribute(java.lang.String name); getAttributeNames()方法 返回一个包含ServletRequest对象中所有属性名的Enumeration对象。 1public java.util.Enumeration getAttributeNames(java.lang.String name); RequestDispatcher对象 当一个Web资源收到客户端的请求后，如果希望服务器通知另外一个资源去处理请求，除了使用sendRedirect()请求重定向外，还可以通过RequestDispatcher接口的实例对象来实现。 ServletRequest接口中获取RequestDispatcher对象的方法 RequestDispatcher对象中的相关方法 请求转发forward() 在Servlet中，如果当前Web资源不想处理请求时，可以通过forward()方法将当前请求传递给其他Web资源进行处理。如图所示，当客户端访问Servlet1时，可以通过foward()方法将请求转发给其他Web资源(如Servlet2)，处理完后，返回客户端。 12345678910111213141516171819package chapter04;import java.io.*;import javax.servlet.*;import javax.servlet.http.*;public class RequestForwardServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/html;charset=utf-8&quot;); //将数据存储到request对象中 request.setAttribute(&quot;company&quot;, &quot;北京传智播客有限公司&quot;); RequestDispatcher dispatcher=request.getRequestDispatcher(&quot;/ResultServlet&quot;); //用forward()方法将当前Servlet的请求转发到ResultServlet页面。 dispatcher.forward(request, response); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 123456789101112131415161718192021package chapter04;import java.io.*;import javax.servlet.*;import javax.servlet.http.*;public class ResultServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/html;charset=utf-8&quot;); //获取PrintWriter对象用于输出信息 PrintWriter out=response.getWriter(); //获取request请求对象中保存的数据 String company=(String) request.getAttribute(&quot;company&quot;); if(company!=null) &#123; out.println(&quot;公司名称:&quot;+company+&quot;&lt;br&gt;&quot;); &#125; &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 可以看出地址栏是RequestForwardServlet的请求路径，却显示了另一个页面的内容，这是因为请求转发是发生在服务内部的行为，在一次请求中可以使用request进行数据共享。 请求包含incude() 指使用include()方法将Servlet请求转发给其他Web资源进行处理，在请求包含返回的响应消息中，即包含了当前Servlet的响应消息，也包含了其他Web资源所作出的响应消息 123456789101112131415161718192021222324package chapter04;import java.io.*;import javax.servlet.*;import javax.servlet.http.*;public class IncludingServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/html;charset=utf-8&quot;); PrintWriter out=response.getWriter(); RequestDispatcher rd=request.getRequestDispatcher(&quot;/IncludedServlet?p1=abc&quot;); out.println(&quot;before including&quot;+&quot;&lt;br/&gt;&quot;); rd.include(request, response); out.println(&quot;after including&quot;+&quot;&lt;br/&gt;&quot;); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub doGet(request, response); &#125;&#125; 12345678910111213141516171819202122232425package chapter04;import java.io.*;import javax.servlet.*;import javax.servlet.http.*;public class IncludedServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //设置响应时使用的字符编码 response.setContentType(&quot;text/html;charset=utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); PrintWriter out=response.getWriter(); out.println(&quot;中国&quot;+&quot;&lt;br/&gt;&quot;); out.println(&quot;URI:&quot;+request.getRequestURI()+&quot;&lt;br/&gt;&quot;); out.println(&quot;QueryString:&quot;+request.getQueryString()+&quot;&lt;br/&gt;&quot;); out.println(&quot;parameter p1:&quot;+request.getParameter(&quot;p1&quot;)+&quot;&lt;br/&gt;&quot;); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub doGet(request, response); &#125;&#125;","path":"page/JavaWeb03.html","date":"01-15","excerpt":"","tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://xiaoliblog.cn/tags/JavaWeb/"}]},{"title":"JavaWeb🌍Servlet基础","text":"Servlet Servlet就是sun公司开发动态Web的一门技术 Sun在这些API中提供一个接口叫做Servlet, 如果你想开发一个Servlet程序， 只需要完成两个小步骤 编写一个类实现Servlet接口 把开发好的Java类部署到web服务器中 实现了Servlet接口的Java程序叫做Servlet Servlet简介 Servlet由Servlet容器提供，所谓的Servlet容器是指提供了Servlet 功能的服务器（指Tomcat），Servlet容器将Servlet动态的加载到服务器上。 Servlet的请求首先会被HTTP服务器接收，HTTP服务器只负责静态HTML页面的解析。 Servlet的请求转交给Servlet容器，Servlet容器会根据web.xml文件中的映射关系，调用相应的Servlet。 Servlet将处理的结果返回给Servlet容器，并通过HTTP服务器将响应传输给客户端。 Servlet的特点 方便：Servlet提供了大量的实用工具例程，如处理很难完成的HTML表单数据、读取和设置HTTP头，以及处理Cookie和跟踪会话等。 跨平台：Servlet用Java类编写，可以在不同操作系统平台和不同应用服务器平台下运行。 灵活性和可扩展性：采用Servlet开发的Web应用程序，由于Java类的继承性及构造函数等特点，使得应用灵活，可随意扩展。 Servlet实现 新建一个普通Maven项目当做主工程，删除src目录，创建子模块 相关依赖添加到主工程的pom.xml文件中 1234567891011121314&lt;!--Servlet--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;!--JSP--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 依赖下载出现问题，可以刷新Maven 创建子模块，需要勾选Webapp模板 然后修改pom.xml里的JDK版本或者删除不需要的标签 在main目录下新建java和resources文件夹 实现Servlet接口 12345678910111213public class HelloServlet1 implements Servlet &#123; public void init(ServletConfig servletConfig) throws ServletException &#123; &#125; public ServletConfig getServletConfig() &#123; return null; &#125; public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123; &#125; public String getServletInfo() &#123; return null; &#125; public void destroy() &#123;&#125;&#125; 继承HttpServlet类 12345678910public class HelloServlet2 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException&#123; this.doGet(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException&#123; this.doPost(req,resp); &#125;&#125; Servlet程序1234567891011121314151617181920212223package com.lzy.JavaWeb;import javax.servlet.Servlet;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class Servlet_01 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException&#123; //得到输出流PrinterWriter对象,Servlet使用输出流来产生响应 PrintWriter writer = resp.getWriter(); writer.print(&quot;Hello,Servlet&quot;); this.doGet(req,resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException&#123; this.doPost(req,resp); &#125;&#125; 我们写的是Java程序，但是要通过浏览器访问，而浏览器需要理解Web服务器，所有我们要在Web服务中注册我们写的Servlet，还需要给它一个浏览器能够访问的路径 配置web.xml文件，虚拟路径的映射 1234567891011121314151617181920&lt;web-app&gt; &lt;!-- servlet标签给Tomcat配置Servlet程序 --&gt; &lt;servlet&gt; &lt;!-- servlet-name标签给Servlet程序起一个别名(一般是类名) --&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;!-- servlet-class是Servlet程序的全类名(一般为包名+类名) --&gt; &lt;servlet-class&gt;com.lzy.JavaWeb.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!-- servlet-mapping标签给Tomcat配置访问地址，用于映射一个对外访问的路径 --&gt; &lt;servlet-mapping&gt; &lt;!-- servlet-name标签告诉服务器，我当前配置的地址给哪个Servlet程序使用 --&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;!-- url-pattern标签配置访问地址 / 斜杠在服务器解析时，表示地址为:http://ip:port/工程路径 /HelloServlet表示http://ip:port/工程路径/HelloServlet) --&gt; &lt;url-pattern&gt;/HelloServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 配置Tomcat，添加【Tomcat】【Local】然后选择Tomcat安装路径，配置访问路径 运行结果 Mapper路径映射 一个Servlet可以指定一个映射路径 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/HelloServlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 一个Servlet指定多个映射路径 123456789101112&lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/HelloServlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/HelloServlet1&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/HelloServlet2&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 一个Servlet可以指定通用映射路径 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/HelloServlet/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 默认请求路径 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 指定一些后缀或者前缀等，*前面不能加映射的路径 1234&lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; Servlet生命周期 123456789101112131415161718package Review;import java.io.*;import javax.servlet.*;import javax.servlet.http.*;public class HelloServlet extends GenericServlet&#123; //初始化阶段 public void init(ServletConfig config)throws ServletException&#123; System.out.println(&quot;----init()----&quot;); &#125; //处理客户端请求阶段 public void service(ServletRequest arg0, ServletResponse arg1) throws ServletException, IOException &#123; System.out.println(&quot;----service()----&quot;); &#125; //终止阶段 public void destroy() &#123; System.out.println(&quot;----destroy()----&quot;); &#125;&#125; 自动加载Servlet程序 当希望某些Servlet程序可以在Tomcat启动时随即启动，可以使用&lt;load-on-startup&gt;元素,最常使用在配置数据库时 12345&lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;chapter04.HelloServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; load-on-startup用于指定Servlet被加载的时机和顺序，所设置的值必须为一个整数 如果为负数或者没有设，Servlet容器将在客户端首次请求这个Servlet时加载它 如果为整数或0，Servlet容器将在Web应用启动时加载并初始化Servlet其值越小，对应Servlet就越先被加载 ServletConfig对象 Servlet的配置信息封装到一个ServletConfig对象中，ServletConfig定义了一系列获取配置信息的方法，有三大作用: 可以取得Servlet程序的别名servlet-name的值 获取初始化参数ini-param 获取ServletContext对象 常用方法 说明 String getInitParameter(String name) 获取servlet的初始化参数的值 Enumeratrion getInitParameterNames() 获取servlet的初始化参数的名称 ServletContext getServletContext() 得到当前Web应用的ServletContext对象 String getServletName() 获取servlet的名称,即web.xml中servlet-name元素的值 123456789101112131415161718192021222324252627282930package Review;import java.io.*;import java.util.*;import javax.servlet.*;import javax.servlet.http.*;public class TestServletConfig extends HttpServlet &#123; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1.首先得到servletconfig对象 ServletConfig config=this.getServletConfig(); //2.获取servlet的名称，对应web.xml里面 String servletName=config.getServletName(); System.out.println(&quot;servlet的名称&quot;+servletName); //3.获取servlet的初始化参数 String value=config.getInitParameter(&quot;encoding&quot;); System.out.println(&quot;初始化参数值：&quot;+value); //4.获取servlet的初始化参数的名称 Enumeration&lt;String&gt; er=config.getInitParameterNames(); while(er.hasMoreElements()) &#123; //获取初始化参数的名称 String name=er.nextElement(); //根据初始化参数的名称，获取对应的值 String value2=config.getInitParameter(name); System.out.println(&quot;初始化参数的名称：&quot;+name); System.out.println(&quot;该名称的值:&quot;+value2); &#125; &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request, response); &#125;&#125; 1234567891011121314151617&lt;servlet&gt; &lt;servlet-name&gt;TestServletConfig&lt;/servlet-name&gt; &lt;servlet-class&gt;Review.TestServletConfig&lt;/servlet-class&gt; &lt;!-- servlet的初始化参数的配置 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;username&lt;/param-name&gt; &lt;param-value&gt;lizhenye&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;TestServletConfig&lt;/servlet-name&gt; &lt;url-pattern&gt;/TestServletConfig&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; ServletContext对象 当Servlet容器启动时，会为每个Web应用创建一个唯一的ServletContext对象代表当前Web应用，该对象不仅封装了当前Web应用的所有信息，而且实现了多个Servlet之间数据的共享 ServletContext接口的作用: 获取Web应用程序的初始化参数: 实现多个Servlet对象共享数据 读取Web应用下的资源文件 获取初始化参数 ServletContext可以获取Web应用程序的初始化参数 先在web.xml中定义参数 12345&lt;!--配置初始化参数--&gt; &lt;context-param&gt; &lt;param-name&gt;url&lt;/param-name&gt; &lt;param-value&gt;jdbc:mysql://localhost:3306/mybatis&lt;/param-value&gt; &lt;/context-param&gt; 创建getInitParameter获取参数 123456789public class getInitParameter extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; ServletContext context = this.getServletContext(); //获取参数 String url = context.getInitParameter(&quot;url&quot;); resp.getWriter().print(url); &#125;&#125; 在web.xml中注册 123456789&lt;servlet&gt; &lt;servlet-name&gt;getInitParamter&lt;/servlet-name&gt; &lt;servlet-class&gt;com.lzy.JavaWeb.getInitParamter&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!--Servlet请求路径--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;getInitParamter&lt;/servlet-name&gt; &lt;url-pattern&gt;/getInitParamter&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 运行结果 实现数据共享 ServletContext可以实现多个Servlet对象共享数据 原理就是ServletContext可以保存Web应用的所有信息，多个Servlet保存在ServletContext中，就可以实现数据共享 HelloServlet用于存放一个值 12345678910111213141516public class HelloServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException&#123; //通过this.可以查看一些方法 //this.getInitParameter() 初始化参数 //this.getServletConfig() Servlet配置 //this.getServletContext() Servlet上下文 ServletContext context= this.getServletContext(); //数据 String username = &quot;李白&quot;; //将一个数据保存在ServletContext中，名字为username，值为username字符串对象 context.setAttribute(&quot;username&quot;,username); System.out.println(&quot;Hello&quot;); this.doGet(req,resp); &#125;&#125; getServlet取得值 12345678910111213public class getServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType(&quot;text/html&quot;); resp.setCharacterEncoding(&quot;utf-8&quot;); //取得HelloServlet的信息 //共享同一个ServletContext对象 ServletContext context = this.getServletContext(); //传入参数，取得对象，然后强制转为String类型 String username = (String)context.getAttribute(&quot;username&quot;); resp.getWriter().print(&quot;名字:&quot;+username); &#125;&#125; 配置路径映射 1234567891011121314151617181920212223242526&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; version=&quot;3.0&quot;&gt; &lt;!-- 注册Servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.lzy.JavaWeb.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!--Servlet请求路径--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/HelloServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;getServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.lzy.JavaWeb.getServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!--Servlet请求路径--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;getServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/getServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 运行结果 请求转发 ServletContext可以实现请求转发 访问ServletDemo01的页面显示的却是ServletDemo02的信息 ServletDemo01 12345678910public class ServletDemo01 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; ServletContext context = this.getServletContext(); //请求转发的路径 RequestDispatcher requestDispatcher = context.getRequestDispatcher(&quot;/ServletDemo02&quot;); //调用forward实现转发 requestDispatcher.forward(req,resp); &#125;&#125; ServletDemo02 12345678public class ServletDemo02 extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType(&quot;text/html&quot;); resp.setCharacterEncoding(&quot;utf-8&quot;); resp.getWriter().print(&quot;我是ServletDemo02的信息&quot;); &#125;&#125; 配置对应的web.xml路径映射后，运行结果如下 读取资源文件 首先在resources文件夹下创建Database.properties配置文件 12username=xialiblogpassword=123 创建PropertiesServlet类获取配置信息 123456789101112public class PropertiesServlet extends HttpServlet&#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //相对路径 InputStream is = this.getServletContext().getResourceAsStream(&quot;/WEB-INF/classes/Database.properties&quot;); Properties prop = new Properties(); prop.load(is); String username = prop.getProperty(&quot;username&quot;); String password = prop.getProperty(&quot;password&quot;); resp.getWriter().print(username+&quot;----&quot;+password); &#125;&#125; 配置相应的路径映射，运行结果如下","path":"page/JavaWeb02.html","date":"01-15","excerpt":"","tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://xiaoliblog.cn/tags/JavaWeb/"}]},{"title":"JavaWeb🌍概述及环境配置","text":"JavaWebJava Web 其实就是一个技术的总和,把Web看成一个容器而已主要使用JavaEE技术来实现.再加上各种中间件 本博客所涉及到的扩展包及软件，已打包好，请👉提取码：t2gg Web应用 所谓Web应用就是多个Web资源的集合，它也称为Web应用程序或Web工程。 一个web应用由多个静态web资源和动态web资源组成，如：html、css、js文件，Jsp文件、java程序、支持jar包、配置文件等等。 Web应用开发好后，若想供外界访问，需要把web应用所在目录交给web服务器管理，这个过程称之为虚似目录的映射。配置有两种方式： 在server.xml文件中配置虚拟目录 在自定义xml文件配置虚拟目录 Web服务器 Web服务器是指驻留于因特网上某种类型计算机的程序，是可以向发出请求的浏览器提供文档的程序。当Web浏览器（客户端）连到服务器上并请求文件时，服务器将处理该请求并将文件反馈到该浏览器上，附带的信息会告诉浏览器如何查看该文件（即文件类型） 服务器是一种被动程序：只有当Internet上运行在其他计算机中的浏览器发出请求时，服务器才会响应。 Tomcat 一个动态Web资源开发完毕后需要发布在Web服务器才能被外界访问。Tomcat是Apache组织推荐的运行Servlet和JSP的容器。它不仅具有Web服务器的基本功能，还提供了数据库连接池等许多通用组件功能 下载安装 Tomcat官网：http://tomcat.apache.org/ 下载后直接解压到指定目录: 找到Tomcat目录\\bin\\startup.bat文件双击启动服务器 或者DOS命令:catalina run 浏览器窗口输入http://localhost:8080 关闭Tomcat：bin\\shutdown.bat Tomcat安装常见问题: Tomcat依赖Java环境，需要在JAVA_HOME配好JDK的路径。（如出现窗口一闪而过） Tomcat默认端口8080，当出现端口被占用时(netstat -ano命令查看)，去Tomcat目录找到conf\\server.xml文件里找到port修改 12345&lt;Connector executor=&quot;tomcatThreadPool&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; --&gt; 文件目录结构 面试题：请你谈谈网站是如何进行访问的！ 输入一个域名，然后回车 检查本机的C:\\Windows\\System32\\drivers\\etc配置文件下有没有这个域名映射 如果有，就直接返回对应的IP地址，这个地址中有我们需要访问的Web程序，可以直接访问 如果没有，就去DNS服务器查找，找到就返回，找不到就报错 HTTP HTTP是Hyper Text Transfer Protocol的缩写，即超文本传输协议。它是一种请求/响应式的协议 HTTP协议专门用于定义浏览器与服务器之间交换数据的过程以及数据本身的格式 HTTP协议特点 支持客户端(浏览器就是一种Web客户端)/服务器模式。 简单快速：客户端向服务器请求服务时，只需传送请求方式和路径。常用的请求方式有GET、POST等，每种方式规定了客户端与服务器联系的类型不同。由于HTTP简单，使得HTTP服务器的程序规模小，因而通信速度很快。 灵活：HTTP允许传输任意类型的数据，正在传输的数据类型由Content-Type加以标记。 无状态：HTTP是无状态协议。无状态是指协议对于事务处理没有记忆能力，如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。 HTTP 1.0 基于HTTP1.0协议的客户端与服务器在交互过程中需要经过建立连接、发送请求信息、回送响应信息、关闭连接四个步骤，并且每次请求都需要与服务器重新建立连接。 HTTP 1.1 客户端可以向服务器端发送多个请求，并且在发送下个请求时，无需等待上次请求的返回结果。必须按照接受客户端请求的先后顺序依次返回响应 结果，以保证客户端能够区分出每次请求的响应内容。 HTTP请求信息 一次完整的HTTP请求消息包括：一个请求行、若干消息头以及实体内容 请求行：请求行位于请求消息的第一行 请求头：用于向服务器端传递附加消息 实体内容：描述了请求消息中传递的真实信息 常见的HTTP请求方式是GET和POST请求方式 HTTP响应信息 HTTP响应消息分为响应状态行、响应消息头和实体内容 响应状态行：响应状态行位于响应消息的第一行 响应请求头：用于向客户器端传递附加消息 实体内容：描述了请求消息中传递的真实信息 常见状态码 状态码 说明 200 表示服务器成功处理了客户端的请求 302 表示请求的资源临时从不同的URI响应请求 404 表示服务器找不到请求的资源 500 表示服务器发生错误，无法处理客户端的请求 配置相关依赖123456789101112131415161718192021222324252627282930313233343536373839404142&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp/javax.servlet.jsp-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp/javax.servlet.jsp-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp.jstl/jstl --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/taglibs/standard --&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.glassfish.web/jstl-impl --&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt; &lt;artifactId&gt;jstl-impl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;","path":"page/JavaWeb01.html","date":"01-15","excerpt":"","tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://xiaoliblog.cn/tags/JavaWeb/"}]},{"title":"绑定域名及备案","text":"可以绑定到自己申请的域名上，不用使用userName.github.io访问了，直接使用自己的域名访问 申请域名 本人是在阿里云购买的域名，地址:https://wanwang.aliyun.com/?spm=5176.19720258.J_8058803260.64.7ff72c4axfGTmr 你需要准备一个阿里云账户，并实名认证，通过个人支付宝认证可用立即成功 本人购买的是.cn结尾的域名，首年新用户只需要8.88：http://xiaoliblog.cn/ 解析域名 购买域名后，进入阿里云控制台 进入域名解析控制台，可以在域名列表看到自己购买的域名，点击解析 进入云解析DNS后，点击添加记录，并按以下要求添加 主机记录 记录类型 解析路线 记录值 @ CNAME 默认 username.github.io www A 默认 username.github,io的IP地址 第一条记录表示将http://xiaoliblog.cn 这个主域名映射到xiaoliblog.github.io 第二条记录指定Github Pages服务器指定的IP地址，不是访问该IP地址即表示访问Github Pages 如何知道的 Github Pages IP，在命令提示符中输入 1ping -4 username.github.io 相关记录说明 记录类型主机记录A记录： 将域名指向一个IPv4地址（例如：8.8.8.8）CNAME：将域名指向另一个域名（例如www.xiaoliblog.cn）MX： 将域名指向邮件服务器地址TXT： 可任意填写，长度限制255，通常做SPF记录（反垃圾邮件）NS： 域名服务器记录，将子域名指定其他DNS服务器解析AAAA：将域名指向一个iPv6地址（例如：ff06:0:0:0:0:0:0:c3）SRV：记录提供特定服务的服务器（例如_xmpp-server._tcp）要解析www.xiaoliblog.cn， 请填写www。主机记录就是域名前缀，常见用法有： www： 解析后的域名为www.xiaoliblog.cn。@： 直接解析主域名 xiaoliblog.cn。*： 泛解析，匹配其他所有域名 *.xiaoliblog.cn。mail： 将域名解析为mail.xiaoliblog.cn，通常用于解析邮箱服务器。二级域名： 如：abc.xiaoliblog.cn，填写abc。手机网站： 如：m.xiaoliblog.cn，填写m GitHub配置 进入GitHub博客仓库-&gt;点击Setting，Options往下找到 Custom domain 添加域名后保存，并勾选Enforce HTTPS即可 原nusername.github.io地址一样是可以访问的，会自动跳转到所购买使用的域名 创建CNAME文件 在博客的source文件夹下建立一个CNAME的文件(CNAME不是.txt，必须不指定格式！) 内容写入你的域名信息，格式不要在前面加入https www这样的前缀，比如我的是xiaoliblog.cn 然后hexo d -g部署你的网站，等待一段时间后，就可以通过你的个性域名访问网站了 SSL安全证书 注册好域名后，用google访问时，可能会出现您访问的不是安全链接的提示，或者能够正常访问，但是域名旁边显示的是一个感叹号，表示不安全，这是因为我们还没有申请安全证书，在申请了证书之后，域名旁边显示的就是一把锁，表示安全 腾讯云和阿里云都提供免费的SSL证书下载，具体安装也有相关的文档，本博客以阿里云为演示获取免费证书，具体措施可以看阿里云官方文档 进入阿里云阿里云证书购买页面，按示例选择选项，并点击证书资源包 按示例选择选项，并点击立即购买，购买成功后，进入证书控制台 点击右侧证书资源包，并点击证书申请 填写相应的申请信息，提交审核，会自动生成一个DNS解析 审核通过，就可以了，github项目中Enforce HTTPS记得勾上 在Chrome浏览器中，打开网站后如果仍然显示不安全，即没有出现锁的图标，右击选择检查元素，进入开发者模式，看Security里面有什么问题。 备案👉网站ICP备案和公安备案流程 注意：ICP备案时，网站要处于禁止访问状态，可以通过停止解析实现👉您备案的网站未指向阿里云国内节点（不含香港）服务器，备案号可能被取消接入问题","path":"page/domainname.html","date":"01-14","excerpt":"","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://xiaoliblog.cn/tags/Hexo/"}]},{"title":"Twikoo+腾讯云评论配置","text":"视频观看 Twikoo作者为大家提供了一个视频教程，建议观看视频教程进行实装 腾讯云+Twikoo 关于Twikoo作者iMaeGoo：https://www.imaegoo.com/about/ Twikoo中文文档：https://twikoo.js.org/ 参考HEO大佬的Twikoo评论系统配置教程：https://blog.zhheo.com/p/2e6bbbd0.html Twikoo配置很简单，基本上看文档就可以配置成功！ HEO大佬的在云函数配置时与文档不同，以文档的配置为准 Butterfly主题 要求你的Butterfly主题版本在3.3以上，Butterfly3.3及以上用户可以通过配置文件来直接启用twikoo 未更新用户需要输入下段代码，更新有风险，更新前需备份。有魔改的用户小心升级 1234cd 主题路径git add *git commit -m &#x27;旧版本一去兮不复返&#x27;git pull 已对主题魔改过的可以参考Akliar大佬的平滑升级魔改后的Hexo主题 非butterfly主题可以参考Twikoo文档进行配置 购买云开发套餐 首先要注册腾讯云账户，然后前往腾讯云的活动区域：立即前往 在网页下方找到新用户专享的套餐购买，立即购买 注意这个付费后面可以降级为免费用户，所付的钱会原路退回 自定义环境名称 如果你从没购买过腾讯云开发（是腾讯云开发新用户），但是无法购买，提示参数错误，可以尝试在控制台中新建一个配置：立即前往提示“选择部署应用”，请选择“不创建环境”。创建后回到活动页购买免费套餐 打开权限 首先进入登陆授权打开匿名登陆 然后进入安全配置将网站url和测试地址添加进安全域名中 12localhost:4000xiaoliblog.cn 部署腾讯云 进入腾讯云控制台云函数点击新建云函数 名称输入twikoo，点击新建按钮 在Twikoo中文文档云函数部署中复制代码，回到刚才的新建函数窗口，粘贴到函数代码中，点击确定 创建好函数后进入函数详情页，点击【函数代码】，并新建一个package.json文件 在Twikoo中文文档云函数部署中复制代码，粘贴到package.json代码框中，点击【保存并安装依赖】 详情请参考Twikoo中文文档云函数部署 主题配置 打开butterfly的主题配置文件_config.yml，启用Twikoo 12345comments: # Up to two comments system, the first will be shown as default # Choose: Disqus/Disqusjs/Livere/Gitalk/Valine/Utterances/Facebook Comments use: - Twikoo 前往控制台获取你的环境id粘贴到配置文件中 1234567# Twikoo # https://github.com/imaegoo/twikootwikoo: envId: xxxg-xxxxx region: visitor: false option: 开启管理面板 进入登录授权点击自定义登陆的【密钥下载】 用文本编辑器打开私钥文件，复制全部内容，在博客网站评论下面点击齿轮并在密码里输入密钥 关于没有齿轮的情况，可以能是主题配置没配好，或者是网络和缓存的问题，可以多进行hexo clean试一试 然后会设置twikoo评论管理密码，登录就可以对twikoo进行设置了！ 表情包 可以在Twikoo控制台引入表情包CDN 其中Heo表情引入了Heo大佬自制的表情包，原文请戳：https://blog.zhheo.com/p/2daa6a7b.html 本人的表情包CDN如下 1https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;xiaoliblog&#x2F;MyCDNRepo@v1.0&#x2F;emotion&#x2F;emotion.json QQ/微信提醒Service 酱 SCKEY 获取 首先需要到 server 的官网，开启微信提醒并获取 SCKEY。 注册—&gt;登陆—&gt;发送消息—&gt;就可以得到SCKEY代码了，具体步骤请戳Server酱官网，里面写的非常详细了 开启微信通知后可以在官方那里测试下能否接到通知（关注一个微信公众号） 复制SCKEY复制到SCKEY环境变量后保存即可 Qmsg 酱key密钥获取 Qmsg 的官网为：https://qmsg.zendee.cn/, 进入官网，登录账号（qq 或者神邸用户都可以 选择并添加一个消息发送者，并填写你接受消息的 qq 号。（可以使用小号登录，大号接收） 获取密钥 点击右上角的文档，把send后面的key复制到LeanCloud的QMSG_KEY环境变量后保存即可","path":"page/comments.html","date":"01-14","excerpt":"","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://xiaoliblog.cn/tags/Hexo/"}]},{"title":"Github图床+七牛云图床","text":"GitHub图床 图床是个啥东西就不用过多介绍了，先来对比一下各路图床： 微博图床：以前用的人比较多，从2019年4月开始开启了防盗链，凉凉 SM.MS：运营四年多了，也变得越来越慢了，到了晚上直接打不开图片，速度堪忧 其他小众图床：随时有挂掉的风险 Imgur等国外图床：国内访问速度太慢，随时有被墙的风险 语雀图床，语雀用的oss本来挺好用，也开启防盗链了 大厂储存服务：例如七牛云、又拍云、腾讯云COS、阿里云OSS等，容量限制，操作繁琐，要花钱 Github图床 Gitee 图床 GitHub 图床是个不错的选择，利用 jsDelivr CDN 加速访问（jsDelivr 是一个免费开源的 CDN 解决方案），PicGo 工具一键上传，操作简单高效，GitHub 和 jsDelivr 都是大厂，不用担心跑路问题，不用担心速度和容量问题，而且完全免费，可以说是目前免费图床的最佳解决方案！ 须知 需要绑定GitHub账户 需要将 token 信息上传给后台 创建图片仓库 登录/注册GitHub，新建一个仓库，填写好仓库名，仓库描述，根据需求选择是否为仓库初始化一个README.md描述文件 生成一个Token在主页依次选择【Settings】-【Developer settings】-【Personal access tokens】-【Generate new token】，填写好描述，勾选【repo】，然后点击【Generate token】生成一个Token，注意这个Token只会显示一次，自己先保存下来，或者等后面配置好PicGo后再关闭此网页 绑定GitHub 点击https://chuibi.cn/，选择图标使用GitHub账户登录 登录后回到主页面，并显示如下蓝框内容 填写仓库信息 获取token 点击下图位置图标 输入以下信息 复制下图蓝框内容，进行下一步 PicGo图床需要提前安装 node.js 否则插件会安装失败！ 使用PicGo图床工具，务必先保证上面的浏览器图床测试正常！ 下载与安装 GitHub项目请戳这里，图床工具的下载链接可以在 README 中获取。 因为国内下载速度很慢，不限速蓝奏云链接戳密码:hvdu PicGo配置 插件设置中搜索 web-uploader 并安装： 安装后可以在图床设置中查看： 配置参数如下 123API地址：http:&#x2F;&#x2F;虚拟主机用户名.m.awhost.cn&#x2F;up.php #简单方法填写获取的链接：https:&#x2F;&#x2F;chuibi.cn&#x2F;up.php?xxxxxxPOST参数名：picJSON路径：data.url 七牛云图床 七牛云的空间大小有10GB，流量也是10GB/月，对于个人博客来讲已经完全够用。但要说明的是，七牛云的免费空间会有一个30天的临时域名，后续要使用的话，必须绑定自己已经备案过的域名才行。如果域名没有备案，就使用以上GitHub图床吧 建立七牛云图床 七牛云官网注册：https://www.qiniu.com/ 添加一个对象存储 创建一个存储空间 提取密钥，记住AK和SK两个密钥，后面要使用的 配置PicGo 在picgo图床设置里面，打开七牛云图床设置，如图设置： Typora配置 点击软件工具栏，文件 –&gt; 偏好设置 –&gt; 图像 –&gt; 配置picgo 点击验证图片上传选项后 可以看到127.0.0.1后面有个端口号36677，这个端口号一定要和picgo里面设置的端口号要一致！否则上传不成功！","path":"page/tc202101.html","date":"01-13","excerpt":"","tags":[{"name":"图床","slug":"图床","permalink":"http://xiaoliblog.cn/tags/%E5%9B%BE%E5%BA%8A/"}]},{"title":"使用Vercel加速GitHub Pages","text":"Vercel本人网站一直部署在Github Page上，但由于访问速度非常影响体验，但由于是学生没有额外的开销去使用收费的托管商，于是查了一下发现vercel和Netlify不仅免费而且访问速度也快！ Vercel支持多个开发框架(Next.js,create-react-app,Nuxt.js) Vercel内置的CI / CD系统会在每次代码更改时触发，推送代码后自动部署 支撑一键导入GitHub/Gitlagb仓库和站点 全球CDN加速 GitHub登录Vercel进入Vercel官网：https://vercel.com/ ，依次点击 sign up - Continue with GitHub 注意GitHub账户绑定的主邮箱📪，有可能QQ邮箱会出现无法使用GitHub账号登陆Vercel的情况，推荐将GitHub主邮箱改为谷歌邮箱，不会改可以问下度娘GitHub更换邮箱（简单粗暴） 导入仓库选择 Import Git Repository 然后Continue输入你仓库的url就行了（https） 导入静态页面仓库之前，需要为你的 Github 安装 Vercel(setting-Application)，此处建议选择 All repositories，意为为所有仓库安装，当然，你也可以选择只为当前仓库安装，也就是 Only select repositories。 下方三个选项保持默认就好，因为 username.github.io 的 master 分支内是本身就已经部署好的静态页面，所以没必要选择特定的框架去再次编译。 2020 年 10 月后 github 新建仓库默认分支改为 main，注意更改。 导入之后可以访问，说明部署成功！ 绑定并解析域名点击Settings👉Domains👉输入自己的域名，并在域名提供商控制台进行域名解析（CNAME）。解析完成后即可通过自己的域名访问自己的博客 参考👉👉使用Vercel来加速Hexo博客","path":"page/vercel.html","date":"01-12","excerpt":"","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://xiaoliblog.cn/tags/Hexo/"}]},{"title":"Java👉JDBC","text":"数据库连接数据库概述 数据库(DataBase,DB):指长期保存在计算机的存储设备上，按照一定规则组织起来，可以被各种用户或应用共享的数据集合。 数据库管理系统(DataBase Management System，DBMS) :指一种操作和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制，以保证数据库的安全性和完整性。用户通过数据库管理系统访问数据库中的数据。 常见数据库管理系统 MySQLMySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。 OrcaleOracle数据库被认为是业界目前比较成功的关系型数据库管理系统。Oracle数据库可以运行在UNIX、Windows等主流操作系统平台，完全支持所有的工业标准，并获得最高级别的ISO标准安全性认证。 DB2DB2是IBM公司的产品，DB2数据库系统采用多进程多线索体系结构，其功能足以满足大中公司的需要，并可灵活地服务于中小型电子商务解决方案。 Microsoft SQL ServerSQL Server 是Microsoft 公司推出的关系型数据库管理系统。具有使用方便可伸缩性好与相关软件集成程度高等优点。 SQL语言DDLData Definition Language 数据定义语言 作用:用来定义数据库对象：库、表、列等 123456789101112131415161718192021222324252627282930313233343536373839/* 操作数据库 */--增 createcreate database 数据库名; --创建新的数据库create database 数据库名 character set GBK;--创建新的字符集为GBK的数据库--查 showshow databases;--查看DBMS中所有的数据库show create database 数据库名;--查看数据库的定义信息--改 alteralter database 数据库名 character set utf8;--把数据库改成utf8字符集--删 dropdrop database 数据库名;--删除数据库--其他use 数据库名;--使用数据库select database();--查看当前正在使用的数据库flush privileges;--刷新数据库/* 操作表 */--增 createcreate table 表名(--创建新表字段名1 字段类型(长度) [约束],字段名2 字段类型(长度) [约束],...);--查 showshow tables;--查询数据库中有的表show create table 表名;--查看表格的创建细节desc 表名;--查看表的字段信息 --改 alteralter table 表名 add 列名 数据类型[约束];--添加一个列alter table 表名 change 旧列名 新列名 新数据类型[约束];--修改列的列名alter table 表名 modify 列名 新数据类型[约束];--修改列的数据类型alter table 表名 drop 列名;--删除表的列alter table 表名 AUTO_INCREMENT=5;--重新设置自增idrename table 旧表名 to 新表名;--修改表名alter table 表名 character set 字符集;--修改表的字符集--删 dropdrop table 表名;drop table if exists 表名;--如果表存在,则删除;如果不存在,也不会报错.这种语句是MySql特有的语句,其他的数据库都是不支持这种语法的 DMLData Manipulation Language 数据操作语言 12345678910111213--增 insertinsert into 表名 values(字段值1,字段值2, ...);--全字段插入insert into 表名(字段1) values(字段值1);--部分字段插入insert into 表名 values(记录1的所有字段),(记录2的所有字段)...;--一次性插入多条 数据--改 updateupdate 表名 set 列名1=列值1,列名2=列值2 ... where 列名=值;--修改操作update 表名 set 列名1=列值1;--没有where条件的,会直接修改所有列名的值update 表名 set 列名1 = replace(列名1,&#x27;原内容&#x27;,&#x27;要替换的内容&#x27;);--批量替换字段里的字符串--删 deletedelete from 表名 where 列名=值;--删除表中条件是where的delete from 表名;--删除表中所有数据，表结构还在，删除后的数据可以找回truncate table 表名;--删除表中所有数据,把表直接drop掉，然后再创建一个同样的新表-删除的数据不能找回。该命令会让id重新从1开始自动递增 DQLData Query Language 数据查询语言 作用:用来查询记录（数据）查询语句的顺序书写顺序:select → from →join on → where → group by → having → order by → limit执行顺序:from → join on → where → group by → having → select → order by → limit 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136/* 简单查询 */select * from emp;--查询所有列select empno,ename,job from emp;--查询指定的列select empno as &#x27;编号&#x27;,ename as &#x27;别名&#x27; from emp;--给列起别名(as可以省略可以使用&quot;&quot;,&#x27;&#x27;或者不使用引号)select e.empno,e.ename from emp as e;--给表起别名,表中的字段也能通过表的别名来调用/* 条件查询 */--条件语句 &gt; &lt; &gt;= &lt;= !=(&lt;&gt;) =--and(&amp;&amp;)select * from emp where deptno=10 and sal&gt;2000;--可以使用&amp;&amp;带代替--or(||)select * from emp where ename=&#x27;smith&#x27; or sal=5000;--可以使用||来代替--between...andselect * from emp where ename between &#x27;A&#x27; and &#x27;F&#x27;;--BETWEEN AND作用于字符型的数据的时候,包含第一个边界值,但是不包含第二个边界值--in(set)select * from emp where sal in(800,1600);--in表示包含的意思--is null (尽量不要使用,会导致索引失效)select * from emp where comm is null;--对于null的判断不能使用=号--notselect * from emp where deptno !=10;select * from emp where deptno &lt;&gt;10;select * from emp where not deptno =10;select * from emp where comm is not null;select * from emp where not comm is null;--注意--对于字符型的数据,是严格区分大小写的--Oracle在任何的平台上都是严格区分字符型数据大小写的--MySql在Liunx/Unix平台上严格区分字符型数据大小写,但是在window平台上不区分字符型数据大小写--可以使用BINARY关键字,让MySql在window平台上也严格字符字符型数据的大小写select * from emp where binary ename=&#x27;smith&#x27;;/* 模糊查询 */select * from emp where ename like &#x27;_M%&#x27;;-- _ ：任意一个字母 查询第二个字母是m的人select * from emp where ename like &#x27;%m%&#x27;;-- %：任意0~n个字母 查询名字包含m的人 /* 字段控制查询 */ select salary*12 as &#x27;年薪&#x27; from emp;--可以使用算术表达式将月薪以年薪的形式显示select distinct deptno from emp;--去掉重复值查询select *,sal+ifnull(comm,0) from emp;/* 排序 */select * from emp order by sal asc;--升序排序,可默认不写select * from emp order by sal desc;--降序排序select * from emp order by sal desc,empno asc;--按月薪降序排序，如果月薪相同，按编号升序排序/* 单行函数 */--year(日期字段) 将日期格式化为年(月日时分秒同理)select year(now())--输出今年select year(&#x27;2018-01-01&#x27;);--2018--substr(被截取字段名称,起启下标,截取长度) 截取字符串的函数select ename,substr(ename,2,1) from emp;--length(str) 返回字符型数据的长度select ename,length(ename) from emp;select * from emp where length(ename)=5;--查询名字的长是5的员工--lower(str) 把字符型数据转换为小写的字符select ename,lower(ename) from emp;--upper(str) 把字符型数据转换为大写的字符select * from emp where binary ename=upper(&#x27;smith&#x27;);/* 聚合函数 */--count() 统计指定列不为NULL的记录行数select count(*) from emp;select count(*) from emp where sal+ifnull(comm,0)&gt;2500--max() 计算指定列的最大值，如果指定列是字符串类型，那么使用字符串排序运算select max(sal) from emp;--min() 计算指定列的最小值，如果指定列是字符串类型，那么使用字符串排序运算select min(sal) from emp;--sum() 计算指定列的数值和，如果指定列类型不是数值类型，那么计算结果为0select sum(sal) from emp;--avg() 计算指定列的平均值，如果指定列类型不是数值类型，那么计算结果为0select avg(sal) from emp;/* 分组查询 */--分组查询select deptno,sum(sal) from emp group by deptno;--HAVING子句select deptno,sum(sal) from emp group by deptno having sum(sal)&gt;9000; --having与where的区别:where是先筛选后分组;having是先分组后筛选/* LIMIT */--分页查询select * from emp limit 5;--查询5行记录，默认从0开始select * from emp limit 0,5;--查询5行记录，起始行从0开始select * from emp limit 3,10;--查询10行记录，起始行从3开始 --注意:LIMIT只能在MySql和SqlServer中有效/* 多表查询(跨表查询) */--联合查询 --说明:合并结果集就是把两个select语句的查询结果合并到一起,被合并的两个结果：列数、列类型必须相同 --union 去除重复记录 --union all 不去除重复记录--连接查询 --内连接 --等值连接:建立在父子表关系上,用等号来连接两个表 select e.empno,e.ename,e.job,e.sal,d.deptno,d.dname from emp e,dept d where e.deptno=d.deptno;--SQL1992语法 select e.empno,e.ename,e.job,e.sal,d.deptno,d.dname from emp e inner join dept d on(e.deptno=d.deptno);--SQL1999语法 --使用内连接的时候,inner可以忽略 --非等值连接:两个表之间没有父子关系,用非等号来连接两个表 select e.empno,e.ename,e.sal,s.grade,s.losal,s.hisal from emp e,salgrade s where e.sal between s.losal and s.hisal;--SQL1992语法 select e.empno,e.ename,e.sal,s.grade,s.losal,s.hisal from emp e join salgrade s on e.sal between s.losal and s.hisal--SQL1999语法 --自连接:使用别名将一个表虚拟成两个表(父子表),然后再这两个表上面做等值连接 select e.empno &#x27;员工编号&#x27;,e.ename &#x27;员工姓名&#x27;,m.empno &#x27;经理编号&#x27;,m.ename &#x27;经理姓名&#x27; from emp e,emp m where e.mgr=m.empno &amp;&amp; m.empno=7698--SQL1992语法 select e.empno &#x27;员工编号&#x27;,e.ename &#x27;员工姓名&#x27;,m.empno &#x27;经理编号&#x27;,m.ename &#x27;经理姓名&#x27; from emp e join emp m on(e.mgr=m.empno) where m.empno=7698--SQL1999语法 --外连接 --左外连接(LEFT OUTER JOIN):左外连接可以把左表中不满足对应关系的数据查询出来 select e.empno,e.ename,e.job,e.sal,d.deptno,d.dname from emp e left outer join dept d on e.deptno=d.deptno;--使用外连接的时候,outer可以忽略 select e.empno,e.ename,e.job,e.sal,d.deptno,d.dname from dept d left join emp e on e.deptno=d.deptno;--左表的位置是相对的 --右外连接(RIGHT OUTER JOIN):右外连接可以把右表中不满足对应关系的数据查询出来 select e.empno,e.ename,e.job,e.sal,d.deptno,d.dname from emp e right join dept d on e.deptno=d.deptno; --全外连接(FULL OUTER JOIN):可以把左右两个表中不满足对应关系的数据都查询出来 select e.empno,e.ename,e.job,e.sal,d.deptno,d.dname from emp e full join dept d on e.deptno=d.deptno;--Oracle支持全外连接,MySql不支持全外连接 --join的更多用法见下表 --子查询 --1.用来给主查询提供查询条件或查询数据而首先执行的一个查询 --2.主查询使用子查询的结果 --子查询必须要放在()里面 --分类 --出现在where中的子查询,用来给查询提供查询条件的 select * from emp where sal&gt;(select max(sal) from emp where deptno=30);--查询高于30部门所有人工资的员工信息 --出现下from后面的子查询,用来给主查询提供查询数据的(all,any) select * from emp where sal&gt;all(select sal from emp);--查询高于30部门所有人工资的员工信息 --(了解)出现在查询列表中的子查询,功能类似于外连接的效果 常用函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* 数据函数 */-- abs() 取绝对值select abs(-1); -- 1-- round() 用于数据的四舍五入select round(13.26723,2);-- 结果13.27--rand() 生成随机数select rand();--生成一个0到1之间的随机数-- ceiling() 向上取整select ceiling(2.5); -- 3-- floor() 向下取整select floor(2.5); -- 2-- sign() 符号函数: 负数返回-1,正数返回1,0返回0select sign(2); -- 1/* 字符串函数 */-- char_length(str) 返回字符串包含的字符数select char_length(&#x27;abcdef&#x27;); -- 6-- concat() 合并字符串,参数可以有多个select concat(&#x27;我爱&#x27;,&#x27;北京&#x27;,&#x27;天安门&#x27;); -- 我爱北京天安门-- insert() 替换字符串,从某个位置开始替换某个长度select insert(&#x27;一二三四五六七&#x27;,1,3,&#x27;八八八&#x27;); -- 八八八四五六七-- lower() 把字符型数据转换为小写的字符select lower(&#x27;Manaphy&#x27;); -- manaphy-- upper() 把字符型数据转换为大写的字符select upper(&#x27;Manaphy&#x27;); -- MANAPHY-- left() 从左边截取字符串select left(&#x27;Manaphy&#x27;,3); -- Man-- right() 从右边截取字符串select right(&#x27;Manaphy&#x27;,3); -- phy-- replace() 替换字符串select replace(&#x27;一二三四五六七&#x27;,&#x27;四五&#x27;,&#x27;八九&#x27;); -- 一二三八九六七-- substr(被截取字段名称,起启下标,截取长度) 截取字符串的函数select substr(&#x27;一二三四五六七&#x27;,1,3); -- 一二三-- reverse() 反转字符串select reverse(&#x27;一二三四五六七&#x27;); -- 七六五四三二一/* 日期函数 */-- year(日期字段) 将日期格式化为年(月日时分秒同理)select year(now());-- 输出今年select year(&#x27;2018-01-01&#x27;);-- 2018-- 获取当前日期select current_date();select curdate();-- 获取当前日期和时间select now();select localtime();select sysdate();-- 获取当前时间select curtime();select current_time(); DCLData Control Language 数据控制语言 作用:用来定义访问权限和安全级别 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/* 实体完整性 */--主键约束 primary key 说明:每个表中要有一个主键, 数据唯一, 且不能为nullcreate table stu(id int primary key);--创建表时指定主键create table stu(id int,name varchar(10),primary key(id,name));--联合主键,创建了两个列作为主键create table stu(id int,name varchar(10));alter table stu add primary key(id);alter table stu modify id int primary key;--在已经有表的情况下使用--唯一约束 unique 说明:数据不能重复create table stu(id int primary key,name varchar(50) unique);--自动增长列 --auto_increment(mysql) --identity(sqlserver) --sequence(oracle) --说明:给主键添加自动增长的数值,列只能是整数类型create table stu(id int primary key auto_increment);--mysql的方式/* 域完整性 */--数据类型 --数值类型:tinyint(1字节) int(4字节) bigint(8字节) folat(4字节) double(8字节) decimal --日期类型 date--1000-01-01/9999-12-31 datetime--1000-01-01 00:00:00/9999-12-31 23:59:59 timestamp--1970-01-01 00:00:00/2038 结束时间是第 2147483647(2^31-1)秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07 time--&#x27;-838:59:59&#x27;/&#x27;838:59:59&#x27; (±35天) year--1901/2155 --字符串类型:char(定长字符串) varchar(变长字符串) binary varbinary text(长文本数据) enum set--非空约束create table stu(id int primary key,name varchar(10) not null);--默认值约束create table stu(id int primary key,sex varchar(2) default &#x27;男&#x27;);--默认是男insert into stu(id) values(1);--默认是男insert into stu values(2,default);--默认是男insert unto stu values(3,null);--此处是null--check约束check(sex=&#x27;男&#x27; or sex=&#x27;女&#x27;)--（mysql不支持）/* 引用完整性 */--外键约束alter table 左表 add foreign key(左表的某个字段) references 右表(主键);create table 表名(id int primary key,name varchar(20),classno bigint,foreign key(classno) references tb_class(classno); --注意 --1.从表的列引用了主表的主键,那么该列就称为外键 --2.外键的名字可以不相同 --3.外键的数据类型必须与主表中主键的数据类型完全相同 --4.外键可以是null值/* 表与表之间的关系 */--1.一对多: 一张表中的一条记录再另一张表中出现多次--2.多对多: 要想两张表之间实现多对多的关系,必须有一张中间表,通过中间表创建与两张表的外键约束,实现多个一 对多,使用这种方式创建外键约束,非常适合实现多个一对多。--3.一对一:一张表里的记录,在另外一张表里只能出现一次.表和表之间的关系必须通过外键来创建,但是外键一创建就是一对多,因此在从表里将外键设置唯一性约束,实现一对一 JDBCJDBC使用详解JDBC的基本使用 JDBC全称Java Database Connectivity JDBC可以通过载入不同的数据库的“驱动程序”而与不同的数据库进行连接。 JDBC优点: 使用的驱动不同，即可连接不同的数据库。 使用同一套操作来操作不同的数据库 如果每一个数据库java都制订一套连接方式，那么当不同的数据库更新的时候，java也需要更新自己的代码，而使用jdbc，使用同一套代码来操作，使用不同的驱动程序（驱动程序由数据库厂商提供）来连接，这使得可以连接不同的数据库。 JDBC访问步骤 加载并注册数据库驱动（导入驱动包sqljdbc4.jar) 通过DriverManager获取数据库连接 通过Connection对象获取Statement对象 使用Statement执行SQL语句 操作ResultSet结果集 关闭资源，释放资源 导入驱动 在对应的数据库厂商网站获取对应的jar包 将对应的jar包添加到引用。在eclipse中可以将jar包导入一个文件夹后，右键Build Path -&gt; add to path就可以将jar包添加到当前项目引用的库里面。 JDBC实例在SQLServer数据库系统创建了一个Student数据库，数据库有一个stu表stu表中数据如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package JDBC_01;import java.sql.*;public class JDBC_01 &#123; public static void main(String[] args) throws SQLException &#123; // TODO Auto-generated method stub Statement stmt=null; ResultSet rs=null; Connection conn=null; try &#123; /* * MySQL和SQLServer加载有以下不同 1.MySQL加载驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 2.通过DriverManager获取数据库连接 String url=&quot;jdbc:mysql://localhost:3306/Student?charaterEncoding=utf-8&quot;; *///*****************************************************************************************88 //1.加载驱动SQL server Class.forName(&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;); System.out.println(&quot;1.加载成功&quot;); //2.通过DriverManager获取数据库连接 //Student为数据库名 String url=&quot;jdbc:sqlserver://localhost:1433;DatabaseName=Student&quot;; String username=&quot;sa&quot;; String password=&quot;123456&quot;; conn=DriverManager.getConnection(url,username,password); System.out.println(&quot;2.连接成功&quot;); //3.通过Connection对象获取Statement对象 stmt=conn.createStatement(); System.out.println(&quot;3.成功获取Statement对象&quot;); //4.使用Statement执行SQL语句 String sql=&quot;select * from stu&quot;; //从stu表中查询 rs=stmt.executeQuery(sql); System.out.println(&quot;4.执行SQL结果如下&quot;+&quot;\\n&quot;); //5.操作ResultSet结果集 System.out.println(&quot;ID|name|sex&quot;); while(rs.next()) &#123; int id=rs.getInt(&quot;ID&quot;); String name=rs.getString(&quot;name&quot;); String sex=rs.getString(&quot;sex&quot;); System.out.println(id+&quot;|&quot;+name+&quot;|&quot;+sex+&quot;|&quot;); &#125; &#125;catch(ClassNotFoundException e) &#123; e.printStackTrace(); &#125;finally &#123; //释放资源，反着关闭 if(rs!=null) &#123; rs.close(); &#125; if(stmt!=null) &#123; stmt.close(); &#125; if(conn!=null) &#123; conn.close(); &#125; &#125; &#125;&#125; 执行结果如下： 详细介绍 加载数据库驱动——Driver接口Driver接口由数据库厂家提供，作为java开发人员，只需要使用Driver接口就可以了。在编程中要连接数据库，必须先装载特定厂商的数据库驱动程序，不同的数据库有不同的装载方法。 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //MySQL Class.forName(&quot;com.microsoft.jdbc.sqlserver.SQLServerDriver&quot;); //SQLServer Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;); //Oracle 建立连接——Connection接口客户端与数据库所有交互都是通过connection对象完成的使用DriverManager来获取URL用于标识数据库的位置，程序员通过URL地址告诉JDBC程序连接哪个数据库，URL的写法为： String url=jdbc:mysql:［］//localhost:3306/数据库名 ?参数名：参数值 url=jdbc:oracle:thin:@localhost:1521:database //Oracle url=jdbc:microsoft:sqlserver://localhost:1433; DatabaseName=database //SQLServer url=jdbc:mysql://localhost:3306/database //MySQL Connection conn = DriverManager.getConnection(url,user,pass); DriverManager类常用方法 说明 registerDriver(Driver driver) 用于向DriverManager中注册给定的JDBC驱动程序 getConnection(String url,String user,String password) 用于建立和数据库的连接，并返回表示连接的Connction对象 Connection常用方法 说明 createStatement() 创建向数据库发送sql的statement对象。 prepareStatement(sql) 创建向数据库发送预编译sql的PrepareSatement对象。 prepareCall(sql) 创建执行存储过程的callableStatement对象。 setAutoCommit(boolean autoCommit) 设置事务是否自动提交。 commit() 在链接上提交事务。 rollback() 在此链接上回滚事务。 getMetaData() 用于返回表示数据库的元数据的DatabaseMetaData对象 执行SQL语句——Statement接口用于执行静态SQL语句并返回它所生成结果的对象。三种Statement类： Statement：由createStatement创建，用于发送简单的SQL语句（不带参数）。 PreparedStatement ：继承自Statement接口，由preparedStatement创建，用于发送含有一个或多个参数的SQL语句。PreparedStatement对象比Statement对象的效率更高，并且可以防止SQL注入，所以我们一般都使用PreparedStatement。 CallableStatement：继承自PreparedStatement接口，由方法prepareCall创建，用于调用存储过程。 Statement st = conn.createStatement(); //获取用于向数据库发送sql语句的statement StiString sql=&quot;select * from stu&quot;; st.executeQuery(sql);//向数据库发送sql Statement对象常用方法 说明 executeQuery(String sql) 用于向数据发送查询语句,返回ResultSet结果集。 executeUpdate(String sql) 用于向数据库发送insert、update或delete语句,返回更新的行数 execute(String sql) 用于向数据库发送任意sql语句 ,返回是否有结果集 addBatch(String sql) 把多条sql语句放到一个批处理中。 executeBatch() 向数据库发送一批sql语句执行。 PreperedStatement是Statement的孩子，它的实例对象可以通过调用： PreperedStatement st = conn.preparedStatement() StiString sql=&quot;select * from users where name=? and password=?&quot;&quot;; st=conn.preparedStatement(sql); st.setString(2,password); st.executeQuery(); Statement会使数据库频繁编译SQL，可能造成数据库缓冲区溢出。PreparedStatement 可对SQL进行预编译，从而提高数据库的执行效率。 并且PreperedStatement对于sql中的参数，允许使用占位符的形式进行替换，简化sql语句的编写。 ** 获取结果——ResultSet接口**Jdbc程序中的ResultSet用于代表Sql语句的执行结果。Resultset封装执行结果时，采用的类似于表格的方式，ResultSet 对象维护了一个指向表格数据行的游标，初始的时候，游标在第一行之前，调用ResultSet.next() 方法，可以使游标指向具体的数据行，进行调用方法获取该行的数据。 1.获取行ResultSet提供了对结果集进行滚动的方法： next()：移动到下一行 Previous()：移动到前一行 absolute(int row)：移动到指定行 beforeFirst()：移动resultSet的最前面。 afterLast() ：移动到resultSet的最后面。 2.获取值ResultSet既然用于封装执行结果的，所以该对象提供的都是用于获取数据的get方法： 获取任意类型的数据 getObject(int index) getObject(string columnName) 获取指定类型的数据，例如： getString(int index) getString(String columnName) SQL类型 JDBC对应方法 返回类型 bit(1)，bit(n) getBoolean，getBytes() Boolean，byte[] tinyint getByte() Byte smallint getShort() Short int getInt Int bigint getLong() Long char,varchar,longvarchar getString String text(clob) blob getClob()，getblob() Clob，blob date getDate() java.sql.Date time getTime() java.sql.Time timestamp getTimestamp java.sql.Timestamp","path":"page/java03.html","date":"01-05","excerpt":"","tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://xiaoliblog.cn/tags/JavaSE/"}]},{"title":"Java👉事件处理","text":"事件处理事件处理的一般方法：1.创建将要产生事件的组件对象2.构造实现相应事件监听器接口的类，并创建事件监听器对象3.为组件对象增加事件监听器对象：组件对象.addXxxListener(事件监听器对象);如：button.addActionListener(this); 注：接口中的方法都含有所产生的事件对象参数，使用该参数的getSource()方法可以得到产生该事件的事件源 ActionListener动作事件 123456789101112131415161718192021222324252627282930313233package Swing_Exception;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import javax.swing.*;public class Exception_2 &#123; JFrame f; JButton b; public Exception_2() &#123; f=new JFrame(&quot;匿名内部类&quot;); b=new JButton(&quot;我是按钮，请点击&quot;); b.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; // TODO 自动生成的方法存根 b.setText(&quot;我被点击了&quot;); &#125; &#125;); f.add(b); f.pack(); f.setLocationRelativeTo(null); f.setVisible(true); &#125; public static void main(String[] args) &#123; // TODO 自动生成的方法存根 new Exception_2(); &#125;&#125; ItemListener选择监听 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package Swing_Exception;import java.awt.*;import java.awt.event.ItemEvent;import java.awt.event.ItemListener;import javax.swing.*;public class ItemEvent_1 &#123; JFrame f; JComboBox xlk;//下拉框 JTextArea t; JScrollPane gd; String str[]= &#123;&quot;选项一&quot;,&quot;选项二&quot;,&quot;选项三&quot;,&quot;选项四&quot;,&quot;选项五&quot;&#125;; public ItemEvent_1()&#123; f=new JFrame(); xlk=new JComboBox(str); t=new JTextArea(5,3); gd=new JScrollPane(t); xlk.addItemListener(new ItemListener() &#123; @Override public void itemStateChanged(ItemEvent e) &#123; // TODO 自动生成的方法存根 int stateChange=e.getStateChange();//获得事件类型 String item=e.getItem().toString();//获得触发此次事件的选项 if(stateChange==ItemEvent.SELECTED) &#123; //查看是否由选中选项触发 System.out.println(&quot;此次事件由 选中 选项 “&quot;+item+&quot;”触发!&quot;); t.append(&quot;此次事件由 选中 选项 “&quot;+item+&quot;”触发!&quot;+&quot;\\n&quot;); &#125;else if(stateChange==ItemEvent.DESELECTED) &#123; //查看是否由取消选中选项触发 System.out.println(&quot;此次事件由 取消选中 选项 “&quot;+item+&quot;”触发!&quot;); t.append(&quot;此次事件由 取消选中 选项 “&quot;+item+&quot;”触发!&quot;+&quot;\\n&quot;); &#125;else &#123; //由其他原因触发 System.out.println(&quot;此次事件由其他原因触发!&quot;+&quot;\\n&quot;); t.append(&quot;此次事件由其他原因触发!&quot;); &#125; &#125; &#125;); f.add(xlk,BorderLayout.NORTH); f.add(gd,BorderLayout.CENTER); f.setSize(300,400); f.setLocationRelativeTo(null); f.setVisible(true); &#125; public static void main(String[] args) &#123; // TODO 自动生成的方法存根 new ItemEvent_1() ; &#125;&#125; KeyListener键盘事件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114package Swing_Exception;import java.awt.*;import java.awt.event.KeyEvent;import java.awt.event.KeyListener;import javax.swing.*;public class KeyColor_1 &#123; JFrame f; JButton b1,b2,b3,b4,b5,b6,b7; JLabel l; public KeyColor_1() &#123; f=new JFrame(&quot;颜色&quot;); b1=new JButton(&quot;1&quot;); b1.setBackground(Color.WHITE); b2=new JButton(&quot;2&quot;); b2.setBackground(Color.WHITE); b3=new JButton(&quot;3&quot;); b3.setBackground(Color.WHITE); b4=new JButton(&quot;4&quot;); b4.setBackground(Color.WHITE); b5=new JButton(&quot;5&quot;); b5.setBackground(Color.WHITE); b6=new JButton(&quot;6&quot;); b6.setBackground(Color.WHITE); b7=new JButton(&quot;7&quot;); b7.setBackground(Color.WHITE); l=new JLabel(&quot;英文键盘模式&quot;); f.setLayout(new FlowLayout()); //f.setFocusable(true);//获得焦点 b1.addKeyListener(new KeyListener() &#123; //b1为焦点 @Override public void keyTyped(KeyEvent e) &#123; // TODO 自动生成的方法存根 &#125; @Override public void keyPressed(KeyEvent e) &#123; //按下 // TODO 自动生成的方法存根 switch((char)e.getKeyCode()) &#123; //判断按下的键值 case KeyEvent.VK_1: b1.setBackground(Color.red); break; case KeyEvent.VK_2: b2.setBackground(Color.orange); break; case KeyEvent.VK_3: b3.setBackground(Color.YELLOW); break; case KeyEvent.VK_4: b4.setBackground(Color.green); break; case KeyEvent.VK_5: b5.setBackground(Color.cyan); break; case KeyEvent.VK_6: b6.setBackground(Color.blue); break; case KeyEvent.VK_7: b7.setBackground(new Color(128,0,255)); break; &#125; &#125; @Override public void keyReleased(KeyEvent e) &#123; //释放 // TODO 自动生成的方法存根 switch((char)e.getKeyCode()) &#123; case KeyEvent.VK_1: b1.setBackground(Color.WHITE); //null为原来色体 break; case KeyEvent.VK_2: b2.setBackground(Color.WHITE); break; case KeyEvent.VK_3: b3.setBackground(Color.white); break; case KeyEvent.VK_4: b4.setBackground(Color.white); break; case KeyEvent.VK_5: b5.setBackground(Color.white); break; case KeyEvent.VK_6: b6.setBackground(Color.white); break; case KeyEvent.VK_7: b7.setBackground(Color.white); break; &#125; &#125; &#125;); f.add(b1); f.add(b2); f.add(b3); f.add(b4); f.add(b5); f.add(b6); f.add(b7); f.add(l,BorderLayout.CENTER); f.pack(); f.setLocationRelativeTo(null); f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); f.setVisible(true); &#125; public static void main(String[] args) &#123; // TODO 自动生成的方法存根 new KeyColor_1(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package Swing_Exception;import java.awt.*;import java.awt.event.KeyAdapter;import java.awt.event.KeyEvent;import java.awt.event.KeyListener;import javax.swing.*;public class KeyListener_1 &#123; JFrame f; JLabel l; JTextArea t; JScrollPane gd; public KeyListener_1() &#123; f=new JFrame(&quot;键盘事件&quot;); l=new JLabel(&quot;请输入:&quot;); t=new JTextArea(5,3); t.addKeyListener(new KeyListener() &#123; @Override public void keyPressed(KeyEvent e) &#123; //键盘输入 // TODO 自动生成的方法存根 String keytext=KeyEvent.getKeyText(e.getKeyCode());//获得描述keycode的标签 if(e.isActionKey()) &#123; System.out.println(&quot;你按下的是动作键“&quot;+keytext+&quot;”&quot;); &#125;else &#123; System.out.println(&quot;你按下的是非动作键“&quot;+keytext+&quot;”&quot;); //获得与此事件中的键相关联的字符 int keycode=e.getKeyCode(); switch(keycode) &#123; case KeyEvent.VK_CONTROL: //判断按下的是否为ctrl键 System.out.println(&quot;,Ctrl键被按下&quot;); break; case KeyEvent.VK_ALT: //判断是否为ait System.out.println(&quot;,AIt键被按下&quot;); break; case KeyEvent.VK_SHIFT: System.out.println(&quot;,Shift键被按下&quot;); break; &#125; System.out.println(); &#125; &#125; @Override public void keyTyped(KeyEvent e) &#123; //键盘按下 // TODO 自动生成的方法存根 //获得输入的字符 System.out.println(&quot;此次输入的是“&quot;+e.getKeyChar()+&quot;”&quot;); &#125; @Override public void keyReleased(KeyEvent e) &#123; //键盘松开 // TODO 自动生成的方法存根 //获得描述Keycode的标签 String keyText=KeyEvent.getKeyText(e.getKeyCode()); System.out.println(&quot;你释放的是“&quot;+keyText+&quot;”键&quot;); System.out.println(); &#125; &#125;); t.setLineWrap(true); gd=new JScrollPane(t); f.add(l,BorderLayout.WEST); f.add(gd,BorderLayout.CENTER); f.setSize(400,400); f.setLocationRelativeTo(null); f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); f.setVisible(true); &#125; public static void main(String[] args) &#123; // TODO 自动生成的方法存根 new KeyListener_1(); &#125;&#125; MouseListener鼠标事件MouseListener接口中的方法:① void mousePressed ( MouseEvent ); //鼠标被按下② void mouseReleased ( MouseEvent ); //鼠标被释放③ void mouseClicked ( MouseEvent ); //鼠标被单击④ void mouseEntered ( MouseEvent ); //光标移入组件⑤ void mouseExit ( MouseEvent ); //光标移出组件 MouseEvent中的常用方法:1.int getButton()； 返回更改了状态的鼠标按键(如果有)。2.int getClickCount()； 返回与此事件关联的鼠标单击次数。3.boolean isAltDown()；返回Alt修饰符在此事件上是否为down。4. boolean isControlDown()；返回Ctrl修饰符在此事件上是否为down。5.boolean isShiftDown()；返回Shift修饰符在此事件上是否为down.6.int getPoint()；返回事件相对于源组件的x，y坐标7.int getX()；返回事件相对于源组件的水平x坐标。8.int getY()；返回事件相对于源组件的垂直Y坐标。9.int isPopupTrigger()；返回鼠标事件是否为该平台的弹出菜单所触发的事件。10.MouseAdapter适配器 MouseMotionListener1.当在组件上进行鼠标拖动、移动时产生该事件。2.MouseMotionListener接口中的方法① void mouseDragged( MouseEvent );② void mouseMoved ( MouseEvent );3.MouseMotionAdapter适配器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package Swing_Exception;import java.awt.Color;import java.awt.event.MouseEvent;import java.awt.event.MouseListener;import java.awt.*;import javax.swing.*;public class MouseEvent_1 &#123; JFrame f; JLabel l; public MouseEvent_1() &#123; f=new JFrame(&quot;鼠标事件&quot;); l=new JLabel(&quot;鼠标测试处&quot;); l.addMouseListener(new MouseListener() &#123; @Override//鼠标发送单机事件触发 public void mouseClicked(MouseEvent e) &#123; // TODO 自动生成的方法存根 System.out.println(&quot;单击了鼠标按键&quot;); int i=e.getButton();//通过该值可以判断按下的是哪个键 if(i==MouseEvent.BUTTON1) System.out.println(&quot;按下的是鼠标左键&quot;); if(i==MouseEvent.BUTTON2) System.out.println(&quot;按下的是鼠标滚轮&quot;); if(i==MouseEvent.BUTTON3) System.out.println(&quot;按下的是鼠标右键&quot;); int Clickcount=e.getClickCount();//点击次数 System.out.println(&quot;点击次数为&quot;+Clickcount+&quot;下&quot;); &#125; @Override//鼠标按键被按下时触发 public void mousePressed(MouseEvent e) &#123; // TODO 自动生成的方法存根 System.out.println(&quot;鼠标按键被按下&quot;); int i=e.getButton();//通过该值可以判断按下的是哪个键 if(i==MouseEvent.BUTTON1) System.out.println(&quot;按下的是鼠标左键&quot;); if(i==MouseEvent.BUTTON2) System.out.println(&quot;按下的是鼠标滚轮&quot;); if(i==MouseEvent.BUTTON3) System.out.println(&quot;按下的是鼠标右键&quot;); &#125; @Override public void mouseReleased(MouseEvent e) &#123; // TODO 自动生成的方法存根 //按下后松下 System.out.println(&quot;鼠标已释放&quot;); &#125; @Override//光标移入组件被触发 public void mouseEntered(MouseEvent e) &#123; // TODO 自动生成的方法存根 System.out.println(&quot;光标移入组件&quot;); l.setForeground(Color.red); &#125; @Override public void mouseExited(MouseEvent e) &#123; // TODO 自动生成的方法存根 System.out.println(&quot;光标移出组件&quot;); l.setForeground(Color.black); &#125; &#125;); f.add(l); f.pack(); f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); f.setLocationRelativeTo(null); f.setVisible(true); &#125; public static void main(String[] args) &#123; // TODO 自动生成的方法存根 new MouseEvent_1(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package Swing_Exception;import java.awt.*;import java.awt.event.MouseEvent;import java.awt.event.MouseMotionListener;import javax.swing.*;public class MyMouseMotionListener &#123; JFrame f; JPanel p; JButton b; JTextArea t; JScrollPane gd; JLabel l; int count=0; public MyMouseMotionListener() &#123; f=new JFrame(&quot;MyMouseMotionListener&quot;); l=new JLabel(&quot;clik and drag the mouse&quot;); t=new JTextArea(10,10); t.addMouseMotionListener(new MouseMotionListener() &#123; @Override public void mouseDragged(MouseEvent e) &#123; // TODO 自动生成的方法存根 count++; t.append(count+&quot;The mouse is dragged:X=&quot;+e.getX()+&quot;Y=&quot;+e.getY()+&quot;\\n&quot;); &#125; @Override public void mouseMoved(MouseEvent e) &#123; // TODO 自动生成的方法存根 count++; t.append(count+&quot;The mouse is moving:X=&quot;+e.getX()+&quot;Y=&quot;+e.getY()+&quot;\\n&quot;); &#125; &#125;); b=new JButton(&quot;退出&quot;); gd=new JScrollPane(t); f.add(l,BorderLayout.NORTH); f.add(gd,BorderLayout.CENTER); f.add(b,BorderLayout.SOUTH); f.setSize(600,600); f.setLocationRelativeTo(null); f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); f.setVisible(true); &#125; public static void main(String[] args) &#123; // TODO 自动生成的方法存根 new MyMouseMotionListener(); &#125;&#125; WindowListener窗口监听 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package Swing_Exception;import java.awt.*;import java.awt.event.WindowEvent;import java.awt.event.WindowFocusListener;import javax.swing.*;public class WindowFocusListener_1 &#123; JFrame f; JPanel p; JTextArea t; JLabel l; JScrollPane gd; public WindowFocusListener_1()&#123; f=new JFrame(&quot;窗口焦点测试&quot;); p=new JPanel(); t=new JTextArea(5,3); gd=new JScrollPane(t); t.setLineWrap(true);//自动换行 l=new JLabel(&quot;测试区域&quot;); l.setFont(new Font(&quot;宋体&quot;,Font.BOLD,50)); f.addWindowFocusListener(new WindowFocusListener() &#123; @Override public void windowGainedFocus(WindowEvent e) &#123;//获得焦点 // TODO 自动生成的方法存根 t.append(&quot;窗口获得焦点&quot;+&quot;\\n&quot;); System.out.println(&quot;\\&quot;窗口获得焦点\\&quot;&quot;); &#125; @Override public void windowLostFocus(WindowEvent e) &#123; //失去焦点 // TODO 自动生成的方法存根 t.append(&quot;窗口失去焦点&quot;+&quot;\\n&quot;); System.out.println(&quot;\\&quot;窗口失去焦点\\&quot;&quot;); &#125; &#125;); p.add(l); f.add(p,BorderLayout.CENTER); f.add(gd,BorderLayout.SOUTH); f.setSize(400,300); f.setLocationRelativeTo(null); f.setVisible(true); &#125; public static void main(String[] args) &#123; // TODO 自动生成的方法存根 new WindowFocusListener_1(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package Swing_Exception;import java.awt.*;import java.awt.event.WindowEvent;import java.awt.event.WindowListener;import javax.swing.*;public class WindowListener_1 &#123; JFrame f; JLabel l; JTextArea t; JScrollPane gd; public WindowListener_1() &#123; f=new JFrame(&quot;窗口事件&quot;); l=new JLabel(&quot;显示&quot;); t=new JTextArea(5,3); t.setLineWrap(true); gd=new JScrollPane(t); f.add(l,BorderLayout.NORTH); f.add(gd,BorderLayout.CENTER); f.addWindowListener(new WindowListener() &#123; @Override public void windowOpened(WindowEvent e) &#123; //窗口打开时触发 // TODO 自动生成的方法存根 System.out.println(&quot;窗口被打开&quot;); t.append(&quot;窗口被打开&quot;); &#125; @Override public void windowClosing(WindowEvent e) &#123; //窗口将要关闭时触发 // TODO 自动生成的方法存根 System.out.println(&quot;窗口将要被关闭&quot;); t.append(&quot;窗口将要被关闭&quot;); &#125; @Override public void windowClosed(WindowEvent e) &#123; //窗口已经被关闭时触发 // TODO 自动生成的方法存根 System.out.println(&quot;窗口已经被关闭&quot;); t.append(&quot;窗口已经被关闭&quot;); &#125; @Override public void windowIconified(WindowEvent e) &#123; //窗口最小化时触发 // TODO 自动生成的方法存根 System.out.println(&quot;窗口被最小化&quot;); t.append(&quot;窗口已经被最小化&quot;); &#125; @Override public void windowDeiconified(WindowEvent e) &#123; //窗口被非最小化时触发 // TODO 自动生成的方法存根 System.out.println(&quot;窗口被非最小化&quot;); t.append(&quot;窗口已经被非最小化&quot;); &#125; @Override public void windowActivated(WindowEvent e) &#123; //窗口被激活时触发 // TODO 自动生成的方法存根 System.out.println(&quot;窗口被激活&quot;); t.append(&quot;窗口被激活&quot;); &#125; @Override public void windowDeactivated(WindowEvent e) &#123; //窗口不再处于激活状态时触发 // TODO 自动生成的方法存根 System.out.println(&quot;窗口不再处于激活状态&quot;); t.append(&quot;窗口不再处于激活状态&quot;); &#125; &#125;); f.setSize(300,400); f.setLocationRelativeTo(null); f.setVisible(true); &#125; public static void main(String[] args) &#123; // TODO 自动生成的方法存根 new WindowListener_1(); &#125;&#125;","path":"page/java09.html","date":"01-05","excerpt":"","tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://xiaoliblog.cn/tags/JavaSE/"}]},{"title":"Java👉网络通信","text":"网络通信相关概念网络(1) 概念：连接终端系统(主机)的通信系统。(2) 功能：实现资源共享、通信。 局域网（Local Area Network，LAN），就是同一区域内通过一定形式连接起来的计算机。 广域网（Wide Area Network，WAN），由LAN延伸到更大的范围。 因特网（Internet），由无数的LAN和WAN组成。 服务器是指提供信息的计算机或程序，客户机是指请求信息的计算机或程序，而网络用于连接服务器与客户机，实现两者相互通信。 IP地址：IP地址是计算机在互联网中唯一标识。 端口：区分应用程序，实现程序间的通信 假如一台计算机提供了HTTP、FTP等多种服务，那么客户机通过不同的端口来确定连接到服务器的哪项服务上。 说明： 0～1023端口用于知名网络服务和应用，1024以上的端口用于用户的普通应用程序。 套接字(Socket)(1)功能：连接应用程序和端口（Port）。(2) 客户端与服务器通过套接字建立连接和通信：① UDP套接字：不可靠。② TCP/IP套接字： 可靠的双向流协议； 可发送任意数量的数据； 提供消息确认、错误检测、错误恢复等服务。 Java将套接字抽象化为类，程序设计者只需创建Socket类对象，即可使用套接字。 C/S模式客户端/服务器模式(c/s)①客户端：请求服务的计算机。②服务器：提供服务的计算机。 多个客户端可同时访问服务器。 一台服务器可以同时为数千台客户端服务。 java.net包(1) InetAddress类 封装IP地址，提供与IP地址相关的方法。 InetAddress方法会抛出UnknownHostException异常，在主机不存在或网络连接错误时发生。 InetAddress类常用方法 说明 InetAddress getLocalHost( ) 创建本地主机的InetAddress对象（含主机名+IP地址） String getHostName( ) 如果是本机则返回计算机名，不是本机则返回主机名，没有域名则是IP地址。 String getHostAddress( ) 返回IP地址 InetAddress getByName( String host) 已知主机名，返回主机的InetAddress对象 12345678910111213141516171819202122232425package net;import java.net.*;public class LoaclIPTest &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub InetAddress ip; try &#123; //创建本地主机的InetAddress对象(含主机名+IP地址) ip=InetAddress.getLocalHost(); String localname=ip.getHostName(); //获取本机名 String localip=ip.getHostAddress(); //获取IP地址 //已知主机名，返回主机的InetAddress对象 //InetAddress aa=InetAddress.getByName(&quot;SC-201611191816&quot;); System.out.println(&quot;本机名：&quot; + localname); System.out.println(&quot;本机IP地址：&quot; + localip); System.out.println(&quot;本机InetAddress对象：&quot; + ip); // System.out.println(&quot;aa：&quot; + aa); &#125;catch(UnknownHostException e) &#123; e.printStackTrace(); &#125; &#125;&#125; (2) ServerSocket 用于创建TCP服务器端Socket，使服务器绑定一个端口，等待客户的连接请求。 ServerSocket常用方法 说明 构造方法：ServerSocket(int port) 创建绑定到特定端口的服务器套接字 Socket accept() 等待客户端的连接，有客户端连接会返回一个对应的Socket InetAddress getInetAddress() 返回封装了ServerSocket绑定的IP地址的InetAddress对象 boolean isClosed() 判断ServerSocket是否关闭 void bind(SocketAddress endpoint) 将ServerSocket对象绑定到指定的IP地址和端口号 int getInetAddress() 返回服务器套接字等待的端口号 void close() 关闭套接字 boolean isBound() 判断ServerSocket的绑定状态 (3) Socket 创建TCP客户端Socket Socket常用方法 说明 Socket(String hostName,int port) 根据主机名和端口创建Socket Socket(InetAddress a,int port) 根据InetAddress和端口创建Socket InputStream getInputStream() 返回InputStream类型的输入流对象 OutputStream getOutputStream() 返回OutputStream类型的输出流对象 int getPort() 返回Socket对象与服务器端连接端口号 InetAddress getLocalAddress() 获取Socket对象绑定的本地IP地址 void close() 关闭Socket连接，结束本次通信 编写C/S程序服务器端 创建一个服务器套接字(ServerSocket)，绑定到指定的端口。 调用accept()方法，侦听来自客户端的请求，如果客户发出请求，则接受连接，返回通信套接字(Socket)。 调用Socket的getInputStream和getOutpuStream方法，获得I/O流，开始网络数据的接收和发送。 关闭通信套接字，关闭服务器套接字。 客户端 创建一个套接字(Socket)，向服务器的侦听端口发出请求。 与服务器正确连接后，调用Socket类的getInputStream()和getOutputStream()方法，获得I/O流，开始网络数据的接收和发送。 关闭通信套接字。 Socket通信方式利用Socket方式进行数据通信与传输的整个过程如图所示：Socket对象代表主叫方，ServerSocket对象代表被叫方，执行accept()方法表示同意建立连接。连接一旦建立，会自动创建一个输入流和一个输出流，通过这两个流可以实现数据的发送。 Socket编程思路(1)I/O流 计算机系统将除CPU、内存以外的其他设备都当作文件处理，包括网络终端（网卡）也不例外。 两台主机之间通过Socket建立握手连接之后，主要通过I/O流来接收和发送数据，实际上，绝大部分网络操作是在操作I/O流。 操作网络端口流与操作磁盘文件流原理相似。 出于效率的考虑，Socket使用的是字节流，但是在实际操作中，字节往往会带来不便，所以我们一般会把字节流改造成字符流后进行操作。 (2)输入 先利用InputStreamReader将InputStream转化成字符流 然后再使用BufferedReader建立缓冲区，以提高效率。12345InputStream is=socket.getInputStream();InputStreamReader isr=new InputStreamReader(is);BufferedReader in=new BufferedReader(isr);in.readLine(); //从流中读出信息 (3)输出 利用PrintWriter类对OutputStream进行包装 PrintWriter称为打印输出流，包装类，它可以直接输出各种类型的数据。如：void println( String ) ;123OutputStream os=socket.getOutputStream();PrintWriter pw=new PrintWriter(os, true);pw.println(“待写信息”); //将信息写入流 C/S实例Client客户端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package 网络通信;import java.io.*;import java.net.*;import javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class Client implements ActionListener &#123; JFrame f; JPanel p; JTextArea jt; //多行文本域 JTextField t; //单行文本域 JButton b; JScrollPane jsp;//滚动条 PrintWriter pw; //防止局部变量 public Client() &#123; f=new JFrame(&quot;客户端窗口&quot;); p=new JPanel(); jt=new JTextArea(); t=new JTextField(20); b=new JButton(&quot;发送&quot;); b.addActionListener(this); f.add(p); p.add(jt); p.add(t); p.add(b); jsp=new JScrollPane(jt); //文本域加滚动条 f.add(jsp); f.setSize(350,250); f.setLocation(300, 200); f.add(p,BorderLayout.SOUTH); f.setIconImage((new ImageIcon(&quot;MyImage/qq图标.jpg&quot;)).getImage()); f.setResizable(false); f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); /*System.exit(0)是退出整个程序，如果有多个窗口，全部都销毁退出。frame.setDefaultCloseOperation()是设置用户在此窗体上发起&quot;close&quot;时默认执行的操作。必须指定以下选项之一： (1)DO_NOTHING_ON_CLOSE（在WindowConstants中定义）：不执行任何操作，要求程序在已注册的 WindowListener 对象的 windowClosing 方法中处理该操作。 (2)HIDE_ON_CLOSE（在WindowConstants中定义）：调用任意已注册的WindowListener对象后自动隐藏该窗体。 (3)DISPOSE_ON_CLOSE（在WindowConstants中定义）：调用任意已注册WindowListener的对象后自动隐藏并释放该窗体。 (4)EXIT_ON_CLOSE（在JFrame中定义）：使用System exit方法退出应用程序。仅在应用程序中使用。 默认情况下，该值被设置为 HIDE_ON_CLOSE也就是说没有设置的话,默认点关闭时只是隐藏窗体,在后台进程中还可以看到，如果有多个窗口，只是销毁调用dispose的窗口，其他窗口仍然存在，整个应用程序还是处于运行状态。*/ f.setVisible(true); //客户端程序思路 //创建一个套接字(Socket)，向服务器的侦听端口发出请求。 //与服务器正确连接后，调用Socket类的getInputStream()（接受）和getOutputStream()（发送）方法，获得I/O流，开始网络数据的接收和发送。 //关闭通信套接字。 try &#123; Socket s=new Socket(&quot;127.0.0.1&quot;,8998); //进入端口，参数为服务器IP地址和端口 可通过cmd命令查找 ping和netstat -an //尝试建立与服务器的连接。如果成功，则返回Socket对象。 //向服务器发送信息 pw=new PrintWriter(s.getOutputStream(),true); //读取键盘控制台的内容 InputStreamReader isr=new InputStreamReader(System.in); BufferedReader br=new BufferedReader(isr); //接收服务器的内容 InputStreamReader isr1=new InputStreamReader(s.getInputStream()); BufferedReader br1=new BufferedReader(isr1); //死循环 多次交流 while(true) &#123; /*System.out.println(&quot;客户端说:&quot;); String str=br.readLine(); //接受控制台 pw.println(str);//向服务器发送信息 */ String str1=br1.readLine();//接受服务器的信息 jt.append(&quot;服务器对我说说:&quot;+str1+&quot;\\r\\n&quot;); //在多行文本域显示 &#125; //s.close();//关闭头接字流 &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; // TODO 自动生成的方法存根 Client c=new Client(); new Client(); &#125; @Override public void actionPerformed(ActionEvent e) &#123; // TODO 自动生成的方法存根 if(e.getSource()==b) &#123; String str=t.getText(); jt.append(&quot;我对服务器说:&quot;+str+&quot;\\r\\n&quot;); //append追加 不覆盖前面的内容 //setText与append区别 在于不会覆盖之前的信息 pw.println(str);//发送给客户端 t.setText(&quot;&quot;);//每次发完单行文本框清空 &#125; &#125; &#125; Server服务端 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137package 网络通信;import java.net.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;//尝试写好窗口 继承实现import javax.swing.*;import java.io.*;public class Server implements ActionListener &#123; JFrame f; JPanel p; JTextArea jt; //多行文本域 JTextField t; //单行 JButton b; JScrollPane jsp;//滚动条 PrintWriter pw; //消除局部变量 public Server()&#123; f=new JFrame(&quot;服务器窗口&quot;); p=new JPanel(); jt=new JTextArea(); t=new JTextField(20); b=new JButton(&quot;发送&quot;); b.addActionListener(this); f.add(p); p.add(jt); p.add(t); p.add(b); jsp=new JScrollPane(jt); //文本域加滚动条 f.add(jsp); f.setSize(350,250); f.setLocation(300, 600); f.add(p,BorderLayout.SOUTH); f.setIconImage(new ImageIcon(&quot;MyImage/qq图标.jpg&quot;).getImage()); f.setResizable(false); f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); /*System.exit(0)是退出整个程序，如果有多个窗口，全部都销毁退出。frame.setDefaultCloseOperation()是设置用户在此窗体上发起&quot;close&quot;时默认执行的操作。必须指定以下选项之一： (1)DO_NOTHING_ON_CLOSE（在WindowConstants中定义）：不执行任何操作，要求程序在已注册的 WindowListener 对象的 windowClosing 方法中处理该操作。 (2)HIDE_ON_CLOSE（在WindowConstants中定义）：调用任意已注册的WindowListener对象后自动隐藏该窗体。 (3)DISPOSE_ON_CLOSE（在WindowConstants中定义）：调用任意已注册WindowListener的对象后自动隐藏并释放该窗体。 (4)EXIT_ON_CLOSE（在JFrame中定义）：使用System exit方法退出应用程序。仅在应用程序中使用。 默认情况下，该值被设置为 HIDE_ON_CLOSE也就是说没有设置的话,默认点关闭时只是隐藏窗体,在后台进程中还可以看到，如果有多个窗口，只是销毁调用dispose的窗口，其他窗口仍然存在，整个应用程序还是处于运行状态。*/ f.setVisible(true); /* 查找IP地址方法 InetAddress ip; try &#123; ip = InetAddress.getLocalHost(); //创建本地主机的InetAddress对象(含主机名+IP地址) String localname = ip.getHostName(); // 获取本机名 String localip = ip.getHostAddress(); // 获取IP地址 InetAddress aa= InetAddress.getByName(&quot;SC-201611191816&quot;); //已知主机名，返回主机的InetAddress对象 System.out.println(&quot;本机名：&quot; + localname); System.out.println(&quot;本机IP地址：&quot; + localip); System.out.println(&quot;本机InetAddress对象：&quot; + ip); System.out.println(&quot;aa：&quot; + aa); &#125; catch (UnknownHostException e1) &#123; // TODO 自动生成的 catch 块 e1.printStackTrace(); &#125; */ //服务端程序思路 //创建一个服务器套接字(ServerSocket)，绑定到指定的端口。 //调用accept()方法，侦听来自客户端的请求，如果客户发出请求，则接受连接，返回通信套接字(Socket)。 //InputStreamReader getInputStream BufferedReader 读取客户端和控制台 //调用Socket的getInputStream（读取）和getOutpuStream（发送）方法，获得I/O流，开始网络数据的接收和发送 //PrintWriter getOutputStream方法发送 //关闭通信套接字，关闭服务器套接字。 try &#123; ServerSocket ss=new ServerSocket(8998); //ServerSocket在服务器上定义一个接口 方便客户端连接 System.out.println(&quot;服务器正在监听&quot;); Socket so=ss.accept(); //等待客户机的链接，若链接，则创建一个Socket类型的套接字 //套接字：连接应用程序和端口 客户端与服务器通过套接字建立连接和通信 //读取客户端发来的信息 //先利用InputStreamReader将InputStream转化成字符流。 //然后再使用BufferedReader建立缓冲区，以提高效率。 //readLine()方法读取 InputStreamReader isr=new InputStreamReader(so.getInputStream()); BufferedReader br=new BufferedReader(isr); //给客户端发信息 //利用PrintWriter类对OutputStream进行包装 //PrintWriter称为打印输出流，包装类，它可以直接输出各种类型的数据。 //如：void println( String ) ; pw = new PrintWriter(so.getOutputStream(),true); //读取服务器控制台发来的信息 /* InputStreamReader isr1=new InputStreamReader(System.in); BufferedReader br1=new BufferedReader(isr1); */ while(true) &#123; String str=br.readLine(); //接受客户端的信息 jt.append(&quot;客户端对我说说:&quot;+str+&quot;\\r\\n&quot;); //在多行文本域显示 /*System.out.println(&quot;服务器说:&quot;); String str1=br1.readLine(); pw.println(str1); //输出服务器发送的信息 */ &#125; //so.close();//关闭套接字流 结束点红点 再点双叉防止下次运行 端口被占用 &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; // TODO 自动生成的方法存根 Server s=new Server(); new Server(); &#125; @Override //监听 public void actionPerformed(ActionEvent e) &#123; // TODO 自动生成的方法存根 if(e.getSource()==b) &#123; //是否点击按钮发送 String str=t.getText(); //从单行文本域中取出1来 jt.append(&quot;我对客户端说:&quot;+str+&quot;\\r\\n&quot;); //append追加 不覆盖前面的内容 发送到多行文本域 //setText与append区别 在于不会覆盖之前的信息 pw.println(str); //发送给客户端 t.setText(&quot;&quot;); //每次发完单行文本框清空 &#125; &#125;&#125;","path":"page/java10.html","date":"01-05","excerpt":"","tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://xiaoliblog.cn/tags/JavaSE/"}]},{"title":"Java👉IO流","text":"I/O 文件、File类、java.io包文件可以认为是相关记录或存放在一起的数据的集合；文件一般是存放在磁盘上的，例如：硬盘、光盘和软盘等。 File文件类提供了文件和目录管理的功能，主要包括： 文件及目录的创建； 文件名、文件大小、最后修改日期等文件属性的查询； 文件目录管理、文件夹创建等操作。 File类位于java.io包中。 注意，File类并不能直接对文件内容进行读/写操作，只能查看文件的属性。 文件操作文件对象（即，File类对象）不但可以表示文件，还可以表示目录，在程序中一个File类对象可以代表一个文件或目录。 文件路径的几种表达形式：File f1 = new File( “c:/ java123/abc.txt” );File f1 = new File( “c:// java123// abc.txt” ); 创建文件对象并非创建文件本身，而是创建一个File类的对象所具有的存储空间，为后续文件的管理、文件的读写做好准备。File f1 = new File( “c:/ java123/abc.txt“ ); 123创建文件:File f=new File(&quot;C:/java123/input.txt&quot;); //开辟存储空间f.createNewFile(); //创建文件 FilenameFilter ： 是一个接口，该接口有唯一方法 boolean accept(File dir, String name) 用于判断dir、name指定文件是否为需要类型。只要创建一个类，实现此接口即可实现文件过滤功能。 123456789101112131415161718192021222324package io流;import java.io.*;public class MyFile3 &#123; public static void main(String[] args) &#123; // TODO 自动生成的方法存根 File newwj=new File(&quot;c:/java123/a.txt&quot;); if(newwj.exists()) &#123; try &#123; newwj.createNewFile();//创建文件 System.out.println(&quot;文件已创建&quot;); &#125;catch(IOException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;名称:&quot;+newwj.getPath()); System.out.println(&quot;绝对路径:&quot;+newwj.getAbsolutePath()); System.out.println(&quot;文件父路径:&quot;+newwj.getParent()); System.out.println(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package io流;import java.io.*;import java.text.*;import java.util.Date;public class MyFile &#123; private static final String FilePath=&quot;c:/java123/媒体文件夹/图片.jpg&quot;; //private static final String FilePath=&quot;c:&quot;+File.pathSeparator+&quot;java123&quot;+File.pathSeparator+&quot;abc.txt&quot;; //pathseparator 文件路径分隔符 public static void main(String[] args) throws IOException &#123; // TODO 自动生成的方法存根 //当前工程所在的根目录 new File(&quot;.&quot;) //方法1 File wj=new File(FilePath); //方法2 //File wj=new File(&quot;c:/java123&quot;,&quot;abc.txt&quot;); //方法3 //File dir=new File(&quot;c:/java123&quot;); //File wj=new File(dir,&quot;abc.txt&quot;); System.out.println(&quot;文件或目录是否存在：&quot;+wj.exists()); System.out.println(&quot;是文件吗:&quot;+wj.isFile()); System.out.println(&quot;是目录吗:&quot;+wj.isDirectory()); System.out.println(&quot;名称:&quot;+wj.getName()); System.out.println(&quot;绝对路径:&quot;+wj.getAbsolutePath()); System.out.println(&quot;文件大小:&quot;+wj.length()); //文件的长度，以字节为单位 System.out.println(&quot;是否为可读:&quot;+wj.canRead()); System.out.println(&quot;是否被写入:&quot;+wj.canWrite()); System.out.println(&quot;文件名字:&quot;+wj.getName()); System.out.println(&quot;文件父路径:&quot;+wj.getParent()); System.out.println(); SimpleDateFormat sj=new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date a=new Date(wj.lastModified()); System.out.println(&quot;最后修改日期:&quot;+wj.lastModified()+&quot; &quot;+sj.format(a)); //使用createNewFile类创建文件 File f1=new File(&quot;c:/java123/新建文件.txt&quot;); boolean b= f1.createNewFile(); System.out.println(&quot;创建文件成功:&quot;+ b); //使用mkdir创建单级空文件夹 mkdir可以创建多级空文件夹，单级也行 File f2=new File(&quot;C:/java123/新建文件夹&quot;); boolean b1=f2.mkdir(); System.out.println(&quot;创建文件夹成功:&quot;+b1); //多级 File f3=new File(&quot;c:/java123/新建多级文件夹/1/2/3&quot;); boolean b3=f3.mkdirs(); System.out.println(&quot;创建多级文件夹成功:&quot;+b3); //list 返回文件下所以文件 及名称 隐藏文件也可以查看 File f4=new File(&quot;c:/java123&quot;); String arr[]=f4.list(); for(String fileName:arr) &#123; System.out.println(fileName); &#125; //listFiles File f5=new File(&quot;c:/java123&quot;); File [] files=f5.listFiles(); for(File f:files) &#123; System.out.println(f); &#125; //使用delete删除文件或文件夹 //文件夹中有内容 不会删除返回false 从硬盘中删除 不走回收站，谨慎 /*if(f1.exists()&amp;&amp;f1.isFile()) &#123; boolean b4=f1.delete();//文件删除 System.out.println(&quot;删除成功&quot;+b4); &#125; */ &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package io流;import java.io.*;//列出指定目录下的所有java源文件和满足条件的文件class FileAccept implements FilenameFilter&#123; String extName=&quot;&quot;; FileAccept(String extName)&#123; //构造方法赋值过滤条件 this.extName=extName; &#125; public boolean accept(java.io.File file,String fileName) &#123; return fileName.endsWith(extName);//过滤条件w &#125;&#125; public class MyFile5 &#123; public static void main(String[] args) &#123; // TODO 自动生成的方法存根 File dir=new File(&quot;c:/java123&quot;); String[] fileNames=dir.list();//返回目录dir中的文件和目录的名称所组成的字符串数组 System.out.println(&quot;所有文件数:&quot;+fileNames.length); for(int i=0;i&lt;fileNames.length;i++) &#123; System.out.println(fileNames[i]); &#125; System.out.println(&quot;\\n\\n&quot;); // FileAccept con=new FileAccept(&quot;mp3&quot;);//过滤条件 fileNames=dir.list(con); System.out.println(&quot;所有mp3文件:&quot;+fileNames.length); for(int i=0;i&lt;fileNames.length;i++) &#123; System.out.println(fileNames[i]); &#125; // System.out.println(&quot;\\n\\n&quot;); FileAccept con1=new FileAccept(&quot;txt&quot;); fileNames=dir.list(con1); System.out.println(&quot;所有txt文件:&quot;+fileNames.length); for(int i=0;i&lt;fileNames.length;i++) &#123; System.out.println(fileNames[i]); &#125; &#125;&#125; 流的概念 File类不负责文件的读写。Java中文件读写是通过“流”的形式完成的。 流是一组有序的数据序列，也称“数据流”。 流是以先进先出的方式完成数据的发送和接收。 根据数据的流向不同，分为输入流和输出流，如果数据的流向是从外设读取到内存中的程序称为“输入流”（Input Stream） ，反之称为输出流（ Output Stream ）。输入流类名以In开始，输出流类名以Out开始。 输入流： 只能从中读取数据，而不能向其写入数据。 输出流：只能向其写入数据，而不能向其读取数据。 输入输出是相对于计算机而言的，输入in就是进来，进入CPU中，所以是读取，而输出out，是计算机往外输出，就是写。 注：如果从硬盘的角度来考虑，图15.1所示的数据流应该是输入流才对；但划分输入/输出流时是从程序运行所在的内存的角度来考虑的，因此如图15.1所在的流时输出流。而不是输入流。 对于如图15.2所示的数据流向，数据从服务器通过网络流向客户端，在这种情况下,Server端的内存负责将数据输出到网络里，因此Server端的程序使用输出流；Client端的内存负责从网络中读取数据，因此Client端的程序应该使用输入流。 流的分类 按照数据处理的方式不同，流又可分为字节流、字符流。字节流类名以Stream结尾，字符流类名以Reader或Writer结尾。 字节流是指8位的通用字节流，以字节为基本单位处理，适合处理二进制文件（音频文件、图片、歌曲等），对于字节流进行操作的类大部分继承于InputStream（输入字节流）类和OutputStream（输出字节流）类； 字符流是指16位的Unicode字符流，以字符（两个字节）为基本单位处理，非常适合处理字符串和文本，对于字符流进行操作的类大部分继承于Reader（读取流）类和Writer（写入流）类。 字节流可用于任何类型的对象，包括二进制对象，而字符流只能处理字符或者字符串。 分类 字节输入流 字节输出流 字符输入流 字符输出流 抽象基类 InputStream OutputStream Reader Writer 访问文件 FileInputStream FileOutputStream FileReader FileWriter 访问数组 ByteArrayInputStream ByteArrayOutputStream CharArrayReader CharArrayWriter 访问管道 PipedInputStream PipedOutputStream PipedReader PipedWriter 访问字符串 StringReader StringWriter 缓冲流 BufferedInputStream BufferedOutputStream BufferedReader BufferedWriter 转换流 InputStreamReader OutputStreamWriter 对象流 ObjectInputStream ObjectOutputStream 抽象基类 FilterInputStream FilterOutputStream FilterReader FilterWriter 打印流 PrintStream PrintWriter 推回输入流 PushbackInputStream PushbackReader 特殊流 DataInputStream DataOutputStream 注：表中粗体字所标出的类代表节点流，必须直接与指定的物理节点关联：斜体字标出的类代表抽象基类，无法直接创建实例。 字节流字节流——适于读写二进制文件.InputStream（字节输入流）和OutputStream（字节输出流）是字节流的两个顶层父类，提供了输入流类与输出流类的通用API。 InputStream InputStream是抽象类，所有字节输入流类都直接或间接继承此类。字节输入流类很多，使用较多有3个：FileInputStream、BufferedInputStream和DataInputStream (1)FileInputStream（字节文件输入流）：此类用于从本地文件中读取内容。(2)BufferedInputStream：此类本身带有一个缓冲区，在读取数据时，先放到缓冲区中，可以减少对数据源的访问，提高运行的效率。(3)DataInputStream：此类提供一些基于多字节读取方法，从而可以读取基本数据类型的数据，如，readDouble()、readInt() 在InputStream里面包含如下3个方法： int read(); 从输入流中读取单个字节（相当于从图15.5所示的水管中取出一滴水），返回所读取的字节数据（字节数据可直接转换为int类型）。 int read(byte[] b)从输入流中最多读取b.length个字节的数据，并将其存储在字节数组b中，返回实际读取的字节数。 int read(byte[] b,int off,int len); 从输入流中最多读取len个字节的数据，并将其存储在数组b中，放入数组b中时，并不是从数组起点开始，而是从off位置开始，返回实际读取的字节数。OutputStream OutputStream是抽象类，所有字节输出流类都直接或间接继承此类。字节输出流类很多，使用较多有3个：FileOutputStream、BufferedOutputStream和DataOutputStream (1)FileOutputStream（字节文件输出流）：此类用于向本地文件中写入数据。(2)BufferedOutputStream：此类本身带有一个缓冲区，在写取数据时，先放到缓冲区中，实现缓冲的数据流。(3)DataOutputStream(OutputStream out) ：创建一个新的数据输出流，将数据写入指定的基础输出流。提供如下三个方法: void write(int c); 将指定的字节/字符输出到输出流中，其中c即可以代表字节，也可以代表字符。 void write(byte[]/char[] buf); 将字节数组/字符数组中的数据输出到指定输出流中。 void write(byte[]/char[] buf, int off,int len ); 将字节数组/字符数组中从off位置开始，长度为len的字节/字符输出到输出流中。 字符流字符流——适于读写文本文件Reader和Writer是java.io包中的两个字符流类的顶层抽象父类，定义了在I/O流中读写字符数据的通用API。在Java中，字符采用是16位的Unicode字符编码。常见字符输入/输出流是由Reader和Writer抽象类派生出来的。处理数据时是以字符为基本单位的。 Reader字符输入流FileReader：用来读取字符文件的便捷类。BufferedReader类：是Reader类的子类，为Reader 对象添加字符缓冲器，为数据输入分配内存存储空间，存取数据更为有效。在Reader中包含如下3个方法： int read(); 从输入流中读取单个字符（相当于从图15.5所示的水管中取出一滴水），返回所读取的字符数据（字节数据可直接转换为int类型）。 int read(char[] b)从输入流中最多读取b.length个字符的数据，并将其存储在字节数组b中，返回实际读取的字符数。 int read(char[] b,int off,int len); 从输入流中最多读取len个字符的数据，并将其存储在数组b中，放入数组b中时，并不是从数组起点开始，而是从off位置开始，返回实际读取的字符数。 Writer字符输出流Writer写入字符类型字符输出流类很多，使用较多的有：FileWriter、BufferedWriter（1）FileWriter：用来写入字符文件的便捷类。FileWriter 用于写入字符流。要写入原始字节流。（2）BufferedWriter：将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。可以指定缓冲区的大小，或者接受默认的大小。在大多数情况下，默认值就足够大了。除非要求提示输出，否则建议用 BufferedWriter 包装所有其 write() 操作可能开销很高的 Writer。提供如下方法: void write(int c); 将指定的字节/字符输出到输出流中，其中c即可以代表字节，也可以代表字符。 void write(byte[]/char[] buf); 将字节数组/字符数组中的数据输出到指定输出流中。 void write(byte[]/char[] buf, int off,int len ); 将字节数组/字符数组中从off位置开始，长度为len的字节/字符输出到输出流中。 void write(String str); 将str字符串里包含的字符输出到指定输出流中。 void write (String str, int off, int len); 将str字符串里面从off位置开始，长度为len的字符输出到指定输出流中。 文件流FileInputStream读文件使用FileInputStream类 读文件FileInputStream类称为文件输入流，继承于InputStream类，是进行文件读操作的最基本类；它的作用是将文件中的数据输入到内存中，我们可以利用它来读文件；由于它属于字节流，因此在读取Unicode字符（如中文）的文件时可能会出现问题。 12345678910111213141516171819202122232425/*编写Java程序，使用FileInputStream读取文件“c:\\java123\\test.txt”的内容，并输出到控制台。一次读1个字节。*/package io流;import java.io.*;public class FileInputStreamDemo1 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub try &#123; File file=new File(&quot;C:/java123/test.txt&quot;);//创建文件对象 FileInputStream fis=new FileInputStream(file); //使用文件对象创建文件输入流对象，相对于打开文件 for(int i=0;i&lt;file.length();i++) &#123; char ch=(char)(fis.read()); //循环读取字符 System.out.println(ch); &#125; System.out.println(); fis.close();//关闭流 &#125;catch(FileNotFoundException e) &#123; System.out.println(&quot;文件打开失败&quot;); &#125;catch(IOException e1) &#123; e1.printStackTrace(); &#125; &#125;&#125; 手动创建C:/java123/test.txt文件，test.txt文件里内容为123； 1234567891011121314151617181920212223242526272829303132/*编写Java程序，使用FileInputStream读取文件“c:\\java123\\test.txt”的内容，并输出到控制台。读到的数据存放到byte型数组中*/package io流;import java.io.*;public class MyFile1 &#123; ///文件读取 FileInputStream read 方法 public static void main(String[] args) &#123; // TODO 自动生成的方法存根 try &#123; File wj=new File(&quot;c:/java123/abc.txt&quot;); //创建文件对象 FileInputStream f=new FileInputStream(wj); /*//单个字节的读取/* for(int i=0;i&lt;wj.length();i++) &#123; char ch=(char)f.read(); System.out.print(ch); &#125; */ // // //多个字节读取 字节数组 byte buy[]=new byte[(int)(wj.length())]; //根据文件字节长度创建字节数组 f.read(buy); //读取文件中的数据放入字节数组中 String str=new String(buy); //字节转换成字符 System.out.println(str); f.close(); // &#125;catch(FileNotFoundException fnfe) &#123; System.out.println(&quot;文件打开失败&quot;); &#125;catch(IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 写文件使用FileOutputStream类 写文件FileOutputStream类称为文件输出流，继承于OutputStream类，是进行文件写操作的最基本类；它的作用是将内存中的数据输出到文件中，我们可以利用它来写文件。 123456789101112131415161718192021/*编写Java程序，使用FileInputStream写文件“c:\\java123\\test.txt”。一次写一个字节。*/package io流;import java.io.*;public class FileOutputStreamDemo1 &#123; public static void main(String[] args) throws IOException&#123; // TODO Auto-generated method stub String str=&quot;Hello World!&quot;; File file=new File(&quot;C:/java123/test.txt&quot;);//创建文件对象 //通过文件对象创建文件输出流对象 //附加第二个参数true，指定进行文件追加，默认为不追加 FileOutputStream fos=new FileOutputStream(file,true); //将逐个字符写入文件中 for(int i=0;i&lt;str.length();i++)&#123; fos.write(str.charAt(i)); //charAt返回指定索引位置的char值 &#125; &#125;&#125; 123456789101112131415161718/*编写Java程序，使用FileInputStream写文件“c:\\java123\\test.txt”。一次写一个字节数组。*/package io流;import java.io.*;public class FileOutputStreamDemo2 &#123; //在函数内部不进行异常处理，将异常抛出函数外部 public static void main(String[] args) throws Exception &#123; // TODO Auto-generated method stub String str=&quot;I Love Java&quot;; //通过文件名创建文件输出流对象 FileOutputStream fos=new FileOutputStream(&quot;C:/java123/test.txt&quot;); byte buffer[]=str.getBytes(); //将字符串转换为字节数组 //将字节数组中包含的数据一次性写入到文件中 fos.write(buffer); fos.close(); &#125;&#125; 复制文件FileInputStream类和FileOutputStream类是成对出现的，一个进行输入（读文件）操作，一个进行输出（写文件）操作；由于采用字节方式进行数据传输，不必考虑数据的格式问题，这两个类对文件操作的效率较高；可以使用这两个类完成复制文件的操作。 123456789101112131415161718192021222324252627282930313233343536package io流;import java.io.*;//文件的复制public class MyFile7 &#123; public static void main(String[] args) throws IOException &#123; File f=new File(&quot;c:/java123/abc.txt&quot;); File destination =new File(&quot;c:/java123/abccopy.txt&quot;); try &#123; //1.创建文件 输入流从系统文件获取字节 FileInputStream fis=new FileInputStream(f); //2.创建文件输出流将数据写入系统文件 FileOutputStream fos=new FileOutputStream(destination); ///3.保存字节数g System.out.println(&quot;文件长度:&quot;+fis.available()); //返回文件的大小2 //4.输入流读取字节数，并保存到字节数组中 byte []buy=new byte[fis.available()]; //5.将字节数组写入目标文件中 fis.read(buy); fos.write(buy); System.out.println(&quot;成功复制文本&quot;); //6.最后关闭输入输出流，释放连接资源 fis.close(); fos.close(); &#125; catch (FileNotFoundException e) &#123; System.out.println(&quot;FileNotFoundException&quot;); e.printStackTrace(); &#125; catch (IOException e) &#123; System.out.println(&quot;IOException &quot;); e.printStackTrace(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package io流;//*****************图片的复制*****************import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;public class MyFile8 &#123; public static void main(String[] args) &#123; File f=new File(&quot;c:/java123/媒体文件夹/图片.jpg&quot;); File destination =new File(&quot;c:/java123/图片copy.jpg&quot;); try &#123; //1.创建文件 输入流从系统文件获取字节 FileInputStream fis=new FileInputStream(f); //2.创建文件输出流将数据写入系统文件 FileOutputStream fos=new FileOutputStream(destination); System.out.println(&quot;文件大小&quot;+fis.available()); ///3.保存字节数 byte[] b=new byte[fis.available()]; //4.输入流读取字节数，并保存到字节数组中 fis.read(b); //5.将字节数组写入目标文件中 fos.write(b); System.out.println(&quot;成功复制图片&quot;); //6.最后关闭输入输出流，释放连接资源 fis.close(); fos.close(); &#125; catch (FileNotFoundException e) &#123; System.out.println(&quot;FileNotFoundException&quot;); e.printStackTrace(); &#125; catch (IOException e) &#123; System.out.println(&quot;IOException &quot;); e.printStackTrace(); &#125; &#125;&#125;```````javapackage io流;//*****************歌曲的复制*****************import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;public class MyFile9 &#123; public static void main(String[] args) &#123; File f=new File(&quot;c:/java123/媒体文件夹/歌曲.mp3&quot;); File destination =new File(&quot;c:/java123/歌曲copy.mp3&quot;); try &#123; //1.创建文件 输入流从系统文件获取字节 FileInputStream fis=new FileInputStream(f); //2.创建文件输出流将数据写入系统文件 FileOutputStream fos=new FileOutputStream(destination); System.out.println(&quot;文件大小&quot;+fis.available()); ///3.保存字节数 byte[] b=new byte[fis.available()]; //4.输入流读取字节数，并保存到字节数组中 fis.read(b); //5.将字节数组写入目标文件中 fos.write(b); System.out.println(&quot;成功复制音频&quot;); //6.最后关闭输入输出流，释放连接资源 fis.close(); fos.close(); &#125; catch (FileNotFoundException e) &#123; System.out.println(&quot;FileNotFoundException&quot;); e.printStackTrace(); &#125; catch (IOException e) &#123; System.out.println(&quot;IOException &quot;); e.printStackTrace(); &#125; &#125;&#125; FileReader FileReader类称为文件读取流，允许以字符流的形式对文件进行读操作，其构造方法有3种重载方式，以下是常用的几种： 该类将从文件中逐个地读取字符，效率比较低下，因此一般将该类对象包装到缓冲流中进行操作。 BufferedReader 12345678910111213141516171819202122/**FileReader配合BufferedReader读文件“c:\\java123\\test.txt”。逐行读取数据，并在控制台显示。*/package io流;import java.io.*;public class MyFile10 &#123; //字符流读取 FileReader 中文 public static void main(String[] args)throws IOException &#123; // TODO 自动生成的方法存根 File f=new File(&quot;C:/java123/abc.txt&quot;); //通过文件对象创建文件读取流对象 FileReader fr=new FileReader(f); //将文件读取流包装成缓冲读取流 BufferedReader br=new BufferedReader(fr); String str; while((str=br.readLine())!=null) &#123; //逐行读取数据 System.out.println(str); &#125; br.close(); //关流要要反着关 fr.close(); &#125;&#125; FileWriter 与FileReader类相似，FileWriter类同样需要使用缓冲流进行包装。 BufferedWriter 123456789101112131415161718192021222324/*FileWriter配合BufferedWriter写文件“c:\\java123\\test3.txt”。逐行写数据。*/package io流;import java.io.*;public class WriterDemo &#123; public static void main(String[] args) throws IOException &#123; // TODO Auto-generated method stub File f=new File(&quot;C:/java123/test.txt&quot;); //通过文件对象创建文件输出字符流对象 FileWriter fw=new FileWriter(f); //将文件输出字符流包装成缓冲流 BufferedWriter bw=new BufferedWriter(fw); bw.write(&quot;大家好！&quot;); bw.write(&quot;我正在学习java&quot;); bw.newLine(); bw.write(&quot;请多多指教！&quot;); bw.newLine(); bw.write(&quot;Luckybug@21cn.com&quot;); bw.close(); fw.close(); &#125;&#125; 控制台输入控制台输入System.in实际上是一个InputStream类的对象；System.in 的read方法可以从控制台接受输入，它只能以字节形式接收数据，并且一次只能接受一个字节，这使输入操作很不便；必须将System.in进行处理，才可以顺利地从控制台接受输入，这将使用到:InputStreamReader类BufferedReader类. 12345678910111213141516171819202122package io流;import java.io.*;public class ConsoleInput &#123; public static void main(String[] args)throws IOException &#123; // TODO Auto-generated method stub //将System.in转化为字符流对象 InputStreamReader isr=new InputStreamReader(System.in); //用缓冲流包装 BufferedReader br=new BufferedReader(isr); System.out.println(&quot;请输入你的姓名:&quot;); String name=br.readLine();//接受输入 System.out.println(&quot;请输入你的年龄:&quot;); int age=Integer.parseInt(br.readLine());//接受输入 System.out.println(&quot;你的姓名:&quot;+name); System.out.println(&quot;你的年龄:&quot;+name); br.close(); isr.close(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536package io流; /* 通过控制台输入内容写入文件**/import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.util.Scanner; //写入文件public class MyFile6 &#123; public static void main(String[] args) throws IOException &#123; Scanner sca=new Scanner(System.in); //写文件 System.out.print(&quot;请输入文件名：&quot;); String name=sca.next(); File file=new File(name+&quot;.txt&quot;);//文件名 相对路径（项目名根目录下）// FileOutputStream fs=new FileOutputStream(file); //如果文件存在 覆盖 FileOutputStream fos=new FileOutputStream(file,true);//true表示追加，如果文件存在 向里面继续添加内容 System.out.println(&quot;请输入写入的内容:&quot;); String str=sca.next(); byte bytes[]=str.getBytes(); //FileOutputStream 是基于字节流 把要写入的信息 保存到字节数组中 fos.write(bytes,0,bytes.length);//将字节数组中全部内容写到文件中 从0—数组的长度 fos.close();//关闭流 System.out.println(&quot;文件写入成功！&quot;); //读文件 FileInputStream fis=new FileInputStream(file); byte bt[]=new byte[1024];//1KB 每次最多读取的1KB 根据文件大小而定 int temp=0; while((temp=fis.read(bt))!=-1)&#123; //将数据保存到数组（缓冲区）中 并返回读取的字节数 -1表示读完了 System.out.println(new String(bt,0,temp));//输出数组中保存内容 按照每次读取的字节数 &#125; fis.close(); &#125;&#125;","path":"page/java14.html","date":"01-05","excerpt":"","tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://xiaoliblog.cn/tags/JavaSE/"}]},{"title":"Java👉Swing组件","text":"Swing程序设计实际开发中使用WindowBuilder插件进行图形界面设计，更加方便快捷。WindowBuilder插件下载WindowBuilder插件安装WindowBuilder插件使用GUI(图形用户界面)为程序提供图形界面，Swing是AWT组件的增强组件，被称为“轻量级组件”，完全由java语言编写，可以在任何平台上运行，相反，依赖于本地平台的组件被称为“重量级组件”，如AWT。Swng包的层次结构和继承关系： 常用Swing组件 常用窗体JFrame窗体是一个容器，是各个组件的载体，可以通过继承java.swing.JFrame类创建一个窗口，在窗口中添加组件。 12345678910//构造方法public JFrame();public JFrame(String title);//语法格式JFrame f=new JFrame(title); //f为JFrame类的对象Container c=f.getContentPane(); //c为Container类的对象，可以使用JFrame对象调用getContentPane()方法获取。//调用getContentPane()方法将窗体转为容器，然后在容器里添加组件。c.add(new JButton(&quot;按钮&quot;));//remove()方法将组件从容器里删除c.remove(new JButton(&quot;按钮&quot;)); 继承JFrame实现: 1234567891011121314151617181920212223package Blog_02; import java.awt.*; //导入awt包import javax.swing.*; //导入swing包public class blog_02_05 extends JFrame&#123; //定义一个类继承JFrame public void CreateJFrame(String title) &#123; //定义一个方法创建JFrame JFrame f=new JFrame(title); //实例化一个JFrame对象，并设置窗口名 Container c=f.getContentPane(); //获取容器 JLabel l1=new JLabel(&quot;这是一个JFrame窗体&quot;); //标签 //使标签上的文字居中 l1.setHorizontalAlignment(SwingConstants.CENTER); c.add(l1); c.setBackground(Color.white); f.setVisible(true); f.setSize(400,250); //setSize(int x,int y) //设置窗体关闭方式 f.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); //设置窗口相对于指定组件的位置。 如果组件当前未显示或者 c 为 null，则此窗口将置于屏幕的中央。 f.setLocationRelativeTo(null); &#125; public static void main(String[] args) &#123; new blog_02_05().CreateJFrame(&quot;创建一个JFrame窗体&quot;); &#125;&#125; 关于窗口关闭方式:1.DO_NOTHING_ON_CLOSE：什么都不做就将窗口关闭。2.DISPOSE_ON_CLOSE：代表任何注册监听程序对象后会自动隐藏并释放窗体。3.HIDE_ON_CLOSE：表示隐藏窗口的默认窗口关闭。4.EXIT_ON_CLOSE：退出应用程序默认窗口关闭。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/*1.导入包:import java.awt.*;import javax.swing;2.定义类，声明组件。3.构造方法中new所有组件。4.主方法main()中，new 构造方法。5,JFrame为容器，JPanel为面板，组件加到面板，面板再加到容器上。*/package Blog_02;import java.awt.*;import javax.swing.*;/* * 三个JPanel分别对应三行，即用户名、密码、按钮三行，任何网格布局3行1列布局 * */public class blog_02_06 &#123; JFrame f; JLabel l1,l2; JPanel p1,p2,p3; JButton b1,b2; JTextField t; JPasswordField pw; public blog_02_06() &#123; f=new JFrame(&quot;用户登录界面&quot;); l1=new JLabel(&quot;用户名&quot;); l2=new JLabel(&quot;密 码&quot;); b1=new JButton(&quot;登录&quot;); b2=new JButton(&quot;注册&quot;); t=new JTextField(10); pw=new JPasswordField(10); p1=new JPanel(); p2=new JPanel(); p3=new JPanel(); //设置按键文本颜色 b1.setForeground(Color.BLUE); b2.setForeground(Color.red); b1.setBackground(Color.gray); b2.setBackground(Color.black); //第一行 p1.add(l1); p1.add(t); p1.setLayout(new FlowLayout()); //第二行 p2.add(l2); p2.add(pw); p2.setLayout(new FlowLayout()); //第三行 p3.add(b1); p3.add(b2); p3.setLayout(new FlowLayout()); //加到容器 f.add(p1); f.add(p2); f.add(p3); f.setLayout(new GridLayout(3,1));//设置网格布局 f.setSize(230,150); f.setLocationRelativeTo(null); f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); f.setResizable(false);//窗口大小是否可变 f.setVisible(true); &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub new blog_02_06(); &#125;&#125; JDialog窗体是Swing组件中的对话框，它继承了AWT组件中的java.awt.Dialog类。JDialog窗体的功能是从一个窗体中弹出另一个窗体。 123456&#x2F;&#x2F;构造方法public JDialog(); &#x2F;&#x2F;没有标题和父窗口的对话框public JDialog(Frame f); &#x2F;&#x2F;创建一个指定父窗口的对话框public JDialog(Frame f,boolean model); &#x2F;&#x2F;创建一个指定类型的对话框，并指定父窗口public JDialog(Frame f,String title); &#x2F;&#x2F;指定标题和父窗口public JDialog(Frame f,String title,boolean model); &#x2F;&#x2F;指定标题、窗体、模式的对话框。 1234567891011121314151617181920212223242526272829303132333435363738394041package Blog_02;import java.awt.*;import java.awt.event.*;import javax.swing.*;class MyJDialog extends JDialog&#123; public MyJDialog(MyFrame frame) &#123; //实例化一个JDialog类对象，指定对话框的父窗体、标题和类型 super(frame,&quot;第一个JDialog窗体&quot;,true); Container c=getContentPane(); //创建一个容器 c.add(new JLabel(&quot;这是一个对话框&quot;)); setBounds(120,120,100,100); //设置对话框大小 setLocationRelativeTo(null); //居中 &#125;&#125;public class MyFrame extends JFrame &#123; public MyFrame() &#123; Container c=getContentPane(); //创建容器 c.setLayout(null); JLabel l1=new JLabel(&quot;这是一个JFrame窗体&quot;); //标签居中 l1.setHorizontalAlignment(SwingConstants.CENTER); c.add(l1); JButton b=new JButton(&quot;弹出对话框&quot;); b.setBounds(10,10,100,21); b.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent e) &#123; new MyJDialog(MyFrame.this).setVisible(true); &#125; &#125;); c.add(b); setSize(200,200); setVisible(true); setLocationRelativeTo(null); &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub new MyFrame(); &#125;&#125; 组件的使用JLabel标签标签由JLabel类定义，它的父类为JComponent类。 123456//构造方法public JLabel();public JLabel(Icon icon);public JLabel(Icon icon,int aligment);public JLabel(String text,int aligment);public JLabel(String text,Icon icon,int aligment); //带文本，带图标的JLabel对象，并设置标签内容的水平对齐方式。 图标的使用Swing中图标可以放置在按钮、标签等组件上。``javaImageIcon img=new ImageIcon(“图片URL”);JButton b=new JButton(img); 123456### 文本组件​&#96;&#96;&#96;javaJTextField t&#x3D;new JTextField(10); &#x2F;&#x2F;长度JTextArea a&#x3D;new JTextArea(5,5);&#x2F;&#x2F;5行5列JPasswordField &#x3D;p&#x3D;new JPasswordField();p.setEchoChar(&quot;%&quot;);&#x2F;&#x2F;设置输入密码显示的字符 按钮组件123456789101112131415JFrame f=new JFrame();JPanel p=new JPanel();//1.创建按钮组对象；ButtonGroup bg=new ButtonGroup();//2.创建若干单选按钮对象JRadioButton b1=new JRadoButton(&quot;男&quot;);JRadioButton b1=new JRadoButton(&quot;女&quot;);//3.将单选按钮加到按钮组中bg.add(b1);bg.add(b2);//4.将单选按钮加到容器中。p.add(b1);p.add(b2);f.add(p); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package Windos;import java.awt.*;import javax.swing.*;public class 单选和复选按钮 &#123; JFrame f; JLabel l,l1; JButton b1,b2; JPanel p1,p2,p3; JCheckBox fx1,fx2,fx3; //复选按钮 JRadioButton dx1,dx2; //单选按钮 ButtonGroup bg;//把单选按钮放进一个组里,默认功能是组里的按钮只能选一个 public 单选和复选按钮() &#123; f=new JFrame(); p1=new JPanel(); p2=new JPanel(); p3=new JPanel(); l=new JLabel(&quot;特长&quot;); l1=new JLabel(&quot;性别&quot;); b1=new JButton(&quot;注册&quot;); b2=new JButton(&quot;取消&quot;); fx1=new JCheckBox(&quot;音乐&quot;); fx2=new JCheckBox(&quot;体育&quot;); fx3=new JCheckBox(&quot;文艺&quot;); dx1=new JRadioButton(&quot;男&quot;); dx2=new JRadioButton(&quot;女&quot;); //按钮组 只能选一个勾选 必须填 bg=new ButtonGroup(); bg.add(dx1); bg.add(dx2); // p1.add(l); p1.add(fx1); p1.add(fx2); p1.add(fx3); p2.add(l1); //还是一个一个加不能添加组 p2.add(dx1); p2.add(dx2); p3.add(b1); p3.add(b2); f.add(p1); f.add(p2); f.add(p3); //其余三个面板为流式布局 f.setLayout(new GridLayout(3,1)); //网格布局 f.setSize(240,150); f.setLocation(300,280); f.setResizable(false); f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); f.setLocationRelativeTo(null); f.setVisible(true); &#125; public static void main(String[] args) &#123; // TODO 自动生成的方法存根 new 单选和复选按钮(); &#125;&#125; 下拉框、下拉列表列表和滚动条12345678910111213//下拉框/*getSelectedItem()的方法得到选择的值和一个getSelectedIndex()得到选择值的索引*/String str[]=&#123;&quot;北京&quot;,&quot;天津&quot;,&quot;上海&quot;,&quot;长沙&quot;&#125;;JComboBox xlk=new JComboBox(str);//列表JPanel p=new JPanel();String xl[]= &#123;&quot;高中&quot;,&quot;大专&quot;,&quot;本科&quot;,&quot;硕士&quot;,&quot;博士&quot;&#125;;JList lb=new JList(xl);lb.setVisibleRowCount(3);//使其滚动 3表示默认显示几个JScrollPane gd=new JScrollPane(lb); //列表加入滚动p.add(xlk);p.add(gd); //面板是添加滚动条。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package Windos;import java.awt.*;import javax.swing.*;/*下拉 * JComboBox 创建字符组 * * 滚动条 * JList 创建字符串组放进去 调用 setVisibleRowCount(3) * JScrollPane 放JList * 添加滚动 * * */public class 下拉列表和滚动条 &#123; JFrame f; JPanel p1,p2; JLabel l1,l2; JComboBox xlk; //下拉框 /*getSelectedItem()的方法得到选择的值和一个getSelectedIndex()得到选择值的索引*/ JList lb; //列表 JScrollPane gd; //滚动条 public 下拉列表和滚动条() &#123; f=new JFrame(); p1=new JPanel(); p2=new JPanel(); l1=new JLabel(&quot;籍贯&quot;); l2=new JLabel(&quot;学历&quot;); String jg[]= &#123;&quot;北京&quot;,&quot;天津&quot;,&quot;长沙&quot;,&quot;湖南&quot;,&quot;安化&quot;,&quot;梅城&quot;&#125;; xlk=new JComboBox(jg); String xl[]= &#123;&quot;高中&quot;,&quot;大专&quot;,&quot;本科&quot;,&quot;硕士&quot;,&quot;博士&quot;&#125;; lb=new JList(xl); lb.setVisibleRowCount(3);//使其滚动 3表示默认显示几个 gd=new JScrollPane(lb); //列表加入滚动 f.setLayout(new GridLayout(2,1)); p1.add(l1); p1.add(xlk); p2.add(l2); p2.add(gd);//添加滚动条 f.add(p1); f.add(p2); f.setTitle(&quot;用户调查&quot;); f.setSize(200,190); f.setLocation(300,200); f.setResizable(false); f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); f.setVisible(true); &#125; public static void main(String[] args) &#123; // TODO 自动生成的方法存根 new 下拉列表和滚动条(); &#125;&#125; 拆分窗口12345678910111213141516171819202122232425262728293031323334353637383940package Windos;import java.awt.*;import javax.swing.*;//图片 Ctrl+C 复制 工程文件右击粘贴 可新建一个文件夹放图片public class 拆分窗口 &#123; JFrame f; JSplitPane cf; //拆分成左右两个界面 JList lb; JLabel l; String str[]= &#123;&quot;软件开发&quot;,&quot;游戏开发&quot;,&quot;平面设计&quot;,&quot;动画制作&quot;,&quot;室内设计&quot;&#125;; public 拆分窗口() &#123; f=new JFrame(); lb=new JList(str); l=new JLabel(new ImageIcon(&quot;Image/雪花.jpg&quot;)); //放java工程路径 cf=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,lb,l);//左右拆分 // cf=new JSplitPane(JSplitPane.VERTICAL_SPLIT,lb,l);//上下拆分 cf.setOneTouchExpandable(true); //出现两个拉动箭头 可以覆盖或收缩掉一界面 f.add(cf); f.setSize(640,480); f.setLocation(300,280); f.setResizable(false); f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); f.setVisible(true); &#125; public static void main(String[] args) &#123; // TODO 自动生成的方法存根 new 拆分窗口(); &#125;&#125; 布局管理绝对布局绝对布局指硬性指定组件在容器中的位置和大小，可以使用绝对坐标的方式来指定组件的位置。 123456789101112131415161718192021222324252627282930/*使用步骤:1.使用Container.setLayout(null)方法取消布局管理器。2.使用Container.setBounds()方法设置每个组件的大小与位置。*/package Blog_02;import java.awt.*;import javax.swing.*;public class blog_02_07 extends JFrame&#123; public blog_02_07() &#123; setTitle(&quot;绝对布局&quot;); setLayout(null); setBounds(0,0,200,150); Container c=getContentPane(); JButton b1=new JButton(&quot;按钮1&quot;); JButton b2=new JButton(&quot;按钮2&quot;); b1.setBounds(10,30,80,30); b2.setBounds(60,70,100,20); c.add(b1); c.add(b2); setVisible(true); &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub new blog_02_07(); &#125;&#125; 流动布局流动布局指组件像“流”一样从左到右摆放组件。 1234567891011121314151617181920212223242526272829303132333435363738394041package Windos;import java.awt.*;import javax.swing.*;public class FlowLayout_1 &#123; JFrame f; JButton b[]; //按钮数组 String str[]= &#123;&quot;话梅&quot;,&quot;果脯&quot;,&quot;薯片&quot;,&quot;饼干&quot;,&quot;巧克力&quot;,&quot;腰果&quot;,&quot;锅巴&quot;,&quot;开心果&quot;&#125;; //字符串数组 public FlowLayout_1() &#123; f=new JFrame(&quot;流动窗口&quot;); b=new JButton[str.length]; //等价于 JButton b[]=new JButton[str.length] 相当于创建按键数组 for(int i=0;i&lt;str.length;i++) &#123; b[i]=new JButton(str[i]); //一个一个new &#125; //网格布局方式 java默认边界布局管理 f.setLayout(new FlowLayout()); //f.setLayout(new FlowLayout(FlowLayout.LEFT));//向左对齐 //f.setLayout(new FlowLayout(FlowLayout.RIGHT));//向右看齐 for(int i=0;i&lt;str.length;i++) &#123; f.add(b[i]); &#125; f.setSize(300,150); f.setLocation(200,200); f.setResizable(false);//不能最大化 拖动 f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); f.setVisible(true); &#125; public static void main(String[] args) &#123; // TODO 自动生成的方法存根 new FlowLayout_1(); &#125;&#125; 边界布局边界布局将容器划分东、南、西、北、中五个区域。 1234567891011121314151617181920212223242526272829303132333435package Windos;import java.awt.*;import javax.swing.*;public class BorderLayout_1 &#123; JFrame f; JButton b,b1,b2,b3,b4; public BorderLayout_1() &#123; f=new JFrame(&quot;边界布局&quot;); b=new JButton(&quot;东方&quot;); b1=new JButton(&quot;西方&quot;); b2=new JButton(&quot;南方&quot;); b3=new JButton(&quot;北方&quot;); b4=new JButton(&quot;中方&quot;); //边界布局方式 f.add(b,BorderLayout.EAST); f.add(b1,BorderLayout.WEST); f.add(b2,BorderLayout.SOUTH); f.add(b3,BorderLayout.NORTH); f.add(b4,BorderLayout.CENTER); //如果不是5个按钮，则会以扩充中部去填补 //使任务管理器中窗口也关闭 ，不占内存 很重要！！！！！ f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//使运行后的窗口不占内存 起关闭作用 /// f.setSize(300,400); f.setLocation(200,200); f.setVisible(true); &#125; public static void main(String[] args) &#123; // TODO 自动生成的方法存根 new BorderLayout_1(); &#125;&#125; 网格布局网格布局将容器划分为网格，所有组件按行和列排列。 123456789101112131415161718192021222324252627282930313233343536package Windos;import java.awt.*;import javax.swing.*;public class GridLayout_1 &#123; JFrame f; JButton b[]; String str[]= &#123;&quot;话梅&quot;,&quot;果脯&quot;,&quot;薯片&quot;,&quot;饼干&quot;,&quot;巧克力&quot;,&quot;腰果&quot;,&quot;锅巴&quot;,&quot;开心果&quot;,&quot;蛋糕&quot;&#125;; //字符串数组 public GridLayout_1() &#123; f=new JFrame(&quot;网格布局&quot;); b=new JButton[str.length]; //等价于JButton b[]=new JButton[大小] 创建数组 for(int i=0;i&lt;str.length;i++) &#123; b[i]=new JButton(str[i]); //一个一个添加 &#125; //网格布局格式 f.setLayout(new GridLayout(3,3,12,13)); //(行，列，长高的像素空间) for(int i=0;i&lt;str.length;i++) &#123; f.add(b[i]); &#125; f.setSize(380,320); f.setLocation(200,200); f.setResizable(false);//不能最大化 不能拉伸窗口 使其固定 f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); f.setVisible(true); &#125; public static void main(String []args) &#123; new GridLayout_1(); &#125;&#125; 盒式布局BoxLayout 可以把控件依次进行水平或者垂直排列布局。createHorizontalBox()：返回一个 Box 对象，它采用水平 BoxLayout，即 BoxLayout 沿着水平方向放置组件，让组件在容器内从左到右排列。createVerticalBox()：返回一个 Box 对象，它采用垂直 BoxLayout，即 BoxLayout 沿着垂直方向放置组件，让组件在容器内从上到下进行排列。Box 布局时，可以使用空隙类来调整和控制组件之间的间隔，使组件布局达到要求。空隙类的对象是一种占用空间但不可见的组件。空隙类的对象有两种：支撑组件（Struct）：用于调整组件间的有指定长度的间距1.createVerticalStrut(int height) 2.createHorizontalStrut(int width)胶水组件（Glue）：用于调整组件间的无指定长度的间距1.createHorizontalGlue() 2.createVerticalGlue() 1234567891011121314151617181920212223242526272829303132333435//垂直盒子/水平盒子package Swing_Layout;import javax.swing.*;public class BoxLayout_1 &#123; JFrame f; JButton b1,b2,b3; Box box; public BoxLayout_1() &#123; f=new JFrame(&quot;盒式布局&quot;); b1=new JButton(&quot;按钮1&quot;); b2=new JButton(&quot;按钮2&quot;); b3=new JButton(&quot;按钮3&quot;); box=Box.createVerticalBox();//垂直盒子 // box=Box.createHorizontalBox()//水平盒子 box.add(b1); box.add(Box.createGlue()); // box.add(Box.createVerticalStrut(10)); box.add(b2); box.add(Box.createGlue()); box.add(b3); f.add(box); //f.pack(); f.setSize(300,400); f.setLocationRelativeTo(null); f.setVisible(true); &#125; public static void main(String[] args) &#123; // TODO 自动生成的方法存根 new BoxLayout_1(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132//改变间隔package Swing_Layout;import javax.swing.*;public class BoxLayout_3 &#123; JFrame f; JButton b; Box box; String name[]= &#123;&quot;按钮1&quot;,&quot;按钮2&quot;,&quot;按钮3&quot;&#125;; public BoxLayout_3() &#123; f=new JFrame(); box=Box.createVerticalBox(); for(int i=0;i&lt;name.length;i++) &#123; b=new JButton(name[i]); if(i==1) box.add(Box.createVerticalStrut(10)); if(i==2) box.add(Box.createVerticalStrut(20)); box.add(b); &#125; f.add(box); f.setSize(300,400); f.setLocationRelativeTo(null); f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); f.setVisible(true); &#125; public static void main(String[] args) &#123; // TODO 自动生成的方法存根 new BoxLayout_3(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package Swing_Layout;import java.awt.BorderLayout;import javax.swing.*;public class BoxLayout_2 &#123; JFrame f; JTextField t; JTextArea jt; JLabel l1,l2; JButton b; JScrollPane gd; Box H1,H2,V1; //水平 水平 垂直 public BoxLayout_2() &#123; f=new JFrame(); //主题 l1=new JLabel(&quot;主题:&quot;); t=new JTextField(10); H1=Box.createHorizontalBox();//水平盒子 H1.add(Box.createHorizontalStrut(5));//离布局间距 H1.add(l1); H1.add(Box.createHorizontalStrut(5));//水平间距 H1.add(t); //setAlignmentX()用于使用了BoxLayout.Y_AXIS时，将控件在X轴方向设置为左对齐、右对齐或居中对 //setAlignmentY()将控件在Y轴方向设置为顶对齐、底对齐或居中对齐 //内容 l2=new JLabel(&quot;内容:&quot;); jt=new JTextArea(); gd=new JScrollPane(jt); H2=Box.createHorizontalBox();//水平 H2.setAlignmentX(1); //设置靠右对齐 X水平轴 H2.add(Box.createHorizontalStrut(5));//边界间距 l2.setAlignmentY(0);//设置标签垂直靠上对齐 H2.add(l2); H2.add(Box.createHorizontalStrut(5));//间距 gd.setAlignmentY(0); //文本域垂直靠上 H2.add(gd); // //垂直 //H2和按键垂直 V1=Box.createVerticalBox(); V1.add(Box.createVerticalStrut(5));//和H1间距 V1.add(H2); //确定 jt.setLineWrap(true); gd.setViewportView(jt); V1.add(Box.createVerticalStrut(5)); b=new JButton(&quot;确定&quot;); b.setAlignmentX(1); //水平靠右 V1.add(b); f.add(H1,BorderLayout.NORTH);//主题 f.add(V1,BorderLayout.CENTER);//垂直加中间 f.setSize(400,500); f.setLocationRelativeTo(null); f.setVisible(true); &#125; public static void main(String[] args) &#123; // TODO 自动生成的方法存根 new BoxLayout_2(); &#125;&#125; 卡片布局卡片布局可以通过点击窗口中的按钮切换不同的面板。像卡片一样叠加，一张接着一张的显示 CardLayout成员方法:JPanel cp=new JPanel();CardLayout c=new CardLayout();c.first(cp):显示第一个卡片c.last(cp)：显示最后一个卡片c.next(cp)：显示当前所显示卡片之后的卡片c.previous(cp)：显示当前所显示卡片之前的卡片c.show(cp,String name)：显示指定标签的卡片 卡片布局使用步骤:1.创建CardLayout布局对象CardLayout l = new CardLayout();2.创建容器对象JPanel panel = new JPanel();3.设置容器对象的布局或使用默认布局panel.setLayout(l);4.向容器中添加组件对象(设组件对象已创建)panel.add(组件对象，“名称”);5.显示组件l.show(panel, “名称”);l.first(panel); l.last(panel);l.next(panel);l.previous(panel); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156package Swing_Layout;import javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class CardLayout_1 &#123; JFrame f; //卡片布局面板 JPanel cp; CardLayout c; JLabel l; //控制面板 JPanel bp; //按键面板 JButton b; public CardLayout_1() &#123; f=new JFrame(); //卡片布局设置 cp=new JPanel(); c=new CardLayout(); cp.setLayout(c); f.add(cp,BorderLayout.CENTER); //标签 String lname[]= &#123;&quot;卡片A&quot;,&quot;卡片B&quot;,&quot;卡片C&quot;&#125;; for(int i=0;i&lt;lname.length;i++) &#123; l=new JLabel(lname[i]); l.setHorizontalAlignment(SwingConstants.CENTER); l.setFont(new Font(&quot;楷书&quot;,Font.BOLD,16)); l.setForeground(new Color(255,0,0)); //像采用卡片布局的面板中加卡片 cp.add(l,lname[i]); &#125; bp=new JPanel(); f.add(bp,BorderLayout.SOUTH); String bname[]= &#123;&quot;第一个&quot;,&quot;前一个&quot;,&quot;卡片A&quot;,&quot;卡片B&quot;,&quot;卡片C&quot;,&quot;后一个&quot;,&quot;最后一个&quot;&#125;; for(int i=0;i&lt;bname.length;i++) &#123; JButton b=new JButton(bname[i]); bp.add(b); b.addActionListener(new ActionListener()&#123; @Override public void actionPerformed(ActionEvent e) &#123; // TODO 自动生成的方法存根 String event=b.getText(); if(event.equals(&quot;第一个&quot;)) &#123; c.first(cp); &#125;else if(event.equals(&quot;前一个&quot;)) &#123; c.previous(cp); &#125;else if(event.equals(&quot;卡片A&quot;)) &#123; c.show(cp,&quot;卡片A&quot;); &#125;else if(event.equals(&quot;卡片B&quot;)) &#123; c.show(cp,&quot;卡片B&quot;); &#125;else if(event.equals(&quot;卡片C&quot;)) &#123; c.show(cp,&quot;卡片C&quot;); &#125;else if(event.equals(&quot;后一个&quot;)) &#123; c.next(cp); &#125;else if(event.equals(&quot;最后一个&quot;)) &#123; c.last(cp); &#125; &#125;&#125;); &#125; f.pack(); f.setLocationRelativeTo(null); f.setVisible(true); &#125; public static void main(String[] args) &#123; // TODO 自动生成的方法存根 new CardLayout_1(); &#125;&#125;​```java//利用卡片布局实训相册![](https://cdn.jsdelivr.net/gh/lzyblog/image@main/2020/11/25/e348f8e551bc264d616c873b59e80976.png)​```javapackage Swing_Layout;import javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class CardLayout_2 &#123; JFrame f; JLabel l; JPanel cp,p; CardLayout c; ImageIcon img; String imgname[]= &#123;&quot;Image/1.jpg&quot;,&quot;Image/2.jpg&quot;,&quot;Image/3.jpg&quot;,&quot;Image/4.jpg&quot;&#125;; String bname[]= &#123;&quot;第一个&quot;,&quot;前一个&quot;,&quot;图片A&quot;,&quot;图片B&quot;,&quot;图片C&quot;,&quot;图片D&quot;,&quot;后一个&quot;,&quot;最后一个&quot;&#125;; String imgname2[]= &#123;&quot;图片A&quot;,&quot;图片B&quot;,&quot;图片C&quot;,&quot;图片D&quot;&#125;; public CardLayout_2() &#123; f=new JFrame(); cp=new JPanel(); c=new CardLayout(); cp.setLayout(c); f.add(cp); for(int i=0;i&lt;imgname.length;i++) &#123; img=new ImageIcon(imgname[i]);//创建图片 l=new JLabel(img);//创建标签 //像采用卡片布局的面板中加卡片 //并为卡片设置名字 cp.add(l,imgname2[i]); &#125; p=new JPanel(); f.add(p,BorderLayout.SOUTH); for(int i=0;i&lt;bname.length;i++) &#123; JButton b=new JButton(bname[i]);//防止局部变量 p.add(b); b.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; // TODO 自动生成的方法存根 String event=b.getText();//按键值 if(event.equals(&quot;第一个&quot;))&#123; c.first(cp); &#125;if(event.equals(&quot;前一个&quot;)) &#123; c.previous(cp); &#125;if(event.equals(&quot;图片A&quot;)) &#123; c.show(cp,&quot;图片A&quot;); &#125;if(event.equals(&quot;图片B&quot;)) &#123; c.show(cp, &quot;图片B&quot;); &#125;if(event.equals(&quot;图片C&quot;)) &#123; c.show(cp, &quot;图片C&quot;); &#125;if(event.equals(&quot;图片D&quot;)) &#123; c.show(cp, &quot;图片D&quot;); &#125;if(event.equals(&quot;后一个&quot;)) &#123; c.next(cp); &#125;if(event.equals(&quot;最后一个&quot;)) &#123; c.last(cp); &#125; &#125; &#125;); &#125; f.pack(); f.setLocationRelativeTo(null); f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); f.setVisible(true); &#125; public static void main(String[] args) &#123; // TODO 自动生成的方法存根 new CardLayout_2(); &#125;&#125; Swing高级JTable表格1234567891011121314一.创建表格控件的各种方式:(1) 调用无参构造函数.JTable table = new JTable();(2) 以表头和表数据创建表格.String columnNames[]= &#123;&quot;姓名&quot;,&quot;性别&quot;,&quot;年龄&quot;,&quot;政治面貌&quot;&#125;;Object data[][]= &#123;&#123;&quot;陈峰&quot;,&quot;男&quot;,new Integer(19),&quot;党员&quot;&#125;, &#123;&quot;田一飞&quot;,&quot;男&quot;,new Integer(18),&quot;团员&quot;&#125;, &#123;&quot;胡锦&quot;,&quot;女&quot;,new Integer(19),&quot;党员&quot;&#125;&#125;;JTable table = new JTable(data, columnNames);JTableHeader tablerHeader=table.getTableHeader(); //获取表格列名.(3)利用表格模型创建表格DefaultTableModel tableModel=new DefaultTableMode();//创建表格模型JTable table=new JTabel(tableModel); //创建表格table.setRowSorter(new TableRowSorter(tableModel)); //设置排序器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145package Swing_list;import java.awt.BorderLayout;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import java.awt.*;import javax.swing.*;import javax.swing.table.DefaultTableModel;import javax.swing.table.TableRowSorter;public class 默认方法创建 &#123; JFrame f; JTable table; JLabel l1,l2,l3,l4,l5; JButton b1,b2,b3; JTextField t1,t2,t3,t4; JPanel p; JScrollPane gd; DefaultTableModel tableModel; String Listname[]= &#123;&quot;学号&quot;,&quot;姓名&quot;,&quot;年龄&quot;,&quot;专业&quot;&#125;; Object[][] date= &#123;&#123;&quot;20172001&quot;,&quot;张三&quot;,new Integer(18),&quot;软件工程&quot;&#125;, &#123;&quot;20172002&quot;,&quot;李四&quot;,new Integer(19),&quot;软件工程&quot;&#125;, &#123;&quot;20172003&quot;,&quot;王五&quot;,new Integer(19),&quot;软件工程&quot;&#125;, &#123;&quot;20172004&quot;,&quot;赵六&quot;,new Integer(18),&quot;软件工程&quot;&#125;&#125;; public 默认方法创建() &#123; f=new JFrame(&quot;表格&quot;); tableModel=new DefaultTableModel(date,Listname);//创建表格模型 table=new JTable(tableModel);//创建表格 gd=new JScrollPane(table);//创建滚动面板 table.setRowHeight(30); //设置表格排序器 table.setRowSorter(new TableRowSorter(tableModel)); //设置表格的选择模式为单选 table.setSelectionMode(ListSelectionModel.SINGLE_INTERVAL_SELECTION); //为表格添加鼠标事件监听器 //点击表格 修改框反应 table.addMouseListener(new MouseAdapter() &#123; //发生了单击事件 public void mouseClicked(MouseEvent e) &#123; //获得被选中行的索引 int selectedRow=table.getSelectedRow(); //行数 //从表格模型中获得指定单元格的值 //行数固定 改变列数来获取 Object a=tableModel.getValueAt(selectedRow, 0);//行 列 Object b=tableModel.getValueAt(selectedRow, 1); Object c=tableModel.getValueAt(selectedRow, 2); Object d=tableModel.getValueAt(selectedRow, 3); t1.setText(a.toString()); //将值赋给文本框 t2.setText(b.toString()); t3.setText(c.toString()); t4.setText(d.toString()); &#125; &#125;); p=new JPanel(); l1=new JLabel(&quot;学号&quot;,JLabel.CENTER); l2=new JLabel(&quot;姓名&quot;,JLabel.CENTER); l3=new JLabel(&quot;年龄&quot;,JLabel.CENTER); l4=new JLabel(&quot;专业&quot;,JLabel.CENTER); l5=new JLabel(&quot;修改表格&quot;,JLabel.CENTER); t1=new JTextField(10); t2=new JTextField(10); t3=new JTextField(10); t4=new JTextField(10); b1=new JButton(&quot;添加&quot;); b1.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; // TODO 自动生成的方法存根 //创建表格行数组 String contents[]= &#123;t1.getText(),t2.getText(),t3.getText(),t4.getText()&#125;; tableModel.addRow(contents);//向表格模型中加一行 l5.setText(&quot;添加成功&quot;); l5.setForeground(Color.BLUE); &#125; &#125;); b2=new JButton(&quot;修改&quot;); b2.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; // TODO 自动生成的方法存根 int selectedRow=table.getSelectedRow();//获得被选中行的索引 if(selectedRow!=-1) &#123;//判断是否被选中 //修改表格模型中的指定值 tableModel.setValueAt(t1.getText(), selectedRow, 0); tableModel.setValueAt(t2.getText(),selectedRow, 0); tableModel.setValueAt(t3.getText(),selectedRow, 0); tableModel.setValueAt(t4.getText(),selectedRow, 0); l5.setText(&quot;修改成功&quot;); l5.setForeground(Color.darkGray); &#125; &#125; &#125;); b3=new JButton(&quot;删除&quot;); b3.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; // TODO 自动生成的方法存根 int selectedRow=table.getSelectedRow();//获得被选中的索引 if(selectedRow!=-1) &#123;//判断是否被选中 //从表格中删除指定行 tableModel.removeRow(selectedRow); l5.setText(&quot;删除成功&quot;); l5.setForeground(Color.red); &#125; &#125; &#125;); p.add(l1); p.add(t1); p.add(l2); p.add(t2); p.add(l3); p.add(t3); p.add(l4); p.add(t4); p.add(l5); p.add(b1); p.add(b2); p.add(b3); p.setLayout(new GridLayout(3,2)); f.add(p,BorderLayout.SOUTH); f.add(gd,BorderLayout.CENTER); f.pack(); f.setLocationRelativeTo(null); f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); f.setVisible(true); &#125; public static void main(String[] args) &#123; // TODO 自动生成的方法存根 new 默认方法创建(); &#125;&#125; JTree树1.JTree类的构造方法:JTree()JTree(TreeNode root) //根据指定根节点创建树JTree(TreeModel newModel) //根据指定树模型创建树2.DefaultMutableTreeNode类实现了TreeNode接口，用来创建树的节点。DefaultMutableTreeNode()DefaultMutableTreeNode(Object userObject) //创建一个具有指定标签的节点DefaultMutableTreeNode(Object userObject,boolean allowsChildren) //创建一个具有指定标签的节点，并且允许有子节点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package Swing_tree;import java.awt.*;import javax.swing.*;import javax.swing.tree.DefaultMutableTreeNode;public class 创建tree_2 &#123; JFrame f; JTree tree; DefaultMutableTreeNode top;//资源管理器 //我的公文包 我的电脑 收藏夹 Readme DefaultMutableTreeNode node1_1,node1_2,node1_3,node1_4; //公司文件 私人文件 本机磁盘 DefaultMutableTreeNode node2_1,node2_2,node2_3,node2_4,node2_5; //网站列表 DefaultMutableTreeNode node3_1; //空 DefaultMutableTreeNode node4_1; public 创建tree_2() &#123; f=new JFrame(&quot;TreeDemo&quot;); top=new DefaultMutableTreeNode(&quot;资源管理器&quot;); node1_1=new DefaultMutableTreeNode(&quot;我的公文包&quot;); node1_2=new DefaultMutableTreeNode(&quot;我的电脑&quot;); node1_3=new DefaultMutableTreeNode(&quot;收藏夹&quot;); node1_4=new DefaultMutableTreeNode(&quot;Readme&quot;); node2_1=new DefaultMutableTreeNode(&quot;公司文件&quot;); node2_2=new DefaultMutableTreeNode(&quot;私人文件&quot;); node2_3=new DefaultMutableTreeNode(&quot;本机磁盘(C:)&quot;); node2_4=new DefaultMutableTreeNode(&quot;本机磁盘(D:)&quot;); node2_5=new DefaultMutableTreeNode(&quot;本机磁盘(E:)&quot;); node3_1=new DefaultMutableTreeNode(&quot;网站列表&quot;); node4_1=new DefaultMutableTreeNode(&quot;&lt;空&gt;&quot;); top.add(node1_1); top.add(node1_2); top.add(node1_3); top.add(node1_4); node1_1.add(node2_1); node1_1.add(node2_2); node1_2.add(node2_3); node1_2.add(node2_4); node1_2.add(node2_5); node1_3.add(node3_1); node3_1.add(node4_1); tree=new JTree(top); f.add(tree); f.setSize(400,400); f.setLocationRelativeTo(null); f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); f.setResizable(true); f.setVisible(true); &#125; public static void main(String[] args) &#123; // TODO 自动生成的方法存根 new 创建tree_2() ; &#125;&#125; JMenu菜单下拉菜单菜单有如下三大组件：JMenuBar，JMenu，JMenuItem。(1) 菜单栏(JMenuBar)：管理 菜单,不参与用户交互操作(2) 菜单(JMenu)：整合管理菜单项（非叶结点）(3) 菜单项(JMenuItem)：菜单系统中的基本组件（叶结点）创建下拉菜单一般步骤(1) 创建一个JMenuBar菜单栏对象，将其放置在JFrame窗口的顶部；(2) 创建JMenu菜单对象，将其添加到JMenuBar菜单栏中;(3) 创建JMenuItem菜单项，将其添加到JMenu菜单中。 JCheckboxMenuItem类用于创建复选菜单项。 JRadioButtonMenuItem类用于创建带有单选的菜单项。 弹出菜单弹出式菜单：JPopupMenu(1) 构造方法： JPopupMenu ( );(2) 常用方法：① add( JMenuItem ) ：将指定菜单项添加到菜单末尾;② show(Component , int , int ) ：在组件调用者的坐标空间指定位置显示弹出菜单。说明：弹出菜单默认不可见，需调用show()方法显示。③ setVisible( boolean ) ：设置弹出菜单的可见性。 定制菜单使用分隔线(1) 作用：便于集中相似/相关的菜单项；(2) JMenu类、JPopupMenu类提供添加分隔条方法addSeparator()：将新分隔符追加到菜单末尾；Jmenu类还提供向指定索引位置插入分隔符方法：insertSeparator(int) 。注意：索引位置从0开始。 启动/禁用方法：setEnable(boolean);① false：禁用菜单/菜单项；② true：启用菜单/菜单项。注意：禁用的菜单/菜单项呈灰色。 设置快捷键(1) 作用：为菜单/菜单项设置快捷键；(2) 设置方法① setMnemonic(int)：参数为与键盘助记符对应的键值；例：setMnemonic(KeyEvent.VK_F)，指定F为快捷键。② setMnemonic(char) ：参数是键盘助记符对应的键值；例：setMnemonic(‘F’)，指定F为快捷键。(3) 说明：① 如菜单名中含指定键盘快捷键，会为该键添加下划线；② 快捷键不区分大小写。 设置加速器(1) 作用：不展开菜单 ，加速器可直接激活相应菜单项事件。(2) 设置方法：setaAccelerator(KeyStroke)方法：getKeyStroke( int keyCode, int modifiers ) ① 作用： 获取KeyStroke对象(KeyStroke类中定义的静态方法)； ②参数keyCode：键盘助记符对应的键值； 由KeyEvent类中定义的VK_开头的静态常量指定。③参数modifiers：多个参数，用|分隔由InputEvent类中定义的静态常量指定。例： CTRL_MASK、ALT_MASK、 SHIFT_MASK等 。如：getKeyStroke(KeyEvent.VK_A, InputEvent.CTRL_MASK | InputEvent.ALT_MASK));//加速器按键为 CTRL+ALT+A 笔记本实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318package SWng_Menu;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.InputEvent;import java.awt.event.KeyEvent;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.File;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.text.SimpleDateFormat;import java.util.Date;import javax.swing.*;public class 记事本作业版 implements ActionListener &#123; JFrame f; JMenuBar cd; JMenu filecd,editcd,fontcd,lookcd,helpcd; //五个主菜单 一级菜单 //文件菜单 JMenuItem filemenuItem[]=new JMenuItem[8];//文件下的8个副菜单 放进数组 二级菜单 String filemenuname[]= &#123;&quot;新建(N)&quot;,&quot;新窗口(W)&quot;,&quot;打开(O)&quot;,&quot;保存(S)&quot;,&quot;另存为(A)&quot;,&quot;页面设置(U)&quot;,&quot;打印(P)&quot;,&quot;退出(X)&quot;&#125;;//文件 //编辑菜单 JMenuItem editmenuItem[]=new JMenuItem[13];//编辑下12个副菜单 二级菜单 String editmenuname[]= &#123;&quot;撤销(U)&quot;,&quot;剪切(T)&quot;,&quot;复制(C)&quot;,&quot;粘贴(P)&quot;,&quot;删除(L)&quot;,&quot;使用Bing搜索&quot;,&quot;查找(F)&quot;,&quot;查找下一个(N)&quot;,&quot;查找上一个(V)&quot;,&quot;替换(R)&quot;,&quot;转到(G)&quot;,&quot;全选(V)&quot;,&quot;时间/日期(D)&quot;&#125;; //编辑 //格式 JMenu stylemenuItem[]=new JMenu[2];// 二级菜单 String formatmenuname[]= &#123;&quot;自动换行(W)&quot;,&quot;字体(F)&quot;&#125;;//格式 //字体 ButtonGroup bg; JRadioButtonMenuItem fontbody[]=new JRadioButtonMenuItem[4]; //单选字体 三级菜单 String fontbodyname[]= &#123;&quot;黑体&quot;,&quot;宋体&quot;,&quot;楷体&quot;,&quot;隶书&quot;&#125;; //字体 //查看 JMenuItem lookmenuItem[]=new JMenuItem[2]; String lookname[]= &#123;&quot;缩放(Z)&quot;,&quot;状态栏(S)&quot;&#125;; //帮助 JMenuItem helpmenuItem[]=new JMenuItem[3]; String helpname[]= &#123;&quot;查看帮助(H)&quot;,&quot;发送反馈(F)&quot;,&quot;关于记事本&quot;&#125;; //工具栏 JToolBar tb; JButton Toolbu[]=new JButton[7]; String Toolname[]= &#123;&quot;新建&quot;,&quot;打开&quot;,&quot;保存&quot;,&quot;剪切&quot;,&quot;复制&quot;,&quot;粘贴&quot;,&quot;字体&quot;&#125;; //文本域 JTextArea t; JScrollPane gd; //弹出菜单 JPopupMenu tm;//弹出菜单 JMenuItem PopumenuItem[]=new JMenuItem[4];//弹出 String popname[]= &#123;&quot;全选&quot;,&quot;复制&quot;,&quot;粘贴&quot;,&quot;剪切&quot;&#125;; //弹出窗口 public 记事本作业版() &#123; f=new JFrame(&quot;新建文本文档-记事本&quot;); f.setIconImage(new ImageIcon(&quot;Image/记事本.png&quot;).getImage()); cd=new JMenuBar();//工具条 //五个主菜单 filecd=new JMenu(&quot;文件(F)&quot;); filecd.setMnemonic(&#x27;F&#x27;); editcd=new JMenu(&quot;编辑(E)&quot;); editcd.setMnemonic(&#x27;E&#x27;); fontcd=new JMenu(&quot;格式(O)&quot;); fontcd.setMnemonic(&#x27;O&#x27;); lookcd=new JMenu(&quot;查看(V)&quot;); lookcd.setMnemonic(&#x27;V&#x27;); helpcd=new JMenu(&quot;帮助(H)&quot;); helpcd.setMnemonic(&#x27;H&#x27;); cd.add(filecd); cd.add(editcd); cd.add(fontcd); cd.add(lookcd); cd.add(helpcd); f.setJMenuBar(cd); //文件添加 for(int i=0;i&lt;filemenuname.length;i++) &#123; filemenuItem[i]=new JMenuItem(filemenuname[i]);//每一个菜单项加名字 if(i&gt;0&amp;&amp;i%2==0) filecd.addSeparator(); filecd.add(filemenuItem[i]);//都加到文件主菜单上 filemenuItem[i].addActionListener(this);//都加监听 &#125; filemenuItem[1].setEnabled(false); //新窗口 filemenuItem[4].setEnabled(false); //另存为 filemenuItem[5].setEnabled(false); //页面设置 filemenuItem[6].setEnabled(false); //打印 filemenuItem[0].setMnemonic(&#x27;N&#x27;); filemenuItem[2].setMnemonic(&#x27;O&#x27;); filemenuItem[3].setMnemonic(&#x27;S&#x27;); filemenuItem[0].setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_N,InputEvent.CTRL_MASK)); filemenuItem[2].setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_O,InputEvent.CTRL_MASK)); filemenuItem[3].setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S,InputEvent.CTRL_MASK)); filemenuItem[7].setMnemonic(&#x27;X&#x27;); //编辑添加 for(int i=0;i&lt;editmenuname.length;i++) &#123; editmenuItem[i]=new JMenuItem(editmenuname[i]);//加名字 if(i&gt;0&amp;&amp;i%2==0) editcd.addSeparator(); editcd.add(editmenuItem[i]); editmenuItem[i].addActionListener(this); &#125; editmenuItem[0].setEnabled(false); for(int i=0;i&lt;11;i++) &#123; editmenuItem[i].setEnabled(false); &#125; editmenuItem[1].setMnemonic(&#x27;T&#x27;); //剪切 editmenuItem[1].setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_X,InputEvent.CTRL_MASK)); editmenuItem[2].setMnemonic(&#x27;C&#x27;); //复制 editmenuItem[2].setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_C,InputEvent.CTRL_MASK)); editmenuItem[3].setMnemonic(&#x27;V&#x27;); //粘贴 editmenuItem[3].setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_V,InputEvent.CTRL_MASK)); editmenuItem[11].setMnemonic(&#x27;A&#x27;); //全选 editmenuItem[11].setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_A,InputEvent.CTRL_MASK)); editmenuItem[12].setMnemonic(&#x27;D&#x27;); //时间 editmenuItem[12].setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F5,InputEvent.CTRL_MASK)); //格式添加 for(int i=0;i&lt;formatmenuname.length;i++) &#123; stylemenuItem[i]=new JMenu(formatmenuname[i]); if(i&gt;0) fontcd.addSeparator(); fontcd.add(stylemenuItem[i]); &#125; stylemenuItem[0].setMnemonic(&#x27;W&#x27;); stylemenuItem[0].setEnabled(false); stylemenuItem[1].setMnemonic(&#x27;F&#x27;); //加字体 bg=new ButtonGroup(); for(int i=0;i&lt;fontbodyname.length;i++) &#123; fontbody[i]=new JRadioButtonMenuItem(fontbodyname[i]);//4个字体 加上名字 bg.add(fontbody[i]);//添加到按键组 实现单选 stylemenuItem[1].add(fontbody[i]);//把4个字体文字添加到字体副菜单 fontbody[i].addActionListener(this); &#125; //查看添加 for(int i=0;i&lt; lookname.length;i++) &#123; lookmenuItem[i]=new JMenuItem(lookname[i]); lookmenuItem[i].setEnabled(false); if(i==1) lookcd.addSeparator(); lookcd.add(lookmenuItem[i]); &#125; lookmenuItem[0].setMnemonic(&#x27;Z&#x27;); lookmenuItem[1].setMnemonic(&#x27;S&#x27;); //帮助添加 for(int i=0;i&lt;helpname.length;i++) &#123; helpmenuItem[i]=new JMenuItem(helpname[i]); if(i==1||i==2) helpcd.addSeparator(); if(i==0||i==1) helpmenuItem[i].setEnabled(false); helpcd.add(helpmenuItem[i]); &#125; helpmenuItem[2].addActionListener(new CreatNewWindos());//关于记事本 //文本域设置 t=new JTextArea(); t.setFont(new Font(&quot;微软雅黑&quot;,Font.PLAIN,20)); gd=new JScrollPane(t); //文本域加滚动 f.add(gd,BorderLayout.CENTER); //弹出菜单 tm=new JPopupMenu(); for(int i=0;i&lt;popname.length;i++) &#123; PopumenuItem[i]=new JMenuItem(popname[i]);//名字 PopumenuItem[i].addActionListener(this); if(i&gt;0) tm.addSeparator(); //加分隔符 tm.add(PopumenuItem[i]);//加到弹出菜单上 &#125; t.addMouseListener(new MouseAdapter() &#123; public void mouseReleased(MouseEvent e) &#123; if(e.isPopupTrigger()) tm.show(e.getComponent(),e.getX(),e.getY()); &#125; &#125;); String Tooltext[]= &#123;&quot;新建&quot;,&quot;打开&quot;,&quot;保存&quot;,&quot;剪切&quot;,&quot;复制&quot;,&quot;粘贴&quot;,&quot;字体&quot;&#125;; //工具栏设置 tb=new JToolBar(); for(int i=0;i&lt;Toolname.length;i++) &#123; Toolbu[i]=new JButton(Toolname[i]);//按键加图片 Toolbu[i].setToolTipText(Tooltext[i]);//鼠标指向的时候 Toolbu[i].setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));//添加一个手的样子 提示用户可以点击 if(i==3||i==6) tb.addSeparator(new Dimension(20,0));//分隔符 tb.add(Toolbu[i]);//加到工具栏 Toolbu[i].addActionListener(this); &#125; f.add(tb,BorderLayout.NORTH);//工具栏设置到北面 tb.setVisible(true); f.setSize(800,600); f.setLocationRelativeTo(null); f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); f.setResizable(true); f.setVisible(true); &#125; //关于记事本的弹出窗口 class CreatNewWindos implements ActionListener&#123; @Override public void actionPerformed(ActionEvent e) &#123; // TODO 自动生成的方法存 JFrame F=new JFrame(&quot;关于记事本&quot;); JLabel l=new JLabel(&quot;开发者:18软件工程三班李振业&quot;+&quot; &quot;+&quot;2019.10.26&quot;); l.setFont(new Font(&quot;楷体&quot;,Font.BOLD,20)); l.setForeground(Color.GRAY); F.add(l); F.setSize(500,300); F.setLocationRelativeTo(null); F.setVisible(true); &#125; &#125; public static void main(String[] args) &#123; // TODO 自动生成的方法存根 new 记事本作业版(); &#125; @Override public void actionPerformed(ActionEvent e) &#123; // TODO 自动生成的方法存根 Object event=e.getSource(); //取按键变量 /***新建***/// ////////////////////////// if(event==filemenuItem[0]||event==Toolbu[0]) &#123; t.setText(&quot;&quot;); //清空 f.setTitle(&quot;新建文本文档-记事本&quot;); &#125;/***退出***/// ////////////////////////// if(event==filemenuItem[7]) &#123; System.exit(0); &#125;/***打开***/// ////////////////////////// if(event==filemenuItem[2]||event==Toolbu[1]) &#123; JFileChooser filechoose=new JFileChooser();//弹出一个窗口 filechoose.setDialogTitle(&quot;文件打开&quot;);//显示弹开窗口的标题 filechoose.showOpenDialog(null);//ShowOpen 改变按钮的显示为打开 filechoose.setVisible(true); String open_filepath=filechoose.getSelectedFile().getAbsolutePath(); //获取此文件的绝对路径 //读取文件 try &#123; File open_file=new File(open_filepath);//根据路径创建文件 FileReader fr=new FileReader(open_file); //读取流 BufferedReader br=new BufferedReader(fr); //缓存流 char byt[]=new char[(int)open_file.length()]; //转为字节流 int content=br.read(byt); //读取内容 f.setTitle(open_file.getName()); //窗口改变名字 t.append(new String(byt,0,content));//文本域append追加显示文字 fr.close();//关闭流 &#125;catch(Exception e1) &#123; System.out.println(&quot;没有打开文件&quot;); &#125; &#125; /***保存**/// ////////////////////////// if(event==filemenuItem[3]||event==Toolbu[2]) &#123; try &#123; JFileChooser filechoose=new JFileChooser();//弹出一个窗口 filechoose.setDialogTitle(&quot;另存为&quot;);//显示弹开窗口的标题 filechoose.showSaveDialog(null); //ShowSava 改变按钮的显示为保存 filechoose.setVisible(true); String save_filepath=filechoose.getSelectedFile().getAbsolutePath(); //获取此文件的绝对路径 File save_file=new File(save_filepath); FileWriter fw=new FileWriter(save_file);//写入流 BufferedWriter bw=new BufferedWriter(fw); //缓存流 bw.write(t.getText());//文本域的内容写入文件 bw.close(); fw.close(); &#125; catch (IOException e1) &#123; // TODO 自动生成的 catch 块 e1.printStackTrace(); &#125; &#125; /***全选**/// ////////////////////////// if(event==editmenuItem[11]||event==PopumenuItem[0]) &#123; t.selectAll();//选定指定的开始和结束位置之间的文本。 &#125; /***时间日期**/// ////////////////////////// if(event==editmenuItem[12]) &#123; Date dt=new Date(); SimpleDateFormat time=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss E&quot;); t.append(time.format(dt));//文本域append追加显示文字 &#125; /***字体**/// ////////////////////////// //黑体 if(event==fontbody[0]) &#123; Font old_font=t.getFont(); Font new_font=new Font(&quot;黑体&quot;,old_font.getStyle(),old_font.getSize()); t.setFont(new_font); &#125; //宋体 if(event==fontbody[1]) &#123; Font old_font=t.getFont(); Font new_font=new Font(&quot;宋体&quot;,old_font.getStyle(),old_font.getSize()); t.setFont(new_font); &#125; //楷体 if(event==fontbody[2]) &#123; Font old_font=t.getFont(); Font new_font=new Font(&quot;楷体&quot;,old_font.getStyle(),old_font.getSize()); t.setFont(new_font); &#125; //隶书 if(event==fontbody[3]) &#123; Font old_font=t.getFont(); Font new_font=new Font(&quot;隶书&quot;,old_font.getStyle(),old_font.getSize()); t.setFont(new_font); &#125; //字体窗口 if(event==Toolbu[6]) &#123; new 字体窗口(); &#125; &#125;&#125; 自动弹窗123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package 自动弹窗;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import javax.swing.*;/*1.JOptionPane.showMessageDialog(组件, “信息的弹框”); * showMessageDialog(Component parentComponent, Object message, String title, int messageType) *2. JOptionPane.showMessageDialog(null, “信息的弹框”, “窗口名字”, 默认或者风格); *默认或者风格种类: *1.参数为1 默认 *2.参数为-1 无提示类型(图标) *3.参数为0 含义为错误(出现错误图标) *4.参数为2 含义为警告(出现感叹号图标) *5.参数为3 含义为问题(出现问题图标) *3.showMessageDialog(Component parentComponent, Object message, String title, int messageType, Icon icon) * 定义图标，加载图片的图标，可以帮助用户识别正在显示消息的种类 */public class showMessageDialog implements ActionListener &#123; JFrame f; JPanel p; ImageIcon img=new ImageIcon(&quot;Image/qq图标.jpg&quot;); JButton b1,b2,b3,b4,b5,b6;//默认 不带图标 警告 错误 问题 图标 public showMessageDialog() &#123; f=new JFrame(&quot;测试窗口&quot;); b1=new JButton(&quot;默认&quot;); b1.addActionListener(this); b2=new JButton(&quot;无图标&quot;); b2.addActionListener(this); b3=new JButton(&quot;错误&quot;); b3.addActionListener(this); b4=new JButton(&quot;警告&quot;); b4.addActionListener(this); b5=new JButton(&quot;问题&quot;); b5.addActionListener(this); b6=new JButton(&quot;图标&quot;); b6.addActionListener(this); p=new JPanel(new GridLayout(2,3)); p.add(b1); p.add(b2); p.add(b3); p.add(b4); p.add(b5); p.add(b6); f.add(p); f.pack(); f.setLocationRelativeTo(null); f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); f.setVisible(true); &#125; public static void main(String[] args) &#123; // TODO 自动生成的方法存根 new showMessageDialog(); &#125; @Override public void actionPerformed(ActionEvent e) &#123; // TODO 自动生成的方法存根 String event=e.getActionCommand(); if(event.equals(&quot;默认&quot;)) &#123; JOptionPane.showMessageDialog(p, &quot;默认&quot;,&quot;提示窗口&quot;,1); &#125; if(event.equals(&quot;无图标&quot;)) &#123; JOptionPane.showMessageDialog(p,&quot;无图标&quot;,&quot;提示窗口&quot;,-1); &#125; if(event.equals(&quot;错误&quot;)) &#123; JOptionPane.showMessageDialog(p,&quot;错误&quot;,&quot;提示窗口&quot;,0); &#125; if(event.equals(&quot;警告&quot;)) &#123; JOptionPane.showMessageDialog(p, &quot;警告&quot;,&quot;提示窗口&quot;,2); &#125; if(event.equals(&quot;问题&quot;)) &#123; JOptionPane.showMessageDialog(p, &quot;问题&quot;,&quot;提示窗口&quot;,3); &#125;if(event.equals(&quot;图标&quot;)) &#123; JOptionPane.showMessageDialog(p, &quot;问题&quot;,&quot;提示窗口&quot;,3,img); &#125; &#125;&#125; 文件选择器文件选择对话框JFileChooser类提供了一个供用户选择文件的对话框。利用该类创建文件选择对话框以及获取用户选择文件的基本步骤如下：（1）创建一个JFileChooser类的对象。（2）默认情况下每次只能选择一个文件，如果希望允许同时选择多个文件，可以通过调用方法setMultiSelectionEnabled(boolean b)设置，将入口参数设为true即表示允许多选。（3）默认情况下只允许选择文件，如果希望允许选择文件夹，可以通过调用方法setFileSelection- Mode(int mode)设置，入口参数可选的静态常量有FILES_ONLY（只允许选择文件）、DIRECTORIES_ ONLY（只允许选择路径）和FILES_AND_DIRECTORIES（均可选择）。（4）如果只希望在对话框中列出指定类型的文件，可以调用setFileFilter(FileFilter filter)方法设置文件过滤器。（5）设置完成后调用showOpenDialog(Component parent)方法显示对话框，该方法将返回一个int型值，用来判断用户是否选择了文件或路径。（6）如果用户选择了文件或路径，可以通过方法getSelectedFile()或getSelectedFiles()获得，方法getSelectedFile()返回的是File对象，方法getSelectedFiles()返回的是File型数组。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package SWng_Menu;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.io.File;import javax.swing.*;public class 文件选择器 &#123; JFrame f; JLabel l; JButton b; JTextField t; JPanel p; public 文件选择器() &#123; f=new JFrame(&quot;文件选择器&quot;); l=new JLabel(&quot;文件:&quot;); b=new JButton(&quot;打开&quot;); b.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent e) &#123; // TODO 自动生成的方法存根 JFileChooser wjchoose=new JFileChooser();//创建文件选择器 //显示文件选择对话框 int i=wjchoose.showOpenDialog(f); //判断用户单击的是否为“打开”按钮 if(i==JFileChooser.APPROVE_OPTION) &#123; //获取选中的文件对象 File selected=wjchoose.getSelectedFile(); //显示选中文件的名称 t.setText(selected.getName()); //t.setText(selected.getAbsolutePath()); &#125; &#125; &#125;); t=new JTextField(20); p=new JPanel(); p.add(l); p.add(t); p.add(b); f.add(p); f.setSize(400,100); f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); f.setLocation(200, 200); f.setResizable(false); f.setVisible(true); &#125; public static void main(String[] args) &#123; // TODO 自动生成的方法存根 new 文件选择器(); &#125;&#125;![](https://cdn.jsdelivr.net/gh/lzyblog/image@main/2020/11/26/aa5cd174f9d7e46ed9e86f8d280df984.png) 文件过滤器如果只希望在对话框中列出指定类型的文件，可以调用setFileFilter(FileFilter filter)方法设置文件过滤器。 javax.swing.filechooser.FileFilter类是一个抽象类，该类的具体定义如下：public abstract class FileFilter { public abstract boolean accept(File f); public abstract String getDescription();} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package SWng_Menu;import java.awt.*;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import javax.swing.*;import javax.swing.filechooser.FileFilter;import javax.swing.filechooser.FileNameExtensionFilter;import java.io.*;public class 文件选择过滤器 &#123; JFrame f; JLabel l; public 文件选择过滤器() &#123; f=new JFrame(&quot;文件选择过滤器&quot;); l=new JLabel(&quot;&lt;双击打开照片&gt;&quot;,SwingConstants.CENTER); l.addMouseListener(new MouseAdapter() &#123; JFileChooser wjchoose; &#123; //创建文件选择对话框 wjchoose=new JFileChooser(); //设置文件过滤器，只列出JPG或GIF格式的图片 FileFilter file=new FileNameExtensionFilter(&quot;图像文件(JPG/GIF)&quot;,&quot;JPG&quot;,&quot;JPEG&quot;,&quot;GIF&quot;); wjchoose.setFileFilter(file); &#125; public void mouseClicked(MouseEvent e) &#123; if(e.getClickCount()==2) &#123;//点击次数 //显示文件选择对话框 int i=wjchoose.showOpenDialog(f); //判断用户点击的是否为“打开”按钮 if(i==JFileChooser.APPROVE_OPTION) &#123; //获取选中的图片对象 File selectedFile=wjchoose.getSelectedFile(); ImageIcon img=new ImageIcon(selectedFile.getAbsolutePath()); //传入图片路径创建图片对象 l.setIcon(img); f.setSize(img.getIconWidth(),img.getIconHeight());//图片的大小显示窗口大小 l.setText(&quot;&quot;); &#125; &#125; &#125; &#125;); f.add(l); f.setSize(300,400); f.setLocation(200, 200); f.setResizable(false); f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); f.setVisible(true); &#125; public static void main(String[] args) &#123; // TODO 自动生成的方法存根 new 文件选择过滤器(); &#125;&#125;","path":"page/java04.html","date":"01-05","excerpt":"","tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://xiaoliblog.cn/tags/JavaSE/"}]},{"title":"Java👉注解和反射","text":"注解Annotation 注解和反射是所有框架的底层 Annotation是从JDK5.0开始引入的新技术 Annotation的作用 不是程序本身，可以对程序作出解释(这一点和注释(comment)没什么区别) 可以被其他程序（比如:编译器等）读取 Annotation的格式: 注解是以@注释名在代码中存在的，还可以添加一些参数值 例如：@SuppressWarnings(value=”unchecked”). Annotation在哪里使用? 可以附加在package，class，method ， field等上面，相当于给他们添加了额外的辅助信息，我们可以通过反射机制编程实现对这些元数据的访问 注解详细介绍👉Java注解(Annotation) 内置注解 @Overide 定义在java.lang.Override中，此注释只适用于修辞方法，表示一个方法声明打算重写超类中的另一个方法声明 @Deprecated 定义在java.lang.Deprecated中，此注释可以用于修辞方法、属性、类，表示不鼓励程序员使用这样的元素，通常是因为它很危险或者存在更好的选择， @SuppressWarnings 定义在java.lang.SuppressWarnings中，用来抑制编译时的警告信息 与前两个注释有所不同，需要添加一个参数才能正确使用，这些参数都是已经定义好了的，选择性的使用就可以. @SuppresSWaningl’”ll”) @SuppressWarnings(“unchecked”) @SuppressWarnings(value={“unchecked”,”deprecation”}) 等等…. 元注解 元注解的作用就是负责注解其他注解，Java定义了4个标准的meta-annotation类型，他们被用来提供对其他annotation类型作说明 这些类型和它们所支持的类在java.lang annotation包中可以找到( @Target , @Retention，@Documented , @Inherited ) @Target ：用于描述注解的使用范围（即:被描述的注解可以用在什么地方） @Retention ：表示需要在什么级别保存该注释信息,用于描述注解的生命周期 (SOURCE &lt;CLASS &lt; RUNTIME) @Document：说明该注解将被包含在javadoc中 @Inherited：说明子类可以继承父类中的该注解 1234567891011121314151617181920212223242526272829package com.company;import java.lang.annotation.*;public class Main &#123; @MyAnnotation public void test()&#123; &#125;&#125;//Target表示注解可以用在哪些地方@Target(value= &#123;ElementType.METHOD,ElementType.TYPE&#125;)//Retention 表示我们的注解在什么地方还有效//runtime&gt;class&gt;sources@Retention(value= RetentionPolicy.RUNTIME)//Documented表示是否将我们的注解生成在Javadoc中@Documented//Inherited 子类可以继承父类的注解@Inherited//定义一个注解@interface MyAnnotation&#123;&#125; 自定义注解 使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口 @interface用来声明一个注解 1234//格式@interface 注解名&#123; 定义内容 &#125; 其中的每一个方法实际上是声明了一个配置参数 1234//注解的参数：参数类型 参数名()String name();//使用 @MyAnnotation(name = &quot;小李博客&quot;) 方法的名称就是参数的名称 返回值类型就是参数的类型（返回值只能是基本类型，Class , String , enum ） 可以通过default来声明参数的默认值 12//设置默认值String name() default &quot;默认值&quot;; 如果只有一个参数成员，一般参数名为value 1String value(); //只有一个参数建议用value命名 注解元素必须要有值，我们定义注解元素时，经常使用空字符串，0作为默认值. 12345678910111213141516171819202122232425262728293031323334353637package com.company;import javax.xml.bind.Element;import java.lang.annotation.*;public class Main &#123; //注解可以显示的赋值 @MyAnnotation1(name = &quot;小李博客&quot;,schools = &#123;&quot;清华大小&quot;&#125;) public void test1()&#123; &#125; //value为参数值，可以省略 @MyAnnotation2(&quot;小李博客&quot;) public void test2()&#123; &#125;&#125;//目标作用域@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)//有效范围@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation1&#123; //注解的参数：参数类型 参数名() String name() default &quot; &quot;; int age() default 0; int id() default -1; //如果默认值为-1，代表不存在 String[] schools() default &#123;&quot;清华大小&quot;,&quot;北京大学&quot;&#125;;&#125;@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@interface MyAnnotation2 &#123; String value(); //只有一个参数建议用value命名&#125; 反射Reflection 动态语言 是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构 主要动态语言: Object-C、 C#、 JavaScript、 PHP、 Python等 静态语言 与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、 C、C++. Java不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动态性，我们可以利用反射机制获得类似动态语言的特性。Java的动态性让编程的时候更加灵活! Reflection (反射) 是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法 1Class C = Class.forName(&quot;java.lang.String&quot;) 加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象(一个类只有一个Class对象)，这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子， 透过这个镜子看到类的结构，所以，我们形象的称之为反射 获得反射对象 API 说明 java.lang.Class 代表一个类 java.lang.reflect.Method 代表类的方法 java.lang.reflect.Field 代表类的成员变量 java.lang.reflect.Constructor 代表类的构造器 在Object类中定义了以下的方法，此方法将被所有子类继承 1public final Class getClass() 以上的方法返回值的类型是一个Class类，此类是Java反射的源头，实际上所谓反射从程序的运行结果来看也很好理解，即：可以通过对象反射求出类的名称 123456789101112131415161718192021222324252627package com.company;//反射public class reflection_Test &#123; public static void main(String[] args) throws ClassNotFoundException&#123; //通过反射获取类的class对象，参数为User类的完整路径 Class c1 = Class.forName(&quot;com.company.User&quot;); System.out.println(c1); Class c2 = Class.forName(&quot;com.company.User&quot;); Class c3 = Class.forName(&quot;com.company.User&quot;); Class c4 = Class.forName(&quot;com.company.User&quot;); //一个类在内存中只有一个Class对象 //一个类别加载后。类的整个结构都会被封装在Class对象中 System.out.println(c2.hashCode()); System.out.println(c3.hashCode()); System.out.println(c4.hashCode()); &#125;&#125;//实体类:pojo entityclass User&#123; private String name; private int id; private int age;&#125; hashCode相同表示为同一类 得到Class类的几种方式 对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口对于每个类而言， JRE都为其保留一个不变的Class类型的对象。一个Class对象包含了特定某个结(class/interface/enum/annotation/primitive type/void/[]])的有关信息 Class 本身也是一个类 Class 对象只能由系统建立对象 一个加载的类在JVM中只会有一个Class实例 一个Class对象对应的是一个加载到JVM中的一个.class文件 每个类的实例都会记得自己是由哪个Class实例所生成 通过Class可以完整地得到一个类中的所有被加载的结构 Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象 Class类常用方法 功能说明 static ClassforName(String name) 返回指定类名name的Class对象 Object newInstance() 调用缺省构造函数，返回Class对象的一个实例 getName() 返回此Class对象所表示的实体(类,接口，数组类或void)的名称 Class getSuperClass() 返回当前Class对象的父类的Class对象 Class[] getinterfaces() 获取当前Class对象的接口 ClassLoader getClassLoader() 返回该类的类加载器 Constructor[] getConstructors() 返回一个包含某些Constructor对象的数组 Method getMothed(String name,Class.. T) 返回一个Method对象，此对象的形参类型为param Type Field[] getDeclaredFields() 返回Field对象的一个数组 若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高 1Class clazz = Person.class; 已知某个类的实例，调用该实例的getClass()方法获取Class对象 1Class clazz = person.getClass(); 已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取,可能抛出ClassNotFoundException 1Class clazz = Class.forName(&quot;demo01 .Student&quot;); 内置基本数据类型可以直接用类名.Type 还可以利用ClassLoader 有以下类 123456789101112131415161718192021222324252627class Person&#123; String name; public Person()&#123; &#125; public Person(String name)&#123; this.name=name; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125;class Student extends Person&#123; public Student()&#123; this.name=&quot;学生&quot;; &#125;&#125;class Teacher extends Person&#123; public Teacher()&#123; this.name=&quot;老师&quot;; &#125;&#125; 获得Class的方法 123456789101112131415161718192021222324252627public class reflection_Test02 &#123; public static void main(String[] args) throws ClassNotFoundException &#123; Person person = new Student(); System.out.println(&quot;这个人是:&quot; + person.name); //方式一: 通过对象获得 Class c1 = person.getClass(); System.out.println(c1.hashCode()); //方式二: forName获得 Class c2 = Class.forName(&quot;com.company.Student&quot;); System.out.println(c2.hashCode()); //方式三: 通过类名.class获得 Class c3 = Student.class; System.out.println(c3.hashCode()); //方式四: 基本内置类型的包装类都有一个Type属性 Class c4 = Integer.TYPE; System.out.println(c4); //获得父类类型 Class c5= c3.getSuperclass(); System.out.println(c5); &#125;&#125; 运行结果 所有类型的Class对象 按住AIt键可以多行复制 12345678910111213141516171819202122232425package com.company;import java.lang.annotation.ElementType;public class reflection_Test03 &#123; public static void main(String[] args) &#123; Class c1= Object.class; //类 Class c2 = Comparable.class; //接口 Class c3 = String[].class; //一维数组 Class c4 = int[][].class; //二维数组 Class c5 = Override.class; //注解 Class c6 = ElementType.class; //枚举 Class c7 = Integer.class; //基本数据类型 Class c8 = void.class; //void Class c9 = Class.class; //Class System.out.println(c1); System.out.println(c2); System.out.println(c3); System.out.println(c4); System.out.println(c5); System.out.println(c6); System.out.println(c7); System.out.println(c8); System.out.println(c9); &#125;&#125; 类加载内存分析 类加载过程 类的加载与ClassLoader的理解 加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象. 链接：将Java类的二进制代码合并到JVM的运行状态之中的过程 验证:：确保加载的类信息符合JVM规范，没有安全方面的问题 准备：正式为类变量(static) 分配内存并设置类变量默认初始值的阶段,这些内存都将在方法区中进行分配 解析：虚拟机常量池内的符号引用(常量名)替换为直接引用(地址)的过程。 初始化: 执行类构器&lt; clinit&gt; ()方法的过程。类构造器&lt; clinit&gt; ()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。(类构造器 是构造类信息的，不是构造该类对象的构造器) 当初始化一 个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化 虚拟机会保证一个类的&lt; clinit&gt; ()方法在多线程环境中被正确加锁和同步 123456789101112131415161718192021222324package com.company;/** * @Auther: http://xiaoliblog.cn * @Date: 2021/3/20 * @Description: com.company * @version: 1.0 */public class reflection_test04 &#123; public static void main(String[] args) &#123; A a = new A(); System.out.println(A.m); &#125;&#125;class A&#123; static &#123; System.out.println(&quot;A类静态代码块初始化&quot;); m = 300; &#125; static int m = 100; public A()&#123; System.out.println(&quot;A类的无参构造初始化&quot;); &#125;&#125; 分析类初始化 类的主动引用(一定会发生类的初始化) 当虚拟机启动，先初始化main方法所在的类 new一个类的对象 调用类的静态成员（除了final常量）和静态方法 使用java.lang.reflect包的方法对类进行反射调用 当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类 类的被动引用(不会发生类的初始化) 当访问一个静态域时，只有真正声明这个域的类才会被初始化。如:当通过子类引用父类的静态变量，不会导致子类初始化 通过数组定义类引用，不会触发此类的初始化 引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了） 类加载器 类加载的作用 将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。 类缓存 标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载(缓存) 一段时间。不过JVM垃圾回收机制可以回收这些Class对象 1234567891011121314151617181920212223242526272829303132333435package com.company;public class reflection_Test05 &#123; public static void main(String[] args) throws ClassNotFoundException&#123; //获取系统类的加载器 ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); System.out.println(systemClassLoader); //获取系统类加载器的父类加载器———&gt;扩展类加载器 ClassLoader parent = systemClassLoader.getParent(); System.out.println(parent); //获取扩展类加载器的父类加载器--&gt;根加载器(C/C++) ClassLoader root = parent.getParent(); System.out.println(root); //测试当前类是哪个加载器加载的 ClassLoader classLoader = Class.forName(&quot;com.company.reflection_Test01&quot;).getClassLoader(); System.out.println(classLoader); //测试JDK内置的类是谁加载的 ClassLoader classLoaderJDK= Class.forName(&quot;java.lang.Object&quot;).getClassLoader(); System.out.println(classLoaderJDK); //如何获得系统类加载器可以加载的路径 System.out.println(System.getProperty(&quot;java.class.path&quot;)); /* * C:\\Program Files\\Java\\jdk1.8.0_192\\jre\\lib\\charsets.jar; * C:\\Program Files\\Java\\jdk1.8.0_192\\jre\\lib\\deploy.jar; * C:\\Program Files\\Java\\jdk1.8.0_192\\jre\\lib\\ext\\access-bridge-64.jar; * C:\\Program Files\\Java\\jdk1.8.0_192\\jre\\lib\\ext\\cldrdata.jar; * ... * */ &#125;&#125; 获取类的运行时结构 Ctrl+Alt+V快速生成变量名 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.company;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;public class reflection_Test06 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, NoSuchMethodException &#123; Class c1= Class.forName(&quot;com.company.User&quot;); //获得类的名字 System.out.println(c1.getName()); //获得包名和类 System.out.println(c1.getSimpleName()); //获得类名 //获得类的属性 System.out.println(&quot;===============================&quot;); Field[] fields = c1.getDeclaredFields(); //获得全部属性 for (Field field : fields) &#123; System.out.println(field); &#125; //获得指定属性的值 Field name = c1.getDeclaredField(&quot;name&quot;); System.out.println(name); //获得类的方法 System.out.println(&quot;===============================&quot;); Method[] methods = c1.getMethods(); //获得本类及其父类的所有方法 for (Method method : methods) &#123; System.out.println(&quot;正常的:&quot;+method); &#125; methods= c1.getDeclaredMethods(); //获得本类的方法 for (Method method : methods) &#123; System.out.println(&quot;getDeclaredMethods:&quot;+method); &#125; //获得指定方法 Method getName = c1.getMethod(&quot;getName&quot;,null); //无参 Method setName = c1.getMethod(&quot;setName&quot;,String.class); //有参 System.out.println(getName); System.out.println(setName); //获得指定的构造器 System.out.println(&quot;===============================&quot;); Constructor[] constructors = c1.getConstructors(); for (Constructor constructor : constructors) &#123; System.out.println(constructor); &#125; constructors = c1.getDeclaredConstructors(); for (Constructor constructor : constructors) &#123; System.out.println(constructor); &#125; //获得指定构造器 Constructor declaredConstructors = c1.getDeclaredConstructor(String.class,int.class,int.class); System.out.println(&quot;指定构造器:&quot;+declaredConstructors); &#125;&#125; 动态创建对象执行方法 创建类的对象：调用Class对象的newInstance()方法 类必须有一-个无参数的构造器。 类的构造器的访问权限需要足够 思考?难道没有无参的构造器就不能创建对象了吗?只要在操作的时候明确的调用类中的构造器，并将参数传递进去之后，才可以实例化操作。 步骤如下 通过Class类的getDeclaredConstructor(Class .. parameterTypes)取得本类的指定形参类型的构造器 向构造器的形参中传递-个对象数组进去，里面包含了构造器中所需的各个参数。 通过Constructor实例化对象 通过反射，调用类中的方法，通过Method类完成。 通过Class类的getMethod(String name,Class..parameterTypes)方法取得一个Method对象，并设置此方法操作时所需要的参数类型 之后使用Objedt invgke(Object obj, Object[] args)进行调用，并向方法中传递要设置的obj对象的参数信息 1Object invoke(Object obj, Object ...args) Object对应原方法的返回值，若原方法无返回值，此时返回null 若原方法若为静态方法，此时形参Object obj可为null 若原方法形参列表为空，则Object[] args为null 若原方法声明为private，则需要在调用此invoke()方法前，显式调用方法对象的setAccessible(true)方法，将可访问private的方法 1setAccessible(true); Method和Field、 Constructbr对象都有setAccessible()方法。 setAccessible作用是启动和禁用访问安全检查的开关。 参数值为true则指示反射的对象在使用时应该取消Java语言访问检查。 提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true 使得原本无法访问的私有成员也可以访问 参数值为false则指示反射的对象应该实施Java语言访问检查 123456789101112131415161718192021222324252627282930313233343536373839404142package com.company;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class relection_Test07 &#123; public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException &#123; //获得Class对象 Class c1 = Class.forName(&quot;com.company.User&quot;); //构造一个对象 User user1 = (User)c1.newInstance(); //调用了User类的无参构造器 System.out.println(user1); //通过构造器创建对象 Constructor declaredConstructor = c1.getDeclaredConstructor(String.class, int.class, int.class); User user2 = (User)declaredConstructor.newInstance(&quot;李白&quot;,1,21); System.out.println(user2); //通过反射调用方法 User user3 = (User)c1.newInstance(); //调用了User类的无参构造器 //通过反射获得一个方法 Method setName = c1.getDeclaredMethod(&quot;setName&quot;,String.class); //invoke 激活 // (对象,&quot;方法的值&quot;) setName.invoke(user3,&quot;李白&quot;); System.out.println(user3.getName()); //通过反射操作属性 User user4 = (User)c1.newInstance(); Field name = c1.getDeclaredField(&quot;name&quot;); //不能直接操作私有属性 //我们需要关闭程序的安全检测，属性或者方法的setAccessible(true) name.setAccessible(true); name.set(user4,&quot;岳飞&quot;); System.out.println(user4.getName()); &#125;&#125; 反射操作泛型 Java采用泛型擦除的机制来引入泛型，Java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换问题,，但是，一旦编译完成，所有和泛型有关的类型全部擦除 为了通过反射操作这些类型，Java新增了ParameterizedType , GenericArrayType，TypeVariable和WildcardType几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型 类型 说明 ParameterizedType 示一种参数化类型,比如Collection&lt;String&gt; GenericArrayType 表示一种元素类型是参数化类型或者类型变量的数组类型 TypeVariable 是各种类型变量的公共父接口 WildcardType 代表一种通配符类型表达式 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.company;import java.lang.reflect.Method;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.List;import java.util.Map;// 通过反射获取泛型public class relection_Test08 &#123; public void test01(Map&lt;String,User&gt; map, List&lt;User&gt; list)&#123; System.out.println(&quot;test01&quot;); &#125; public Map&lt;String,User&gt; test02()&#123; System.out.println(&quot;test02&quot;); return null; &#125; public static void main(String[] args) throws NoSuchMethodException &#123; Method method = relection_Test08.class.getMethod(&quot;test01&quot;, Map.class, List.class); Type[] genericParameterTypes = method.getGenericParameterTypes(); for (Type genericParameterType : genericParameterTypes) &#123; System.out.println(genericParameterType); if(genericParameterType instanceof ParameterizedType)&#123; Type[] actualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments(); for (Type actualTypeArgument : actualTypeArguments) &#123; System.out.println(actualTypeArgument); &#125; &#125; &#125; method = relection_Test08.class.getMethod(&quot;test02&quot;, null); Type genericReturnType = method.getGenericReturnType(); if(genericReturnType instanceof ParameterizedType)&#123; Type[] actualTypeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments(); for (Type actualTypeArgument : actualTypeArguments) &#123; System.out.println(actualTypeArgument); &#125; &#125; &#125;&#125; 反射操作注解 getAnnotations getAnnotation 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package com.company;import java.lang.annotation.*;import java.lang.reflect.Field;//反射操作注解public class relection_Test09 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException &#123; Class c1 = Class.forName(&quot;com.company.Student2&quot;); //通过反射获得注解 Annotation[] annotations = c1.getAnnotations(); for (Annotation annotation : annotations) &#123; System.out.println(annotation); &#125; System.out.println(&quot;=============================&quot;); //获得注解value的值 table db_table= (table) c1.getAnnotation(table.class); String value = db_table.value(); System.out.println(value); System.out.println(&quot;=============================&quot;); //获得类指定的注解 Field f = c1.getDeclaredField(&quot;name&quot;); field annotation = f.getAnnotation(field.class); System.out.println(annotation.columnName()); System.out.println(annotation.type()); System.out.println(annotation.length()); System.out.println(&quot;=============================&quot;); f = c1.getDeclaredField(&quot;id&quot;); annotation = f.getAnnotation(field.class); System.out.println(annotation.columnName()); System.out.println(annotation.type()); System.out.println(annotation.length()); &#125;&#125;@table(&quot;db_Student&quot;)class Student2&#123; @field(columnName = &quot;db_id&quot;,type=&quot;int&quot;,length = 10) private int id; @field(columnName = &quot;db_age&quot;,type=&quot;int&quot;,length = 10) private int age; @field(columnName = &quot;db_name&quot;,type=&quot;varchar&quot;,length = 10) private String name; public Student2() &#123; &#125; public Student2(int id, int age, String name) &#123; this.id = id; this.age = age; this.name = name; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Student2&#123;&quot; + &quot;id=&quot; + id + &quot;, age=&quot; + age + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125;//类名的注解@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@interface table&#123; String value(); //表名&#125;//属性的注解@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@interface field&#123; String columnName(); //列名 String type(); int length();&#125;","path":"page/java05.html","date":"01-05","excerpt":"","tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://xiaoliblog.cn/tags/JavaSE/"}]},{"title":"Java👉线程、线程通信","text":"线程相关概念 程序（Program）是为实现特定目标或解决特定问题而用计算机语言编写的命令序列的集合。 进程（Process）是程序关于某个数据集合上的一次运行活动（对应一个exe），是独立运行的程序(正在运行的程序)；对应了从代码加载、执行至执行完毕的一个完整过程；是系统进行资源分配和调度的一个独立单位。 线程（Thread）是进程的一个实体，CPU调度和分派的基本单位，是比进程更小的、能独立运行的基本单位。一个应用程序中有多条并发执行的线索，每条线索都被称为一个线程。各线程交替执行，彼此间可以通信。 并发执行：多个程序块宏观上同时运行的现象。 单线程程序程序未派生出多线程，只有一个线程；程序代码按照调用顺序依次往下执行，没有程序代码交替运行的现象。 多线程程序程序派生出了多线程；多段程序代码交替运行的现象，每段程序对应一个线程，各线程相互独立，并发执行。 主线程 Java程序启动时，自动产生一个进程，默认创建一个线程，该线程通常称为程序的主线程，应用来运行main()方法中的代码。 每个java程序都至少有一个线程：主线程； 重要性①主线程用来产生其他子线程；②主线程执行各种关闭动作，通常最后完成执行。 线程与进程的关系 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。 操作系统把资源分配给进程，而同一进程的所有线程共享该进程的所有资源。 进程是拥有资源的基本单位，而线程是作为CPU调度和分配的基本单位。 Thread类方法 构造方法 说明 pubilc Thread() 创建新的Thread对象 public Thread(String) 创建指定名称的线程 public Thread(Runnable) 创建以Runnable接口子类对象为参数的线程 public Thread(Runnable,String) 创建以Runnable接口子类对象为参数的线程，并给线程命名 方法 用途 static Thread currentThread() 返回正在执行的线程 final String getName() 返回线程的名称 final void setName(String) 设置线程的名称 final int getPriority() 设置名称的优先级 void setPriority(int) 设置线程的优先级 static void sleep(long millis) 将线程挂起一段时间 void start() 启动线程，开始执行线程 void run() 运行线程 static void yield() 自动放弃CPU，以便其他线程能够运行，自己到队列的最后等待 final void join() 等待被join的线程执行完毕 final void wait() 等待其他的线程的notify，获得notify信号后继续执行后面的代码 final void notify() 当前线程被阻塞，直到被另一个线程唤醒，然后当前线程继续执行上次未完成操作 boolean isInterrupted() 返回线程是否被中断 static int activeCount() 返回激活的线程数 创建线程线程运行的代码由run()方法实现。 方法一：继承Thread类，重写run()方法。 方法二：实现Runnable接口，重写run()方法 说明：实现Runnable接口方式更优。java类只参单一继承，但能实现多个接口。 123456789101112方法一：继承Thread类，复写run方法1) 定义线程最简单的办法：定义类继承Thread。例：class Mythread extends Thread&#123; public void run()&#123;……. //要在线程中执行的代码; &#125;&#125;(2) 启动新线程：调用start()方法例：Mythread t=new Mythread(); t.start(); 12345678910方法二：实现Runnable接口，复写run方法(1) 定义实现Runnable接口的类，实现run()方法class myThread implements Runnable &#123; public void run() &#123; /*实现该方法*/ &#125;&#125;(2) 以Runnable对象为参数创建线程。① 以Runnable对象传给Thread的构造函数，创建独立的Thread对象；② 调用线程的start( )方法启动线程。例：Thread t=new Thread(new myThread()); t.start(); 线程生命周期 新建：新创建的线程对象处于新建 状态，不能运行。 就绪(可运行)线程对象调用start()方法进入就绪状态，进入线程队列排队，此时具备了运行条件，一旦轮到CPU，就可脱离创建它的主线程独立开始自己的生命周期。 运行就绪线程获得CPU使用权，进入运行状态，自动调用run()方法，从第一句代码开始运行。 一旦线程进入可执行状态，它就会在就绪与运行状态下转换，同时也有可能进入等待、休眠、阻塞、或死亡状态： 等待当处于运行状态的线程调用Thread类中的wait方法时，该线程便进入等待状态。进入等待状态的线程必须调用Thread类中的notify方法才能被唤醒，而notifyAll方法是将所有处于等待状态的线程唤醒。 休眠当线程调用Thread类中的sleep方法时，则会进入休眠状态。 阻塞(中断)正在执行的线程如果发出输入输出请求，则不能继续执行，则进入阻塞状态。只有引起阻塞的原因消失（如，输入输出结束），线程才可以继续进入就绪状态等待CPU处理。 死亡线程完成了全部工作（即执行完了run()方法）、或提前被强制终止了，就进入死亡状态。处于死亡状态的线程不具有继续执行的能力。 线程的调度及优先级线程的调度：Java虚拟机为程序中的每个线程分配CPU使用权的特定机制。 线程的调度模型: 分时调度模型 所有线程轮流获得CPU使用权，平均分配每个线程占用的CPU时间片。 抢占式调度模型 让可运行队列中优先级高的线程优先占用CPU，优先级相同的线程随机选择一个线程占用CPU。 线程优先级(priority)： 作用将线程的重要程度告诉线程调度机制。 Thread类中用常量定义了java线程的优先级① NORM_PRIORITY：值为5② MAX_PRIORITY：值为10③ MIN_PRIORITY：值为1 。 与优先级相关的方法：① final void setPriority ( int newp)修改线程的当前优先级②final int getPriority ()返回线程的优先级 线程的操作sleep() 格式：sleep( long )说明：参数为毫秒。 功能：暂停正在执行的线程，将CPU让给其他线程。 注意事项：抛出InterruptedException异常。 123456789101112131415161718192021222324252627package 多线程;//程序的睡眠class xc implements Runnable&#123; public void run() &#123; //不可以用Throws 抛出异常 继承和实现接口都不能抛 for(int i=0;i&lt;10;i++) &#123; System.out.println(Thread.currentThread().getName()+&quot; &quot;+i); try &#123; Thread.sleep(1000);//1000毫秒=1s 睡眠过程中 &#125;catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public class 多线程1 &#123; public static void main(String[] args) &#123; // TODO 自动生成的方法存根 xc c=new xc(); Thread t=new Thread(c); t.setName(&quot;倒计时&quot;); t.start(); &#125;&#125; yield() 格式：yield( ) 功能：暂停正在执行的线程，执行其他线程。 yield()与sleep() ：① 共同点：暂停正在运行的线程；② 不同点：yield()不阻塞线程，只将线程转换到就绪状态，让系统重新调度一次；sleep() 线程会进入休眠状态，休眠一段时间。 12345678910111213141516171819202122232425262728293031323334package 多线程;//线程的让步//应用遇到某些条件时，这件事暂时不做，先其他的做class Xc4 implements Runnable&#123; public void run() &#123; for(int i=0;i&lt;=30;i++) &#123; System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i); if(i%5==0) &#123; Thread.yield(); //线程不执行 当i=5 线程分给其他线程 其他线程执行到满足条件 在让步 让步 &#125; &#125; &#125;&#125;public class 多线程2 &#123; public static void main(String[] args) &#123; // TODO 自动生成的方法存根 Xc4 xc=new Xc4(); Thread t=new Thread(xc); Thread t1=new Thread(xc); t.setName(&quot;线程1&quot;); t1.setName(&quot;线程2&quot;); t.start(); t1.start(); &#125;&#125; join() 格式：① join( )② join( long millis )③ join( long millis, int nanos) 功能：等待线程终止，时间最长为millis毫秒+nanos纳秒。 当在某个线程中调用其他线程的join()方法时，调用的线程将被阻塞，直到被join()方法加入的线程执行完成后才会继续运行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/*在项目中创建JoinTest类，该类继承了Jframe类。该实例包括两个进度条，进度条的进度由线程来控制，通过使用join方法使上面的进度条必须等待下面的进度条完成后才可以继续。*/package 多线程;import javax.swing.*;import java.awt.*;public class JoinTest &#123; private Thread t1;//定义两个线程 private Thread t2; JFrame f; JProgressBar pb1; //进度条1 JProgressBar pb2; //进度条2 int count=0; public JoinTest() &#123; super(); f=new JFrame(); pb1=new JProgressBar(); pb2=new JProgressBar(); f.add(pb1,BorderLayout.NORTH); f.add(pb2,BorderLayout.SOUTH); pb1.setStringPainted(true); //显示数字字符 pb2.setStringPainted(true); f.setSize(200,100); f.setLocation(200,200); f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); f.setResizable(false); f.setVisible(true); //使用匿名内部类形式初始化Thread实例 t1=new Thread(new Runnable() &#123; int count=0; public void run() &#123; //重写run方法 while(true) &#123; pb1.setValue(++count); //设置进度条的当前值 try &#123; Thread.sleep(100); //使线程1休眠 t2.join(); //线程2插队 &#125; catch (InterruptedException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; &#125; &#125; &#125;); t1.start(); //启动线程1 调用 run方法 t2=new Thread(new Runnable() &#123; int count=0; public void run() &#123; while(true) &#123; pb2.setValue(++count); try &#123; Thread.sleep(100); &#125;catch(Exception e) &#123; e.printStackTrace();; &#125; if(count==100) //当增长为100时跳出 break; &#125; &#125; &#125;); t2.start(); //启动线程2 &#125; public static void main(String[] args) &#123; // TODO 自动生成的方法存根 JoinTest br=new JoinTest(); &#125;&#125; 多线程的同步线程的同步：用以解决多个线程同时访问同一个资源！ 资源共享冲突资源共享的冲突: 资源冲突：多个线程同时访问一个资源所导致例：同时访问一个变量；例：同时入往一台打印机上输出。 并发程序要处理的核心问题：资源共享问题。 在多线程环境下，必须防止两个线程同时访问同一个资源。 资源共享冲突的解决思路: 在线程运行时给资源上锁第一个访问这个资源的线程给它上锁，在解锁之前，其它线程不能访问这个资源；第二个线程给这个资源上锁，……，如此循环。 采用串行访问方式保证同一时刻只有一个线程能够访问这个共享资源。 synchronizedjava同步机制： synchronized 每个对象都有一个锁，在执行对象的同步代码（需要共享资源的代码）时，该对象会被锁住。 所有线程的同步代码都会共享同一个锁，该锁会防止多个线程同时读写共用的内存。 只要有一个线程还在调用synchronized方法，其他线程就不允许访问所有的synchronized方法，当线程离开synchronized方法，对象就被解锁。 12345**********同步代码块格式*******synchronized ( lock )&#123; 共享资源代码块 &#125; lock：锁对象(可为任意对象)。① 未锁值：1 (默认)；② 锁定值 : 0。 线程执行同步代码块时，先检查锁对象标志位：①未锁时执行同步代码块，同时锁定标志位；② 锁定时其它的同步线程发生阻塞，等待同步代码解锁。 12345678910**********同步方法格式********synchronized 返回值类型 方法名( 参数列表 ) &#123; 共享资源代码块&#125;等价于返回值类型 方法名( 参数列表 )&#123; synchronized(this) &#123; …… &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package 多线程;class Che implements Runnable&#123; public static int chepiao=100; //static 使多个线程共享100张车票 //static的主要作用在于创建独立于具体对象的域变量或者方法 //被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法不属于任何一个实例对象，而是被类的实例对象所共享。 public static String a=new String(&quot;1&quot;);//字符串随意定义 public void run() &#123; while(true) &#123; //synchronized的作用是让他所管辖的代码部分，要么全部执行完要么全部不执行 synchronized(a) &#123;//既可修饰代码块，又可以修饰函数,修饰函数不需要字符串 public synchronized void run() 让函数执行完 //两个线程的a是线程自己的，并不是共有的 加public static变成公共的 //一次执行完 if(chepiao&gt;0) &#123; System.out.println(&quot;第&quot;+Thread.currentThread().getName()+&quot;个车站正在卖第&quot;+(101-chepiao)+&quot;张车票&quot;); --chepiao; try &#123; Thread.sleep(50); &#125; catch (InterruptedException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; &#125;else &#123; break; &#125; // &#125; &#125; &#125;&#125;public class 车票售票实例 &#123; public static void main(String[] args) &#123; // TODO 自动生成的方法存根 Thread t=new Thread(new Che()); Thread t1=new Thread(new Che()); //t.setName(&quot;上海1&quot;); t.start(); //t1.setName(&quot;长沙2&quot;); t1.start(); &#125;&#125; 死锁 死锁——两个线程彼此占据着对方需要的资源，并且等待着对方释放资源。 死锁是由于线程间相互竞争资源或彼此通信而产生的一种阻塞现象，若没有外力作用，都将无法推进下去。 死锁线程：永远在相互等待的线程。 多线程通信线程通信：解决线程间的协同工作问题(彼此配合)Object类提供线程通信的方法 void wait()使当前线程放弃同步锁并进入等待，直到其他线程进入此同步锁，并调用notify()或notifyAll()方法唤醒该线程为止。 void notify()唤醒此同步锁上等待的第一个调用wait()方法的线程。 void notifyAll()唤醒此同步锁上等待的调用wait()方法的所有线程。 两个线程，假设分别为A和B，A线程用于“放入苹果”，而B线程用于“拿走苹果”；一次只能放一个；A线程放好后，就通知线程拿走；B拿到后，就通知A接着放；如果A线程没有放，则B线程不能拿。","path":"page/java11.html","date":"01-05","excerpt":"","tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://xiaoliblog.cn/tags/JavaSE/"}]},{"title":"Java👉泛型和枚举","text":"泛型泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数 使用 Java 泛型的概念，我们可以写一个泛型方法来对一个对象数组排序。然后，调用该泛型方法来对整型数组、浮点数数组、字符串数组等进行排序 泛型方法你可以写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。下面是定义泛型方法的规则： 所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的&lt;E&gt;）。 每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。 类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。 泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（像int,double,char的等）。 12345678910111213141516171819202122232425262728293031323334353637383940public class GenericMethodTest&#123; // 泛型方法 printArray public static &lt; E &gt; void printArray( E[] inputArray ) &#123; // 输出数组元素 for ( E element : inputArray )&#123; System.out.printf( &quot;%s &quot;, element ); &#125; System.out.println(); &#125; public static void main( String args[] ) &#123; // 创建不同类型数组： Integer, Double 和 Character Integer[] intArray = &#123; 1, 2, 3, 4, 5 &#125;; Double[] doubleArray = &#123; 1.1, 2.2, 3.3, 4.4 &#125;; Character[] charArray = &#123; &#x27;H&#x27;, &#x27;E&#x27;, &#x27;L&#x27;, &#x27;L&#x27;, &#x27;O&#x27; &#125;; System.out.println( &quot;整型数组元素为:&quot; ); printArray( intArray ); // 传递一个整型数组 System.out.println( &quot;\\n双精度型数组元素为:&quot; ); printArray( doubleArray ); // 传递一个双精度型数组 System.out.println( &quot;\\n字符型数组元素为:&quot; ); printArray( charArray ); // 传递一个字符型数组 &#125; &#125;/*整型数组元素为:1 2 3 4 5 双精度型数组元素为:1.1 2.2 3.3 4.4 字符型数组元素为:H E L L O */ 泛型类 泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。 和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。 1234567891011121314151617181920212223242526272829public class Box&lt;T&gt; &#123; private T t; public void add(T t) &#123; this.t = t; &#125; public T get() &#123; return t; &#125; public static void main(String[] args) &#123; Box&lt;Integer&gt; integerBox = new Box&lt;Integer&gt;(); Box&lt;String&gt; stringBox = new Box&lt;String&gt;(); integerBox.add(new Integer(10)); stringBox.add(new String(&quot;菜鸟教程&quot;)); System.out.printf(&quot;整型值为 :%d\\n\\n&quot;, integerBox.get()); System.out.printf(&quot;字符串为 :%s\\n&quot;, stringBox.get()); &#125;&#125;/*整型值为 :10字符串为 :菜鸟教程*/ 类型通配符 类型通配符一般是使用?代替具体的类型参数。例如 List&lt;?&gt; 在逻辑上是List&lt;String&gt;,List&lt;Integer&gt; 等所有List&lt;具体类型实参&gt;的父类。 12345678910111213141516171819202122232425262728import java.util.*; public class GenericTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; name = new ArrayList&lt;String&gt;(); List&lt;Integer&gt; age = new ArrayList&lt;Integer&gt;(); List&lt;Number&gt; number = new ArrayList&lt;Number&gt;(); name.add(&quot;icon&quot;); age.add(18); number.add(314); getData(name); getData(age); getData(number); &#125; public static void getData(List&lt;?&gt; data) &#123; System.out.println(&quot;data :&quot; + data.get(0)); &#125;&#125;/*data :icondata :18data :314*/ 因为getData()方法的参数是List类型的，所以name，age，number都可以作为这个方法的实参，这就是通配符的作用 类型通配符上限通过形如List来定义，如此定义就是通配符泛型值接受Number及其下层子类类型。 1234567891011121314151617181920212223242526272829303132import java.util.*; public class GenericTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; name = new ArrayList&lt;String&gt;(); List&lt;Integer&gt; age = new ArrayList&lt;Integer&gt;(); List&lt;Number&gt; number = new ArrayList&lt;Number&gt;(); name.add(&quot;icon&quot;); age.add(18); number.add(314); //getUperNumber(name);//1 getUperNumber(age);//2 getUperNumber(number);//3 &#125; public static void getData(List&lt;?&gt; data) &#123; System.out.println(&quot;data :&quot; + data.get(0)); &#125; public static void getUperNumber(List&lt;? extends Number&gt; data) &#123; System.out.println(&quot;data :&quot; + data.get(0)); &#125;&#125;/*data :18data :314*/ 在(//1)处会出现错误，因为getUperNumber()方法中的参数已经限定了参数泛型上限为Number，所以泛型为String是不在这个范围之内，所以会报错 类型通配符下限通过形如 List&lt;? super Number&gt;来定义，表示类型只能接受Number及其三层父类类型，如 Object 类型的实例。 枚举Java 枚举是一个特殊的类，一般表示一组常量，比如一年的 4 个季节，一个年的 12 个月份，一个星期的 7 天，方向有东南西北等。 Java 枚举类使用 enum 关键字来定义，各个常量使用逗号 , 来分割。 例如定义一个颜色的枚举类。 1234enum Color &#123; RED, GREEN, BLUE; &#125; 以上枚举类 Color 颜色常量有 RED, GREEN, BLUE，分别表示红色，绿色，蓝色。 1234567891011121314151617enum Color&#123; RED, GREEN, BLUE;&#125; public class Test&#123; // 执行输出结果 public static void main(String[] args) &#123; Color c1 = Color.RED; System.out.println(c1); &#125;&#125;/*RED*/ 内部类中使用枚举枚举类也可以声明在内部类中 1234567891011121314151617public class Test&#123; enum Color &#123; RED, GREEN, BLUE; &#125; // 执行输出结果 public static void main(String[] args) &#123; Color c1 = Color.RED; System.out.println(c1); &#125;&#125;/*RED*/ 每个枚举都是通过 Class 在内部实现的，且所有的枚举值都是 public static final 的。 以上的枚举类 Color 转化在内部类实现： 123456class Color&#123; public static final Color RED = new Color(); public static final Color BLUE = new Color(); public static final Color GREEN = new Color();&#125; 迭代枚举元素可以使用 for 语句来迭代枚举元素： 12345678910111213141516enum Color&#123; RED, GREEN, BLUE;&#125;public class MyClass &#123; public static void main(String[] args) &#123; for (Color myVar : Color.values()) &#123; System.out.println(myVar); &#125; &#125;&#125;/*REDGREENBLUE*/ 在 switch 中使用枚举类枚举类常应用于 switch 语句中： 123456789101112131415161718192021222324enum Color&#123; RED, GREEN, BLUE;&#125;public class MyClass &#123; public static void main(String[] args) &#123; Color myVar = Color.BLUE; switch(myVar) &#123; case RED: System.out.println(&quot;红色&quot;); break; case GREEN: System.out.println(&quot;绿色&quot;); break; case BLUE: System.out.println(&quot;蓝色&quot;); break; &#125; &#125;&#125;/*蓝色*/ 相关方法enum 定义的枚举类默认继承了java.lang.Enum类，并实现了 java.lang.Seriablizable 和 java.lang.Comparable 两个接口。 values(), ordinal() 和 valueOf() 方法位于 java.lang.Enum 类中： values() 返回枚举类中所有的值。 ordinal()方法可以找到每个枚举常量的索引，就像数组索引一样。 valueOf()方法返回指定字符串值的枚举常量。 123456789101112131415161718192021222324252627282930enum Color&#123; RED, GREEN, BLUE;&#125; public class Test&#123; public static void main(String[] args) &#123; // 调用 values() Color[] arr = Color.values(); // 迭代枚举 for (Color col : arr) &#123; // 查看索引 System.out.println(col + &quot; at index &quot; + col.ordinal()); &#125; // 使用 valueOf() 返回枚举常量，不存在的会报错 IllegalArgumentException System.out.println(Color.valueOf(&quot;RED&quot;)); // System.out.println(Color.valueOf(&quot;WHITE&quot;)); &#125;&#125;/*RED at index 0GREEN at index 1BLUE at index 2RED*/ 枚举类成员 枚举跟普通类一样可以用自己的变量、方法和构造函数，构造函数只能使用 private 访问修饰符，所以外部无法调用。 枚举既可以包含具体方法，也可以包含抽象方法。 如果枚举类具有抽象方法，则枚举类的每个实例都必须实现它。 123456789101112131415161718192021222324252627282930313233enum Color&#123; RED, GREEN, BLUE; // 构造函数 private Color() &#123; System.out.println(&quot;Constructor called for : &quot; + this.toString()); &#125; public void colorInfo() &#123; System.out.println(&quot;Universal Color&quot;); &#125;&#125; public class Test&#123; // 输出 public static void main(String[] args) &#123; Color c1 = Color.RED; System.out.println(c1); c1.colorInfo(); &#125;&#125;/*Constructor called for : REDConstructor called for : GREENConstructor called for : BLUEREDUniversal Color*/","path":"page/java06.html","date":"01-05","excerpt":"","tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://xiaoliblog.cn/tags/JavaSE/"}]},{"title":"Java👉异常机制","text":"异常处理异常是一个在程序执行期间发生的事件，它中断了正在执行的程序的正常指令流 Exception 所有的异常类是从 java.lang.Exception 类继承的子类 Exception 类是 Throwable 类的子类。除了Exception类外，Throwable还有一个子类Error 。 Error 用来指示运行时环境发生的错误。例如，JVM 内存溢出。一般地，程序不会从错误中恢复。 异常类有两个主要的子类：IOException 类和 RuntimeException 类。 Java 内置异常类Java 语言定义了一些异常类在 java.lang 标准包中 Java 根据各个类库也定义了一些其他的异常，下面的表中列出了 Java 的非检查性异常 异常 描述 ArithmeticException 当出现异常的运算条件时，抛出此异常。例如，一个整数”除以零”时，抛出此类的一个实例 ArrayIndexOutOfBoundsException 用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引 ArrayStoreException 试图将错误类型的对象存储到一个对象数组时抛出的异常 ClassCastException 当试图将对象强制转换为不是实例的子类时，抛出该异常 IllegalArgumentException 抛出的异常表明向方法传递了一个不合法或不正确的参数 IllegalMonitorStateException 抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程 IllegalStateException 在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下 IllegalThreadStateException 线程没有处于请求操作所要求的适当状态时抛出的异常 IndexOutOfBoundsException 指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出 NegativeArraySizeException 如果应用程序试图创建大小为负的数组，则抛出该异常 NullPointerException 当应用程序试图在需要对象的地方使用 null 时，抛出该异常 NumberFormatException 当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常 SecurityException 由安全管理器抛出的异常，指示存在安全侵犯 StringIndexOutOfBoundsException 此异常由 String 方法抛出，指示索引或者为负，或者超出字符串的大小 UnsupportedOperationException 当不支持请求的操作时，抛出该异常 下面的表中列出了 Java 定义在 java.lang 包中的检查性异常类。 异常 描述 ClassNotFoundException 应用程序试图加载类时，找不到相应的类，抛出该异常 CloneNotSupportedException 当调用 Object 类中的 clone 方法克隆对象，但该对象的类无法实现 Cloneable 接口时，抛出该异常 IllegalAccessException 拒绝访问一个类的时候，抛出该异常 InstantiationException 当试图使用 Class 类中的 newInstance 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常 InterruptedException 一个线程被另一个线程中断，抛出该异常 NoSuchFieldException 请求的变量不存在 NoSuchMethodException 请求的方法不存在 异常方法下面的列表是 Throwable 类的主要方法: 方法 说明 public String getMessage() 返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了 public Throwable getCause() 返回一个Throwable 对象代表异常原因 public String toString() 使用getMessage()的结果返回类的串级名字 public void printStackTrace() 打印toString()结果和栈层次到System.err，即错误输出流 public StackTraceElement [] getStackTrace() 返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底 public Throwable fillInStackTrace() 用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中 捕获异常使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。 1234567try&#123; // 程序代码&#125;catch(ExceptionName e1)&#123; //Catch 块&#125; 多重捕获块一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获 12345678910try&#123; // 程序代码&#125;catch(异常类型1 异常的变量名1)&#123; // 程序代码&#125;catch(异常类型2 异常的变量名2)&#123; // 程序代码&#125;catch(异常类型3 异常的变量名3)&#123; // 程序代码&#125; finally关键字 finally 关键字用来创建在 try 代码块后面执行的代码块。 无论是否发生异常，finally 代码块中的代码总会被执行。 在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。 finally 代码块出现在 catch 代码块最后，语法如下： 123456789ry&#123; // 程序代码&#125;catch(异常类型1 异常的变量名1)&#123; // 程序代码&#125;catch(异常类型2 异常的变量名2)&#123; // 程序代码&#125;finally&#123; // 程序代码&#125; throws/throw 关键字如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的 下面方法的声明抛出一个 RemoteException 异常： 1234567891011import java.io.*;public class className&#123; public void deposit(double amount) throws RemoteException &#123; // Method implementation throw new RemoteException(); &#125; //Remainder of class definition&#125; 一个方法可以声明抛出多个异常，多个异常之间用逗号隔开。例如，下面的方法声明抛出 RemoteException 和 InsufficientFundsException： 1234567891011import java.io.*;public class className&#123; public void withdraw(double amount) throws RemoteException, InsufficientFundsException &#123; // Method implementation &#125; //Remainder of class definition&#125; 声明自定义异常 在 Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。 所有异常都必须是 Throwable 的子类。 如果希望写一个检查性异常类，则需要继承 Exception 类。 如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。 可以像下面这样定义自己的异常类： 12class MyException extends Exception&#123;&#125; 以下实例是一个银行账户的模拟，通过银行卡的号码完成识别，可以进行存钱和取钱的操作 123456789101112131415161718// 文件名InsufficientFundsException.javaimport java.io.*; //自定义异常类，继承Exception类public class InsufficientFundsException extends Exception&#123; //此处的amount用来储存当出现异常（取出钱多于余额时）所缺乏的钱 private double amount; public InsufficientFundsException(double amount) &#123; this.amount = amount; &#125; public double getAmount() &#123; return amount; &#125;&#125; 为了展示如何使用我们自定义的异常类， 在下面的 CheckingAccount 类中包含一个 withdraw() 方法抛出一个 InsufficientFundsException 异常 12345678910111213141516171819202122232425262728293031323334353637383940414243/ 文件名称 CheckingAccount.javaimport java.io.*; //此类模拟银行账户public class CheckingAccount&#123; //balance为余额，number为卡号 private double balance; private int number; public CheckingAccount(int number) &#123; this.number = number; &#125; //方法：存钱 public void deposit(double amount) &#123; balance += amount; &#125; //方法：取钱 public void withdraw(double amount) throws InsufficientFundsException &#123; if(amount &lt;= balance) &#123; balance -= amount; &#125; else &#123; double needs = amount - balance; throw new InsufficientFundsException(needs); &#125; &#125; //方法：返回余额 public double getBalance() &#123; return balance; &#125; //方法：返回卡号 public int getNumber() &#123; return number; &#125;&#125; 下面的 BankDemo 程序示范了如何调用 CheckingAccount 类的 deposit() 和 withdraw() 方法 1234567891011121314151617181920212223//文件名称 BankDemo.javapublic class BankDemo&#123; public static void main(String [] args) &#123; CheckingAccount c = new CheckingAccount(101); System.out.println(&quot;Depositing $500...&quot;); c.deposit(500.00); try &#123; System.out.println(&quot;\\nWithdrawing $100...&quot;); c.withdraw(100.00); System.out.println(&quot;\\nWithdrawing $600...&quot;); c.withdraw(600.00); &#125;catch(InsufficientFundsException e) &#123; System.out.println(&quot;Sorry, but you are short $&quot; + e.getAmount()); e.printStackTrace(); &#125; &#125;&#125; 编译上面三个文件，并运行程序 BankDemo，得到结果如下所示： 123456789Depositing $500...Withdrawing $100...Withdrawing $600...Sorry, but you are short $200.0InsufficientFundsException at CheckingAccount.withdraw(CheckingAccount.java:25) at BankDemo.main(BankDemo.java:13) 通用异常 在Java中定义了两种类型的异常和错误。 JVM(Java虚拟机) 异常：由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类。 程序级异常：由程序或者API程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类。","path":"page/java12.html","date":"01-05","excerpt":"","tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://xiaoliblog.cn/tags/JavaSE/"}]},{"title":"Java👉集合框架","text":"集合框架集合框架图||深入了解Java集合框架 简化图 从上面的集合框架图可以看到，Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键/值对映射 所有集合类都位于java.util包下。Java的集合类主要由两个接口派生而出：Collection和Map，Collection和Map是Java集合框架的根接口，这两个接口又包含了一些子接口或实现类 集合接口：6个接口（短虚线表示），表示不同集合类型，是集合框架的基础。 抽象类：5个抽象类（长虚线表示），对集合接口的部分实现。可扩展为自定义集合类。 实现类：8个实现类（实线表示），对接口的具体实现。 Collection 接口是一组允许重复的对象。 Set 接口继承 Collection，集合元素不重复。 List 接口继承 Collection，允许重复，维护元素插入顺序。 Map接口是键－值对象，与Collection接口没有什么关系 Set、List和Map可以看做集合的三大类： List集合是有序集合，集合中的元素可以重复，访问集合中的元素可以根据元素的索引来访问。 Set集合是无序集合，集合中的元素不可以重复，访问集合中的元素只能根据元素本身来访问（也是集合里元素不允许重复的原因）。 Map集合中保存Key-value对形式的元素，访问时只能根据每项元素的key来访问其value。 总体分析 看上面的框架图，先抓住它的主干，即Collection和Map。 Collection是一个接口，是高度抽象出来的集合，它包含了集合的基本操作和属性。Collection包含了List和Set两大分支。 List是一个有序的队列，每一个元素都有它的索引。第一个元素的索引值是0。List的实现类有LinkedList, ArrayList, Vector, Stack。 Set是一个不允许有重复元素的集合。Set的实现类有HastSet和TreeSet。HashSet依赖于HashMap，它实际上是通过HashMap实现的；TreeSet依赖于TreeMap，它实际上是通过TreeMap实现的。 Map是一个映射接口，即key-value键值对。Map中的每一个元素包含“一个key”和“key对应的value”。AbstractMap是个抽象类，它实现了Map接口中的大部分API。而HashMap，TreeMap，WeakHashMap都是继承于AbstractMap。Hashtable虽然继承于Dictionary，但它实现了Map接口。 接下来，再看Iterator。它是遍历集合的工具，即我们通常通过Iterator迭代器来遍历集合。我们说Collection依赖于Iterator，是因为Collection的实现类都要实现iterator()函数，返回一个Iterator对象。ListIterator是专门为遍历List而存在的。 再看Enumeration，它是JDK 1.0引入的抽象类。作用和Iterator一样，也是遍历集合；但是Enumeration的功能要比Iterator少。在上面的框图中，Enumeration只能在Hashtable, Vector, Stack中使用。 最后，看Arrays和Collections。它们是操作数组、集合的两个工具类。 ArrayListArrayList 类是一个可以动态修改的数组，与普通数组的区别就是它是没有固定大小的限制，我们可以添加或删除元素。 ArrayList 继承了 AbstractList ，并实现了 List 接口。ArrayList 类位于 java.util 包中，使用前需要引入它，语法格式如下： 12import java.util.ArrayList; // 引入 ArrayList 类ArrayList&lt;E&gt; objectName =new ArrayList&lt;&gt;(); // 初始化 E: 泛型数据类型，用于设置 objectName 的数据类型，只能为引用数据类型。 objectName: 对象名。 添加元素添加元素到 ArrayList 可以使用 add() 方法: 123456789101112131415import java.util.ArrayList;public class RunoobTest &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; sites = new ArrayList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Weibo&quot;); System.out.println(sites); &#125;&#125;/*[Google, Runoob, Taobao, Weibo]*/ 访问元素访问 ArrayList中的元素 可以使用 get() 方法 123456789101112131415import java.util.ArrayList;public class RunoobTest &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; sites = new ArrayList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Weibo&quot;); System.out.println(sites.get(1)); // 访问第二个元素 &#125;&#125;/*Runoob*/ 修改元素修改 ArrayList元素 可以使用 set() 方法 12345678910111213141516import java.util.ArrayList;public class RunoobTest &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; sites = new ArrayList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Weibo&quot;); sites.set(2, &quot;Wiki&quot;); // 第一个参数为索引位置，第二个为要修改的值 System.out.println(sites); &#125;&#125;/*[Google, Runoob, Wiki, Weibo]*/ 删除元素删除ArrayList 中的元素可以使用 remove() 方法 12345678910111213141516import java.util.ArrayList;public class RunoobTest &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; sites = new ArrayList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Weibo&quot;); sites.remove(3); // 删除第四个元素 System.out.println(sites); &#125;&#125;/*[Google, Runoob, Taobao]*/ 计算大小计算ArrayList 中的元素数量可以使用 size() 方法 123456789101112131415import java.util.ArrayList;public class RunoobTest &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; sites = new ArrayList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Weibo&quot;); System.out.println(sites.size()); &#125;&#125;/*4*/ 迭代数组我们可以使用 for 来迭代数组列表中的元素： 1234567891011121314151617181920mport java.util.ArrayList;public class RunoobTest &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; sites = new ArrayList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Weibo&quot;); for (int i = 0; i &lt; sites.size(); i++) &#123; System.out.println(sites.get(i)); &#125; &#125;&#125;/*GoogleRunoobTaobaoWeibo*/ 也可以使用for-each来迭代元素： 1234567891011121314import java.util.ArrayList;public class RunoobTest &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; sites = new ArrayList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Weibo&quot;); for (String i : sites) &#123; System.out.println(i); &#125; &#125;&#125; ArrayList排序Collections 类也是一个非常有用的类，位于 java.util 包中，提供的 sort() 方法可以对字符或数字列表进行排序。 1234567891011121314151617181920212223import java.util.ArrayList;import java.util.Collections; // 引入 Collections 类public class RunoobTest &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; myNumbers = new ArrayList&lt;Integer&gt;(); myNumbers.add(33); myNumbers.add(15); myNumbers.add(20); myNumbers.add(34); myNumbers.add(8); myNumbers.add(12); Collections.sort(myNumbers); // 数字排序 for (int i : myNumbers) &#123; System.out.println(i); &#125; &#125;&#125;/*8 12 15 20 33 34*/ ArrayList方法 方法 说明 add() 将元素插入到指定位置的 arraylist 中 addAll() 添加集合中的所有元素到 arraylist 中 clear() 删除 arraylist 中的所有元素 clone() 复制一份 arraylist contains() 判断元素是否在 arraylist get() 通过索引值获取 arraylist 中的元素 indexOf() 返回 arraylist 中元素的索引值 removeAll() 删除存在于指定集合中的 arraylist 里的所有元素 remove() 删除 arraylist 里的单个元素 size() 返回 arraylist 里元素数量 isEmpty() 判断 arraylist 是否为空 subList() 截取部分 arraylist 的元素 set() 替换 arraylist 中指定索引的元素 sort() 对 arraylist 元素进行排序 toArray() 将 arraylist 转换为数组 toString() 将 arraylist 转换为字符串 ensureCapacity() 设置指定容量大小的 arraylist lastIndexOf() 返回指定元素在 arraylist 中最后一次出现的位置 retainAll() 保留 arraylist 中在指定集合中也存在的那些元素 containsAll() 查看 arraylist 是否包含指定集合中的所有元素 trimToSize() 将 arraylist 中的容量调整为数组中的元素个数 removeRange() 删除 arraylist 中指定索引之间存在的元素 replaceAll() 将给定的操作内容替换掉数组中每一个元素 removeIf() 删除所有满足特定条件的 arraylist 元素 forEach() 遍历 arraylist 中每一个元素并执行特定操作 更多 API 方法可以查看：https://www.runoob.com/manual/jdk11api/java.base/java/util/ArrayList.html LinkedList链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的地址。 链表可分为单向链表和双向链表。 一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接。 一个双向链表有三个整数值: 数值、向后的节点链接、向前的节点链接。 以下情况使用 ArrayList : 频繁访问列表中的某一个元素。 只需要在列表末尾进行添加和删除元素操作。 以下情况使用 LinkedList : 你需要通过循环迭代来访问列表中的某些元素。 需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。 LinkedList 类位于 java.util 包中，使用前需要引入它，语法格式如下： 123456// 引入 LinkedList 类import java.util.LinkedList; LinkedList&lt;E&gt; list = new LinkedList&lt;E&gt;(); // 普通创建方法或者LinkedList&lt;E&gt; list = new LinkedList(Collection&lt;? extends E&gt; c); // 使用集合创建链表 添加元素LinkedList使用add()、addFirst()、addLast()添加元素 123456789101112131415161718import java.util.LinkedList;public class RunoobTest &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; sites = new LinkedList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); // 使用 addFirst() 在头部添加元素 sites.addFirst(&quot;Wiki&quot;); // 使用 addLast() 在尾部添加元素 sites.addLast(&quot;Wiki&quot;); System.out.println(sites); &#125;&#125;/*[wiki,Google,Runoob,Taobao,wiki]*/ 移除元素LinkedList使用removeFirst、removeLast移除元素 1234567891011121314151617181920// 引入 LinkedList 类import java.util.LinkedList;public class RunoobTest &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; sites = new LinkedList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Weibo&quot;); // 使用 removeFirst() 移除头部元素 sites.removeFirst(); // 使用 removeLast() 移除尾部元素 sites.removeLast(); System.out.println(sites); &#125;&#125;/*[Runoob,Taobao]*/ 获取元素LinkedList使用getFirst()、getLast()获取元素 12345678910111213141516// 引入 LinkedList 类import java.util.LinkedList;public class RunoobTest &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; sites = new LinkedList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Weibo&quot;); // 使用 getFirst() 获取头部元素 System.out.println(sites.getFirst()); //Google // 使用 getLast() 获取尾部元素 System.out.println(sites.getLast()); //weibo &#125;&#125; 迭代元素我们可以使用 for 配合 size() 方法来迭代列表中的元素： 123456789101112131415161718192021// 引入 LinkedList 类import java.util.LinkedList;public class RunoobTest &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; sites = new LinkedList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Weibo&quot;); for (int size = sites.size(), i = 0; i &lt; size; i++) &#123; System.out.println(sites.get(i)); &#125; &#125;&#125;/*GoogleRunoobTaobaoWeibo*/ 也可以使用 for-each 来迭代元素： 123456789101112131415// 引入 LinkedList 类import java.util.LinkedList;public class RunoobTest &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; sites = new LinkedList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Weibo&quot;); for (String i : sites) &#123; System.out.println(i); &#125; &#125;&#125; LinkedList方法 方法 说明 public boolean add(E e) 链表末尾添加元素，返回是否成功，成功为 true，失败为 false public void add(int index, E element) 向指定位置插入元素 public boolean addAll(Collection c) 将一个集合的所有元素添加到链表后面，返回是否成功，成功为 true，失败为 false public boolean addAll(int index, Collection c) 将一个集合的所有元素添加到链表的指定位置后面，返回是否成功，成功为 true，失败为 false public void addFirst(E e) 元素添加到头部 public void addLast(E e) 元素添加到尾部 public boolean offer(E e) 向链表末尾添加元素，返回是否成功，成功为 true，失败为 false public boolean offerFirst(E e) 头部插入元素，返回是否成功，成功为 true，失败为 false public boolean offerLast(E e) 尾部插入元素，返回是否成功，成功为 true，失败为 false public void clear() 清空链表 public E removeFirst() 删除并返回第一个元素 public E removeLast() 删除并返回最后一个元素 public boolean remove(Object o) 删除某一元素，返回是否成功，成功为 true，失败为 false public E remove(int index) 删除指定位置的元素 public E poll() 删除并返回第一个元素 public E remove() 删除并返回第一个元素 public boolean contains(Object o) 判断是否含有某一元素 public E get(int index) 返回指定位置的元素 public E getFirst() 返回第一个元素 public E getLast() 返回最后一个元素 public int indexOf(Object o) 查找指定元素从前往后第一次出现的索引 public int lastIndexOf(Object o) 查找指定元素最后一次出现的索引 public E peek() 返回第一个元素 public E element() 返回第一个元素 public E peekFirst() 返回头部元素 public E peekLast() 返回尾部元素 public E set(int index, E element) 设置指定位置的元素 public Object clone() 克隆该列表 public Iterator descendingIterator() 返回倒序迭代器 public int size() 返回链表元素个数 public ListIterator listIterator(int index) 返回从指定位置开始到末尾的迭代器 public Object[] toArray() 返回一个由链表元素组成的数组 public T[] toArray(T[] a) 返回一个由链表元素转换类型而成的数组 更多 API 方法可以查看：https://www.runoob.com/manual/jdk11api/java.base/java/util/LinkedList.html HashSet HashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。 HashSet 允许有 null 值。 HashSet 是无序的，即不会记录插入的顺序。 HashSet 不是线程安全的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。 您必须在多线程访问时显式同步对 HashSet 的并发访问。 HashSet 实现了 Set 接口。 HashSet 类位于 java.util 包中，使用前需要引入它，语法格式如下： 12import java.util.HashSet; // 引入 HashSet 类HashSet&lt;String&gt; sites = new HashSet&lt;String&gt;(); 添加元素HashSet 类提供类很多有用的方法，添加元素可以使用 add() 方法: 1234567891011121314151617// 引入 HashSet 类 import java.util.HashSet;public class RunoobTest &#123; public static void main(String[] args) &#123; HashSet&lt;String&gt; sites = new HashSet&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Zhihu&quot;); sites.add(&quot;Runoob&quot;); // 重复的元素不会被添加 System.out.println(sites); &#125;&#125;/*[Google, Runoob, Zhihu, Taobao]*/ 判断元素是否存在我们可以使用 contains() 方法来判断元素是否存在于集合当中: 1234567891011121314151617// 引入 HashSet 类 import java.util.HashSet;public class RunoobTest &#123; public static void main(String[] args) &#123; HashSet&lt;String&gt; sites = new HashSet&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Zhihu&quot;); sites.add(&quot;Runoob&quot;); // 重复的元素不会被添加 System.out.println(sites.contains(&quot;Taobao&quot;)); &#125;&#125;/*true*/ 删除元素我们可以使用 remove() 方法来删除集合中的元素: 12345678910111213141516// 引入 HashSet 类 import java.util.HashSet;public class RunoobTest &#123; public static void main(String[] args) &#123; HashSet&lt;String&gt; sites = new HashSet&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Zhihu&quot;); sites.add(&quot;Runoob&quot;); // 重复的元素不会被添加 sites.remove(&quot;Taobao&quot;); // 删除元素，删除成功返回 true，否则为 false System.out.println(sites); &#125;&#125;/*[Google, Runoob, Zhihu]*/ 删除集合中所有元素可以使用 clear 方法： 12345678910111213141516// 引入 HashSet 类 import java.util.HashSet;public class RunoobTest &#123; public static void main(String[] args) &#123; HashSet&lt;String&gt; sites = new HashSet&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Zhihu&quot;); sites.add(&quot;Runoob&quot;); // 重复的元素不会被添加 sites.clear(); System.out.println(sites); &#125;&#125;/*[]*/ 计算大小如果要计算 HashSet 中的元素数量可以使用 size() 方法： 123456789101112131415// 引入 HashSet 类 import java.util.HashSet;public class RunoobTest &#123; public static void main(String[] args) &#123; HashSet&lt;String&gt; sites = new HashSet&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Zhihu&quot;); sites.add(&quot;Runoob&quot;); // 重复的元素不会被添加 System.out.println(sites.size()); &#125;&#125;//4 迭代HashSet可以使用 for-each 来迭代 HashSet 中的元素。 12345678910111213141516171819202122// 引入 HashSet 类 import java.util.HashSet;public class RunoobTest &#123; public static void main(String[] args) &#123; HashSet&lt;String&gt; sites = new HashSet&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Zhihu&quot;); sites.add(&quot;Runoob&quot;); // 重复的元素不会被添加 for (String i : sites) &#123; System.out.println(i); &#125; &#125;&#125;/*GoogleRunoobZhihuTaobao*/ 更多 API 方法可以查看：https://www.runoob.com/manual/jdk11api/java.base/java/util/HashSet.html IteratorJava Iterator（迭代器）不是一个集合，它是一种用于访问集合的方法，可用于迭代 ArrayList 和 HashSet 等集合。Iterator 是 Java 迭代器最简单的实现，ListIterator 是 Collection API 中的接口， 它扩展了 Iterator 接口。 迭代器 it 的两个基本操作是 next 、hasNext 和 remove。 调用 it.next() 会返回迭代器的下一个元素，并且更新迭代器的状态。 调用 it.hasNext() 用于检测集合中是否还有元素。 调用 it.remove() 将迭代器返回的元素删除。 Iterator 类位于 java.util 包中，使用前需要引入它，语法格式如下： 1import java.util.Iterator; // 引入 Iterator 类 获取一个迭代器集合想获取一个迭代器可以使用 iterator() 方法: 12345678910111213141516171819202122// 引入 ArrayList 和 Iterator 类import java.util.ArrayList;import java.util.Iterator;public class RunoobTest &#123; public static void main(String[] args) &#123; // 创建集合 ArrayList&lt;String&gt; sites = new ArrayList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Zhihu&quot;); // 获取迭代器 Iterator&lt;String&gt; it = sites.iterator(); // 输出集合中的第一个元素 System.out.println(it.next()); &#125;&#125;/*Google*/ 循环集合元素让迭代器 it 逐个返回集合中所有元素最简单的方法是使用 while 循环： 123456789101112131415161718192021222324252627282930// 引入 ArrayList 和 Iterator 类import java.util.ArrayList;import java.util.Iterator;public class RunoobTest &#123; public static void main(String[] args) &#123; // 创建集合 ArrayList&lt;String&gt; sites = new ArrayList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Zhihu&quot;); // 获取迭代器 Iterator&lt;String&gt; it = sites.iterator(); // 输出集合中的所有元素 while(it.hasNext()) &#123; System.out.println(it.next()); &#125; &#125;&#125;/*GoogleRunoobTaobaoZhihu*/","path":"page/java07.html","date":"01-05","excerpt":"","tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://xiaoliblog.cn/tags/JavaSE/"}]},{"title":"Java👉面向对象","text":"面向对象类实质上是封装对象属性和行为的载体，对象则是类抽象出来的一个实例,类是静态的概念，而对象则是一个动态的概念，因为只有运行时才给对象分配空间，对象才真正存在。 面向对象：是一种通过对象的方式，把现实世界映射到计算机模型的一种编程方法。 面向过程：是把模型分解成一步一步的过程。 面向对象程序设计具有以下特点： 封装性：解决了数据的安全性问题。 继承性：解决了代码的重用问题。 多态性：解决了程序的扩展问题。 类和对象对象：对象是类的一个实例，有状态和行为。例如人的状态有名字、年龄，行为有吃饭、睡觉类：类是一个模板，它描述一类对象的行为和状态。 下图图中汽车为类（class），而具体的每个人车该类的对象（object），对象包含含来汽车的颜色、品牌、名称等： 类 类是一系列对象的抽象。 类是变量和方法的集合体。 类是Java中基本的结构单元。所有的Java语句均出现在类中，所有的方法均在类中定义。 12345678910111213141516171819public class Dog &#123; String breed; int size; String colour; int age; void eat() &#123; &#125; void run() &#123; &#125; void sleep()&#123; &#125; void name()&#123; &#125;&#125; 一个类可以包含以下类型变量： 局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。 成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。 类变量：类变量也声明在类中，方法体之外，但必须声明为 static 类型。 构造方法 构造方法没有返回值,不需要写void,只用public声明。 构造方法名称要与本类的名称相同。 一旦为类编写构造方法,默认的构造方法将会被覆盖。 编写构造方法的目的是向对象传递参数(一般有参),以及对成员变量进行初始化(一般无参)。 构造方法同样支持方法重载。 构造方法不能被static,final,abstract,synchronized,native等修饰符修饰。 构造方法中只能使用成员变量，而且当参数与成员变量同名时，只能用关键字this指明当前对象。 构造方法不能被程序直接调用。 1234567891011121314151617class Apple &#123; int sum; String color; public Apple()&#123;&#125;; public Apple(int sum)&#123;&#125;; public Apple(String color)&#123;&#125;; public Apple(int sum,String color)&#123;&#125;;&#125;public class createApple &#123; public static void main(String[] args) &#123; Apple apple1 = new Apple(); Apple apple2 = new Apple(1); Apple apple3 = new Apple(&quot;red&quot;); Apple apple4 = new Apple(2,&quot;color&quot;); &#125;&#125; 创建对象象是根据类创建的。在Java中，使用关键字 new 来创建一个新的对象。创建对象需要以下三步： 声明：声明一个对象，包括对象名称和对象类型。 实例化：使用关键字 new 来创建一个对象。 初始化：使用 new 创建对象时，会调用构造方法初始化对象。 1234567891011public class Puppy&#123; public Puppy(String name)&#123; //这个构造器仅有一个参数：name System.out.println(&quot;小狗的名字是 : &quot; + name ); &#125; public static void main(String[] args)&#123; // 下面的语句将创建一个Puppy对象 Puppy myPuppy = new Puppy( &quot;tommy&quot; ); &#125;&#125; 访问实例变量和方法 通过已创建的对象来访问成员变量和成员方法，如下所示： 123456/* 实例化对象 */Object referenceVariable = new Constructor();/* 访问类中的变量 */referenceVariable.variableName;/* 访问类中的方法 */referenceVariable.methodName(); 封装封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。 修改属性的可见性来限制对属性的访问（一般限制为private），例如： 1234public class Person &#123; private String name; private int age;&#125; 这段代码中，将 name 和 age 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问，例如： 12345678910111213141516public class Person&#123; private String name; private int age; public int getAge()&#123; return age; &#125; public String getName()&#123; return name; &#125; public void setAge(int age)&#123; this.age = age; &#125; public void setName(String name)&#123; this.name = name; &#125;&#125; 采用 this关键字是为了解决实例变量（private String name）和局部变量（setName(String name)中的name变量）之间发生的同名的冲突。 访问控制符 继承继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 语法在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的，一般形式如下： 12345class 父类 &#123;&#125;class 子类 extends 父类 &#123;&#125; 继承类型 继承的特性 子类拥有父类非 private 的属性、方法。 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。 Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 B 类继承 A 类，C 类继承 B 类，所以按照关系就是 B 类是 C 类的父类，A 类是 B 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。 继承关键字继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 java.lang 包中，所以不需要 import）祖先类。 extends在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。 1234567891011121314public class Animal &#123; private String name; private int id; public Animal(String myName, String myid) &#123; //初始化属性值 &#125; public void eat() &#123; //吃东西方法的具体实现 &#125; public void sleep() &#123; //睡觉方法的具体实现 &#125; &#125; public class Penguin extends Animal&#123; &#125; implements使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。 123456789101112public interface A &#123; public void eat(); public void sleep();&#125; public interface B &#123; public void show();&#125; public class C implements A,B &#123;&#125; super与thissuper关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。this关键字：指向自己的引用。 123456789101112131415161718192021222324252627282930class Animal &#123; void eat() &#123; System.out.println(&quot;animal : eat&quot;); &#125;&#125; class Dog extends Animal &#123; void eat() &#123; System.out.println(&quot;dog : eat&quot;); &#125; void eatTest() &#123; this.eat(); // this 调用自己的方法 super.eat(); // super 调用父类方法 &#125;&#125; public class Test &#123; public static void main(String[] args) &#123; Animal a = new Animal(); a.eat(); Dog d = new Dog(); d.eatTest(); &#125;&#125;/*animal : eatdog : eatanimal : eat*/ finalfinal 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写： 声明类 1final class 类名 &#123;//类体&#125; 声明方法修饰符(public/private/default/protected) final 返回值类型 方法名()&#123;//方法体&#125; 实例变量也可以被定义为 final，被定义为 final 的变量不能被修改。被声明为 final 类的方法自动地声明为 final，但是实例变量并不是 final staticstatic可以用来修饰成员变量和方法。 静态变量，也成为类变量。静态变量不需要类的实例化就可以被类直接调用。 1static String name=&quot;zhangsan&quot;; 静态方法，就是没有this的方法，可以直接使用类名.方法名进行调用。静态方法不依赖任何对象直接访问，在静态方法中不能访问类的非静态成员变量和非静态方法。 123static void printMessage()&#123;System.out.println(&quot;cxuan is writing the article&quot;);&#125; 静态代码块,可用于类的初始化操作。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。 12345public class StaicBlock &#123;static&#123;System.out.println(&quot;I&#x27;m A static code block&quot;);&#125;&#125; Override/Overload重写(Override)重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！ 重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。 重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。 1234567891011class Fruit &#123; public void eat()&#123; System.out.printl(&#x27;eat fruit&#x27;); &#125;&#125;class Apple extends Fruit&#123; @Override public void eat()&#123; System.out.printl(&#x27;eat apple&#x27;); &#125;&#125; 方法的重写规则 参数列表与被重写方法的参数列表必须完全相同。 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。 父类的成员方法只能被它的子类重写。 声明为 final 的方法不能被重写。 声明为 static 的方法不能被重写，但是能够被再次声明。 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 构造方法不能被重写。 如果不能继承一个类，则不能重写该类的方法。 Super当需要在子类中调用父类的被重写方法时，要使用 super 关键字。 1234567891011121314151617181920212223242526class Animal&#123; public void move()&#123; System.out.println(&quot;动物可以移动&quot;); &#125;&#125; class Dog extends Animal&#123; public void move()&#123; super.move(); // 应用super类的方法 System.out.println(&quot;狗可以跑和走&quot;); &#125;&#125; public class TestDog&#123; public static void main(String args[])&#123; Animal b = new Dog(); // Dog 对象 b.move(); //执行 Dog类的方法 &#125;&#125;/*动物可以移动狗可以跑和走*/ 重载(Overload)重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。 重载规则 被重载的方法必须改变参数列表(参数个数或类型不一样)； 被重载的方法可以改变返回类型； 被重载的方法可以改变访问修饰符； 被重载的方法可以声明新的或更广的检查异常； 方法能够在同一个类中或者在一个子类中被重载。 无法以返回值类型作为重载函数的区分标准。 1234567891011121314151617181920212223public class Test &#123; public static int add(int a,int b) &#123; return a+b; &#125; public static double add(double a,double b) &#123; return a+b; &#125; public static int add(int a) &#123; return a; &#125; public static int add(int a,double b) &#123; return 1; &#125; public static int add(double a,int b) &#123; return 1; &#125; public static void main(String[] args) &#123; System.out.println(&quot;调用add(int,int)方法:&quot;+add(1,2)); System.out.println(&quot;调用add(double,double)方法:&quot;+add(1.3,2.2)); System.out.println(&quot;调用add(int)方法:&quot;+add(1)); &#125;&#125; 区别 多态多态是同一个行为具有多个不同表现形式或形态的能力。 多态就是同一个接口，使用不同的实例而执行不同操作，如图所示： 必要条件多态存在的三个必要条件 继承 重写 父类引用指向子类对象：Parent p = new Child(); 123456789101112131415161718192021class Shape &#123; void draw() &#123;&#125;&#125; class Circle extends Shape &#123; void draw() &#123; System.out.println(&quot;Circle.draw()&quot;); &#125;&#125; class Square extends Shape &#123; void draw() &#123; System.out.println(&quot;Square.draw()&quot;); &#125;&#125; class Triangle extends Shape &#123; void draw() &#123; System.out.println(&quot;Triangle.draw()&quot;); &#125;&#125; 抽象类在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。 只要类中有一个抽象方法，此类就被标记为抽象类 抽象类除了不能实例化对象，只能用来继承 抽象类的子类必须重写抽象类中的所有抽象方法。 在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。 在Java语言中使用abstract class来定义抽象类123public abstract class Test&#123; abstract void testAbstract();//定义抽象方法&#125; 接口 某个类中所有方法都为抽象方法，此类可定义为接口。关键字interface。 接口不可以实例化，只能用关键字implements实现。某个类可以实现多个接口。 如果父类使用了某个接口，则子类也就自然使用了该接口，子类不必再使用implements声明自己使用这个接口。 接口可以被继承，可以通过关键字extends声明一个接口是另一个接口的子接口。子接口将继承父接口中的全部方法和常量。 如果一个类声明实现一个接口，但没有实现接口中的所有方法，那么这个类必须是抽象类。 类在实现接口方法时必须给出方法体，一定要用public修饰。 123456789101112public interface MyInterface&#123; public int add(int x,int y); public int sub(int x,int y);&#125;public class Myclass implements MyInterface&#123; public int add(int x,int y)&#123; //实现接口中的方法。 return x+y; &#125; public int sub(int x,int y)&#123; return x-y; &#125;&#125; 区别 接口与类相似点 一个接口可以有多个方法。 接口文件保存在 .java 结尾的文件中，文件名使用接口名。 接口的字节码文件保存在 .class 结尾的文件中。 接口相应的字节码文件必须在与包名称相匹配的目录结构中。 接口与类的区别 接口不能用于实例化对象。 接口没有构造方法。 接口中所有的方法必须是抽象方法。 接口不能包含成员变量，除了 static 和 final 变量。 接口不是被类继承了，而是要被类实现。 接口支持多继承。 接口特性 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。 接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。 抽象类和接口的区别 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。 一个类只能继承一个抽象类，而一个类却可以实现多个接口。","path":"page/java08.html","date":"01-05","excerpt":"","tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://xiaoliblog.cn/tags/JavaSE/"}]},{"title":"Java👉核心基础","text":"Java简介 Java最早是由SUN公司（已被Oracle收购）的詹姆斯·高斯林（高司令，人称Java之父）在上个世纪90年代初开发的一种编程语言。 Java 主要分为三个版本： JavaSE(J2SE)(Java2 Platform Standard Edition，java平台标准版) JavaEE(J2EE)(Java 2 Platform,Enterprise Edition，java平台企业版) JavaME(J2ME)(Java 2 Platform Micro Edition，java平台微型版)。 Java的特点 跨平台性：跨平台性是指软件可以不受计算机硬件和操作系统的约束而在任意计算机环境下正常运行。 Java自带的虚拟机很好地实现了跨平台性。 .面向对象：面向对象(Objiect Oriented)是一种软件开发思想。它是对现实世界的一种抽象，面向对象会把相关的数据和方法组织为一个整体看待。不用像面向过程那样严格按照顺序来执行每个动作。 健壮性：Java的强类型机制、异常处理、垃圾的自动收集等是Java程序健壮性的重要保证。 多线程：是一种轻量级进程，是现代程序设计中必不可少的一种特性。多线程处理能力使得程序能够具有更好的交互性、实时性。 Java运行机制 Java语言编写的程序既是编译型的，又是解释型。 运行期环境代表着Java平台，开发人员编写Java代码(.java文件)，然后用Java编译器将之编译成字节码(.class文件)，JVM才能识别并运行它（编译只进行一次，而解释在每次运行程序时都会进行） JVM针对每个操作系统开发其对应的解释器，所以只要其操作系统有对应版本的JVM，那么这份Java编译后的代码就能够运行起来，这就是Java能一次编译，到处运行的原因 *.java-&gt;*.class-&gt;字节码-&gt;机器码 相关概念 JVM(Java Virtual Machine)：Java虚拟机，使软件在不同操作系统中，模拟相同的环境。 JRE(Java Runtime Environment)：Java运行环境,包含JVM和解释器，完整的运行环境. JDK(Java Development Kit)：Java开发工具包，包含JRE+类+开发工具包 API(Application Programming Interface)：程序编程接口，JavaAPI文档是Java程序员开发不可缺少的编程辞典。 环境变量 开发Java需要JDK和编程工具 JDK下载:Oracle公司官方网站 Eclipse开发工具下载 配置环境变量的原因：系统不知道去哪找JDK 【我的电脑】-&gt;【属性】-&gt;【高级系统设置】-&gt;【环境变量】 第一步：新建JAVA_HOME变量名，并找到JDK路径作为变量值 第二步：新建CLASSPATH变量名，并把(.)作为变量值，指代当前路径。 根据CLASSPATH环境变量定位类，在JDK1.4版本以前需要设置CLASSPATH变量值为(.)，用以告诉JRE需要在当前路径下搜索Java类。 第三步：找到Path目录，把JDK下bin目录作为新建值，bin目录下有Java命令工具，此Path路径告诉计算机所用Java指令去哪找。 Windows操作系统是根据Path环境变量来查找命令，Path环境变量的值是一系列路径，根据路径查找。 变量和常量变量是在程序的运行过程中其值可以被改变的量 Java中的变量遵循先声明、后赋值、再使用的原则。声明的作用有两点： 确定该变量的标识符(即名称)，以便系统为它指定存储地址和识别它，这便是“按名访问”原则 为该变量指定数据类型，以便系统为它分配足够的存储单元 12int x=45; //实例变量static int y=90; //静态变量 常量是指在程序的整个运行过程中其值始终保持不变的量 Java语言用final 关键字来定义常量。 1final static double PI=3.1415; 数据类型在Java中，数据类型只有四类八种 整数型：byte、short、int、long 浮点型：float和double 字符型：char 布尔型：boolean 数据类型 关键字 内存占用 取值范围 字节型 byte 1个字节 -128~127 短整型 short 2个字节 -32768~32767 整型 int（默认） 4个字节 -231次方~2的31次方-1 长整型 long 8个字节 -2的63次方~2的63次方-1 单精度浮点数 float 4个字节 1.4013E-45~3.4028E+38 双精度浮点数 double（默认） 8个字节 4.9E-324~1.7977E+308 字符型 char 2个字节 0-65535 布尔类型 boolean 1个字节 true，false Java中的默认类型：整数类型是 int 、浮点类型是 double 大小写敏感 类名：首字母大写，例如MyFirstClass 包名：包名尽量小写,例如my.first.package 方法命：首字母小写，后面每个单词字母都需要大写，例如myFirstMethod() 自动转换 自动转换：将取值范围小的类型自动提升为取值范围大的类型 12345678public static void main(String[] args) &#123; int i = 1; byte b = 2; // byte x = b + i; // 报错 //int类型和byte类型运算，结果是int类型 int j = b + i; System.out.println(j);&#125; byte 类型内存占有1个字节，在和 int 类型运算时会提升为 int 类型 ，自动补充3个字节，因此计算后的结果还是 int 类型 同样道理，当一个 int 类型变量和一个 double 变量运算时， int 类型将会自动提升为 double 类型进行运算 12345678public static void main(String[] args) &#123; int i = 1; double d = 2.5; //int类型和double类型运算，结果是double类型 //int类型会提升为double类型 double e = d+i; System.out.println(e);&#125; 范围小的类型向范围大的类型提升， byte 、short、char 运算时直接提升为 int 1byte、short、char‐‐&gt;int‐‐&gt;long‐‐&gt;float‐‐&gt;double 强制转换 强制转换：将取值范围大的类型 强制转换成 取值范围小的类型 转换格式 123数据类型 变量名 = （数据类型）被转数据值；// double类型数据强制转成int类型，直接去掉小数点。int i = (int)1.5 当一个 short 类型与 1 相加，我们知道会类型提升，但是还想给结果赋值给short类型变量，就需要强制转换 12345678910111213public static void main(String[] args) &#123; //short类型变量，内存中2个字节 short s = 1; /* 出现编译失败 s和1做运算的时候，1是int类型，s会被提升为int类型 s+1后的结果是int类型，将结果在赋值会short类型时发生错误 short内存2个字节，int类型4个字节 必须将int强制转成short才能完成赋值 */ s = s + 1；//编译失败 s = (short)(s+1);//编译成功&#125; 浮点转成整数，直接取消小数点，可能造成数据损失精度。 int 强制转成 short 砍掉2个字节，可能造成数据丢失 运算符算数运算符 算数运算符 说明 + 加法运算，字符串连接运算 - 减法运算 * 乘法运算 / 除法运算 % 取模运算，两个数字相除取余数 ++、-- 自增自减运算 ++ 运算，变量自己增长1。反之，-- 运算，变量自己减少1，用法与 ++ 一致 变量在独立运算时， 前 ++ 和 后 ++ 没有区别 和其他变量放在一起， 前 ++ 和 后 ++ 就产生了不同 变量 前 ++ ：变量a自己加1，将加1后的结果赋值给b，也就是说a先计算。a和b的结果都是2 1234567891011121314151617public static void main(String[] args) &#123; int a = 1; int b = ++a; System.out.println(a);//计算结果是2 System.out.println(b);//计算结果是2&#125;````- 变量 后 `++` ：变量a先把自己的值1，赋值给变量b，此时变量b的值就是1，变量a自己再加1。a的结果是2，b的结果是1```javapublic static void main(String[] args) &#123; int a = 1; int b = a++; System.out.println(a);//计算结果是2 System.out.println(b);//计算结果是1&#125; + 符号在遇到字符串的时候，表示连接、拼接的含义 123public static void main(String[] args)&#123; System.out.println(&quot;5+5=&quot;+5+5);//输出5+5=55 &#125; 赋值运算符 赋值运算符 说明 = 等于号 += 加等于 -= 减等于 *= 乘等于 /= 除等于 %= 取模等 赋值运算符，就是将符号右边的值，赋给左边的变量 12345public static void main(String[] args)&#123; int i = 5; i+=5;//计算方式 i=i+5 变量i先加5，再赋值变量i System.out.println(i); //输出结果是10&#125; 比较运算符 比较运算符 说明 == 比较符号两边数据是否相等，相等结果是true &lt; 比较符号左边的数据是否小于右边的数据，如果小于结果是true &gt; 比较符号左边的数据是否大于右边的数据，如果大于结果是true &lt;= 比较符号左边的数据是否小于或者等于右边的数据，如果小于结果是true &gt;= 比较符号左边的数据是否大于或者等于右边的数据，如果小于结果是true != 不等于符号 ，如果符号两边的数据不相等，结果是true 比较运算符，是两个数据之间进行比较的运算，运算结果都是布尔值 true 或者 false 12345678public static void main(String[] args) &#123; System.out.println(1==1);//true System.out.println(1&lt;2);//true System.out.println(3&gt;4);//false System.out.println(3&lt;=4);//true System.out.println(3&gt;=4);//false System.out.println(3!=4);//true&#125; 逻辑运算符 逻辑运算符，是用来连接两个布尔类型结果的运算符，运算结果都是布尔值 true 或者 false 1234567891011public static void main(String[] args) &#123; System.out.println(true &amp;&amp; true);//true System.out.println(true &amp;&amp; false);//false System.out.println(false &amp;&amp; true);//false，右边不计算 System.out.println(false || false);//falase System.out.println(false || true);//true System.out.println(true || false);//true，右边不计算 System.out.println(!false);//true&#125; 三元运算符1数据类型 变量名 = 布尔类型表达式？结果1：结果2 布尔类型表达式结果是 true，三元运算符整体结果为结果1，赋值给变量。 布尔类型表达式结果是 false，三元运算符整体结果为结果2，赋值给变量 123456public static void main(String[] args) &#123; int i = (1==2 ? 100 : 200); System.out.println(i);//200 int j = (3&lt;=4 ? 500 : 600); System.out.println(j);//500&#125; 流程控制顺序结构 if条件语句 12345int a = 10;if(a &gt; 10)&#123;return true;&#125;return false; if…else条件语句 1234567int year=(int)(Math.random()*2000)+1;System.out.println(&quot;The year is:&quot;+year);if(year%4==0 &amp;&amp; year%100!=0 ||year%400==0)System.out.println(year+&quot;年是闰年!&quot;);else System.out.println(year+&quot;年不是闰年!&quot;);&#125; if…else if 多分支语句 123456789101112//多条件判断int x = 40;if(x &gt; 60) &#123;System.out.println(&quot;x的值大于60&quot;);&#125; else if (x &gt; 30) &#123;System.out.println(&quot;x的值大于30但小于60&quot;);&#125; else if (x &gt; 0) &#123;System.out.println(&quot;x的值大于0但小于30&quot;);&#125; else &#123;System.out.println(&quot;x的值小于等于0&quot;);&#125; 选择语句 switch分支语句 123456789101112131415//判断整数类型switch (option) &#123;case 3: ... break;case 2: ... break;case 1: ... break;default: ... break;&#125; 表达式option只能返回几个数据类型的值：int、short、byte、charcase子句中的值必须是常量，而且所有case子句中的值是不同的 循环结构 While 循环while循环通常用于循环次数不确定的情况，也可以用于循环次数确定的情况。利用一个条件来判断是否反复执行这个语句。 1234while (条件表达式) &#123; //条件为true，执行循环语句，条件为false退出循环。 循环语句&#125;// 继续执行后续代码 1234int a = 10;while(a &gt; 5)&#123; a--;&#125; do while循环 123do &#123; //先执行循环，再判断条件 执行循环语句&#125; while (条件表达式); 123456nt b = 10;// do···while循环语句do &#123; System.out.println(&quot;b == &quot; + b); b--;&#125; while(b == 1); for循环for循环执行时，首先执行初始化操作，然后判断终止条件是否被满足，如果满足执行循环体，最后执行迭代运算。完成一次循环后，重新判断终止条件。 123for (初始化; 循环检测条件; 迭代运算) &#123; // 执行语句&#125; for each循环（增强for） 1234int array[] = &#123;7, 8, 9&#125;;for (int arr : array) &#123; System.out.println(arr);&#125; 跳出语句 break 用于强行退出当前循环 12345for(int i = 0;i &lt; 10;i++)&#123; if(i == 5)&#123; //i=5跳出循环 break; &#125;&#125; continue 用于执行下一次循环。 1234567for(int i = 0;i &lt; 10;i++)&#123; System.out.printl(&quot; i = &quot; + i ); if(i == 5)&#123; //执行下一次循环 System.out.printl(&quot;continue ... &quot;); continue; &#125;&#125; 包装类Java为了能将基本数据类型视为对象处理，并能连接相关的方法，为每个数据类型都提供了包装类。 所有的包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类 Number 的子类。 这种由编译器特别支持的包装称为装箱，所以当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。相似的，编译器也可以把一个对象拆箱为内置类型。Number 类属于 java.lang 包。 12345678910public class Test&#123; public static void main(String[] args)&#123; Integer x = 5; x = x + 10; System.out.println(x); &#125;&#125;/*15*/ String类在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。 12345String s1 = &quot;Runoob&quot;; // String 直接创建String s2 = &quot;Runoob&quot;; // String 直接创建String s3 = s1; // 相同引用String s4 = new String(&quot;Runoob&quot;); // String 对象创建String s5 = new String(&quot;Runoob&quot;); // String 对象创建 方法 说明 str.length() 返回字符串长度 str.indexOf(substr) 返回指定字符串首次出现的索引位置。没有找到返回-1,字符串下标0~length()-1 str.lastIndexOf(String str) 返回指定字符串最后一次出现的索引位置，没有找到返回-1 str.charAt(int index) 返回指定索引处的字符 str.substring(int beginIndex) 获取从指定位置开始截取到该字符串结尾的子串 str.substring(int beginIndex,int endIndex) 获取从指定位置开始截取到某一位置的子串 str.trim() 返回字符串的副本，忽略前后空格 str.replace(char old,char new) 将指定字符串或字符替换为新字符串或字符 str.startsWith(String s) 判断是否以s开头 str.endsWith(String s) 判断是否以s结尾 str1.equals(str2) 比较是否有相同的字符和长度 str1.equalsIgnoreCase(str2) 不区分大小写比较 str.toLowerCase() 转为小写 str.toUpperCase() 转为大写 String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了如果需要对字符串做很多修改，那么应该选择使用 StringBuffer &amp; StringBuilder 类。 StringBuffer当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。 和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。 在使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，所以如果需要对字符串进行修改推荐使用 StringBuffer。 StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。 由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。 12345678910111213141516171819public class RunoobTest&#123; public static void main(String args[])&#123; StringBuilder sb = new StringBuilder(10); sb.append(&quot;Runoob..&quot;); System.out.println(sb); sb.append(&quot;!&quot;); System.out.println(sb); sb.insert(8, &quot;Java&quot;); System.out.println(sb); sb.delete(5,8); System.out.println(sb); &#125;&#125;/*Runoob..Runoob..!Runoob..Java!RunooJava!*/ 然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。 123456789101112public class Test&#123; public static void main(String args[])&#123; StringBuffer sBuffer = new StringBuffer(&quot;菜鸟教程官网：&quot;); sBuffer.append(&quot;www&quot;); sBuffer.append(&quot;.runoob&quot;); sBuffer.append(&quot;.com&quot;); System.out.println(sBuffer); &#125;&#125;/*菜鸟教程官网：www.runoob.com*/ StringBuffer方法 说明 public StringBuffer append(String s) 将指定的字符串追加到此字符序列 public StringBuffer reverse() 将此字符序列用其反转形式取代 public delete(int start, int end) 移除此序列的子字符串中的字符 public insert(int offset, int i) 将 int 参数的字符串表示形式插入此序列中 replace(int start, int end, String str) 使用给定 String 中的字符替换此序列的子字符串中的字符 除以上几种方法外，其他方法与String类似 数组Java 语言中提供的数组是用来存储固定大小的同类型元素。 123456789101112131415161718192021222324ublic class TestArray &#123; public static void main(String[] args) &#123; // 数组大小 int size = 10; // 定义数组 double[] myList = new double[size]; myList[0] = 5.6; myList[1] = 4.5; myList[2] = 3.3; myList[3] = 13.2; myList[4] = 4.0; myList[5] = 34.33; myList[6] = 34.0; myList[7] = 45.45; myList[8] = 99.993; myList[9] = 11123; // 计算所有元素的总和 double total = 0; for (int i = 0; i &lt; size; i++) &#123; total += myList[i]; &#125; System.out.println(&quot;总和为： &quot; + total); &#125;&#125; 处理数组数组的元素类型和数组的大小都是确定的，所以当处理数组元素时候，我们通常使用基本循环或者 For-Each 循环 1234567891011public class TestArray &#123; public static void main(String[] args) &#123; double[] myList = &#123;1.9, 2.9, 3.4, 3.5&#125;; // 打印所有数组元素 for (double element: myList) &#123; System.out.println(element); &#125; &#125;&#125; Arrays类java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。 方法 说明 public static int binarySearch(Object[] a, Object key) 用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(插入点) - 1) public static boolean equals(long[] a, long[] a2) 如果两个指定的 long 型数组彼此相等，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等） public static void fill(int[] a, int val) 将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等） public static void sort(Object[] a) 对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等） 日期和时间Date类java.util 包提供了 Date 类来封装当前的日期和时间。 Date 类提供两个构造函数来实例化 Date 对象。 1Date dt=new Date(); 方法 说明 boolean after(Date date) 若当调用此方法的Date对象在指定日期之后返回true,否则返回false boolean before(Date date) 若当调用此方法的Date对象在指定日期之前返回true,否则返回false Object clone( ) 返回此对象的副本 int compareTo(Date date) 比较当调用此方法的Date对象和指定日期。两者相等时候返回0。调用对象在指定日期之前则返回负数。调用对象在指定日期之后则返回正数 int compareTo(Object obj) 若obj是Date类型则操作等同于compareTo(Date) 。否则它抛出ClassCastException boolean equals(Object date) 当调用此方法的Date对象和指定日期相等时候返回true,否则返回false long getTime( ) 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数 int hashCode( ) 返回此对象的哈希码值 void setTime(long time) 用自1970年1月1日00:00:00 GMT以后time毫秒数设置时间和日期 String toString( ) 把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat) 123456789101112131415import java.util.Date; public class DateDemo &#123; public static void main(String args[]) &#123; // 初始化 Date 对象 Date date = new Date(); // 使用 toString() 函数显示日期时间 System.out.println(date.toString()); &#125;&#125;/*Mon May 04 09:51:52 CDT 2013*/ SimpleDateFormat 格式化日期SimpleDateFormat 是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat 允许你选择任何用户自定义日期时间格式来运行 12345678910111213141516import java.util.*;import java.text.*; public class DateDemo &#123; public static void main(String args[]) &#123; Date dNow = new Date( ); SimpleDateFormat ft = new SimpleDateFormat (&quot;yyyy-MM-dd hh:mm:ss&quot;); System.out.println(&quot;当前时间为: &quot; + ft.format(dNow)); &#125;&#125;/*当前时间为: 2018-09-06 10:16:34*/ 1SimpleDateFormat ft = new SimpleDateFormat (&quot;yyyy-MM-dd hh:mm:ss&quot;); 这一行代码确立了转换的格式，其中 yyyy 是完整的公元年，MM 是月份，dd 是日期，HH:mm:ss 是时、分、秒。 注意:有的格式大写，有的格式小写，例如 MM 是月份，mm 是分；HH 是 24 小时制，而 hh 是 12 小时制 日期和时间格式化编码时间模式字符串用来指定时间格式。在此模式中，所有的 ASCII 字母被保留为模式字母，定义如下： 字母 描述 示例 G 纪元标记 AD y 四位年份 2001 M 月份 July or 07 d 一个月的日期 10 h A.M./P.M. (1~12)格式小时 12 H 一天中的小时 (0~23) 22 m 分钟数 30 s 秒数 55 S 毫秒数 234 E 星期几 Tuesday D 一年中的日子 360 F 一个月中第几周的周几 2 (second Wed. in July) w 一年中第几周 40 W 一个月中第几周 1 a A.M./P.M. 标记 PM k 一天中的小时(1~24) 24 K A.M./P.M. (0~11)格式小时 10 z 时区 Eastern Standard Time ‘ 文字定界符 Delimiter “ 单引号 使用printf格式化日期printf 方法可以很轻松地格式化时间和日期。使用两个字母格式，它以 %t 开头并且以下面表格中的一个字母结尾。 转换符 说明 示例 c 包括全部日期和时间信息 星期六 十月 27 14:21:20 CST 2007 F “年-月-日”格式 2007-10-27 D “月/日/年”格式 10/27/07 r “HH:MM:SS PM”格式（12时制） 02:25:51 下午 T “HH:MM:SS”格式（24时制） 14:28:16 R “HH:MM”格式（24时制） 14:28 12345678910111213141516171819202122232425262728293031import java.util.Date; public class DateDemo &#123; public static void main(String args[]) &#123; // 初始化 Date 对象 Date date = new Date(); //c的使用 System.out.printf(&quot;全部日期和时间信息：%tc%n&quot;,date); //f的使用 System.out.printf(&quot;年-月-日格式：%tF%n&quot;,date); //d的使用 System.out.printf(&quot;月/日/年格式：%tD%n&quot;,date); //r的使用 System.out.printf(&quot;HH:MM:SS PM格式（12时制）：%tr%n&quot;,date); //t的使用 System.out.printf(&quot;HH:MM:SS格式（24时制）：%tT%n&quot;,date); //R的使用 System.out.printf(&quot;HH:MM格式（24时制）：%tR&quot;,date); &#125;&#125;/*全部日期和时间信息：星期一 九月 10 10:43:36 CST 2012 年-月-日格式：2012-09-10 月/日/年格式：09/10/12 HH:MM:SS PM格式（12时制）：10:43:36 上午 HH:MM:SS格式（24时制）：10:43:36 HH:MM格式（24时制）：10:43 */","path":"page/java01.html","date":"01-05","excerpt":"","tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://xiaoliblog.cn/tags/JavaSE/"}]},{"title":"Visual Studio Code常用插件","text":"VS Code简介插件参考 || 官方插件库 || VSCode常用插件和技巧教程 vscode是微软开发的的一款代码编辑器，就如官网上说的一样，vscode重新定义（redefined）了代码编辑器。 当前市面上常用的轻型代码编辑器主要是：sublime，notepad++，editplus，atom这几种。 比起notepad++、editplus，vscode集成了许多IDE才具有的功能，比起它们更像一个代码编辑器； 比起sublime，vscode颜值更高，安装配置插件更为方便； 比起atom，vscode启动速度更快，打开各种大文件不卡。 可以说，vscode既拥有高自由度、又拥有高性能和高颜值，最关键的是，vscode还是一款免费并且有团队持续快速更新的代码编辑器。 可以说，vscode是代码编辑器的首选。个人推荐编写前端代码时，代码编辑器选择vscode，IDE选择WebStorm。 vscode安装插件只需要点击图片所示按钮，即可进入拓展，在搜索框中输入插件名点击安装后，等待安装好即可点击重新加载重启vscode使得插件生效。 当你不需要某个插件时只需要进入扩展，点击对应插件右下角的齿轮按钮即可选择禁用或卸载该插件。 下载VS Code👉蓝奏云下载密码：8ogy 安装中文包 Windows系统下按快捷键：ctrl+shift+p打开命令面板，界面如下 在输入框中输入：Configure Display Language （若是中文模式下，要切换其他语言，则输入：配置语言）。回车。 vscode会为你打开一个json文件，长下面这样—— 把其中的 “locale”:”” 改成图上的 “locale”:”zh-CN” ,再重启vscode，界面语言就会是中文了 注意：若重启后语言没有改变，可能是你没有下载适用于 VSCode 的中文（简体）语言包，链接如下：Chinese (Simplified) Language Pack for Visual Studio Code - Visual Studio Marketplace 配置语言环境 Windows系统下按快捷键：ctrl+shift+p打开命令面板，输入Change Language Mode，界面如下 找到HTML语言，回车后，在第一行打下感叹号，确定光标在感叹号的后面，之后按下tab键或者enter键都可以，就会生成html的基本语法 功能插件Open in browser插件 Visual Studio Code默认是在VScode的控制台下查看html页面，这对于我们调试和查看效果十分不方便。所以这里我们需要安装一下扩展插件，在浏览器中查看html页面。 安装完成后，选择你要在浏览器打开的HTML页面，按快捷键Alt + B 就可以在默认浏览器下打开你写的页面了 使用快捷键 Shift + Alt + B 可以选择其他浏览器打开。 或者对想要运行的HTML页面处右击选择open in default browse，也可以选择open in other browse，自己选择浏览器即可 Live Server插件 首先，vscode本身没有新建项目的选项，所以要先创建一个空的文件夹喔。 然后打开vscode，再在vscode里面打开文件夹，这样才可以创建项目。 导入VScode后，需要配置一下，Ctrl+shift+p，然后输入task，点击第一个选项即可配置。 跳转后，再次选择other……即可自动生成配置文件喔。 安装Live Server插件 新建一个工作区（也可以直接拖一个文件夹到vscode中），注意单独新建一个HTML文件拖动到IDE中是使用不了Live Server的，需要把这个HTML文件放到创建的工作区(文件夹)中，新建完成后我们可以在状态栏上看到一个Go Live，单击会自动打开浏览器并显示 如果没有状态栏上，也可以在文件上单击右键，选择Open With Live Server这一项 这样就可以在一个工程项目文件夹开发，并能实时预览 Markdown插件 vscode默认是支持Markdown的，但是我们还是需要一些额外的插件来辅助。如前文安装中文包一般，到vscode的插件市场中，搜索Markdown关键字，安装这几个插件—— 第一个插件，是一个组合包，一股脑把最常用的Markdown优化都给你装好； 第二个插件，则是Github使用的Markdown渲染样式，不是特别华丽，很朴素，很简洁的样式，因为很多人用Markdown都是为了使用Github Pages，所以这个样式特别受欢迎。使用这个样式，在本地就能预览Markdown文件最终在Github Pages中显示的效果。 为了集中管理用Markdown的文档，你可以在你容易找到的地方，专门建立一个文件夹，这取决于大家使用电脑的习惯，每个人都不一样。使用vscode打开这个文件夹，你会在左侧的导航窗口里，看到这样的显示—— 点击右上角的这个图标—— 然后你的页面就会变成两栏分列的样子；右侧这一栏就是markdown文件被渲染为HTML的预览；由于我们安装了Github的渲染风格，所以这里会按照Github的样式来渲染你的markdown文件。 Auto Rename Tag AutoRename Tag是一款面向Web开发人员的VSCode扩展。顾名思义，Auto Rename Tag可以在一个标签更改时自动更新另一个标签 Snippets Snippets 是节约时间提高生产力的最好办法。这并不是单单某一个语言的扩展，而是多种语言的各种扩展。 下面是一些流行的 Snippets 扩展： Angular Snippts (version 11) Python JavaScript (ES6) code snippets HTML Snippets ES7 React/Redux/GraphQL/React-Native snippets Vue 3 Snippets jQuery Code Snippets 例如，在React中创建新组建时，输入函数式组件的语法非常繁琐。使用ES7React/Redux/GraphQL/React-Native snippets扩展，只需要输入rfc并按回车即可创建函数式组件 px to rem &amp; rpx (cssrem) 一款px转rem的插件 Better Comments 使用Better Comments扩展，可以将注释分为警告、询问、待办、重点等几大类，并提供注释高亮效果 在\\\\或者&lt;!--后面使用下述字符做标记： * 表示重点 ! 表示错误和警告 ? 表示询问和问题 // 表示删除 TODO表示待办事项 也可以自己定义属于自己的颜色。方法如下： 点击插件上的小齿轮，选择Extension Setting. 点击Edit in setting.json选项，点击后打开了settings.json 可以根据自己的喜好自定义了 也可以增加新的注释颜色到setting.json中 Import Cost Import cost可以在代码中显示导入的估计大小。编写项目时，很重要的一点就是不要导入过大的软件包，以免损害用户体验。避免导入过大软件包的方法之一就是随时跟踪软件包的大小。 如果导入过大，Import Cost就会用红色显示大小，以示警告。你可以自行配置小、中、大分别对应的大小。 GitLens GitLens是一款开源扩展。它给VSCode添加了Git的功能 能通过Git blame和code lens的功能，将代码的作者可视化 遍历某个文件的历史版本 在行尾显示当前行的作者信息，而不会对工作造成干扰 自定义状态栏，显示当前行的上次修改者和修改日期 Prettier 格式化JavaScript / TypeScript / CSS Prettier安装成功后，编辑器默认的格式化处理就会被prettier代替， 默认快捷键是alt + shift + f Polacode 快速生成漂亮的代码截图 安装完成后，先打开你要分享的代码，然后按Ctrl + Shift + p 打开命令面板,然后再输入框中输入Polacode,就可以打开使用了，可以设置阴影、透明度，然后点击圆形图标即可截图保存 其他插件 JavaScript Booster 提高JavaScript代码专业度，插件会帮助你在你写的不合理的地方显示黄色感叹号，单击黄色感叹号后，就会跟我们变成更好的代码 Code Spell Checker 拼写检查器。比如 banana 单词写错成 banane ，会提示你是否修改成 banana ，也可以将 banane 添加至检查器的字典中。 Path Intellisense 自动完成文件名 Trailing Spaces 突出显示尾随空格，让你的“空格”型强迫症 显示呈现。 Code Runner 这个插件可以直接运行所选中的代码。 A-super-translate 划词翻译。鼠标停留选中几秒就会查看翻译内容 filesize 在状态栏中显示当前文件大小 TabNine Al辅助代码补全神器。可以根据你写过的代码习惯，来给你匹配合适的字段 Error Lens 将编辑器诊断出的警告、错误、语法问题（提示的波浪线）等，以用颜色填充行背景的方式突出提示，并将诊断信息显示在尾部 美化插件Fira code字体 GitHub上下载字体：https://github.com/tonsky/FiraCode，在README.md中往下翻页，会看到download链接（如下图） 如果访问GitHUb太慢，可以从我的蓝奏云链接直接下载👉密码:696f 打开压缩包，进入Fira_Code_v5.2\\ttf文件夹, 选中所有字体，右键选择【为所有用户安装】 打开【控制面板\\所有控制面板项\\字体\\Fira Code】，可以查看是否安装成功 【文件】-【首选项】-【设置】，搜索font，并在settings.json打开 修改或添加如下代码，注意用逗号分隔： 1234&quot;editor.fontFamily&quot;: &quot;Fira Code&quot;, //后边的引号中写上要设置的字体类型，个人比较喜欢Fira Code&quot;editor.fontLigatures&quot;: true, //这个控制是否启用字体连字，true启用，false不启用，这里选择启用&quot;editor.fontSize&quot;: 14, //设置字体大小，这个不多说都明白&quot;editor.fontWeight&quot;: &quot;normal&quot; //这个设置字体粗细，可选normal,bold,&quot;100&quot;~&quot;900&quot;等，选择合适的就行 推荐另一款字体JetBrains Mono：https://www.jetbrains.com/lp/mono/ Bracket Pair Colorizer 这款扩展可以将匹配的括号染成相同的颜色。同一个文件内嵌套的组件、函数、对象等带来的大量括号很容易让人摸不着头脑 Icons 描述性的图标可以帮你区分不同的文件和文件夹。图标也让开发过程更有趣。 下面是两个VSCode标签页的比较。一个有图标，另一个没有。 有许多图标扩展可供选择。流行的图标扩展有： vscode-icons Material Icon Theme Material Theme Icons Simple icons Indent-Rainbow 可以让让缩进带有颜色","path":"page/vscode.html","date":"01-03","excerpt":"","tags":[{"name":"工具","slug":"工具","permalink":"http://xiaoliblog.cn/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"JavaMail📪邮件接发技术","text":"电子邮件的接发过程感谢YSOcean||Java发邮件 假设用户A从QQ邮箱发送邮件到用户B163邮箱的图示，然后对图示的过程进行详细的介绍： 用户A的电子邮箱为：&#120;&#120;&#64;&#x71;&#113;&#46;&#x63;&#111;&#x6d;，通过邮件客户端软件写好一封邮件，交到QQ的邮件服务器，这一步使用的协议是SMTP,对应图示的①； QQ邮箱会根据用户A发送的邮件进行解析，也就是根据收件地址判断是否是自己管辖的账户，如果收件地址也是QQ邮箱，那么会直接存放到自己的存储空间。这里我们假设收件地址不是QQ邮箱，而是163邮箱，那么QQ邮箱就会将邮件转发到163邮箱服务器，转发使用的协议也是SMTP，对应图示的②； 163邮箱服务器接收到QQ邮箱转发过来的邮件，也会判断收件地址是否是自己，发现是自己的账户，那么就会将QQ邮箱转发过来的邮件存放到自己的内部存储空间，对应图示的③； 用户A将邮件发送了之后，就会通知用户B去指定的邮箱收取邮件。用户B会通过邮件客户端软件先向163邮箱服务器请求，要求收取自己的邮件，对应图示的④； 163邮箱服务器收到用户B的请求后，会从自己的存储空间中取出B未收取的邮件，对应图示⑤； 163邮箱服务器取出用户B未收取的邮件后，将邮件发给用户B，对应图示的⑥；最后三步用户B收取邮件的过程，使用的协议是POP3; 邮件服务器图示出现了两个邮件服务器，QQ和163邮件服务器。用户想要在网上收发邮件，必须要有专门的邮件服务器。邮件服务器我们可以假想为现实生活中的邮局。 如果按功能划分，邮件服务器可以划分为两种类型： SMTP邮件服务器：替用户发送邮件和接收外面发送给本地用户的邮件，对应上图的第一、二步。它相当于现实生活中邮局的邮件接收部门（可接收普通用户要投出的邮件和其他邮局投递进来的邮件）。 POP3/IMAP邮件服务器：帮助用户读取SMTP邮件服务器接收进来的邮件，对应上图的第六步。它相当于专门为前来取包裹的用户提供服务的部门。 电子邮箱 电子邮箱也称为E-mail地址，比如用户A的&#x78;&#x78;&#64;&#x71;&#x71;&#x2e;&#x63;&#111;&#109;，和用户B的&#120;&#x78;&#64;&#49;&#x36;&#51;&#x2e;&#x63;&#111;&#x6d;。 用户能通过E-mail地址标识自己发送的电子邮件，同时也可以通过这个地址接收别人发来的电子邮件 电子邮箱需要到邮件服务器进行申请，也就是说，电子邮箱其实就是用户在邮件服务器上申请的账户。邮件服务器会把接收到的邮件保存到为该账户所分配的邮箱空间中，用户通过用户名密码登录到邮件服务器查收该地址已经收到的邮件。一般来讲，邮件服务器为用户分配的邮箱空间是有限的。 邮件客户端软件我们可以直接在网站上进行邮件收发，也可以用邮件客户端软件。比如常见的FoxMail，Outlook Express。邮件客户端软件通常集邮件撰写，发送和收发功能于一体，主要用于帮助用户将邮件发送给SMTP邮件服务器和从POP3/IMAP邮件服务器读取用户的电子邮件。 推荐使用163邮箱，不推荐使用QQ邮箱！ 邮件传输协议电子邮件需要在邮件客户端和邮件服务器之间，以及两个邮件服务器之间进行邮件传递，那就必须要遵守一定的规则，这个规则就是邮件传输协议。下面我们分别简单介绍几种协议（后面会详细讲解）： SMTP协议：全称为 Simple Mail Transfer Protocol，简单邮件传输协议。它定义了邮件客户端软件和SMTP邮件服务器之间，以及两台SMTP邮件服务器之间的通信规则。 POP3协议：全称为 Post Office Protocol，邮局协议。它定义了邮件客户端软件和POP3邮件服务器的通信规则。 IMAP协议：全称为 Internet Message Access Protocol,Internet消息访问协议，它是对POP3协议的一种扩展，也是定义了邮件客户端软件和IMAP邮件服务器的通信规则。 JavaMail实际项目中我们不需要考虑邮件的底层实现协议，因为 sun 公司（现在已经被orcal收购了）开发的JavaMail API 就是为方便Java开发人员在应用程序中实现邮件接收和发送功能而提供的一套标准开发包，屏蔽了底层的邮件实现协议 JavaMail介绍 JavaMail 是sun公司（现以被甲骨文收购）为方便Java开发人员在应用程序中实现邮件发送和接收功能而提供的一套标准开发包，它支持一些常用的邮件协议，如前面所讲的SMTP，POP3，IMAP,还有MIME等。我们在使用JavaMail API 编写邮件时，无须考虑邮件的底层实现细节，只要调用JavaMail 开发包中相应的API类就可以了。 本项目开源代码：https://github.com/xiaoliblog/MyCode/tree/main/JavaMailProject JavaMail下载地址：https://github.com/javaee/javamail/releases，下载javax.mail.jar Maven地址：https://mvnrepository.com/artifact/javax.mail/mail ，还需要下载一个用于支持的activation.jar包 123456789101112&lt;!-- https://mvnrepository.com/artifact/javax.mail/mail --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.mail&lt;/groupId&gt; &lt;artifactId&gt;mail&lt;/artifactId&gt; &lt;version&gt;1.4.7&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/javax.activation/activation --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.activation&lt;/groupId&gt; &lt;artifactId&gt;activation&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt; JavaMail API JavaMail API 按照功能可以划分为如下三大类： 创建和解析邮件的API 发送邮件的API 接收邮件的API 以上三种类型的API在JavaMail 中由多个类组成，但是主要有四个核心类，我们在编写程序时，记住这四个核心类，就很容易编写出Java邮件处理程序 Message 类:javax.mail.Message 类是创建和解析邮件的核心 API，这是一个抽象类，通常使用它的子类javax.mail.internet.MimeMessage 类。它的实例对象表示一份电子邮件。客户端程序发送邮件时，首先使用创建邮件的 JavaMail API 创建出封装了邮件数据的 Message 对象，然后把这个对象传递给邮件发送API（Transport 类） 发送。客户端程序接收邮件时，邮件接收API把接收到的邮件数据封装在Message 类的实例中，客户端程序在使用邮件解析API从这个对象中解析收到的邮件数据。 Transport 类：javax.mail.Transport 类是发送邮件的核心API 类，它的实例对象代表实现了某个邮件发送协议的邮件发送对象，例如 SMTP 协议，客户端程序创建好 Message 对象后，只需要使用邮件发送API 得到 Transport 对象，然后把 Message 对象传递给 Transport 对象，并调用它的发送方法，就可以把邮件发送给指定的 SMTP 服务器。 Store 类：javax.mail.Store 类是接收邮件的核心 API 类，它的实例对象代表实现了某个邮件接收协议的邮件接收对象，例如 POP3 协议，客户端程序接收邮件时，只需要使用邮件接收 API 得到 Store 对象，然后调用 Store 对象的接收方法，就可以从指定的 POP3 服务器获得邮件数据，并把这些邮件数据封装到表示邮件的 Message 对象中。 Session 类：javax.mail.Session 类用于定义整个应用程序所需的环境信息，以及收集客户端与邮件服务器建立网络连接的会话信息，例如邮件服务器的主机名、端口号、采用的邮件发送和接收协议等。Session 对象根据这些信息构建用于邮件收发的 Transport 和 Store 对象，以及为客户端创建 Message 对象时提供信息支持。 开启服务及授权码 某些邮箱服务器为了增加邮箱本身密码的安全性，给 SMTP 客户端设置了独立密码（有的邮箱称为“授权码”）, 对于开启了独立密码的邮箱, 邮箱账户密码必需使用这个独立密码（授权码）。 一般在邮箱的设置里都会有，QQ邮箱也类似，设置后复制授权码，该授权码可以登录邮箱，需保密 简单邮件 简单邮件，没有附件和图片，即纯文本邮件 发送步骤 基本步骤 连接邮件服务器的参数配置 是否需要设置SSL加密（比如QQ邮箱） 创建包含邮件服务器的网络连接信息的Session对象 创建包含邮件内容的实例对象Message 通过session得到transport对象，连接邮箱服务器，发送Message，关闭连接 某些邮箱服务器要求 SMTP 连接需要使用 SSL 安全认证 (为了提高安全性，邮箱支持SSL连接，也可以自己开启)，如果无法连接邮件服务器,，仔细查看控制台打印的 log,，如果有有类似 “连接失败, 要求 SSL 安全连接” 等错误，则开启 SSL 安全连接 SMTP 服务器的端口 (非 SSL 连接的端口一般默认为 25， 可以不添加，如果开启了 SSL 连接，需要改为对应邮箱的 SMTP 服务器的端口，具体可查看对应邮箱服务的帮助，QQ邮箱的SMTP(SLL)端口为465或587, 其他邮箱自行去查看) 12345final String smtpPort = &quot;465&quot;;prop.setProperty(&quot;mail.smtp.port&quot;, smtpPort);prop.setProperty(&quot;mail.smtp.socketFactory.class&quot;,&quot;javax.net.ssl.SSLSocketFactory&quot;);prop.setProperty(&quot;mail.smtp.socketFactory.fallback&quot;, &quot;false&quot;);prop.setProperty(&quot;mail.smtp.socketFactory.port&quot;, smtpPort); 或者设置如下，但要确定包导入成功，最好新建一个lib目录存放 activation-1.1.1.jar mail-1.4.7.jar 12345//关于qq邮箱，还要设置ssl加密，加上一下代码即可,大厂，其他邮箱不需要MailSSLSocketFactory sf = new MailSSLSocketFactory();sf.setTrustAllHosts(true);prop.put(&quot;mail.smtp.ssl.enable&quot;, &quot;true&quot;);prop.put(&quot;mail.smtp.ssl.socketFactory&quot;, sf); 编码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.lzy.mail;import java.util.Date;import java.util.Properties;import javax.mail.*;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage;public class MailDemo01 &#123; //发件人邮箱地址 public static String senderAddress = &quot;2312057536@qq.com&quot;; //收件人邮箱地址 public static String recipientAddress = &quot;2312057536@qq.com&quot;; //发件人邮箱账户名 public static String senderAccount = &quot;2312057536@qq.com&quot;; //发件人邮箱账户密码(独立密码或者授权码) public static String senderPassword = &quot;npbxxxxfxxmieaae&quot;; public static void main(String[] args) throws Exception &#123; //连接邮件服务器的参数配置 Properties prop = new Properties(); prop.setProperty(&quot;mail.host&quot;, &quot;smtp.qq.com&quot;); //设置qq邮箱服务器 prop.setProperty(&quot;mail.transport.protocol&quot;, &quot;smtp&quot;); //邮件发送协议 prop.setProperty(&quot;mail.smtp.auth&quot;, &quot;true&quot;); //需要验证用户名密码 //关于qq邮箱，还要设置ssl加密，加上一下代码即可,大厂，其他邮箱不需要 MailSSLSocketFactory sf = new MailSSLSocketFactory(); sf.setTrustAllHosts(true); prop.put(&quot;mail.smtp.ssl.enable&quot;, &quot;true&quot;); prop.put(&quot;mail.smtp.ssl.socketFactory&quot;, sf); //使用JavaMail发送邮箱的5个步骤 //1.创建定义整个程序所需要的环境信息的Session 对象 //其他:Session session = Session.getInstance(props); //qq才有！其他邮箱就不用 Session session = Session.getDefaultInstance(prop, new Authenticator() &#123; @Override protected PasswordAuthentication getPasswordAuthentication() &#123; //发件人邮箱用户名、授权码 return new PasswordAuthentication(senderAddress, senderPassword); &#125; &#125;); //开启Session的debug模式，这样就可以看到程序发送Email的运行状态 session.setDebug(true); //开启后可以看到进程 //2.创建邮件的实例对象(利用封装的方法) Message message = getMimeMessage(session); //3.通过session得到transport对象 Transport transport = session.getTransport(); //4.使用邮箱的账户名和授权码连接上邮箱服务器 transport.connect(senderAccount, senderPassword); //5.发送邮件 transport.sendMessage(message, message.getAllRecipients()); //如果只想发送给指定的人，可以如下写法 //transport.sendMessage(message, new Address[]&#123;new InternetAddress(&quot;xxx@qq.com&quot;)&#125;); //6.关闭连接 transport.close(); &#125; public static MimeMessage getMimeMessage(Session session) throws Exception &#123; //创建一封邮件的实例对象 注意需要传递session MimeMessage message = new MimeMessage(session); //指明邮件的发件人地址 message.setFrom(new InternetAddress(senderAddress)); /** * 设置收件人地址（可以增加多个收件人、抄送、密送），即下面这一行代码书写多行 * MimeMessage.RecipientType.TO:发送 * MimeMessage.RecipientType.CC：抄送 * MimeMessage.RecipientType.BCC：密送 */ //指明邮件的收件人地址 message.setRecipient(Message.RecipientType.TO, new InternetAddress(recipientAddress)); //邮件的标题 message.setSubject(&quot;只包含文本的简单邮件&quot;,&quot;UTF-8&quot;); //邮件的正文文本内容 message.setContent(&quot;&lt;h1 style=&#x27;color:red&#x27;&gt;Hello Babe！&lt;/h1&gt;&quot;, &quot;text/html;charset=UTF-8&quot;); //设置邮件的发送时间,默认立即发送 message.setSentDate(new Date()); return message; &#125;&#125; 执行完上述代码，然后我们查看收件箱 邮件发送注意实现 发件人的邮箱账户名和密码：有的邮箱设置了独立密码，还有的必须用授权码登录（qq邮箱），要开启SMTP服务 发件人的SMTP服务器地址：一般是 smtp.xxx.com，比如163邮箱是smtp.163.com，qq邮箱是smtp.qq.com 有些邮箱服务器要求必须要使用 SSL 安全连接; 有可能你收件人地址，发件人地址等信息都正确了，控制台也打印了正确的信息，但是在收件箱就是收不到信息。这是因为可能收件箱服务器拒收了你发的邮件（比如认为你的邮件是广告），这时候可能在垃圾箱里能找到，可能找不到。解决办法是重复的邮件内容不要多次发送，或者更换收件箱试试 复杂邮件 复杂邮件指带有附件的邮件，比如文件和图片等 MIME MIME（多用途互联网邮件扩展类型） MimeBodyPart javax.mail.internet.MimeBodyPart类表示的是一个MIME消息，它和MimeMessage类一样都是从Part接口继承过来。 MimeMultipart javax.mai.internet.MimeMultipart是抽象类Multipart的实现子类，它用来组合多个MIME消息。一个MimeMultipart对象可以包含多代表MIME消息的MimeBodyPart对象 发送图片 在src资源目录下存放qq登录图片.png图片 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package com.lzy.mail;import javax.activation.DataHandler;import javax.activation.FileDataSource;import javax.mail.*;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeBodyPart;import javax.mail.internet.MimeMessage;import javax.mail.internet.MimeMultipart;import java.util.Properties;//复杂文件 带图片public class MailDemo02 &#123; //发件人邮箱地址 public static String senderAddress = &quot;2312057536@qq.com&quot;; //收件人邮箱地址 public static String recipientAddress = &quot;2312057536@qq.com&quot;; //发件人邮箱账户名 public static String senderAccount = &quot;2312057536@qq.com&quot;; //发件人邮箱账户密码(独立密码或者授权码) public static String senderPassword = &quot;xxxxxxxxx&quot;; public static void main(String[] args) throws Exception &#123; //连接邮件服务器的参数配置 Properties prop = new Properties(); prop.setProperty(&quot;mail.host&quot;, &quot;smtp.qq.com&quot;); //设置qq邮箱服务器 prop.setProperty(&quot;mail.transport.protocol&quot;, &quot;smtp&quot;); //邮件发送协议 prop.setProperty(&quot;mail.smtp.auth&quot;, &quot;true&quot;); //需要验证用户名密码 //关于qq邮箱，还要设置ssl加密，加上一下代码即可,大厂，其他邮箱不需要 final String smtpPort = &quot;465&quot;; prop.setProperty(&quot;mail.smtp.port&quot;, smtpPort); prop.setProperty(&quot;mail.smtp.socketFactory.class&quot;, &quot;javax.net.ssl.SSLSocketFactory&quot;); prop.setProperty(&quot;mail.smtp.socketFactory.fallback&quot;, &quot;false&quot;); prop.setProperty(&quot;mail.smtp.socketFactory.port&quot;, smtpPort); //使用JavaMail发送邮箱的5个步骤 //1.创建定义整个程序所需要的环境信息的Session 对象 //qq才有！其他邮箱就不用 Session session = Session.getDefaultInstance(prop, new Authenticator() &#123; @Override protected PasswordAuthentication getPasswordAuthentication() &#123; //发件人邮箱用户名、授权码 return new PasswordAuthentication(senderAddress, senderPassword); &#125; &#125;); //开启Session的debug模式，这样就可以看到程序发送Email的运行状态 session.setDebug(true); //开启后可以看到进程 //2. 创建邮件的实例对象 Message message = getMimeMessage(session); //3.通过session得到transport对象 Transport ts = session.getTransport(); //4.使用邮箱的账户名和授权码连接上邮箱服务器 ts.connect(senderAccount, senderPassword); //5.//发送邮件，并发送到所有收件人地址，message.getAllRecipients() 获取到的是在创建邮件对象时添加的所有收件人, 抄送人, 密送人 ts.sendMessage(message, message.getAllRecipients()); //6.关闭连接 ts.close(); &#125; /*获得创建一封邮件的实例对象*/ public static MimeMessage getMimeMessage(Session session) throws Exception &#123; //1. 创建一封邮件的实例对象 MimeMessage message = new MimeMessage(session); //2. 设置发件人地址 message.setFrom(new InternetAddress(senderAddress)); //3. 设置收件人地址(可以增加多个收件人、发送TO、抄送CC、密送BCC) message.setRecipient(MimeMessage.RecipientType.TO, new InternetAddress(recipientAddress)); //4. 设置邮件的标题 message.setSubject(&quot;带图片的文件&quot;, &quot;UTF-8&quot;); //下面是设置邮件正文 //msg.setContent(&quot;简单的纯文本邮件！&quot;, &quot;text/html;charset=UTF-8&quot;); //准备邮件数据 // 5. 创建图片&quot;节点&quot; MimeBodyPart image = new MimeBodyPart(); // 读取本地文件 DataHandler：数据处理 DataHandler dh = new DataHandler(new FileDataSource(&quot;D:\\\\IDEA_Workspace\\\\FIle_Mail\\\\File_Demo01\\\\src\\\\qq登录图片.png&quot;)); // 将图片数据添加到&quot;节点&quot; image.setDataHandler(dh); // 为&quot;节点&quot;设置一个唯一编号（在文本&quot;节点&quot;将引用该ID） image.setContentID(&quot;qq_img&quot;); //准备正文数据 //6. 创建文本&quot;节点&quot; MimeBodyPart text = new MimeBodyPart(); // 这里添加图片的方式是将整个图片包含到邮件内容中, 这里以cid:id的形式引用上面设置的ID，实际上也可以以 http 链接的形式添加网络图片 text.setContent(&quot;这是一封邮件正文带图片&lt;img src=&#x27;cid:qq_img&#x27;&gt;的邮件&quot;, &quot;text/html;charset=UTF-8&quot;); //7. 描述数据关系(将 文本 和 图片&quot;节点&quot;合成一个混合&quot;节点&quot;) MimeMultipart mm = new MimeMultipart(); mm.addBodyPart(text); mm.addBodyPart(image); mm.setSubType(&quot;related&quot;); //关联关系,附件&quot;mixed&quot; //8. 设置到消息中，保存修改 message.setContent(mm); //把最后编辑好的邮件放到消息中 message.saveChanges(); //保存修改 return message; &#125;&#125; 运行结果 发送图片和附件 在src资源目录下存放附件.txt文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128package com.lzy.mail;import com.sun.mail.util.MailSSLSocketFactory;import javax.activation.DataHandler;import javax.activation.FileDataSource;import javax.mail.*;import javax.mail.internet.*;import java.util.Properties;//复杂文件 带图片 带附件public class MailDemo03 &#123; //发件人邮箱地址 public static String senderAddress = &quot;2312057536@qq.com&quot;; //收件人邮箱地址 public static String recipientAddress = &quot;2312057536@qq.com&quot;; //发件人邮箱账户名 public static String senderAccount = &quot;2312057536@qq.com&quot;; //发件人邮箱账户密码(独立密码或者授权码) public static String senderPassword = &quot;npbxxxxxxxxe&quot;; public static void main(String[] args) throws Exception &#123; //连接邮件服务器的参数配置 Properties prop = new Properties(); prop.setProperty(&quot;mail.host&quot;, &quot;smtp.qq.com&quot;); //设置qq邮箱服务器 prop.setProperty(&quot;mail.transport.protocol&quot;, &quot;smtp&quot;); //邮件发送协议 prop.setProperty(&quot;mail.smtp.auth&quot;, &quot;true&quot;); //需要验证用户名密码 //关于qq邮箱，还要设置ssl加密，加上一下代码即可,大厂，其他邮箱不需要 final String smtpPort = &quot;465&quot;; prop.setProperty(&quot;mail.smtp.port&quot;, smtpPort); prop.setProperty(&quot;mail.smtp.socketFactory.class&quot;, &quot;javax.net.ssl.SSLSocketFactory&quot;); prop.setProperty(&quot;mail.smtp.socketFactory.fallback&quot;, &quot;false&quot;); prop.setProperty(&quot;mail.smtp.socketFactory.port&quot;, smtpPort); //使用JavaMail发送邮箱的5个步骤 //1.创建定义整个程序所需要的环境信息的Session 对象 //qq才有！其他邮箱就不用 Session session = Session.getDefaultInstance(prop, new Authenticator() &#123; @Override protected PasswordAuthentication getPasswordAuthentication() &#123; //发件人邮箱用户名、授权码 return new PasswordAuthentication(senderAddress, senderPassword); &#125; &#125;); //开启Session的debug模式，这样就可以看到程序发送Email的运行状态 session.setDebug(true); //开启后可以看到进程 //2. 创建邮件的实例对象 Message message = getMimeMessage(session); //3.通过session得到transport对象 Transport ts = session.getTransport(); //4.使用邮箱的账户名和授权码连接上邮箱服务器 ts.connect(senderAccount, senderPassword); //5.//发送邮件，并发送到所有收件人地址，message.getAllRecipients() 获取到的是在创建邮件对象时添加的所有收件人, 抄送人, 密送人 ts.sendMessage(message, message.getAllRecipients()); //6.关闭连接 ts.close(); &#125; public static MimeMessage getMimeMessage(Session session) throws Exception &#123; //1. 创建一封邮件的实例对象 MimeMessage message = new MimeMessage(session); //2. 设置发件人地址 message.setFrom(new InternetAddress(senderAddress)); //3. 设置收件人地址(可以增加多个收件人、发送TO、抄送CC、密送BCC) message.setRecipient(MimeMessage.RecipientType.TO, new InternetAddress(recipientAddress)); //4. 设置邮件的标题 message.setSubject(&quot;带图片和附件的邮件&quot;); /* 编写邮件的内容 1.图片 2.附件 3.文本 */ //图片 MimeBodyPart img = new MimeBodyPart(); //图片需要经过数据处理。。。 DataHandler：数据处理 DataHandler dh1 = new DataHandler(new FileDataSource(&quot;D:\\\\IDEA_Workspace\\\\FIle_Mail\\\\File_Demo01\\\\src\\\\qq登录图片.png&quot;)); img.setDataHandler(dh1); //在我们的图片节点中放入这个处理的图片数据 img.setContentID(&quot;qq_img&quot;); //给图片设置一个ID，我们可以在文件节点内容中引用 //文本 MimeBodyPart text = new MimeBodyPart(); text.setContent(&quot;这个带图片&lt;img src=&#x27;cid:qq_img&#x27;&gt;的邮件&quot;, &quot;text/html;charset=UTF-8&quot;); //创建附件&quot;节点&quot; MimeBodyPart attachment = new MimeBodyPart(); // 读取本地文件 DataHandler dh2 = new DataHandler(new FileDataSource(&quot;D:\\\\IDEA_Workspace\\\\FIle_Mail\\\\File_Demo01\\\\src\\\\附件.txt&quot;)); attachment.setDataHandler(dh2); // 设置附件的文件名（需要编码） //attachment.setFileName(&quot;附件.txt&quot;); attachment.setFileName(MimeUtility.encodeText(dh2.getName())); //拼装邮件正文内容 MimeMultipart multipart1 = new MimeMultipart(); multipart1.addBodyPart(img); multipart1.addBodyPart(text); multipart1.setSubType(&quot;related&quot;); //1.文本和图片内嵌成功 //new MimeBodyPart().setContent(multipart1);将拼装好的正文内容设为主体 MimeBodyPart contextText = new MimeBodyPart(); contextText.setContent(multipart1); //拼接附件 MimeMultipart allFile = new MimeMultipart(); allFile.addBodyPart(attachment); //附件 allFile.addBodyPart(contextText); //正文 allFile.setSubType(&quot;mixed&quot;); //正文和附件都存在邮件中，所有类型都设为mixed //设置到消息中，保存修改 message.setContent(allFile); //把最后编辑好的邮件放到消息中 message.saveChanges(); //保存修改 return message; &#125;&#125; 运行结果 接收邮件 接收邮件用处不多，稍作了解即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 package com.lzyblog.mail; import java.util.Properties;import javax.mail.Address;import javax.mail.Folder;import javax.mail.Message;import javax.mail.Session;import javax.mail.Store; public class RecipientMail &#123; //收件人地址 public static String recipientAddress = &quot;xxx@163.com&quot;; //收件人账户名 public static String recipientAccount = &quot;xxx&quot;; //收件人账户密码 public static String recipientPassword = &quot;xxx&quot;; public static void main(String[] args) throws Exception &#123; //1、连接邮件服务器的参数配置 Properties props = new Properties(); //设置传输协议 props.setProperty(&quot;mail.store.protocol&quot;, &quot;pop3&quot;); //设置收件人的POP3服务器 props.setProperty(&quot;mail.pop3.host&quot;, &quot;pop3.163.com&quot;); //2、创建定义整个应用程序所需的环境信息的 Session 对象 Session session = Session.getInstance(props); //设置调试信息在控制台打印出来 //session.setDebug(true); Store store = session.getStore(&quot;pop3&quot;); //连接收件人POP3服务器 store.connect(&quot;pop3.163.com&quot;, recipientAccount, recipientPassword); //获得用户的邮件账户，注意通过pop3协议获取某个邮件夹的名称只能为inbox Folder folder = store.getFolder(&quot;inbox&quot;); //设置对邮件账户的访问权限 folder.open(Folder.READ_WRITE); //得到邮件账户的所有邮件信息 Message [] messages = folder.getMessages(); for(int i = 0 ; i &lt; messages.length ; i++)&#123; //获得邮件主题 String subject = messages[i].getSubject(); //获得邮件发件人 Address[] from = messages[i].getFrom(); //获取邮件内容（包含邮件内容的html代码） String content = (String) messages[i].getContent(); &#125; //关闭邮件夹对象 folder.close(); //关闭连接对象 store.close(); &#125; &#125; 注册邮件实例前端界面 注册界面index.jsp 12345678910111213141516&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;注册&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/RegisterServlet&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;br/&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;br/&gt; 邮箱：&lt;input type=&quot;text&quot; name=&quot;email&quot;&gt; &lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 注册成功提醒界面info.jsp 12345678910&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;网站温馨提示&lt;/h1&gt;$&#123;message&#125;&lt;/body&gt;&lt;/html&gt; 实体类 在com.lzy.pojo包下，创建User实体类 12345678910111213141516171819package com.lzy.pojo;import lombok.Data;@Datapublic class User &#123; private String username; private String password; private String email; //无参和有参构造方法 //getter和setter方法 public User(String username, String password, String email) &#123; this.username = username; this.password = password; this.email = email; &#125;&#125; Servlet 在com.lzy.servlet创建RegisterServlet 123456789101112131415161718192021222324252627282930313233343536373839package com.lzy.servlet;import com.lzy.pojo.User;import com.lzy.utils.Sendmail;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class RRegisterServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //接受用户请求，封装成对象 String username = req.getParameter(&quot;username&quot;); String password = req.getParameter(&quot;password&quot;); String email = req.getParameter(&quot;email&quot;); User user = new User(username, password, email); //用户注册成功之后，给用户发送一封邮件 //我们使用多线程来专门发送邮件，防止出现耗时，和网站注册人数过多的情况； Sendmail send = new Sendmail(user); //启动线程，线程启动之后就会执行run方法来发送邮件 send.start(); //注册用户 req.setAttribute(&quot;message&quot;, &quot;注册成功，我们已经发了一封带了注册信息的电子邮件，请查收！如网络不稳定，可能过会儿才能收到！！&quot;); req.getRequestDispatcher(&quot;info.jsp&quot;).forward(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; 邮件发送工具类 在com.lzy.utils下，创建工具类Sendmail 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.lzy.utils;import com.lzy.pojo.User;import com.sun.mail.util.MailSSLSocketFactory;import javax.mail.*;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage;import java.util.Properties;//网站3秒原则：一个网页白屏加载超过3秒以上用户体验差//多线程实现用户体验 （异步处理）public class Sendmail extends Thread &#123; //用于给用户发送邮件的邮箱 private String from = &quot;2312057536@qq.com&quot;; //邮箱的用户名 private String username = &quot;2312057536@qq.com&quot;; //邮箱的密码 qq授权码 private String password = &quot;nxxxbxxxxxxxe&quot;; //发送邮箱的服务地址 private String host = &quot;smtp.qq.com&quot;; private User user; public Sendmail(User user) &#123; this.user = user; &#125; //重写run方法的实现，在run方法中发送邮件给指定的用户 @Override public void run() &#123; try &#123; Properties prop = new Properties(); prop.setProperty(&quot;mail.host&quot;, &quot;smtp.qq.com&quot;); //设置qq邮箱服务器 prop.setProperty(&quot;mail.transport.protocol&quot;, &quot;smtp&quot;); //邮件发送协议 prop.setProperty(&quot;mail.smtp.auth&quot;, &quot;true&quot;); //需要验证用户名密码 //关于qq邮箱，还要设置ssl加密，加上一下代码即可,大厂，其他邮箱不需要 MailSSLSocketFactory sf = new MailSSLSocketFactory(); sf.setTrustAllHosts(true); prop.put(&quot;mail.smtp.ssl.enable&quot;, &quot;true&quot;); prop.put(&quot;mail.smtp.ssl.socketFactory&quot;, sf); //使用JavaMail发送邮箱的5个步骤 //1.创建定义整个程序所需要的环境信息的Session 对象 //qq才有！其他邮箱就不用 Session session = Session.getDefaultInstance(prop, new Authenticator() &#123; @Override protected PasswordAuthentication getPasswordAuthentication() &#123; //发件人邮箱用户名、授权码 return new PasswordAuthentication(from, password); &#125; &#125;); //开启Session的debug模式，这样就可以看到程序发送Email的运行状态 session.setDebug(true); //开启后可以看到进程 //2.通过session得到transport对象 Transport ts = null; ts = session.getTransport(); //3.使用邮箱的用户名和授权码连接上邮箱服务器 ts.connect(&quot;smtp.qq.com&quot;, from, password); //4.创建邮件 //创建邮件对象 注意需要传递session MimeMessage message = new MimeMessage(session); //指明邮件的发件人 message.setFrom(new InternetAddress(from)); //指明邮件的收件人 message.setRecipient(Message.RecipientType.TO, new InternetAddress(user.getEmail())); //邮件的标题 message.setSubject(&quot;用户注册邮件&quot;); String info = &quot;恭喜注册成功，您的用户名：&quot; + user.getUsername() + &quot;，您的密码&quot; + user.getPassword() + &quot;，请妥善保管，如有问题请联系网站客服！！&quot;; //邮件的文本内容 message.setContent(info, &quot;text/html;charset=UTF-8&quot;); //5.发送邮件 ts.sendMessage(message, message.getAllRecipients()); //6.关闭连接 ts.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果 index.jsp前端界面 info.jsp提醒界面 收到邮件如下","path":"page/JavaMail.html","date":"12-31","excerpt":"","tags":[{"name":"企业常用技术","slug":"企业常用技术","permalink":"http://xiaoliblog.cn/tags/%E4%BC%81%E4%B8%9A%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF/"}]},{"title":"Hexo博客结构及配置文件解析","text":"Hexo结构 详情请查阅Hexo中文文档：https://hexo.io/zh-cn/docs/ 创建完成后，指定文件夹的目录如下 12345678910|-- _config.yml|-- package.json|-- .deploy_git|-- node_modules|-- scaffolds|-- source |-- _posts|-- public|-- themes|-- .gitignore config.yml _config.yml 初始化时自动创建。网站的全局配置文件，设置包括网站标题、副标题、作者、关键字和描述信息等。详情请参考： 配置 | Hexo package.json package.json 初始化时自动创建，应用程序的信息。可以查看hexo的版本以及安装的扩展版本。框架的基本参数信息和它所依赖的插件，在 npm 安装时使用--save 保存进去。 .deploy_git .deploy_git 在部署到github后自动创建。 此目录中的内容 = github站点中对于repository中的内容 = 最近一次上传到站点的public目录中的内容 因此，该目录的结构和 public 目录基本一致（不一致的情况是由于重新生成，但是没有发布站点造成，此时 public 内容新于 .deploy_git 内容） node_modules 存放安装的Hexo扩展 1234567node_modules├─.bin├─hexo├─hexo-deployer-git├─hexo-generator-archive├─hexo-generator-category├─hexo-generator-feed Hexo 默认安装： 12345678910hexo: 主程序hexo-deployer-git: git部署hexo-generator-archive: 存档页面生成器hexo-generator-category: 类别生成器hexo-generator-index: index生成器hexo-generator-tag: 标签生成器hexo-renderer-ejs: 进一步了解 EJS tj&#x2F;ejs · GitHubhexo-renderer-stylus: 进一步了解 Stylus GitHub - hexojs&#x2F;hexo-renderer-stylus: Stylus renderer for Hexohexo-renderer-marked: Markdown引擎，让你可以用markdown格式书写博客hexo-server: 服务器，让你可以本地预览博客 public public 执行 hexo g 命令，Hexo程序会解析 source 、当前使用的theme，生成的静态网页内容目录就是 public 。执行 hexo d 则将该目录内容复制到 .deploy_git 目录。使用 hexo clean 清除 db.json 和 public 文件夹下的所有文件。 scaffolds scaffolds 本意是 “脚手架” 的意思，这里引申为模板文件夹。当你 hexo new page xxx 的时候，Hexo 会根据该文件夹下的对应文件进行初始化构建。详情参考： 模版 | Hexo source source 正如其名，source 文件夹存储一些直接来自用户的文件，它很重要，如果不出意外你的文章就是保存在这个文件夹下（_posts）。_posts 目录下的md文件，会被编译成 html 文件，放到 public 文件夹下。 其他开头命名为_(下划线)的文件 / 文件夹 将会被忽略。因此可以在source目录下创建 _drafts 目录用于存放未完成的草稿，其中内容不会发布到网站 其他开头非_的文件 / 文件夹 会被拷贝到public目录并上传到站点 可以创建 img 目录来存放在博客引用到的图片等 要添加新的页面（例如about），执行 hexo new page PageName 命令即会在 source 中自动新建子目录 PageName favicon.ico 在主题配置文件中引用 /favicon.ico 来设置站点的页面图标 themes `themes· 主题文件夹，存储主题。相关的主题可以在 Github 上免费采购。 12345├── _config.yml #主题配置文件├── languages # 语言文件夹。根据 Hexo 目录中 _config.yml 设置的语言来选择站点以哪种语言来呈现├── layout #存放主题的模板文件，决定了网站内容的呈现方式├── scripts # 脚本文件夹。在启动时，Hexo 会载入此文件夹内的 JavaScript 文件└── source # 资源文件夹，除了模板以外的资源，例如 CSS、JavaScript 文件等，都应该放在这个文件夹中 layout 存放主题的模板文件，决定了网站内容的呈现方式。Hexo 根据模板文件的扩展名来决定所使用的模板引擎，例如： 12layout.ejs - 使用 EJSlayout.swig - 使用 Sw 更多参考 模板|Hexo EJS tj/ejs · GitHub Stylus GitHub - hexojs/hexo-renderer-stylus: Stylus renderer for Hexo .gitignore .gitignore .gitignore 文件作用是声明不被 git 记录的文件，hexo init &lt;folder&gt; 也会产生一个 .gitignore 文件，可以先删除或者直接编辑，对hexo不会有影响。 yml配置文件 YAML是一个类似 XML、JSON 的标记性语言。YAML 强调以数据为中心，并不是以标识语言为重点。因而 YAML 本身的定义比较简单，号称“一种人性化的数据格式语言” yaml是专门用来写配置文件的语言。它用首行缩进表示层级关系，便于读写理解。 配置文件一般用来对所需环境进行设置。hexo中涉及到两个配置文件，一个是位于主目录下的，另一个是位于主题目录下的。 通常主目录下的配置文件用于对全站的配置，比如站点的基本信息，文章的布局，写作的格式，部署到github上的参数等等。 而主题目录下的配置文件用于对该主题的配置，比如站点导航栏的设置，一些插件的设置等。 yml语法 约定 k: v 表示键值对关系，冒号后面必须有一个空格 使用空格的缩进表示层级关系，空格数目不重要，只要是左对齐的一列数据，都是同一个层级的 大小写敏感 缩进时不允许使用Tab键，只允许使用空格。 松散表示，Java中对于驼峰命名法，可用原名或使用-代替驼峰，如java中的lastName属性,在yml中使用lastName或 last-name都可正确映射。 键值关系 对于键与值主要是看能否表示以下内容：普通的值(数字、字符串、布尔)、日期、对象、数组、集合等。 普通值(字面量) k: v：字面量直接写； 字符串默认不用加上单引号或者双绰号； &quot; &quot;: 双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 name: &quot;zhangsan \\n lisi&quot;：输出；zhangsan 换行 lisi ‘ ’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据 12345name1: zhangsanname2: &#x27;zhangsan \\n lisi&#x27;name3: &quot;zhangsan \\n lisi&quot;age: 18flag: true 日期 1date: 2021/01/01 对象(属性和值)、Map(键值对) 在下一行来写对象的属性和值的关系，注意缩进 12345people: name: zhangsan age: 20# 行内写法people: &#123;name:zhangsan,age: 20&#125; 数组、list、set 用-值表示数组中的一个元素 123456pets: - dog - pig - cat# 行内写法pets: [dog,pig,cat] 数组对象、list对象、set对象 123456peoples: - name: zhangsan age: 22 - name: lisi age: 20 - &#123;name: wangwu,age: 18&#125; 与Java对比 Java代码示例（省略get，set方法） 12345678910111213141516public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Dog&gt; lists; private Dog dog; private String[] arr;｝public class Dog &#123; private String name; private Integer age;&#125; 对应yml 123456789101112131415161718person: boss: false maps: k1: v1 k2: 14 lists: - name: d1 age: 2 - name: d2 age: 3 - &#123;name: d3,age: 4&#125; birth: 2017/12/15 dog: name: p_dog age: 15 age: 13 last-name: 张三 arr: [s1,s2,s3] 文档块 对于测试环境，预生产环境，生产环境可以使用不同的配置，如果只想写到一个文件中，yml与是支持的，每个块用---隔开 12345678910111213141516171819server: port: 8081spring: profiles: active: prod #激活对应的文档块---server: port: 8083spring: profiles: dev #指定属于哪个环境---server: port: 8084spring: profiles: prod #指定属于哪个环境 Pug模板引擎 hexo默认的是使用ejs，同类型的东西还有很多，比如jade，swig。我选用主题是用jade的。hexo首先会解析md文件，然后根据layout判断布局类型，再调用其他的文件，这样每一块的内容都是独立的，提高代码的复用性。最终会生成一个html页面。 jade采用缩进语法格式，和python比较类似，看上去也很舒服，我比较喜欢这种风格。在hexo中使用jade需要安装相应的模块，否则无法使用。 关于Pug模板语言，可以查看我的一篇博客 Pug模板引擎https://xiaoliblog.cn/page/pug.html styl配置文件 Stylus 是一个 基于Node.js的CSS的预处理框架。以说是一种新型语言，其本质上做的事情与sass/less等类似。Stylus 比less更强大，而且基于nodejs；比sass更符合我们的思路。 关于Stylus预处理语言，可以查看我的一篇博客 Stylus预处理框架https://xiaoliblog.cn/page/Stylus.html","path":"page/hexo03.html","date":"12-04","excerpt":"","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://xiaoliblog.cn/tags/Hexo/"}]},{"title":"换机软件及开发环境备忘手册","text":"必装神器常用软件 Snippaste 目前用过最赞的截图软件 官方网址：https://zh.snipaste.com/ Potplayer 具有强大的解码库，各种格式的视频都能够播放，而且对电脑的要求也比较低，播放起来十分流畅！ 官方网址：https://potplayer.en.softonic.com/ Bandicam 录屏神器，Bandicam 是行业领先的游戏录制屏幕录像软件 官方网址：http://www.bandicam.cn/ 火绒安全软件 专业尽职 极致低调 只为巩固安全防线 官方网址：https://www.huorong.cn/ 格式工厂 好用的视频，音频，图片文件一键格式转换工具 腾讯软件中心格式工厂下载链接 ScreenToGif 超好用的Gif制作软件 官方网址：https://www.screentogif.com/ Bandizip 一个强大的多功能解压缩文件管理工具 官方网址：https://www.bandisoft.com/bandizip/ Office全家桶 Office全家桶没得说，办公必备 官方网址：https://www.office.com/ 万彩办公大师 万彩办公大师包含：pdf工具套件、格式转换工具套件、图片编辑工具套件、OCR识别工具套件、屏幕录制工具套件、文件处理工具套件等 官方网址：http://www.wofficebox.com/ Adobe全家桶 Lightroom、Photoshop、Premiere、Audition 官方网址：https://www.adobe.com/cn/ QQ、微信就不用提了 开发软件 Typora 超好用的MarkDown编辑器 官方网址：https://www.typora.io/ PicGo 基于Electron-Vue开发的图床工具 Github地址：https://github.com/Molunerfinn/PicGo Visual Studio Code 前端开发必备神器，免费开源的现代化微软代码编辑器，支持几乎所有主流的开发语言的语法高亮、括号匹配、代码片段、代码对比 Diff、GIT 等特性 官方网址：https://code.visualstudio.com/ IntelliJ IDEA 最给力的Java后端开发神器 官方网址：https://www.jetbrains.com/idea/ PyCharm 最流行的Python开发工具 官网网址：https://www.jetbrains.com/pycharm/ Sublime text3 轻量化写代码神器 官方网址：https://www.sublimetext.com/3 Postman 开源的网页调试工具 官方网址：https://www.postman.com/downloads/ Dev-C++ 是一个windows下的c和c++程序的集成开发环境 下载地址：https://bloodshed-dev-c.en.softonic.com/ SQLyog 开源的图形化MySQL数据库管理工具 官方网址：https://sqlyog.en.softonic.com/ Xshell and Xftp XShell是一个强大的安全终端模拟软件 官方网址：https://www.xshellcn.com/ SQLDeveloper Oracle官方开发数据库管理工具 官方下载地址：https://www.oracle.com/tools/downloads/sqldev-downloads.html 开发环境Java开发环境 Java-JDK8下载：https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html 根据电脑配置下载完成后双击安装，双击安装，路径默认。后面也是全部默认安装。 安装完成后，可在命令行窗口，输入 java -version 查看 java 安装版本 然后配置环境变量，参考我的博客Java基础语法-环境变量 下载Maven并配置Maven本地仓库和阿里镜像，最后还需要配置环境变量 Python开发环境 进入官网：https://www.python.org/downloads/windows/ 在下载列表中选择Window平台安装包，包格式为：python-XYZ.msi 文件 ， XYZ 为你要安装的版本号 下载后，双击下载包，进入 Python 安装向导，安装非常简单，你只需要使用默认的设置一直点击”下一步”直到安装完成即可 Anaconda 是一个 python 库管理软件，可以方便的管理和安装 python 的各类库 Anoconda镜像下载地址：https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/ 具体下载及安装配置参考👉Anaconda的安装教程 Hexo博客环境 Hexo 基于 Node.js，搭建过程中还需要使用 npm（Node.js 已带） 和 git，因此先搭建本地操作环境，安装 Node.js 和 Git。 Node.js下载网址：https://nodejs.org/zh-cn Node.js安装教程：https://blog.csdn.net/antma/article/details/86104068 Git下载地址：https://git-scm.com/download/win Git安装及配置：https://www.cnblogs.com/xueweisuoyong/p/11914045.html 安装完成后，任意位置右击鼠标Git Bash Here(全程用Git Bash,git为linux命令) 1$ node -v 1$ npm -v 1$ git --version 记得把npm换源，使用阿里服务器下载 1npm config set registry https://registry.npm.taobao.org Codesheep书签 推荐B站CodeSheep的浏览器书签 密码:33av","path":"page/computer.html","date":"12-04","excerpt":"","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://xiaoliblog.cn/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"Butterfly魔改系列🦋搞定背景音乐","text":"hexo-tag-aplayer hexo-tag-aplayer插件项目地址：https://github.com/MoePlayer/hexo-tag-aplayer 安装插件 1$ npm install --save hexo-tag-aplayer(安装插件) 配置说明 1234567891011aplayer: true（在Font-Matter中）&#123;% meting &quot;2751269737&quot; &quot;netease&quot; &quot;playlist&quot; &quot;autoplay&quot; &quot;mutex:false&quot; &quot;listmaxheight:340px&quot; &quot;preload:none&quot; &quot;theme:#ad7a86&quot;%&#125;参数介绍： &quot;narrow&quot;: false,// （可选）播放器袖珍风格 &quot;autoplay&quot;: true,// （可选) 自动播放，移动端浏览器暂时不支持此功能 &quot;mode&quot;: &quot;random&quot;,// （可选）曲目循环类型，有 &#x27;random&#x27;（随机播放）, &#x27;single&#x27; (单曲播放), &#x27;circulation&#x27; (循环播放), &#x27;order&#x27; (列表播放)， 默认：&#x27;circulation&#x27; &quot;showlrc&quot;: 3,// （可选）歌词显示配置项，可选项有：1,2,3 &quot;mutex&quot;: true,// （可选）该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停 &quot;theme&quot;: &quot;#e6d0b2&quot;,// （可选）播放器风格色彩设置，默认：#b7daff &quot;preload&quot;: &quot;metadata&quot;,// （可选）音乐文件预载入模式，可选项： &#x27;none&#x27; &#x27;metadata&#x27; &#x27;auto&#x27;, 默认: &#x27;auto&#x27; &quot;listmaxheight&quot;: &quot;513px&quot;,// (可选) 该播放列表的最大长度 创建一个页面进行配置 12345678---title: 音乐date: 2020-11-19 18:02:36aplayer: true---# 吉他指弹音乐歌单&#123;% meting &quot;5345536427&quot; &quot;netease&quot; &quot;playlist&quot; &quot;autoplay&quot; &quot;mutex:false&quot; &quot;listmaxheight:340px&quot; &quot;preload:none&quot; &quot;theme:#ad7a86&quot;%&#125; 明月浩空音乐 转载自👉👉👉博主XJHui&#39;s Blog不会pjax？这篇博客教你如何搞定背景音乐 注册并登陆 明月浩空音乐官网地址：https://myhkw.cn/ 进入官网进行注册，输入用户名、密码等信息： 注册并登录后，进入管理控制台 点击添加【+播放器】，输入播放器名称： 配置播放器 进入【播放器管理】，配置授权域名，这个功能的目的是防止盗取播放次数，对于付费用户（特别购买播放次数的用户）如果别人盗取了你播放器id 将其用于自己网站，那么你的播放次数就得不到保障 点击左侧【新建歌单】 进入【歌单管理】，为歌单添加音乐 将歌单加入播放器： 删除原有歌单的原因：免费用户只能添加一个歌单 开始使用 在【播放器管理】可以进行个性化设置，然后进行测试 如果没有该选项，尝试刷新页面解决 测试成功后，获取 js 代码： 以本人的butterfly主题为例，若版本&gt;=2.3.5，则在主题配置文件中搜索bottom，将复制的js代码粘贴上去 123456inject: head: bottom: # 皓月当空音乐 - &lt;script src=&quot;//lib.baomitu.com/jquery/3.5.1/jquery.min.js&quot;&gt;&lt;/script&gt; - &lt;script src=&quot;https://myhkw.cn/api/player/160561664166&quot; id=&quot;myhk&quot; key=&quot;160561664166&quot; m=&quot;1&quot;&gt;&lt;/script&gt; 如果本地运行提示，就需要再加上jQuery的js 1&lt;script src=&quot;//lib.baomitu.com/jquery/3.5.1/jquery.min.js&quot;&gt;&lt;/script&gt; 后记 使用 hexo s 命令本地测试时播放器不能使用，因为在前面步骤中播放器绑定了安全域名，而本地使用的域名是 localhost:4000，导致触发限制，执行 hexo d 命令后将其推到远程仓库，即可在自己博客使用啦！","path":"page/butterfly03.html","date":"12-04","excerpt":"","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://xiaoliblog.cn/tags/Hexo/"}]},{"title":"Hexo博客部署到阿里云服务器","text":"前言 最近学Linux特意搞了一个阿里云轻量级服务器，服务器购买及宝塔配置请参考：https://xiaoliblog.cn/page/server.html 虽然只有三个月到期，就想着把博客部署到服务器试试，新手部署服务器最常见的方法就是：直接把本地生成的public中的文件，直接ftp到服务器www根目录，简单粗暴 还有一种更优雅地方式，那就是直接在服务器上搭建git仓库，hexo三连直接deploy上去（跟搭建在github pages上的方式一样）` 详情请参考《Hexo 部署至云服务器（宝塔面板） 》：https://www.heson10.com/posts/51315.html 部署教程 服务器安装宝塔面板 创建git仓库，并配置git钩子，自动同步文件到网站目录 配置网站访问设置 本地git deploy设置 准备工作 云服务安装宝塔面板：https://xiaoliblog.cn/page/server.html 本地生成ssh密钥备用，已有可忽略 1234git config --global user.name &quot;GitHub用户名&quot;git config --global user.email &quot;GitHub的邮箱&quot;ssh-keygen -t rsa -C &quot;GitHub的邮箱&quot;git config --global core.autocrlf false # 禁用自动转换，这个不设置后面上传时会出现警告 id_ras.pub存放路径在Win10下是C:\\Users\\电脑自定义名\\.ssh下 连接服务器终端 宝塔面板用户可直接左侧导航栏终端登录 也可以使用XShell远程连接服务器 切换到root账号· 1sudo su root 安装git 12git --version # 没有就安装yum install git 创建Git账户 创建Git账户并赋予权限 12adduser gitchmod 740 /etc/sudoers 编辑/etc/sudoers/文件· 1vim /etc/sudoers 按i进入编辑模式，找到root ALL=(ALL) ALL，在其下方加入： 1git ALL=(ALL) ALL 输入完成后按esc，再输入:wq，保存退出。 更改/etc/sudoers权限 1chmod 400 /etc/sudoers 设置git账户密码 1sudo passwd git 输入密码，输入的时候是看不到任何显示的，输完回车即可。 切换至 git 用户，创建 ~/.ssh 文件夹和 ~/.ssh/authorized_keys 文件 123su gitmkdir ~/.sshvim ~/.ssh/authorized_keys 同样i进入编辑模式，把之前本地准备的id_rsa.pub文件中的公钥复制进去，按esc后，输入:wq保存 更改权限 12chmod 600 /home/git/.ssh/authorized_keyschmod 700 /home/git/.ssh 本地右击桌面输入git Bash测试 1ssh -v git@服务器ip地址或域名 注：此时的 ssh 登录 git 用户不需要密码！否则就有错 创建git仓库 切换为root用户 1sudo su root 创建repo作为仓库目录，并加权限 123mkdir /var/repochown -R git:git /var/repochmod -R 755 /var/repo 创建 hexo 目录作为网站根目录 123mkdir /var/hexochown -R git:git /var/hexochmod -R 755 /var/hexo 创建一个空白的 git 仓库 12cd /var/repogit init --bare hexo.git 编辑一个 Git 钩子 1vim /var/repo/hexo.git/hooks/post-receive 按i进入编辑模式，添加下面的代码，按esc输入:wq 保存 12#!/bin/bashgit --work-tree=/var/hexo --git-dir=/var/repo/hexo.git checkout -f 更改权限 12chown -R git:git /var/repo/hexo.git/hooks/post-receivechmod +x /var/repo/hexo.git/hooks/post-receive 宝塔网站配置 创建一个网站 本地 Git deploy 设置 安装git部署插件 1npm install hexo-deployer-git --save 在博客根目录配置 1234deploy: type: git repo: git@服务器ip或域名:/var/repo/hexo.git branch: master 配置完成后，可直接hexo三连到自己的服务器。简单快捷。","path":"page/hexo02.html","date":"12-04","excerpt":"","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://xiaoliblog.cn/tags/Hexo/"}]},{"title":"Pug模板语言","text":"Pug模板引擎 Pug，原名 Jade， 是一个很流行的 HTML 模板引擎，后来由于 Jade 被注册为商标的原因，改名为 Pug，可以参考Pug官方文档：https://www.pugjs.cn/api/getting-started.html 模板引擎的作用，就是将界面与数据分离。最简单的原理是将模板内容中指定的地方替换成数据，实现业务代码与逻辑代码分离。 Pug模板特点 无需结束标签 在html中，几乎每个标签都需要写相应的结束标签，这既耗费时间和精力又使代码更加冗长，而且万一忘了写结束标签会导致不可预期又难以定位的错误。相比之下，pug没有结束标签，代码更加简洁高效。 强制缩进 强制缩进有人喜欢有人不喜欢，但是它带来的好处却是无可置疑的：它使得团队中所有人的风格都统一了起来，使得阅读别人的代码不再那么恐怖，让所有人都养成了缩进代码的好习惯，也减少了因为代码格式化产生的冲突等问题。 代码复用和维护 pug中的include功能让我们可以不再一遍又一遍地写相同的代码，如头部引用和组件模板等。遇到要修改时也不用一个又一个地去搜索和修改每一个地方，只需修改一个地方一次。 标签写法与CSS相同 pug中的标签的写法与CSS中的选择器相同，因此写CSS时更加方便，可以直接拷贝tag作为选择器编写样式。 缺点有： 一旦强制缩进嵌套过多，阅读起来比较吃力。 pug模板和最后生成的html页面有一定差距。有时调试起来并不容易。 安装Pug 通过npm安装Pug 1npm install pug -g 如果需要使用命令行对 pug 模板进行编译，还需要安装 pug-cli 1npm install pug-cli -g 初写Pug 创建index.pug 文件 12div p Hello Pug 使用以下命令可以看到pug生成的HTML文档 其会自动在xxx.pug文件夹下生成一个xxx.html的文件 -P参数可以让html文档变得有可读性， -w可以实时监控.pug文件的修改，如果有变化就自动更新相应的html文件。 常用的还有-o用来指定输出的html的目录。 1pug -P -w index.pug 可以看到生成了一个index.html文件 123&lt;div&gt; &lt;p&gt;Hello Pug&lt;/p&gt;&lt;/div&gt; 将HTML转为Pug（jade）的工具 html2jade：http://html2jade.org/ aaron-powell：http://html2jade.aaron-powell.com/ Pug语法 注意：统一使用tab或者空格缩进，如果混用，就不会有我们想要的效果了 基础 Pug对缩进很严格，pug 模板中省略了 HTML 中的标签&lt; &gt;，其通过缩进关系，代替以前html的层级包含关系，标签后空格内容表示标签中内容 1234567doctype htmlhead meta(charset&#x3D;&#39;utf-8&#39;) title Hello Pugbody div p Hello Pug 编译结果 12345678910&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Hello Pug&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt;Hello Pug&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 标签 HTML 标签中的属性用 ( ) 包围起来，属性之间用 , 隔开，属性值用&#39; &#39;包裹 1a(href&#x3D;&#39;&#x2F;&#x2F;www.baidu.com&#39;, title&#x3D;&#39;百度一下&#39;) 百度一下 编译后· 1&lt;a href=&quot;//www.baidu.com&quot; title=&quot;百度一下&quot;&gt;百度一下&lt;/a&gt; 文本 利用空格分割表示文本，多行文本需要在标签后加 ., 文本内容保持同样缩进 如果文本中还包含标签，则需要直接添加标签 1234p. line1 line2 line3 &lt;strong&gt;strong&lt;&#x2F;strong&gt; 编译后 12345&lt;p&gt; line1 line2 line3 &lt;strong&gt;strong&lt;/strong&gt;&lt;/p&gt; 这种情况一般适用于大段文字的例子，比如 &lt;script&gt; 中的内容： 1234script. (function test() &#123; alert(123) &#125;)() 编译后 12345&lt;script&gt; (function test() &#123; alert(123) &#125;)()&lt;/script&gt; 也可以使用|来书写，效果相同 1234p | line1 | line2 | line3 &lt;strong&gt;strong&lt;&#x2F;strong&gt; 如果一行的开头是尖括号 &lt;，那么正行都会当做纯文本，即便当中的内容包含 HTML 标签，也会原样输出： 1&lt;span&gt;123&lt;/span&gt; 注释 单行注释· 12&#x2F;&#x2F; 这个注释会被编译到HTML&#x2F;&#x2F;- 这个注释不会被编译到HTML 块注释 123&#x2F;&#x2F; 块注释 块注释 IE注释 123&lt;!--[if IE 8]&gt;&lt;html class&#x3D;&#39;ie8&#39;&gt;&lt;[endif]--&gt;&lt;!--[if IE 9]&gt;&lt;html class&#x3D;&#39;ie9&#39;&gt;&lt;[endif]--&gt;&lt;!--[if IE]&gt;&lt;html class&#x3D;&#39;ie8&#39;&gt;&lt;[endif]--&gt; 变量 利用-开始一段不直接进行输入的代码 12- for (var i &#x3D; 0; i&lt;3; i++) p #&#123;i&#125; 利用= 开始一段带有输出的代码（注意 = 前后不能有空格） 12- for (var i &#x3D; 0; i&lt;3; i++) p&#x3D;i 编译后 123&lt;p&gt;1&lt;/p&gt;&lt;p&gt;2&lt;/p&gt;&lt;p&gt;3&lt;/p&gt; 声明变量使用 -var varName = varValue, 使用变量 #&#123;varName&#125; 12- var text&#x3D;&#39;Pug&#39;p Hello #&#123;text&#125; 编译后 1&lt;p&gt;Hello Pug&lt;/p&gt; 默认情况下，所有属性都经转义，目的是为了防止跨站脚本攻击等攻击方式 12- var unescaped &#x3D; &#39;&lt;strong&gt;Hello&lt;&#x2F;strong&gt;&#39;p #&#123;unescaped&#125; 编译后 1&lt;p&gt;&amp;lt;strong&amp;gt;Hello&amp;lt;/strong&amp;gt;&lt;/p&gt; 如果需要使用特殊字符，即未经过转义的字符， 在引用变量时使用 !&#123;&#125; 代替 #&#123;&#125;（在定义属性时用 != 代替 =） 12- var unescaped &#x3D; &#39;&lt;strong&gt;Hello&lt;&#x2F;strong&gt;&#39;p !&#123;unescaped&#125; 编译后 1&lt;p&gt;&lt;strong&gt;Hello&lt;/strong&gt;&lt;/p&gt; 未经定义的变量输出结果是空值，而非 undefined 类 class 可以是一个字符串，也可以是一个包含多个类名的数组 1p(class&#x3D;[&#39;class1&#39;, &#39;class2&#39;]) class 编译后 1&lt;p class=&quot;class1 class2&quot;&gt;class&lt;/p&gt; 也可以是一个对象 1p(class&#x3D;&#123;class3: false, class4: true&#125;) class 编译后 1&lt;p class=&quot;class4&quot;&gt;class&lt;/p&gt; 类和ID的字面量 类可以使用 .classname 语法来定义， ID 使用 #idname 来定义，在省略标签名是默认是 div 1234&#x2F;&#x2F; p.class5 classp#id1 id.class6 class 编译后 123&lt;p class=&quot;class5&quot;&gt;class&lt;/p&gt;&lt;p id=&quot;id1&quot;&gt;id&lt;/p&gt;&lt;div class=&quot;class6&quot;&gt;class&lt;/div&gt; &amp;attributes &amp;attributes 语法可以将一个对象转化为一个元素的属性列表。 1p#id2(class&#x3D;&#39;class7&#39;)&amp;attributes(&#123;&#39;data-url&#39;: &#39;&#x2F;&#x2F;www.baidu.com&#39;&#125;) 编译后 1&lt;p class=&quot;class7&quot; id=&quot;id2&quot; data-url=&quot;//www.baidu.com&quot;&gt;&lt;/p&gt; 流程控制条件控制 可以省略语句开头的 -, 类似常规的 JavaScript 语法形式 12345678- var number &#x3D; function() &#123;return 15&#125;;if(number() &lt; 0) p number &lt; 0else if(number() &gt; 5) p number &gt; 5else p number between (0,5) unless varA 等同于 if(!varA) 循环 使用 each 实现循环是最常见的方式，第二个参数就是循环时的索引值 123ul each val in [1,2,3,4,5] li #&#123;val + &#39;index&#39; + index&#125; &#x2F;&#x2F; 等同于 li&#x3D;val + &#39;index&#39; + index 编译后 1234567&lt;ul&gt; &lt;li&gt;1index0&lt;/li&gt; &lt;li&gt;2index1&lt;/li&gt; &lt;li&gt;3index2&lt;/li&gt; &lt;li&gt;4index3&lt;/li&gt; &lt;li&gt;5index4&lt;/li&gt;&lt;/ul&gt; 也可以对对象进行循环 1234- var object &#x3D; &#123;name: &#39;chow&#39;, age:22&#125;; ul each value, key in object li&#x3D;key + &#39;:&#39; + value 编译后 1234&lt;ul&gt; &lt;li&gt;name:chow&lt;/li&gt; &lt;li&gt;age:22&lt;/li&gt;&lt;/ul&gt; 用于迭代的对象或数组仅仅是个 JavaScript 表达式，因此它可以是变量、函数调用的结果 1each value, key in friends &gt; 110 ? object : &#39;&#39; 可以为 each 添加一个 else 块，用于当被循环对象无法提供被循环内容时调用 123456- var friends &#x3D; 100ul each value, key in friends &gt; 110 ? object : &#39;&#39; li&#x3D;key + &#39;:&#39; + value else li nothing 也可以使用while 来创建循环 1234- var n &#x3D; 0;ul while n &lt; 4 li&#x3D; n++ 分支条件 case 是 JavaScript 中 switch 中的缩写 123456789- var friends &#x3D; 1case friends when 1 p you only have 1 friend when 2 p you have 2 friends default p you have a lot of friends 可以使用块展开的语法： 123456- var friends &#x3D; 11case friends when 1: p you only have 1 friend when 2: p you have 2 friends default: p you have a lot of friends 包含 相当于 JavaScript 中的 import 功能 123456789101112&#x2F;&#x2F; - index.pugdoctype htmlhtml include includes&#x2F;head.pug body h1 我的网站 p 欢迎来到我这简陋得不能再简陋的网站。 include includes&#x2F;foot.pug&#x2F;&#x2F; - includes&#x2F;head.pughead title 我的网站 编译后 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;我的网站&lt;/title&gt; &lt;script src=&quot;/javascripts/jquery.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/javascripts/app.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我的网站&lt;/h1&gt; &lt;p&gt;欢迎来到我这简陋得不能再简陋的网站。&lt;/p&gt; &lt;footer id=&quot;footer&quot;&gt; &lt;p&gt;Copyright (c) foobar&lt;/p&gt; &lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; 被包含的如果不是 Pug 文件，那么就只会当作文本内容来引入 12345script include say.js&#x2F;&#x2F; say.jsalert(&#39;hello&#39;); 编译后 123&lt;script&gt; alert(&#x27;hello&#x27;);&lt;/script&gt; 模板继承 Pug 支持使用 block 和 extends 实现继承，一个称之为“块”（block）的代码块，可以被子模板覆盖、替换。这个过程是递归的。 简单来说就是，b.pug 通过 extends a.pug 关键词来继承 a.pug 中的全部代码，再通过声明与 a.pug 中相同的 block 来替代原来模板中的内容 Pug 允许您去替换（默认的行为）、prepend（向头部添加内容），或者 append（向尾部添加内容）一个块。 Pug 模板继承是一个非常强大的功能，您可以借助它将复杂的页面模板拆分成若干个小而简洁的文件。然而，如果您将大量的模板继承、链接在一起，那么有可能会反而把事情弄得更加复杂。 Mixin Mixin 实现了代码的复用 12mixin myMixin li This should be repeated 编译后： 123456789ul each n in [1,2,3] +myMixin&lt;ul&gt; &lt;li&gt;This should be repeated&lt;/li&gt; &lt;li&gt;This should be repeated&lt;/li&gt; &lt;li&gt;This should be repeated&lt;/li&gt;&lt;/ul&gt; 可以向 myMixin中传入参数 12mixin myMixin(text) li This should be #&#123;text&#125; 编译后： 123456789ul each n in [1,2,3] +myMixin(n)&lt;ul&gt; &lt;li&gt;This should be 1&lt;/li&gt; &lt;li&gt;This should be 2&lt;/li&gt; &lt;li&gt;This should be 3&lt;/li&gt;&lt;/ul&gt; 其实可以将 Mixin 理解为一个函数，返回值是一段 HTML 代码，每次调用都会返回相同值 123function myMixin(text)&#123; return `&lt;li&gt;This should be $&#123;text&#125;&lt;/li&gt;`&#125; 也可以通过 block 关键字将外部内容传入到 Mixin 中 123456789mixin article(name) if block block else p 默认内容+articlep ------------------+article p 随便写点什么 编译后： 123&lt;p&gt;默认内容&lt;/p&gt;&lt;p&gt;------------------&lt;/p&gt;&lt;p&gt;随便写点什么&lt;/p&gt; 可以向 Mixin 中引入rest 参数 1234mixin rest(name, ...others) each other in others p&#x3D;&#39;剩余参数是&#39; + other+rest(&#39;old_chow&#39;, 1,2,3,4,5) 12345&lt;p&gt;剩余参数是1&lt;/p&gt;&lt;p&gt;剩余参数是2&lt;/p&gt;&lt;p&gt;剩余参数是3&lt;/p&gt;&lt;p&gt;剩余参数是4&lt;/p&gt;&lt;p&gt;剩余参数是5&lt;/p&gt; 当然是 arguments 对象在 Mixin 中也是可以使用的 arguments 是传入函数的所有参数，rest是对应位置的参数 Vue 中使用 Pug 在 Vue 的单文件组件中的 &lt;template&gt; 中可以使用 Pug 进行模板的编写（JADE步骤相同） 首先安装 Pug 依赖 1npm install pug pug-loader pug-filters -D 安装成功后，在 webpack 的配置文件 webpack.base.conf.js 的 modules 中的 rules 节点下添加如下配置： 1234&#123; test: /\\.pug$/, loader: &#x27;pug&#x27;&#125; 这样，.vue 单文件组件 就支持 Pug 并实时编译了。 12345678910111213141516171819&lt;template lang=&quot;pug&quot;&gt; ul - var arr = [1,2,3] each value in arr li(id=&quot;test&quot; + value) value + &#123;&#123;this.name&#125;&#125;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; name: &#x27;chow&#x27; &#125; &#125;, computed: &#123;&#125;, methods: &#123;&#125;, components: &#123;&#125; &#125;&lt;/script&gt;","path":"page/pug.html","date":"12-04","excerpt":"","tags":[{"name":"Pug","slug":"Pug","permalink":"http://xiaoliblog.cn/tags/Pug/"}]},{"title":"Stylus预处理框架","text":"styl配置文件 Stylus 是一个 基于Node.js的CSS的预处理框架。以说是一种新型语言，其本质上做的事情与sass/less等类似。Stylus 比less更强大，而且基于nodejs；比sass更符合我们的思路。 安装Stylus 安装 12# installnpm install stylus -g 使用以下命令，把xxx.styl文件编译成xxx.css文件 -w(watch): 监听文件的变化并重新编译， -o(out): 输出css文件 12# watch and complie stylus file from command linestylus -w xxx.styl -o xxx.css 语法选择器 冒号,分号,大括号可写可不写 后代关系用相同缩进表示 父子关系用&gt;表示 伪类元素用 &amp; 表示其宿主元素 属性写在前, 嵌套子元素样式写在后 分组选择器用相同缩进即可, 如 +a`` +span +span 编写index.styl文件，并通过stylus -w index.styl -o index.css命令转换 变量 定义变量并赋值(建议用 $作 为 变 量 前 缀 ) , 如$width=3px 定义函数(arguments为内置所有参数, 也可自定义参数), border() $width dashed #foo 函数参数可以写默认值，类似于es6的解构赋值， 如 padding(top=1px,right=2px) 方法名加() 为调用函数，如 border() 建议变量定义在最上面, 然后是函数, 然后才是代码. 最好的方式是变量和函数定义成单独的文件, 然后通过@import variable.styl 导入 使用@height 会冒泡查找值, 如自身有此属性则获取该属性值; 否则层层向上查找该属性, 如果都没有则报错 可以使用运算符进行计算 z-index 1 unless @z-index 表示默认 z-index=1 除非 @z-index 存在 插值 实现类似 autoprefixer.css 的效果给兼容属性加前缀 使用循环 for in 减少代码量 使用 if-else 判断逻辑 尾参数… 可以使用 args... 或者 arr... 等接受所有参数; 前面也可以单个接受参数; 但是 尾参数写法只能作为最后一个参数 也可以使用 args[0] 或者 arguments[0] 这种下标的方式访问 args... 会忽略 , ;如果希望不忽略请使用 arguments @extend继承 使用 @extend 将公共样式抽取, 用子类继承; 在html中可以少写一个类名 ,如 class=&quot;btn btn-primary&quot; 只需要写成 class=&quot;btn-primary&quot;","path":"page/Stylus.html","date":"12-04","excerpt":"","tags":[{"name":"Stylus","slug":"Stylus","permalink":"http://xiaoliblog.cn/tags/Stylus/"}]},{"title":"Hexo博客访问速度优化","text":"Vercel加速使用Vercel加速GitHub Pageshttps://xiaoliblog.cn/page/vercel.html JsDeliver加速文件前期准备 一个GitHub账号 创建一个仓库用于上传文件 上传文件或者图片后就可以通过JsDeliver链接方式加速 已搭建好博客仓库的可以忽略 JSD链接 比如我想访问博客仓库img目录下的404.jpg 可以通过JSD链接访问https://cdn.jsdelivr.net/gh/xiaoliblog/xiaoliblog.github.io/img/404.jpg 直接引用方式分支及版本号 格式：https://cdn.jsdelivr.net/gh/&lt;用户名&gt;/&lt;仓库名&gt;/&lt;文件及路径&gt; 比如以上链接：https://cdn.jsdelivr.net/gh/xiaoliblog/xiaoliblog.github.io/img/404.jpg代表GitHub用户名xiaoliblog下的xiaoliblog.github.io里img目录下的404.jpg 分支与版本号加到仓库后面，用 @符链接。格式为：https://cdn.jsdelivr.net/gh/&lt;用户名&gt;/&lt;仓库名&gt;@[分支/版本号]/&lt;文件及路径&gt; 分支名 简述 特点 普通分支 即 GitHub 的分支，可以创建多个。默认为 master 按分支引用，如同按分支开发 latest 最后一次提交 代表最后一次的提交，即每上传一个新文件，都可以用这个分支引用到。也就是不加版本号的默认情况。 版本号 即指定版本的内容，需配合版本发布 已发布的版本不会受到仓库内容变化的影响 使用版本号引用的优点在于：这个链接仅停留在发布版本号的时刻，无论仓库如何变化，这个版本号的文件都不会受到影响。同时可以避免 JSD 缓存问题 发布版本 使用版本号访问image仓库下的headimg.jpg访问链接：https://cdn.jsdelivr.net/gh/xiaoliblog/image@v1.0/headimg.jpg，可以发现只在仓库名image后面加上@版本号即可 静态资源加速图片资源加速 压缩图片分为有损压缩和无损压缩。无损压缩推荐 Tinypng，有损压缩推荐 imagine TinyPNG Imagine 特点 无损压缩 有损压缩，以牺牲图像质量，降低图像色彩来达到缩减图像大小的目的。 优点 能够完全保留图像色彩，不损伤图像质量 1. 压缩程度高，支持转 png 为 jpg 或 webp，进一步减少图片大小2. 软件支持一次处理多张图片，无上限，处理完成支持直接批量覆盖原文件或重命名 缺点 单次仅能上传 20 张图片，每张限制大小为 5MB，无法处理更大图片。 PNG 转其他格式为不可逆操作（指覆盖保存后），且可能反而会增加图片大小。 如果没有特别要求，直接使用Imagine进行有损压缩即可。虽然说是有损压缩，但是默认压缩会自主计算压缩程度，一般默认程度就能节省 70% 空间，且肉眼几乎发现不了图片压缩情况。 Gulp 压缩全站静态资源 参考 Butterfly 作者的教程：https://butterfly.js.org/posts/4073eda/#Gulp%E5%A3%93%E7%B8%AE 安装 Gulp 12npm install -g gulp-cli npm install gulp --save-dev 安装压缩 HTML 12npm install gulp-htmlclean --save-devnpm install gulp-html-minifier-terser --save-dev 压缩HTML gulp-html-minifier-terser 可以压缩 HTML 里的 ES6 语法 安装压缩CSS 1npm install gulp-clean-css --save-dev 安装压缩JS 12npm install --save-dev gulp-uglifynpm install --save-dev gulp-babel @babel/core @babel/preset-env 在博客根目录下创建gulpfile.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748var gulp = require(&#x27;gulp&#x27;);var cleanCSS = require(&#x27;gulp-clean-css&#x27;);var htmlmin = require(&#x27;gulp-html-minifier-terser&#x27;);var htmlclean = require(&#x27;gulp-htmlclean&#x27;);var uglify = require(&#x27;gulp-uglify&#x27;)var babel = require(&#x27;gulp-babel&#x27;) gulp.task(&#x27;compress&#x27;, () =&gt; gulp.src([&#x27;./public/**/*.js&#x27;, &#x27;!./public/**/*.min.js&#x27;]) .pipe(babel(&#123; presets: [&#x27;@babel/preset-env&#x27;] &#125;)) .pipe(uglify().on(&#x27;error&#x27;, function (e) &#123; console.log(e) &#125;)) .pipe(gulp.dest(&#x27;./public&#x27;)))gulp.task(&#x27;minify-css&#x27;, () =&gt; &#123; return gulp.src([&#x27;./public/**/*.css&#x27;]) .pipe(cleanCSS(&#123; compatibility: &#x27;ie11&#x27; &#125;)) .pipe(gulp.dest(&#x27;./public&#x27;));&#125;); gulp.task(&#x27;minify-html&#x27;, () =&gt; &#123; return gulp.src(&#x27;./public/**/*.html&#x27;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, //清除 HTML 註释 collapseWhitespace: true, //压缩 HTML collapseBooleanAttributes: true, //省略布尔属性的值 &lt;input checked=&quot;true&quot;/&gt; ==&gt; &lt;input /&gt; removeEmptyAttributes: true, //删除所有空格作属性值 &lt;input id=&quot;&quot; /&gt; ==&gt; &lt;input /&gt; removeScriptTypeAttributes: true, //删除 &lt;script&gt; 的 type=&quot;text/javascript&quot; removeStyleLinkTypeAttributes: true, //删除 &lt;style&gt; 和 &lt;link&gt; 的 type=&quot;text/css&quot; minifyJS: true, //压缩页面 JS minifyCSS: true, //压缩页面 CSS minifyURLs: true &#125;)) .pipe(gulp.dest(&#x27;./public&#x27;))&#125;);// 执行 gulp 命令时执行的任务gulp.task(&#x27;default&#x27;, gulp.parallel( &#x27;compress&#x27;, &#x27;minify-css&#x27;, &#x27;minify-html&#x27;)) 在hexo g之后运行gulp进行压缩 1hexo cl &amp;&amp; hexo g &amp;&amp; gulp 异步加载 详情请参考Akilar大佬的Hexo 异步加载方案：https://akilar.top/posts/615d5ede/ 当我们的博客引入大量的第三方脚本（js），而基于页面读取 js 的加载顺序，每当浏览器在加载 html 的过程中遇到 &lt;script&gt;js代码片段&lt;/script&gt; 这样的标签时，浏览器会暂停继续构建 html，而是优先执行当前的 js 脚本，等执行完毕后再继续加载后面的 html 至于外部脚本 &lt;script src=&quot;js外链&quot;&gt;&lt;/script&gt; 这样的写法，更是要先下载脚本，然后再执行，之后才能继续处理剩余的页面 无形中，多出了一大把的加载时间。我们可以通过给 &lt;script&gt;&lt;/script&gt; 添加 defer 和 ansyc 属性来实现异步加载，调整 js 的加载时间和顺序，确保浏览器构建 HTML 的过程一切顺利 原理剖析 此图来源于Akliar大佬的异步加载方案原理https://akilar.top/posts/615d5ede/ 可以看到，总的 HTML 加载时间，下载脚本的时间，执行脚本的时间是固定的。不同之处在于 HTML 阻塞的时间以及执行脚本的次序 不加任何 async 和 defer 的情况，页面总加载时间最长，是 HTML 加载时间 + 下载脚本时间 + 执行脚本时间 加了 async`和 defer 的时间，在加载 HTML 时间足够长的情况下，所有静态资源总的加载时间都是 HTML 加载时间 + 执行脚本时间 使用范例 defer 特性除了告诉浏览器不要阻塞页面之外，还可以确保脚本执行的相对顺序。 这个很适合使用到 Vue 和 jquery 等 js 框架的 js 脚本，给它们添加 defer 属性以后，可以确保 HTML 加载完毕，且 js 下载完毕后，各个 js 脚本继续按照引入的顺序执行，从而确保不会因为依赖缺失而报错。 其他脚本不会等待 async 脚本加载完成，同样，async 脚本也不会等待其他脚本。 这个适合使用原生 js， 没有引用任何 js 框架，自己独立就能运行，且体量相对较小的 js 脚本，随页面加载同步下载执行。 async 加在那些非必要的，起装饰或者优化效果的 js 上，defer 加在那些确保页面完整性的必要 js 上 不要给影响页面生成的 js（例如 util.js、main.js、lazy_load.js、vue.js、jquery.js）添加异步加载标签 (不论是 async 还是 defer 都不要加)，不然会造成大面积页面功能模块失效 12345678910111213141516171819202122232425262728bottom: - &lt;script defer https://cdn.jsdelivr.net/npm/vue@2.6.11&quot;&gt;&lt;/script&gt; # Vue.js作为依赖项，必须确保在所有使用到它提供的方法的诸多js之前引入，并且添加defer - &lt;script defer src=&quot;/live2d-widget/autoload.js&quot;&gt;&lt;/script&gt; # 看板娘使用到了jquery依赖，所以需要defer - &lt;script async src=&quot;/js/dytitle.js&quot;&gt;&lt;/script&gt; # 动态网页标题是原生js，且体量小，可以直接async - &lt;script async src=&quot;/js/mouse_snow.min.js&quot;&gt;&lt;/script&gt; # 鼠标滑动雪花是原生js，且体量小，可以直接async - &lt;script defer data-pjax src=&quot;/clock/js/clock.js&quot;&gt;&lt;/script&gt; # 首页电子钟用到了vue依赖，所以需要defer - &lt;script defer data-pjax src=&quot;/magnet/catalogMagnet.js&quot;&gt;&lt;/script&gt; # 首页磁贴用到了vue依赖，所以需要defer - &lt;script defer src=&quot;/botui/botui.js&quot;&gt;&lt;/script&gt; - &lt;script defer data-pjax src=&quot;/botui/botui_init.js&quot;&gt;&lt;/script&gt; # 侧栏聊天窗用到了vue依赖，所以需要defer - &lt;script defer src=&quot;/runtime/flipcountdown.js&quot;&gt;&lt;/script&gt; - &lt;script defer data-pjax src=&quot;/runtime/runtime.js&quot;&gt;&lt;/script&gt; # 页脚计时器用到了jquery依赖，所以需要defer - &lt;script defer src=&quot;https://cdn.jsdelivr.net/npm/artitalk&quot;&gt;&lt;/script&gt; - &lt;script defer data-pjax src=&quot;/artitalk/artitalkkey.js&quot;&gt;&lt;/script&gt; - &lt;script defer data-pjax src=&quot;/artitalk/artitalk.js&quot;&gt;&lt;/script&gt; # 侧栏说说依赖于artitalk.js，必须确保其加载顺序，在保证页面引入顺序的同时添加defer - &lt;script async src=&quot;/js/redirect.js&quot;&gt;&lt;/script&gt; - &lt;script async src=&quot;/js/mirror.js&quot;&gt;&lt;/script&gt; # 404和镜像站重定向都是原生js，可以直接async - &lt;script defer data-pjax src=&quot;https://cdn.jsdelivr.net/gh/Akilarlxh/Akilarlxh.github.io@v3.3.3_3/gitcalendar/js/gitcalendar.js&quot;&gt;&lt;/script&gt; # gitcalendar用到了vue依赖，所以需要defer CSS 异步加载 CSS没有JS添加异步那么方便， 一种方法是通过定义一个无效 media，使得该 CSS 引入优先级最低，再用 onload=&quot;this.media=&#39;all&#39;&quot; 在页面加载完成后纠正 media，并加载 CSS 1&lt;link rel=&quot;stylesheet&quot; href=&quot;/example.css&quot; media=&quot;defer&quot; onload=&quot;this.media=&#x27;all&#x27;&quot;&gt; 还有一种利用 `rel=”preload” 属性的方案，但是目前只有 Chrome 浏览器可以完美支持，等推广还需要很长一段时间，写法如下： 1&lt;link rel=&quot;preload&quot; href=&quot;cssfile.css&quot; as=&quot;style&quot; onload=&quot;this.rel=&#x27;stylesheet&#x27;&quot;&gt;","path":"page/Hexo01.html","date":"12-03","excerpt":"","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://xiaoliblog.cn/tags/Hexo/"}]},{"title":"Butterfly魔改系列🦋扩展功能和特效","text":"扩展功能友情链接 打开Basn命令 1hexo new page link 找到C:\\[rootblog]\\source\\link\\index.md 12345---title: 友情链接date: 2020-06-03 17:53:02type: link--- 在C:\\[rootblog]\\source\\ 目录下新建_data 文件夹，文件夹内新建 link.yml 1234567- class_name: 友情链接 class_desc: 🤝🤝🤝 link_list: - name: 小李博客 link: https://xiaoliblog.cn/ avatar: https://cdn.jsdelivr.net/gh/lzyblog/image@main/2020/11/19/1f52735f41052a8a163fbef9101b879e.png descr: 越努力越幸运 Categories Magnet 首页分类磁贴效果如下 教程请参考Akilar大佬的基于 Butterfly 主题的分类磁贴：https://akilar.top/posts/a9131002/ Gitcalendar Gitcalendar效果如下 项目API地址：https://github.com/Zfour/python_github_calendar_api 教程请参考Akilar大佬的基于 Butterfly 主题的首页置顶 gitcalendar：https://akilar.top/posts/1f9c68c9/ Friend link subscription 项目地址：https://github.com/Zfour/Butterfly-friend-poor-html 教程请参考Akilar大佬的基于 Butterfly 主题的友链朋友圈前端配置方案：https://akilar.top/posts/8480b91c/ Algolia搜索功能注册algolia 项目地址：https://github.com/oncletom/hexo-algolia 前往Algolia注册页面，注册一个新账户。可以使用GitHub或者Google账户直接登录，注册后的14天内拥有所有功能（包括收费类别的）。之后若未续费会自动降级为免费账户，免费账户总共有10,000条记录，每月有100,000的可以操作数 注册完成后，左侧侧边栏找到【Indices】创建一个新的Index，这个 Index 将在后面使用 左侧侧边栏找到API Keys，进入后点击【All API Keys】，然后【New API Key】 填上index name，然在ACL里面增加删除和新增Object的权限，其他可以默认 然后就有了一个API Key（马赛克部分），保存好 安装algolia 在Hexo根目录下执行 1npm install hexo-algolia --save 在Hexo根目录的_config.yml中加入algolia的配置，注意改成前面API Keys页面相应配置 这里注意apikey填写刚才你创建的那个有权限的，其余的在your api keys里面可以找到 123456algolia: applicationID: &#x27;your applicationID&#x27; apiKey: &#x27;your apiKey&#x27; adminApiKey: &#x27;your adminApiKey&#x27; indexName: &#x27;your indexName&#x27; chunkSize: 5000 上传数据到algolia，下面your apiKey替换为刚才自己创建拥有权限的api 12export HEXO_ALGOLIA_INDEXING_KEY=your apiKeyhexo algolia 看到如下信息，证明成功了，可以去algolia网站上查看，索引已经上传成功了 123456789INFO [hexo-algolia] Testing HEXO_ALGOLIA_INDEXING_KEY permissions.INFO Start processingINFO [hexo-algolia] 218 records to index (post, page).INFO [hexo-algolia] Indexing chunk 1 of 5 (50 records)INFO [hexo-algolia] Indexing chunk 2 of 5 (50 records)INFO [hexo-algolia] Indexing chunk 3 of 5 (50 records)INFO [hexo-algolia] Indexing chunk 4 of 5 (50 records)INFO [hexo-algolia] Indexing chunk 5 of 5 (18 records)INFO [hexo-algolia] Indexing done. 开启algolia 进入主题的_config.yml配置文件，配置如下 12345678algolia_search: enable: true hits: per_page: 10 labels: input_placeholder: Search for Posts hits_empty: &quot;我们没有找到任何搜索结果: $&#123;query&#125;&quot; hits_stats: &quot;找到$&#123;hits&#125;条结果（用时$&#123;time&#125; ms）&quot; 本地搜索 由于Algolia每次增加文章都要重新提交一下如下代码： 12export HEXO_ALGOLIA_INDEXING_KEY=your apiKeyhexo algolia 觉得麻烦的话可以换本地搜索 把Algolia的根目录配置文件注释掉，主题配置文件改为false，并卸载掉插件 1npm uninstall hexo-algolia searchdb插件 安装本地搜索插件 1npm install hexo-generator-searchdb --save 在站点根目录的配置文件组添加 12345search: path: search.xml field: post format: html limit: 10000 在主题配置文件_config.yml中启用： 123# Local searchlocal_search: enable: true #本地搜索 最后记得hexo三连，如果直接hexo g -d的话，搜索关键字不会变红 1hexo cl &amp; hexo g &amp; hexo d jsoncontent插件 还有另一个插件hexo-generator-json-content，本插件原理和上个插件差不多，都是生成一个文件用来本地搜索，二选一即可 输入以下命令安装插件 1npm install hexo-generator-json-content --save 打开博客目录，找到_config.yml文件，添加以下内容 123456789101112131415161718192021jsonContent: dateFormat: MM-DD pages: title: true text: true path: true date: true excerpt: true preview: true posts: title: true text: true path: true date: true excerpt: true tags: [&#123; name: tag.name, slug: tag.slug, permalink: tag.permalink &#125;] preview: true 同样在主题配置文件中打开本地搜索 123# 本地搜索local_search: enable: true 扩展特效引入GIuHub徽标 徽标生成网站：https://shields.io/ 图标查询网站：https://simpleicons.org/ 通过 shields.io 在线生成 label: 标签，徽标左侧内容 message: 信息，徽标右侧内容 color: 色值，支持支持十六进制、rgb、rgba、hsl、hsla 和 css 命名颜色。十六进制记得删除前面的 #号 输入相关信息后，点击 make badge 即可得到徽标的 URL。可以用 img 标签引用，写法简单。不过正式写法建议用 object 标签引用，写法示例如下 1234567&lt;!-- label=Frame，Message=Hexo，color=blue --&gt;https://img.shields.io/badge/Frame-Hexo-blue&lt;!-- 在页面上可以使用img标签来引用 --&gt;&lt;img src=&quot;https://img.shields.io/badge/Frame-Hexo-blue&quot;&gt;&lt;!-- 部分属性例如link需要用object标签来引用 --&gt;&lt;!--/badge/label-message-color?style&amp;logo&amp;link--&gt;&lt;object data=&quot;https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=Hexo&amp;link=https://hexo.io&quot;&gt;&lt;/object&gt; 查看代码测试 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253.github-badge &#123; display: inline-block; border-radius: 4px; text-shadow: none; font-size: 12px; color: #fff; line-height: 15px; background-color: #ABBAC3; margin-bottom: 5px;&#125;.github-badge .badge-subject &#123; display: inline-block; background-color: #4D4D4D; padding: 4px 4px 4px 6px; border-top-left-radius: 4px; border-bottom-left-radius: 4px;&#125;.github-badge .badge-value &#123; display: inline-block; padding: 4px 6px 4px 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px;&#125;.github-badge .bg-brightgreen &#123; background-color: #4DC820 !important;&#125;.github-badge .bg-orange &#123; background-color: #FFA500 !important;&#125;.github-badge .bg-yellow &#123; background-color: #D8B024 !important;&#125;.github-badge .bg-blueviolet &#123; background-color: #8833D7 !important;&#125;.github-badge .bg-pink &#123; background-color: #F26BAE !important;&#125;.github-badge .bg-red &#123; background-color: #e05d44 !important;&#125;.github-badge .bg-blue &#123; background-color: #007EC6 !important;&#125;.github-badge .bg-lightgrey &#123; background-color: #9F9F9F !important;&#125;.github-badge .bg-grey, .github-badge .bg-gray &#123; background-color: #555 !important;&#125;.github-badge .bg-lightgrey, .github-badge .bg-lightgray &#123; background-color: #9f9f9f !important;&#125;123456789101112131415161718192021&lt;div class=&quot;github-badge&quot;&gt; &lt;span class=&quot;badge-subject&quot;&gt;Powered&lt;/span&gt;&lt;span class=&quot;badge-value bg-blue&quot;&gt;Hexo&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;github-badge&quot;&gt; &lt;span class=&quot;badge-subject&quot;&gt;Hosted&lt;/span&gt;&lt;span class=&quot;badge-value bg-brightgreen&quot;&gt;GitHub&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;github-badge&quot;&gt; &lt;span class=&quot;badge-subject&quot;&gt;DNR&lt;/span&gt;&lt;span class=&quot;badge-value bg-firebrick&quot;&gt;Aliyun&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;github-badge&quot;&gt; &lt;span class=&quot;badge-subject&quot;&gt;CDN&lt;/span&gt;&lt;span class=&quot;badge-value bg-orange&quot;&gt;jsDelivr&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;github-badge&quot;&gt; &lt;span class=&quot;badge-subject&quot;&gt;PictureBed&lt;/span&gt;&lt;span class=&quot;badge-value bg-blueviolet&quot;&gt;SM.MS&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;github-badge&quot;&gt; &lt;span class=&quot;badge-subject&quot;&gt;Theme&lt;/span&gt;&lt;span class=&quot;badge-value bg-blue&quot;&gt;Material X&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;github-badge&quot;&gt; &lt;span class=&quot;badge-subject&quot;&gt;&lt;i class=&quot;fa fa-copyright&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;span class=&quot;badge-value bg-lightgrey&quot;&gt;BY-NC-SA 4.0&lt;/span&gt; &lt;/div&gt; 参考Akilar的博文：https://akilar.top/posts/e87ad7f8/ 添加2D人物模型 在博客文件夹下右击,Git Bash 1npm install --save hexo-helper-live2d 1npm install live2d-widget-model-hijiki(模型名) 参考模型名及样式 12345678910111213141516171819在根目录配置文件中添加如下代码：live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false log: false model: use: live2d-widget-model-hijiki(模型名) display: position: right width: 150 height: 300 mobile: show: true react: opacity: 0.7 新春灯笼特效 参考项目地址：https://github.com/fz6m/china-lantern butterfly主题配置文件对应位置修改 1234inject: head: bottom: - &lt;script src=&quot;https://cdn.jsdelivr.net/gh/fz6m/china-lantern@1.6/dist/china-lantern.min.js&quot;&gt;&lt;/script&gt; 也可以通过CSS引入 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;style&gt; @media only screen and (max-width: 760px) &#123; .deng-box, .deng-box1 &#123; display: none; &#125; &#125; @media only screen and (min-width: 768px) and (max-width: 1024px) &#123; .right &#123; float: left !important; &#125; &#125; .deng-box &#123; position: fixed; top: 20px; left: 10px; z-index: 99; &#125; .deng-box1 &#123; position: fixed; top: 20px; right: 10px; z-index: 99; &#125; .deng-box1 .deng &#123; position: relative; width: 120px; height: 90px; margin: 50px; background: #d8000f; background: rgba(216, 0, 15, 0.8); border-radius: 50% 50%; -webkit-transform-origin: 50% -100px; -webkit-animation: swing 5s infinite ease-in-out; box-shadow: -5px 5px 30px 4px rgba(252, 144, 61, 1); &#125; .deng &#123; position: relative; width: 120px; height: 90px; margin: 50px; background: #d8000f; background: rgba(216, 0, 15, 0.8); border-radius: 50% 50%; -webkit-transform-origin: 50% -100px; -webkit-animation: swing 3s infinite ease-in-out; box-shadow: -5px 5px 50px 4px rgba(250, 108, 0, 1); &#125; .deng-a &#123; width: 100px; height: 90px; background: #d8000f; background: rgba(216, 0, 15, 0.1); margin: 12px 8px 8px 10px; border-radius: 50% 50%; border: 2px solid #dc8f03; &#125; .deng-b &#123; width: 45px; height: 90px; background: #d8000f; background: rgba(216, 0, 15, 0.1); margin: -4px 8px 8px 26px; border-radius: 50% 50%; border: 2px solid #dc8f03; &#125; .xian &#123; position: absolute; top: -20px; left: 60px; width: 2px; height: 20px; background: #dc8f03; &#125; .shui-a &#123; position: relative; width: 5px; height: 20px; margin: -5px 0 0 59px; -webkit-animation: swing 4s infinite ease-in-out; -webkit-transform-origin: 50% -45px; background: #ffa500; border-radius: 0 0 5px 5px; &#125; .shui-b &#123; position: absolute; top: 14px; left: -2px; width: 10px; height: 10px; background: #dc8f03; border-radius: 50%; &#125; .shui-c &#123; position: absolute; top: 18px; left: -2px; width: 10px; height: 35px; background: #ffa500; border-radius: 0 0 0 5px; &#125; .deng:before &#123; position: absolute; top: -7px; left: 29px; height: 12px; width: 60px; content: &quot; &quot;; display: block; z-index: 999; border-radius: 5px 5px 0 0; border: solid 1px #dc8f03; background: #ffa500; background: linear-gradient( to right, #dc8f03, #ffa500, #dc8f03, #ffa500, #dc8f03 ); &#125; .deng:after &#123; position: absolute; bottom: -7px; left: 10px; height: 12px; width: 60px; content: &quot; &quot;; display: block; margin-left: 20px; border-radius: 0 0 5px 5px; border: solid 1px #dc8f03; background: #ffa500; background: linear-gradient( to right, #dc8f03, #ffa500, #dc8f03, #ffa500, #dc8f03 ); &#125; .deng-t &#123; font-family: 华文行楷; font-size: 26px; color: #dc8f03; font-weight: bold; line-height: 44px; text-align: center; &#125; .night .deng-t, .night .deng-box, .night .deng-box1 &#123; background: transparent !important; &#125; @-moz-keyframes swing &#123; 0% &#123; -moz-transform: rotate(-10deg); &#125; 50% &#123; -moz-transform: rotate(10deg); &#125; 100% &#123; -moz-transform: rotate(-10deg); &#125; &#125; @-webkit-keyframes swing &#123; 0% &#123; -webkit-transform: rotate(-10deg); &#125; 50% &#123; -webkit-transform: rotate(10deg); &#125; 100% &#123; -webkit-transform: rotate(-10deg); &#125; &#125; &lt;/style&gt; &lt;div class=&quot;deng-box&quot;&gt; &lt;div class=&quot;deng&quot;&gt; &lt;div class=&quot;xian&quot;&gt;&lt;/div&gt; &lt;div class=&quot;deng-a&quot;&gt; &lt;div class=&quot;deng-b&quot;&gt;&lt;div class=&quot;deng-t&quot;&gt;喜迎&lt;/div&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;shui shui-a&quot;&gt; &lt;div class=&quot;shui-c&quot;&gt;&lt;/div&gt; &lt;div class=&quot;shui-b&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;deng-box1&quot;&gt; &lt;div class=&quot;deng&quot;&gt; &lt;div class=&quot;xian&quot;&gt;&lt;/div&gt; &lt;div class=&quot;deng-a&quot;&gt; &lt;div class=&quot;deng-b&quot;&gt;&lt;div class=&quot;deng-t&quot;&gt;新春&lt;/div&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;shui shui-a&quot;&gt; &lt;div class=&quot;shui-c&quot;&gt;&lt;/div&gt; &lt;div class=&quot;shui-b&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 雪花飘落特效 butterlfy主题配置文件相应位置修改 123456inject: head: bottom: - &lt;div&gt;&lt;canvas id=&quot;snow&quot; style=&quot;position:fixed;top:0;left:0;width:100%;height:100%;z-index:99999;pointer-events:none&quot;&gt;&lt;/canvas&gt;&lt;/div&gt; - &lt;script&gt;const notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));&lt;/script&gt; - &lt;script async type=&quot;text/javascript&quot; src=&quot;https://cdn.jsdelivr.net/gh/Candinya/Kratos-Rebirth@latest/source/js/snow.min.js&quot;&gt;&lt;/script&gt; 自定义404页面 无论是GitHub还是Vercel自带的404页面，个人都不是很满意，所以可以自定义404页面 1$ hexo new page &quot;404&quot; 在Hexo博客source目录下生成一个404文件夹，其中有一个index.md文件，这个文件其实就相当于是404.html了 打开index.md，修改头部信息。注意不要忘了修改permalink，不然不会在根目录下生成404.html 1234layout: falsecomments: falsetitle: 404permalink: /404 由于markdown是支持插入html内容的，因此只需要在这个md文件里写入html代码即可。要注意的是html代码之间千万不能有空行，不然会标签识别错误! 自定义404页面可以去404模板查找，js和css可以放到刚才生成的404目录下 然后hexo g和hexo d部署即可 自定义独立页面 Hexo 是一个轻量、快速，简单和强大的博客框架，当我们需要发布博文的时候，只需要将写好的文章（MarkDown文件）放入本地的 \\source\\_posts 文件夹，然后再推送上去就行了，原理就是当我们在执行 hexo g 命令时，.md 文件就会被转化成 HTML 文件，但是有时候我们需要新建一个独立的页面，这个页面不使用主题的渲染，具有自己独立的样式，有两种方法实现 skip_render 使用 Hexo 提供的跳过渲染配置，在博客根目录的配置文件 _config.yml 里找到 skip_render 关键字，在后面添加想要跳过渲染的页面 比如我们创建 \\source\\about\\index.html, 配置文件填写:skip_render: about\\*\\*，那么就表示 \\source\\about 里所有的文件将跳过渲染，里面的文件将会被直接复制到 public 文件夹，此时就会得到一个独立的 about 页面；官方文档：https://hexo.io/docs/configuration layout: false 还可以通过在文章头部的Front-matter里添加配置 layout: false 来跳过渲染配置 比如我们要使 about 页面跳过渲染，创建 \\source\\about\\index.md，将这个页面的相关 HTML 代码写进.md文件并保存，然后在 index.md 的头部写入： 123456789---layout: false---&#123;% raw %&#125;xxxxxxxxxxxxxxx HTML代码 xxxxxxxxxxxxxxx&#123;% endraw %&#125; Front-matter 是 .md 文件最上方以 — 分隔的区域，用于指定个别文件的变量，官方文档：https://hexo.io/docs/front-matter .md文件中的 HTML 代码要用 ` 和 ` 包起来，使其能正确编译里面的代码 Hexo访问URL全英文 在使用Hexo框架生成静态博客时，其实是将你写好的.md文件输出成HTML文件进行渲染，其中HTML的文件名称就是.md的文件名称 例如：Java学习笔记.md经过hexo g命令会生成Java学习笔记.html；执行hexo d命令会将文件推送到你的仓库，那么你访问这篇章时，对应的地址栏就是http://xxxx/.../Java学习笔记.html ，这样看起来很别扭，对搜索引擎也不友好 于是有两种解决方法 一种是增加文章ID，可以自动生成一串字符，但不会现实HTML后缀 另一种是修改文件生成规则，需要为每一篇文章定义一个唯一的名称 增加文章ID 具体可以参考Hexo官方文档中永久链接（Permalinks） | Hexo这一篇文章 在博客根目录的配置文件_congif.yml中修改permalink变量 12#permalink: :year/:month/:day/:title # 这是原配置permalink: :year/:id/ # 替换为此新配置 可以自定义名称，在.\\scaffolds\\post.md中修改为： 123456789---title: &#123;&#123; title &#125;&#125;id: date: &#123;&#123; date &#125;&#125;updated: &#123;&#123; date &#125;&#125;categories:tags:permalink: --- 在我们的具体文章中，你可以使用任意数字和字母作为此文章的id，但最好有规律的命名，不用包含特殊字符，推荐使用创建日期中的月+日+时+分+秒来定义一个id 1234---title: &#123;&#123; title &#125;&#125;permalink: 02062017--- 改文件生成规则 在博客根目录的配置文件_congif.yml中修改permalink变量 12#permalink: :year/:month/:day/:title # 这是原配置permalink: page/:fileName.html # 替换为此新配置 page是目录，执行hexo g会在public下生成，我让生成的HTML文件都放在page下，:fileName.html是HTML的命名格式，其中fileName是个变量，变量值来自于.md文件的设置，每篇文章只要头部加了这个属性，并赋值且确保唯一就OK了 1234567---title: 计算机网络🌈数据链路层subtitle: sticky: fileName: h3s09btags: 计算机网络categories: 为了避免忘记在写文章时写fileName属性，我们可以修改模板，在scaffolds目录下有三个模板，修改其中的post.md 1234567---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:categories:fileName: 千万别忘写，必须要唯一！--- 命名规范可以自己定义，比如今天是五月m，日期29，周三w，时间是17点，文件名就可以就是m29w17","path":"page/butterfly02.html","date":"12-03","excerpt":"","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://xiaoliblog.cn/tags/Hexo/"}]},{"title":"Butterfly魔改系列🦋扩展标签外挂","text":"样式引入 下载源码 密码:eayb 在[BlogRoot]\\themes\\butterfly\\source\\css\\引入下载的MyStyle\\tagStyle.css文件 在主题配置文件引入 12345678inject: head: - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/MyStyle/tagStyle.css&quot; media=&quot;defer&quot; onload=&quot;this.media=&#x27;all&#x27;&quot;/&gt; - # DOM动画特效 - &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/gh/zykjofficial/zykjresource@master/css/font-awesome-animation.min.css&quot; media=&quot;defer&quot; onload=&quot;this.media=&#x27;all&#x27;&quot;/&gt; # Volantis主题标签 - &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/font-awesome-animation.min.css&quot; media=&quot;defer&quot; onload=&quot;this.media=&#x27;all&#x27;&quot;&gt; - &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/plugins.min.css&quot; media=&quot;defer&quot; onload=&quot;this.media=&#x27;all&#x27;&quot;&gt; 主题内置参考Butterfly主题文档 复选列表1234567891011121314&#123;% tabs t1 %&#125;&lt;!-- tab --&gt;**This is Tab 1.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 2.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 3.**&lt;!-- endtab --&gt;&#123;% endtabs %&#125; t1 1t1 2t1 3This is Tab 1.This is Tab 2.This is Tab 3. 自定义Tab名 + 只有icon + icon和Tab名 12345678910111213&#123;% tabs t2%&#125;&lt;!-- tab 第一个Tab --&gt;**tab名字为第一个Tab**&lt;!-- endtab --&gt;&lt;!-- tab @fab fa-apple-pay --&gt;**只有图标 沒有Tab名字**&lt;!-- endtab --&gt;&lt;!-- tab 炸弹@fas fa-bomb --&gt;**名字+icon**&lt;!-- endtab --&gt;&#123;% endtabs %&#125; 第一个Tab炸弹tab名字为第一个Tab只有图标 沒有Tab名字名字+icon Tab block must have unique name! 每个表格都需要定义不同的名称，如t1,t2 Button按钮语法格式代码演示1代码演示2代码演示3代码演示412345678910111213141516&#123;% btn [url],[text],[icon],[color] [style] [layout] [position] [size] %&#125;[url] : 鏈接[text] : 按鈕文字[icon] : [可選] 圖標[color] : [可選] 按鈕背景顔色(默認style時） 按鈕字體和邊框顔色(outline時) default/blue/pink/red/purple/orange/green[style] : [可選] 按鈕樣式 默認實心 outline/留空[layout] : [可選] 按鈕佈局 默認為line block/留空[position] : [可選] 按鈕位置 前提是設置了layout為block 默認為左邊 center/right/留空[size] : [可選] 按鈕大小 larger/留空12345点击按钮&#123;% btn &#x27;https://lzyblog.github.io/&#x27;,xiaoliblog %&#125;点击按钮 &#123;% btn &#x27;https://lzyblog.github.io/&#x27;,xiaoliblog ,far fa-hand-point-right %&#125;点击按钮 &#123;% btn &#x27;https://lzyblog.github.io/&#x27;,xiaoliblog ,outline %&#125;点击按钮 &#123;% btn &#x27;https://lzyblog.github.io/&#x27;,xiaoliblog ,far fa-hand-point-right,outline %&#125;点击按钮 &#123;% btn &#x27;https://lzyblog.github.io/&#x27;,xiaoliblog ,far fa-hand-point-right,larger %&#125; 点击按钮xiaoliblog点击按钮 xiaoliblog点击按钮 xiaoliblog点击按钮 xiaoliblog点击按钮 xiaoliblog123&#123;% btn &#x27;https://xiaoliblog.cn/&#x27;,xiaoliblog,far fa-hand-point-right,block %&#125;&#123;% btn &#x27;https://xiaoliblog.cn/&#x27;,xiaoliblog,far fa-hand-point-right,block center larger %&#125;&#123;% btn &#x27;https://xiaoliblog.cn/&#x27;,xiaoliblog,far fa-hand-point-right,block right outline larger %&#125; xiaoliblogxiaoliblogxiaoliblog1234567&#123;% btn &#x27;https://xiaoliblog.cn/&#x27;,xiaoliblog,far fa-hand-point-right,larger %&#125;&#123;% btn &#x27;https://xiaoliblog.cn/&#x27;,xiaoliblog,far fa-hand-point-right,blue larger %&#125;&#123;% btn &#x27;https://xiaoliblog.cn/&#x27;,xiaoliblog,far fa-hand-point-right,pink larger %&#125;&#123;% btn &#x27;https://xiaoliblog.cn/&#x27;,xiaoliblog,far fa-hand-point-right,red larger %&#125;&#123;% btn &#x27;https://xiaoliblog.cn/&#x27;,xiaoliblog,far fa-hand-point-right,purple larger %&#125;&#123;% btn &#x27;https://xiaoliblog.cn/&#x27;,xiaoliblog,far fa-hand-point-right,orange larger %&#125;&#123;% btn &#x27;https://xiaoliblog.cn/&#x27;,xiaoliblog,far fa-hand-point-right,green larger %&#125; xiaoliblogxiaoliblogxiaoliblogxiaoliblogxiaoliblogxiaoliblogxiaoliblog123456789&lt;div class=&quot;btn-center&quot;&gt;&#123;% btn &#x27;https://xiaoliblog.cn/&#x27;,xiaoliblog,far fa-hand-point-right,outline larger %&#125;&#123;% btn &#x27;https://xiaoliblog.cn/&#x27;,xiaoliblog,far fa-hand-point-right,outline blue larger %&#125;&#123;% btn &#x27;https://xiaoliblog.cn/&#x27;,xiaoliblog,far fa-hand-point-right,outline pink larger %&#125;&#123;% btn &#x27;https://xiaoliblog.cn/&#x27;,xiaoliblog,far fa-hand-point-right,outline red larger %&#125;&#123;% btn &#x27;https://xiaoliblog.cn/&#x27;,xiaoliblog,far fa-hand-point-right,outline purple larger %&#125;&#123;% btn &#x27;https://xiaoliblog.cn/&#x27;,xiaoliblog,far fa-hand-point-right,outline orange larger %&#125;&#123;% btn &#x27;https://xiaoliblog.cn/&#x27;,xiaoliblog,far fa-hand-point-right,outline green larger %&#125;&lt;/div&gt; xiaoliblog xiaoliblog xiaoliblog xiaoliblog xiaoliblog xiaoliblog xiaoliblog 内置标签注意：标签外挂是Hexo独有的功能，並不是标签的Markdown格式。以下的写法，只适用于Butterfly主题，用在其它主題上不会有效果，甚至可能会报错。使用前请留意 主题文件配置语法格式参数列表示例代码效果演示123456789101112note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. style: modern icons: true border_radius: 3 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0123&#123;% note 样式参数 %&#125;文本内容&#123;% endnote %&#125;123456info 蓝色叹号warning 黄色叹号done 绿色打钩success 绿色打钩error 红色禁止danger 红色打叉1234567891011121314151617181920212223&#123;% note default %&#125;default 提示标签符&#123;% endnote %&#125;&#123;% note primary %&#125;primary 提示标签符&#123;% endnote %&#125;&#123;% note success %&#125;success 提示标签符&#123;% endnote %&#125;&#123;% note info %&#125;info 提示标签符&#123;% endnote %&#125;&#123;% note warning %&#125;warning 提示标签符&#123;% endnote %&#125;&#123;% note danger %&#125;danger 提示标签符&#123;% endnote %&#125;default 提示标签符 primary 提示标签符 success 提示标签符 info 提示标签符 warning 提示标签符 danger 提示标签符 自定义标签图标语法格式参数列表代码演示效果演示123&#123;% note [color] [icon] [style] %&#125;&#123;% endnote %&#125;123color (default &#x2F; blue &#x2F; pink &#x2F; red &#x2F; purple &#x2F; orange &#x2F; green)icon 只支持 fontawesome 图标(需要引入CDN), 也可以配置 no-iconstyle simple&#x2F;modern&#x2F;flat&#x2F;disabled123456789101112131415161718192021&#123;% note &#x27;fab fa-cc-visa&#x27; flat %&#125;你是刷 Visa 還是 UnionPay&#123;% endnote %&#125;&#123;% note blue &#x27;fas fa-bullhorn&#x27; flat %&#125;2021年快到了....&#123;% endnote %&#125;&#123;% note pink &#x27;fas fa-car-crash&#x27; flat %&#125;小心開車 安全至上&#123;% endnote %&#125;&#123;% note red &#x27;fas fa-fan&#x27; flat%&#125;這是三片呢？還是四片？&#123;% endnote %&#125;&#123;% note orange &#x27;fas fa-battery-half&#x27; flat %&#125;你是刷 Visa 還是 UnionPay&#123;% endnote %&#125;&#123;% note purple &#x27;far fa-hand-scissors&#x27; flat %&#125;剪刀石頭布&#123;% endnote %&#125;&#123;% note green &#x27;fab fa-internet-explorer&#x27; flat %&#125;前端最討厭的瀏覽器&#123;% endnote %&#125;你是刷 Visa 還是 UnionPay 2021年快到了…. 小心開車 安全至上 這是三片呢？還是四片？ 你是刷 Visa 還是 UnionPay 剪刀石頭布 前端最討厭的瀏覽器 隐藏标签InlineBlockToggleinline在文本里面添加按钮隐藏内容，只限文字(content不能包含英文逗号，可用&amp;sbquo;) 1&#123;% hideInline content,display,bg,color %&#125; content: 文本內容 display: 按钮显示示的文字(可选) bg: 按钮的背景颜色(可选) color: 按钮文字的颜色(可选) 123哪个英文字母最酷？ &#123;% hideInline 因为西装裤(C装酷),查看答案,#FF7242,#fff %&#125;门里站着一个人?打一字 &#123;% hideInline 闪 %&#125; 哪个英文字母最酷？ 查看答案 因为西装裤(C装酷) 门里站着一个人?打一字 Click 闪block独立的block隐藏内容，可用隐藏很多内容，包括图片，代码块等待(display不能包含英文逗号，可用&amp;sbquo;) 123&#123;% hideBlock display,bg,color %&#125;content&#123;% endhideBlock %&#125; content: 文本內容 display: 按钮显示示的文字(可选) bg: 按钮的背景颜色(可选) color: 按钮文字的颜色(可选) 1234查看答案&#123;% hideBlock 查看答案 %&#125;傻子，怎麼可能有答案&#123;% endhideBlock %&#125; 查看答案 查看答案 傻子，怎麼可能有答案 当你需要展示的内容太多，可用把它隐藏在收缩框里，需要时再把它展开(display不能包含英文逗号，可用&amp;sbquo;) 123&#123;% hideToggle display,bg,color %&#125;content&#123;% endhideToggle %&#125; 12345678910&#123;% hideToggle Butterfly安裝方法 %&#125;在你的博客根目录里git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly如果想要安裝比較新的dev分支，可以git clone -b dev https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly&#123;% endhideToggle %&#125; Butterfly安裝方法 在你的博客根目录里 git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly 如果想要安裝比較新的dev分支，可以 git clone -b dev https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly 标签扩展复选/单选按钮 此项修改需要在源文件中添加新的文件，当然了并不会修改作者源文件。升级时只需要重新把这几个文件放入相应文件即可。 文件下载地址 密码:77ik 添加的位置为：主题目录下的 scripts 中的 tags 文件夹中。 接下来在配置文件引入 css 即可：https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/plugins.min.css 123inject: head: - &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/plugins.min.css&quot;&gt; 语法格式参数列表示例代码效果查看源码查看官方文档：https://volantis.js.org/v2/tag-plugins/ Markdown用法 1&#123;% checkbox 样式参数（可选）, 文本（支持简单md） %&#125; HTML页面用法 1&lt;div class=&quot;checkbox yellow checked&quot;&gt;&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot;&gt;&lt;p&gt;黄色+默认选中&lt;/p&gt;&lt;/div&gt; 颜色 1red, yellow, green, cyan, blue 样式 1plus, minus, times 选中状态 1checked Markdown用法 12345678910&#123;% checkbox 纯文本测试 %&#125;&#123;% checkbox checked, 支持简单的 [markdown](https://guides.github.com/features/mastering-markdown/) 语法 %&#125;&#123;% checkbox red, 支持自定义颜色 %&#125;&#123;% checkbox green checked, 绿色 + 默认选中 %&#125;&#123;% checkbox yellow checked, 黄色 + 默认选中 %&#125;&#123;% checkbox cyan checked, 青色 + 默认选中 %&#125;&#123;% checkbox blue checked, 蓝色 + 默认选中 %&#125;&#123;% checkbox plus green checked, 增加 %&#125;&#123;% checkbox minus yellow checked, 减少 %&#125;&#123;% checkbox times red checked, 叉 %&#125; 1234567&#123;% radio 纯文本测试 %&#125;&#123;% radio checked, 支持简单的 [markdown](https://guides.github.com/features/mastering-markdown/) 语法 %&#125;&#123;% radio red, 支持自定义颜色 %&#125;&#123;% radio green, 绿色 %&#125;&#123;% radio yellow, 黄色 %&#125;&#123;% radio cyan, 青色 %&#125;&#123;% radio blue, 蓝色 %&#125; HTML页面用法 1234567&lt;div class=&quot;checkbox yellow checked&quot;&gt;&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot;&gt;&lt;p&gt;黄色+默认选中&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;checkbox red checked&quot;&gt;&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot;&gt;&lt;p&gt;红色+默认选中&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;checkbox cyan checked&quot;&gt;&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot;&gt;&lt;p&gt;青色+默认选中&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;checkbox blue checked&quot;&gt;&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot;&gt;&lt;p&gt;蓝色+默认选中&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;checkbox plus grenn checked&quot;&gt;&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot;&gt;&lt;p&gt;增加&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;checkbox minus yellow checked&quot;&gt;&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot;&gt;&lt;p&gt;减少&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;checkbox times red checked&quot;&gt;&lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot;&gt;&lt;p&gt;叉&lt;/p&gt;&lt;/div&gt; 1234&lt;div class=&quot;checkbox yellow checked&quot;&gt;&lt;input type=&quot;radio&quot; checked=&quot;checked&quot;&gt;&lt;p&gt;黄色+默认选中&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;checkbox red checked&quot;&gt;&lt;input type=&quot;radio&quot; checked=&quot;checked&quot;&gt;&lt;p&gt;红色+默认选中&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;checkbox cyan checked&quot;&gt;&lt;input type=&quot;radio&quot; checked=&quot;checked&quot;&gt;&lt;p&gt;青色+默认选中&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;checkbox blue checked&quot;&gt;&lt;input type=&quot;radio&quot; checked=&quot;checked&quot;&gt;&lt;p&gt;蓝色+默认选中&lt;/p&gt;&lt;/div&gt; 纯文本测试 支持简单的 markdown 语法 支持自定义颜色 绿色 + 默认选中 黄色 + 默认选中 青色 + 默认选中 蓝色 + 默认选中 增加 减少 叉 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261[data-theme=&quot;dark&quot;] .checkbox &#123; filter: brightness(0.7);&#125;.checkbox &#123; display: flex; align-items: center;&#125;.checkbox input &#123; -webkit-appearance: none; -moz-appearance: none; -ms-appearance: none; -o-appearance: none; appearance: none; position: relative; height: 16px; width: 16px; transition: all 0.15s ease-out 0s; cursor: pointer; display: inline-block; outline: none; border-radius: 2px; flex-shrink: 0; margin-right: 8px;&#125;.checkbox input[type=&quot;checkbox&quot;]:before,.checkbox input[type=&quot;checkbox&quot;]:after &#123; position: absolute; content: &quot;&quot;; background: #fff;&#125;.checkbox input[type=&quot;checkbox&quot;]:before &#123; left: 1px; top: 5px; width: 0; height: 2px; transition: all 0.2s ease-in; transform: rotate(45deg); -webkit-transform: rotate(45deg); -moz-transform: rotate(45deg); -ms-transform: rotate(45deg); -o-transform: rotate(45deg);&#125;.checkbox input[type=&quot;checkbox&quot;]:after &#123; right: 7px; bottom: 3px; width: 2px; height: 0; transition: all 0.2s ease-out; transform: rotate(40deg); -webkit-transform: rotate(40deg); -moz-transform: rotate(40deg); -ms-transform: rotate(40deg); -o-transform: rotate(40deg); transition-delay: 0.25s;&#125;.checkbox input[type=&quot;checkbox&quot;]:checked:before &#123; left: 0; top: 7px; width: 6px; height: 2px;&#125;.checkbox input[type=&quot;checkbox&quot;]:checked:after &#123; right: 3px; bottom: 1px; width: 2px; height: 10px;&#125;.checkbox.minus input[type=&quot;checkbox&quot;]:before &#123; transform: rotate(0); left: 1px; top: 5px; width: 0; height: 2px;&#125;.checkbox.minus input[type=&quot;checkbox&quot;]:after &#123; transform: rotate(0); left: 1px; top: 5px; width: 0; height: 2px;&#125;.checkbox.minus input[type=&quot;checkbox&quot;]:checked:before &#123; left: 1px; top: 5px; width: 10px; height: 2px;&#125;.checkbox.minus input[type=&quot;checkbox&quot;]:checked:after &#123; left: 1px; top: 5px; width: 10px; height: 2px;&#125;.checkbox.plus input[type=&quot;checkbox&quot;]:before &#123; transform: rotate(0); left: 1px; top: 5px; width: 0; height: 2px;&#125;.checkbox.plus input[type=&quot;checkbox&quot;]:after &#123; transform: rotate(0); left: 5px; top: 1px; width: 2px; height: 0;&#125;.checkbox.plus input[type=&quot;checkbox&quot;]:checked:before &#123; left: 1px; top: 5px; width: 10px; height: 2px;&#125;.checkbox.plus input[type=&quot;checkbox&quot;]:checked:after &#123; left: 5px; top: 1px; width: 2px; height: 10px;&#125;.checkbox.times input[type=&quot;checkbox&quot;]:before &#123; transform: rotate(45deg); left: 3px; top: 1px; width: 0; height: 2px;&#125;.checkbox.times input[type=&quot;checkbox&quot;]:after &#123; transform: rotate(135deg); right: 3px; top: 1px; width: 0; height: 2px;&#125;.checkbox.times input[type=&quot;checkbox&quot;]:checked:before &#123; left: 1px; top: 5px; width: 10px; height: 2px;&#125;.checkbox.times input[type=&quot;checkbox&quot;]:checked:after &#123; right: 1px; top: 5px; width: 10px; height: 2px;&#125;.checkbox input[type=&quot;radio&quot;] &#123; border-radius: 50%;&#125;.checkbox input[type=&quot;radio&quot;]:before &#123; content: &quot;&quot;; display: block; width: 8px; height: 8px; border-radius: 50%; margin: 2px; transform: scale(0); transition: all 0.25s ease-out;&#125;.checkbox input[type=&quot;radio&quot;]:checked:before &#123; transform: scale(1);&#125;.checkbox input &#123; border: 2px solid #2196f3;&#125;.checkbox input[type=&quot;checkbox&quot;]:checked &#123; background: #2196f3;&#125;.checkbox input[type=&quot;radio&quot;]:checked:before &#123; background: #2196f3;&#125;.checkbox.red input &#123; border-color: #fe5f58;&#125;.checkbox.red input[type=&quot;checkbox&quot;]:checked &#123; background: #fe5f58;&#125;.checkbox.red input[type=&quot;radio&quot;]:checked:before &#123; background: #fe5f58;&#125;.checkbox.green input &#123; border-color: #3dc550;&#125;.checkbox.green input[type=&quot;checkbox&quot;]:checked &#123; background: #3dc550;&#125;.checkbox.green input[type=&quot;radio&quot;]:checked:before &#123; background: #3dc550;&#125;.checkbox.yellow input &#123; border-color: #ffbd2b;&#125;.checkbox.yellow input[type=&quot;checkbox&quot;]:checked &#123; background: #ffbd2b;&#125;.checkbox.yellow input[type=&quot;radio&quot;]:checked:before &#123; background: #ffbd2b;&#125;.checkbox.cyan input &#123; border-color: #1bcdfc;&#125;.checkbox.cyan input[type=&quot;checkbox&quot;]:checked &#123; background: #1bcdfc;&#125;.checkbox.cyan input[type=&quot;radio&quot;]:checked:before &#123; background: #1bcdfc;&#125;.checkbox.blue input &#123; border-color: #2196f3;&#125;.checkbox.blue input[type=&quot;checkbox&quot;]:checked &#123; background: #2196f3;&#125;.checkbox.blue input[type=&quot;radio&quot;]:checked:before &#123; background: #2196f3;&#125;.checkbox p &#123; display: inline-block; margin-top: 2px !important; margin-bottom: 0 !important;&#125; 小标签设置语法格式示例代码效果演示源码查看1&lt;p class=&#x27;div-border [颜色|方向加粗]&#x27;&gt;你的文字&lt;/p&gt;12345678910111213141516&lt;!-- note语法示例 --&gt;&lt;p class=&#x27;div-border green&#x27;&gt;绿色&lt;/p&gt;&lt;p class=&#x27;div-border red&#x27;&gt;红色&lt;/p&gt;&lt;p class=&#x27;div-border yellow&#x27;&gt;黄色&lt;/p&gt;&lt;p class=&#x27;div-border grey&#x27;&gt;灰色&lt;/p&gt;&lt;p class=&#x27;div-border blue&#x27;&gt;蓝色&lt;/p&gt;&lt;!-- 小tag标签语法示例 --&gt;&lt;span class=&quot;inline-tag red&quot;&gt;红色小标签&lt;/span&gt;&lt;span class=&quot;inline-tag green&quot;&gt;绿色小标签&lt;/span&gt;&lt;span class=&quot;inline-tag blue&quot;&gt;蓝色小标签&lt;/span&gt;&lt;span class=&quot;inline-tag yellow&quot;&gt;黄色小标签&lt;/span&gt;&lt;span class=&quot;inline-tag grey&quot;&gt;灰色小标签&lt;/span&gt;&lt;!-- 加粗案例 --&gt;&lt;p class=&#x27;div-border green left right&#x27;&gt;绿色&lt;/p&gt; 绿色 红色 黄色 灰色 蓝色 红色小标签绿色小标签蓝色小标签黄色小标签灰色小标签 绿色1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889[data-theme=&quot;dark&quot;] span.inline-tag &#123; color: rgba(255, 255, 255, 0.8);&#125;[data-theme=&quot;dark&quot;] span.inline-tag &#123; filter: brightness(0.7);&#125;span.inline-tag &#123; display: inline; padding: 0.2em 0.6em 0.3em; font-size: 90%; font-weight: 400; line-height: 1; color: #fff; text-align: center; white-space: nowrap; vertical-align: baseline; border-radius: 0.1rem; border-radius: 6px; background-color: var(--Color);&#125;.font5 &#123; display: block; width: 100%; text-align: left; font-weight: 500; line-height: 32px; border-left-color: #767676; background: #f6f6f6;&#125;p.red,span.red &#123; --Color: rgb(233, 30, 100); --ColorA: rgba(233, 30, 100, 0.2);&#125;p.green,span.green &#123; --Color: rgb(139, 195, 74); --ColorA: rgba(139, 195, 74, 0.2);&#125;p.blue,span.blue &#123; --Color: rgb(3, 169, 244); --ColorA: rgba(3, 169, 244, 0.2);&#125;p.yellow,span.yellow &#123; --Color: rgb(255, 193, 7); --ColorA: rgba(255, 193, 7, 0.2);&#125;p.grey,span.grey &#123; --Color: rgb(76, 76, 76); --ColorA: rgba(76, 76, 76, 0.2);&#125;p.div-border &#123; padding: 10px; border: 1px solid var(--Color, #333); border-radius: 0.4rem; background-color: var(--ColorA, transparent);&#125;p.left &#123; border-left-width: 5px; border-left-color: var(--Color);&#125;p.bottom &#123; border-bottom-width: 5px; border-bottom-color: var(--Color);&#125;p.right &#123; border-right-width: 5px; border-right-color: var(--Color);&#125;p.top &#123; border-top-width: 5px; border-top-color: var(--Color);&#125; 上标式标签 为简单的一句话提供的简便写法。 语法格式参数列表静态示例静态演示动画示例动画演示CSS源码 配合font-awesome-animation 的 css 样式，直接中类名中添加即可，相关动画可以查看动画特效 123&lt;div class=&quot;tip [参数] [动画]&quot;&gt; &lt;p&gt;文本内容&lt;/p&gt;&lt;/div&gt;1234567[参数]不填默认为 infowarning 黄色叹号success 绿色打钩error 红色禁止[动画]参考动画特效12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;div class=&quot;tip&quot;&gt; &lt;p&gt;为简单的一句话提供的简便写法。&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;tip success&quot;&gt; &lt;p&gt;为简单的一句话提供的简便写法。&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;tip error&quot;&gt; &lt;p&gt;为简单的一句话提供的简便写法。&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;tip warning&quot;&gt; &lt;p&gt;为简单的一句话提供的简便写法。&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;tip wtgo&quot;&gt; &lt;p&gt;为简单的一句话提供的简便写法。&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;tip ban&quot;&gt; &lt;p&gt;为简单的一句话提供的简便写法。&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;tip home&quot;&gt; &lt;p&gt;为简单的一句话提供的简便写法。&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;tip important&quot;&gt; &lt;p&gt;为简单的一句话提供的简便写法。&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;tip ref&quot;&gt; &lt;p&gt;为简单的一句话提供的简便写法。&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;tip ffa&quot;&gt; &lt;p&gt;为简单的一句话提供的简便写法。&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;tip key&quot;&gt; &lt;p&gt;为简单的一句话提供的简便写法。&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;tip socd&quot;&gt; &lt;p&gt;为简单的一句话提供的简便写法。&lt;/p&gt;&lt;/div&gt; 为简单的一句话提供的简便写法。 为简单的一句话提供的简便写法。 为简单的一句话提供的简便写法。 为简单的一句话提供的简便写法。 为简单的一句话提供的简便写法。 为简单的一句话提供的简便写法。 为简单的一句话提供的简便写法。 为简单的一句话提供的简便写法。 为简单的一句话提供的简便写法。 为简单的一句话提供的简便写法。 为简单的一句话提供的简便写法。 为简单的一句话提供的简便写法。 ///添加动画 为简单的一句话提供的简便写法。 为简单的一句话提供的简便写法。 1234567891011121314151617181920&lt;!-- On DOM load（当页面加载时显示动画）--&gt;&lt;div class=&quot;tip faa-horizontal animated&quot;&gt; &lt;p&gt;为简单的一句话提供的简便写法。&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;tip success faa-flash animated&quot;&gt; &lt;p&gt;为简单的一句话提供的简便写法。&lt;/p&gt;&lt;/div&gt;&lt;!-- On hover（当鼠标悬停时显示动画）--&gt;&lt;div class=&quot;tip faa-horizontal animated-hover&quot;&gt; &lt;p&gt;为简单的一句话提供的简便写法。&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;tip success faa-flash animated-hover&quot;&gt; &lt;p&gt;为简单的一句话提供的简便写法。&lt;/p&gt;&lt;/div&gt; On DOM load（当页面加载时显示动画） 为简单的一句话提供的简便写法。 为简单的一句话提供的简便写法。 On hover（当鼠标悬停时显示动画） 为简单的一句话提供的简便写法。 为简单的一句话提供的简便写法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380.tip &#123; position: relative; color: #fff; background: #20a0ff; background: -webkit-gradient( linear, left top, right top, from(#20a0ff), to(#20b8ff) ); background: -webkit-linear-gradient(left, #20a0ff, #20b8ff); background: linear-gradient(90deg, #20a0ff, #20b8ff); padding: 6px 20px; border-radius: 10px; -webkit-box-shadow: 0 3px 5px rgba(32, 160, 255, 0.5); box-shadow: 0 3px 5px rgba(32, 160, 255, 0.5); margin-bottom: 20px;&#125;.tip p &#123; margin: 5px 0 !important;&#125;.tip:before &#123; background: #20a0ff; background: -webkit-gradient( linear, left bottom, left top, from(#0092ff), to(#20b8ff) ); background: -webkit-linear-gradient(bottom, #0092ff, #20b8ff); background: linear-gradient(0deg, #0092ff, #20b8ff); border-radius: 50%; color: #fff; content: &quot;\\f129&quot;; font-size: 12px; position: absolute; width: 24px; height: 24px; line-height: 24.5px; left: -12px; top: -12px; -webkit-box-shadow: 0 0 0 2.5px #fff; box-shadow: 0 0 0 2.5px #fff; font-weight: 600; font-family: &quot;Font Awesome 5 Free&quot;; text-align: center;&#125;.btn,.getit a &#123; position: relative;&#125;.well .tip:before &#123; -webkit-box-shadow: 0 0 0 2.5px #f7f8f9; box-shadow: 0 0 0 2.5px #f7f8f9;&#125;.tip ol &#123; margin: 0;&#125;.tip.success &#123; background: #61be33; background: -webkit-gradient( linear, left top, right top, from(#61be33), to(#8fce44) ); background: -webkit-linear-gradient(left, #61be33, #8fce44); background: linear-gradient(90deg, #61be33, #8fce44); text-shadow: 0 -1px #61be33; -webkit-box-shadow: 0 3px 5px rgba(104, 195, 59, 0.5); box-shadow: 0 3px 5px rgba(104, 195, 59, 0.5);&#125;.tip.success:before &#123; background: -webkit-gradient( linear, left bottom, left top, from(#52bb1d), to(#95d34b) ); background: -webkit-linear-gradient(bottom, #52bb1d, #95d34b); background: linear-gradient(0deg, #52bb1d, #95d34b); content: &quot;\\f00c&quot;; text-shadow: 0 -1px #61be33;&#125;.tip.warning &#123; background: #ff953f; background: -webkit-gradient( linear, left top, right top, from(#ff953f), to(#ffb449) ); background: -webkit-linear-gradient(left, #ff953f, #ffb449); background: linear-gradient(90deg, #ff953f, #ffb449); text-shadow: 0 -1px #ff953f; -webkit-box-shadow: 0 3px 5px rgba(255, 154, 73, 0.5); box-shadow: 0 3px 5px rgba(255, 154, 73, 0.5);&#125;.tip.warning:before &#123; background: -webkit-gradient( linear, left bottom, left top, from(#ff8f35), to(#ffc149) ); background: -webkit-linear-gradient(bottom, #ff8f35, #ffc149); background: linear-gradient(0deg, #ff8f35, #ffc149); content: &quot;\\f12a&quot;; text-shadow: 0 -1px #ff953f;&#125;.tip.error &#123; background: #ff4949; background: -webkit-gradient( linear, left top, right top, from(#ff4949), to(#ff7849) ); background: -webkit-linear-gradient(left, #ff4949, #ff7849); background: linear-gradient(90deg, #ff4949, #ff7849); text-shadow: 0 -1px #ff4949; -webkit-box-shadow: 0 3px 5px rgba(255, 73, 73, 0.5); box-shadow: 0 3px 5px rgba(255, 73, 73, 0.5);&#125;.tip.error:before &#123; background: -webkit-gradient( linear, left bottom, left top, from(#ff3838), to(#ff7849) ); background: -webkit-linear-gradient(bottom, #ff3838, #ff7849); background: linear-gradient(0deg, #ff3838, #ff7849); content: &quot;\\f00d&quot;; text-shadow: 0 -1px #ff4949;&#125;.tip.wtgo &#123; background: -webkit-gradient( linear, left bottom, left top, from(#3d8b48), to(#477837) ); background: -webkit-linear-gradient(bottom, #3c3, #459431); background: linear-gradient(530deg, #78ca33, #25822c); content: &quot;\\f00d&quot;; text-shadow: 0 -1px #4cf706;&#125;.tip.wtgo:before &#123; background: -webkit-gradient( linear, left bottom, left top, from(#3c0), to(#3c0) ); background: -webkit-linear-gradient(bottom, #3c3, #459431); background: linear-gradient(776deg, #78ca33, #25822c); content: &quot;\\f0e7&quot;; text-shadow: 0 -1px #4cf706;&#125;.tip.ban &#123; background: #ff4949; background: -webkit-gradient( linear, left top, right top, from(#ff4949), to(#ff3443) ); background: -webkit-linear-gradient(left, #ff4949, #ff1022); background: linear-gradient(90deg, #ff4949, #f03b49); text-shadow: 0 -1px #ff4949; -webkit-box-shadow: 0 3px 5px rgba(255, 73, 73, 0.5); box-shadow: 0 3px 5px rgba(255, 73, 73, 0.5);&#125;.tip.ban:before &#123; background: -webkit-gradient( linear, left bottom, left top, from(#ff3838), to(#ce4617) ); background: -webkit-linear-gradient(bottom, #ff3838, #d23e49); background: linear-gradient(0deg, #ff3838, #ff1022); content: &quot;\\f05e&quot;; text-shadow: 0 -1px #ff4949;&#125;.tip.home &#123; background: #15e5ff; background: -webkit-gradient( linear, left top, right top, from(#5bc6d4) to(#0ec0ef) ); background: -webkit-linear-gradient(left, #0ec0ef, #80e0f9); background: linear-gradient(90deg, #0ec0ef, #80e0f7); text-shadow: 0 -1px #0ec0ef; -webkit-box-shadow: 0 3px 5px #01caff; box-shadow: 0 3px 5px #01caff;&#125;.tip.home:before &#123; background: -webkit-gradient( linear, left bottom, left top, form(#0ec0ee) to(#0ee0cc) ); background: -webkit-linear-gradient(bottom, #0ec0ee, #0ec2ee); background: linear-gradient(0deg, #0ec0ee, #0ec0ea); content: &quot;\\f015&quot;; text-shadow: 0 -1px #0ec0ea;&#125;.tip.important &#123; background: #f3a700; background: -webkit-gradient( linear, left top, right top, from(#ffbd2b), to(#ffbd2b) ); background: -webkit-linear-gradient(left, #ffbd2b, #ffd26f); background: linear-gradient(290deg, #ef6e6e, #ffb000); text-shadow: 0 -1px #a97a12; -webkit-box-shadow: 0 3px 5px #ffb000; box-shadow: 0 3px 5px #ffb000;&#125;.tip.important:before &#123; background: -webkit-gradient( linear, left bottom, left top, from(#ff3838), to(#ffbd2b) ); background: -webkit-linear-gradient(bottom, #ff3838, #ffbd2b); background: linear-gradient(270deg, #ffbd2b, #f5626d); content: &quot;\\f129&quot;; text-shadow: 0 -1px #ffbd2b;&#125;.tip.ref &#123; background: #00a9ff; background: -webkit-gradient( linear, left top, right top, from(#51a7bd33), to(#c7eef9) ); background: -webkit-linear-gradient(left, #53cff1, #2e9fbd); background: linear-gradient(230deg, #47c0e0, #2dc342); text-shadow: 0 -1px #1bcdfc; -webkit-box-shadow: 0 3px 5px #1bcdfc; box-shadow: 0 3px 5px #20b1ad;&#125;.tip.ref:before &#123; background: -webkit-gradient( linear, left bottom, left top, from(#00c3f7), to(#88d3e6) ); background: -webkit-linear-gradient(bottom, #83e5ff, #0aa8d2); background: linear-gradient(270deg, #40c0e2, #3dc550); content: &quot;\\f021&quot;; text-shadow: 0 -1px #17cfff;&#125;.tip.ffa &#123; background: #1502ff; background: -webkit-gradient( linear, left top, right top, from(#51a7bd33), to(#8379ff) ); background: -webkit-linear-gradient(left, #5246e2, #5246e2); background: linear-gradient(230deg, #40c0e2, #5247e2); text-shadow: 0 -1px #8278fd; -webkit-box-shadow: 0 3px 5px #4037a7; box-shadow: 1 3px 5px #5e52ec;&#125;.tip.ffa:before &#123; background: -webkit-gradient( linear, left bottom, left top, from(#3020f3), to(#b1abf5) ); background: -webkit-linear-gradient(bottom, #5246e2, #5246e2); background: linear-gradient(560deg, #40c0e2, #5246e2); content: &quot;\\f085&quot;; text-shadow: 0 -1px #098cf5;&#125;.tip.key &#123; background: #25c33b; background: -webkit-gradient( linear, left top, right top, from(#51a7bd33), to(#8379ff) ); background: -webkit-linear-gradient(left, #648798, #90a4ae); background: linear-gradient(230deg, #90a4ae, #b7a7a7); text-shadow: 0 -1px #c1c0d4; -webkit-box-shadow: 0 3px 5px #d3d2de; box-shadow: 1 3px 5px #d5d4de;&#125;.tip.key:before &#123; background: -webkit-gradient( linear, left bottom, left top, from(#dddce8), to(#b1abf5) ); background: -webkit-linear-gradient(bottom, #5246e2, #5246e2); background: linear-gradient(560deg, #bccdd2, #cfced4); content: &quot;\\f084&quot;; text-shadow: 0 -1px #a9b2b9;&#125;.tip.socd &#123; background: #25c33b; background: -webkit-gradient( linear, left top, right top, from(#51a7bd33), to(#8379ff) ); background: -webkit-linear-gradient(left, #648798, #90a4ae); background: linear-gradient(230deg, #ffaa0d, #deb455); text-shadow: 0 -1px #c1c0d4; -webkit-box-shadow: 0 3px 5px #d3d2de; box-shadow: 1 3px 5px #d5d4de;&#125;.tip.socd:before &#123; background: -webkit-gradient( linear, left bottom, left top, from(#dddce8), to(#b1abf5) ); background: -webkit-linear-gradient(bottom, #5246e2, #5246e2); background: linear-gradient(560deg, #f9ae07, #ffb615); content: &quot;\\f0f3&quot;; text-shadow: 0 -1px #ffb81b;&#125;[data-theme=&quot;dark&quot;] .tip &#123; filter: brightness(0.7);&#125; 富文本按钮语法格式参数列表示例代码源码查看官方文档：https://volantis.js.org/v4/tag-plugins/ 1234&#123;% btns 样式参数 %&#125;&#123;% cell 标题, 链接, 图片或者图标 %&#125;&#123;% cell 标题, 链接, 图片或者图标 %&#125;&#123;% endbtns %&#125; 样式参数位置可以写图片样式、布局方式，多个样式参数用空格隔开 布局方式默认为自动宽度，适合视野内只有一两个的情况 参数 含义 wide 宽一点的按钮 fill 填充布局，自动铺满至少一行，多了会换行。 center 居中，按钮之间是固定间距。 around 居中分散 grid2 等宽最多 2 列，屏幕变窄会适当减少列数。 grid3 等宽最多 3 列，屏幕变窄会适当减少列数。 grid4 等宽最多 4 列，屏幕变窄会适当减少列数。 grid5 等宽最多 5 列，屏幕变窄会适当减少列数。 增加文字样式，可以在容器内增加 &lt;b&gt;标题&lt;/b&gt; 和 &lt;p&gt;描述文字&lt;/p&gt; 如果需要显示类似「团队成员」之类的一组含有头像的链接： 1234567&#123;% btns circle grid5 %&#125;&#123;% cell 小李博客, https:&#x2F;&#x2F;xiaoliblog.cn, https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;xiaoliblog&#x2F;image@6b5e7ef72be1c8973d94e5a9c49accbf775ad820&#x2F;2021&#x2F;02&#x2F;01&#x2F;c485da031fe0e464d04eaba8a66c4a8f.png %&#125;&#123;% cell 小李博客, https:&#x2F;&#x2F;xiaoliblog.cn, https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;xiaoliblog&#x2F;image@6b5e7ef72be1c8973d94e5a9c49accbf775ad820&#x2F;2021&#x2F;02&#x2F;01&#x2F;c485da031fe0e464d04eaba8a66c4a8f.png %&#125;&#123;% cell 小李博客, https:&#x2F;&#x2F;xiaoliblog.cn, https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;xiaoliblog&#x2F;image@6b5e7ef72be1c8973d94e5a9c49accbf775ad820&#x2F;2021&#x2F;02&#x2F;01&#x2F;c485da031fe0e464d04eaba8a66c4a8f.png %&#125;&#123;% cell 小李博客, https:&#x2F;&#x2F;xiaoliblog.cn, https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;xiaoliblog&#x2F;image@6b5e7ef72be1c8973d94e5a9c49accbf775ad820&#x2F;2021&#x2F;02&#x2F;01&#x2F;c485da031fe0e464d04eaba8a66c4a8f.png %&#125;&#123;% cell 小李博客, https:&#x2F;&#x2F;xiaoliblog.cn, https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;xiaoliblog&#x2F;image@6b5e7ef72be1c8973d94e5a9c49accbf775ad820&#x2F;2021&#x2F;02&#x2F;01&#x2F;c485da031fe0e464d04eaba8a66c4a8f.png %&#125;&#123;% endbtns %&#125; 小李博客 小李博客 小李博客 小李博客 小李博客 或者含有图标的按钮： 1234&#123;% btns rounded grid5 %&#125;&#123;% cell 下载源码, /, fas fa-download %&#125;&#123;% cell 查看文档, /, fas fa-book-open %&#125;&#123;% endbtns %&#125; 下载源码 查看文档 圆形图标 + 标题 + 描述 + 图片 + 网格 5 列 + 居中 1234567891011121314&#123;% btns circle center grid5 %&#125;&lt;a href=&#x27;https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1&#x27;&gt; &lt;i class=&#x27;fab fa-apple&#x27;&gt;&lt;/i&gt; &lt;b&gt;心率管家&lt;/b&gt; &#123;% p red, 专业版 %&#125; &lt;img src=&#x27;https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/heartmate_pro.png&#x27;&gt;&lt;/a&gt;&lt;a href=&#x27;https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1&#x27;&gt; &lt;i class=&#x27;fab fa-apple&#x27;&gt;&lt;/i&gt; &lt;b&gt;心率管家&lt;/b&gt; &#123;% p green, 免费版 %&#125; &lt;img src=&#x27;https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/heartmate_lite.png&#x27;&gt;&lt;/a&gt;&#123;% endbtns %&#125; 心率管家 专业版 心率管家 免费版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231[data-theme=&quot;dark&quot;] div.btns &#123; filter: brightness(0.7);&#125;[data-theme=&quot;dark&quot;] div.btns a &#123; background: 0 0;&#125;div.btns &#123; margin: 0 -8px; display: flex; flex-wrap: wrap; align-items: flex-start; overflow: visible; line-height: 1.8;&#125;div.btns,div.btns p,div.btns a &#123; font-size: 0.8125rem; color: #555;&#125;div.btns b &#123; font-size: 0.875rem;&#125;div.btns.wide &gt; a &#123; padding-left: 32px; padding-right: 32px;&#125;div.btns.fill &gt; a &#123; flex-grow: 1; width: auto;&#125;div.btns.around &#123; justify-content: space-around;&#125;div.btns.center &#123; justify-content: center;&#125;div.btns.grid2 &gt; a &#123; width: calc(100% / 2 - 16px);&#125;@media screen and (max-width: 1024px) &#123; div.btns.grid2 &gt; a &#123; width: calc(100% / 2 - 16px); &#125;&#125;@media screen and (max-width: 768px) &#123; div.btns.grid2 &gt; a &#123; width: calc(100% / 2 - 16px); &#125;&#125;@media screen and (max-width: 500px) &#123; div.btns.grid2 &gt; a &#123; width: calc(100% / 1 - 16px); &#125;&#125;div.btns.grid3 &gt; a &#123; width: calc(100% / 3 - 16px);&#125;@media screen and (max-width: 1024px) &#123; div.btns.grid3 &gt; a &#123; width: calc(100% / 3 - 16px); &#125;&#125;@media screen and (max-width: 768px) &#123; div.btns.grid3 &gt; a &#123; width: calc(100% / 3 - 16px); &#125;&#125;@media screen and (max-width: 500px) &#123; div.btns.grid3 &gt; a &#123; width: calc(100% / 1 - 16px); &#125;&#125;div.btns.grid4 &gt; a &#123; width: calc(100% / 4 - 16px);&#125;@media screen and (max-width: 1024px) &#123; div.btns.grid4 &gt; a &#123; width: calc(100% / 3 - 16px); &#125;&#125;@media screen and (max-width: 768px) &#123; div.btns.grid4 &gt; a &#123; width: calc(100% / 3 - 16px); &#125;&#125;@media screen and (max-width: 500px) &#123; div.btns.grid4 &gt; a &#123; width: calc(100% / 2 - 16px); &#125;&#125;div.btns.grid5 &gt; a &#123; width: calc(100% / 5 - 16px);&#125;@media screen and (max-width: 1024px) &#123; div.btns.grid5 &gt; a &#123; width: calc(100% / 4 - 16px); &#125;&#125;@media screen and (max-width: 768px) &#123; div.btns.grid5 &gt; a &#123; width: calc(100% / 3 - 16px); &#125;&#125;@media screen and (max-width: 500px) &#123; div.btns.grid5 &gt; a &#123; width: calc(100% / 2 - 16px); &#125;&#125;div.btns a &#123; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; margin: 8px; margin-top: calc(1.25 * 16px + 32px); min-width: 120px; font-weight: bold; display: flex; justify-content: flex-start; align-content: center; align-items: center; flex-direction: column; padding: 8px; text-align: center; background: #f6f6f6; border-radius: 4px;&#125;div.btns a &gt; img:first-child,div.btns a &gt; i:first-child &#123; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; height: 64px; width: 64px; box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.1); margin: 16px 8px 4px 8px; margin-top: calc(-1.25 * 16px - 32px); border: 2px solid #fff; background: #fff; line-height: 60px; font-size: 28px;&#125;div.btns a &gt; img:first-child.auto,div.btns a &gt; i:first-child.auto &#123; width: auto;&#125;div.btns a &gt; i:first-child &#123; color: #fff; background: #2196f3;&#125;div.btns a p,div.btns a b &#123; margin: 0.25em; font-weight: normal; line-height: 1.25; word-wrap: break-word;&#125;div.btns a b &#123; font-weight: bold; line-height: 1.3;&#125;div.btns a img &#123; margin: 0.4em auto;&#125;div.btns a:not([href]) &#123; cursor: default; color: inherit;&#125;div.btns a[href]:hover &#123; background: rgba(255, 87, 34, 0.15);&#125;div.btns a[href]:hover,div.btns a[href]:hover b &#123; color: #ff5722;&#125;div.btns a[href]:hover &gt; img:first-child,div.btns a[href]:hover &gt; i:first-child &#123; transform: scale(1.1) translateY(-8px); box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.1);&#125;div.btns a[href]:hover &gt; i:first-child &#123; background: #ff5722;&#125;div.btns.circle a &gt; img:first-child,div.btns.circle a &gt; i:first-child &#123; border-radius: 32px;&#125;div.btns.rounded a &gt; img:first-child,div.btns.rounded a &gt; i:first-child &#123; border-radius: 16px;&#125; Folding 查看图片测试 查看默认打开的折叠框 这是一个默认打开的折叠框。 查看代码测试 查看列表测试 hahahehe 查看嵌套测试 查看嵌套测试2 查看嵌套测试3 hahaha 语法格式参数列表示例代码源码查看 官方文档：https://volantis.js.org/v4/tag-plugins/ 12345&#123;% folding 参数（可选）, 标题 %&#125;![](https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg)&#123;% endfolding % 参数位置可以填写颜色和状态，多个参数用空格隔开 颜色 1blue, cyan, green, yellow, red 状态填写open 代表默认打开 123456789101112131415161718192021222324252627282930313233343536&#123;% folding 查看图片测试 %&#125;![](https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;xiaoliblog&#x2F;image@e72b6ce51e3fd88307f7f12e487747020bfb921c&#x2F;2021&#x2F;04&#x2F;22&#x2F;c02b2a29dd05fac30303d16e44d39c65.png)&#123;% endfolding %&#125;&#123;% folding cyan open, 查看默认打开的折叠框 %&#125;这是一个默认打开的折叠框。&#123;% endfolding %&#125;&#123;% folding green, 查看代码测试 %&#125;&#123;% endfolding %&#125;&#123;% folding yellow, 查看列表测试 %&#125;- haha- hehe&#123;% endfolding %&#125;&#123;% folding red, 查看嵌套测试 %&#125;&#123;% folding blue, 查看嵌套测试2 %&#125;&#123;% folding 查看嵌套测试3 %&#125;hahaha &lt;span&gt;&lt;img src&#x3D;&#39;hhttps:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;xiaoliblog&#x2F;image@e72b6ce51e3fd88307f7f12e487747020bfb921c&#x2F;2021&#x2F;04&#x2F;22&#x2F;c02b2a29dd05fac30303d16e44d39c65.png&#39; style&#x3D;&#39;height:24px&#39;&gt;&lt;&#x2F;span&gt;&#123;% endfolding %&#125;&#123;% endfolding %&#125;&#123;% endfolding %&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165[data-theme=&quot;dark&quot;] details &#123; filter: brightness(0.7);&#125;details &#123; display: block; padding: 16px; margin: 0.5rem 0; border-radius: 4px; font-size: 0.7375rem; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease; border: 1px solid #f6f6f6;&#125;details summary &#123; cursor: pointer; padding: 16px; margin: -16px; border-radius: 4px; color: rgba(85, 85, 85, 0.7); font-size: 0.7375rem; font-weight: bold; position: relative; line-height: normal;&#125;details summary &gt; p,details summary &gt; h1,details summary &gt; h2,details summary &gt; h3,details summary &gt; h4,details summary &gt; h5,details summary &gt; h6 &#123; display: inline; border-bottom: none !important;&#125;details summary:hover &#123; color: #555;&#125;details summary:hover:after &#123; position: absolute; content: &quot;+&quot;; text-align: center; top: 50%; transform: translateY(-50%); right: 16px;&#125;details &gt; summary &#123; background: #f6f6f6;&#125;details[blue] &#123; border-color: #e8f4fd;&#125;details[blue] &gt; summary &#123; background: #e8f4fd;&#125;details[cyan] &#123; border-color: #e8fafe;&#125;details[cyan] &gt; summary &#123; background: #e8fafe;&#125;details[green] &#123; border-color: #ebf9ed;&#125;details[green] &gt; summary &#123; background: #ebf9ed;&#125;details[yellow] &#123; border-color: #fff8e9;&#125;details[yellow] &gt; summary &#123; background: #fff8e9;&#125;details[red] &#123; border-color: #feefee;&#125;details[red] &gt; summary &#123; background: #feefee;&#125;details[open] &#123; border-color: rgba(85, 85, 85, 0.2);&#125;details[open] &gt; summary &#123; border-bottom: 1px solid rgba(85, 85, 85, 0.2); border-bottom-left-radius: 0; border-bottom-right-radius: 0;&#125;details[open][blue] &#123; border-color: rgba(33, 150, 243, 0.3);&#125;details[open][blue] &gt; summary &#123; border-bottom-color: rgba(33, 150, 243, 0.3);&#125;details[open][cyan] &#123; border-color: rgba(27, 205, 252, 0.3);&#125;details[open][cyan] &gt; summary &#123; border-bottom-color: rgba(27, 205, 252, 0.3);&#125;details[open][green] &#123; border-color: rgba(61, 197, 80, 0.3);&#125;details[open][green] &gt; summary &#123; border-bottom-color: rgba(61, 197, 80, 0.3);&#125;details[open][yellow] &#123; border-color: rgba(255, 189, 43, 0.3);&#125;details[open][yellow] &gt; summary &#123; border-bottom-color: rgba(255, 189, 43, 0.3);&#125;details[open][red] &#123; border-color: rgba(254, 95, 88, 0.3);&#125;details[open][red] &gt; summary &#123; border-bottom-color: rgba(254, 95, 88, 0.3);&#125;details[open] &gt; summary &#123; color: #555; margin-bottom: 0;&#125;details[open] &gt; summary:hover:after &#123; content: &quot;-&quot;;&#125;details[open] &gt; div.content &#123; padding: 16px; margin: -16px; margin-top: 0;&#125;details[open] &gt; div.content p &gt; a:hover &#123; text-decoration: underline;&#125; ElementUI 先引入样式 1&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/gh/zykjofficial/zykjresource@master/css/elementui.css&quot;&gt; 进入 ElementUi 官网: https://element.eleme.cn/#/zh-CN/component/button F12 查看，注意: 不支持fontawesome图标,请不要使用 密码样式的文本语法格式示例代码源码查看 官方文档：https://volantis.js.org/v4/tag-plugins/ 使用方法 1&lt;psw&gt;你要隐藏的内容&lt;/psw&gt;1&lt;psw&gt;你能看见我吗？&lt;/psw&gt; 你能看见我吗？12345678910111213141516171819#article-container psw:hover &#123; color: #333; background: none;&#125;#article-container psw &#123; color: transparent; background: #666; border-radius: 2px; transition: all 0.28s ease; -moz-transition: all 0.28s ease; -webkit-transition: all 0.28s ease; -o-transition: all 0.28s ease;&#125;[data-theme=&quot;dark&quot;] #article-container psw:hover &#123; color: #fff; filter: brightness(0.7);&#125; 扩展功能BiliBili 视频播放器 安装 hexo-tag-bilibili插件 1npm install --save hexo-tag-bilibili 安装插件后可能需要hexo clean清除一下缓存才有效果 语法格式示例代码效果演示 只能写 AID 号 如 78542237，如果为BVID号 如BV1nJ411v7iM，则需要转换一下 哔哩哔哩 BVID、AID 互转工具互转：https://bv-av.cn/get-bv-av 123&#123;% bilibili [av_id] %&#125;or&#123;% bilibili [av_id] [page] %&#125;1&#123;% bilibili 78542237 %&#125; 按键ctrl+alt+del 语法格式源码查看1&lt;kbd&gt;ctrl&lt;/kbd&gt;+&lt;kbd&gt;alt&lt;/kbd&gt;+&lt;kbd&gt;del&lt;/kbd&gt;1234567891011121314151617181920212223/*键盘样式 来自 https://blog.hclonely.com/ */kbd &#123; display: inline-block; color: #666; font: bold 9pt arial; text-decoration: none; text-align: center; padding: 2px 5px; margin: 0 5px; background: #eff0f2; -moz-border-radius: 4px; border-radius: 4px; border-top: 1px solid #f5f5f5; -webkit-box-shadow: inset 0 0 20px #e8e8e8, 0 1px 0 #c3c3c3, 0 1px 0 #c9c9c9, 0 1px 2px #333; -moz-box-shadow: inset 0 0 20px #e8e8e8, 0 1px 0 #c3c3c3, 0 1px 0 #c9c9c9, 0 1px 2px #333; -webkit-box-shadow: inset 0 0 20px #e8e8e8, 0 1px 0 #c3c3c3, 0 1px 0 #c9c9c9, 0 1px 2px #333; box-shadow: inset 0 0 20px #e8e8e8, 0 1px 0 #c3c3c3, 0 1px 0 #c9c9c9, 0 1px 2px #333; text-shadow: 0 1px 0 #f5f5f5;&#125; 动画特效 需要引入CSS样式：https://cdn.jsdelivr.net/gh/zykjofficial/zykjresource@master/css/font-awesome-animation.min.css 字体图标 Font Awesome：http://www.fontawesome.com.cn/faicons/ 阿里IconFont：https://www.iconfont.cn/ 12&lt;i class=&quot;字体图标 动画名&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fas fa-rocket faa-rising animated&quot;&gt;&lt;/i&gt; On DOM load On hover Icon faa-wrench animated faa-wrench animated-hover fas fa-wrench faa-ring animated faa-ring animated-hover fas fa-bell faa-horizontal animated faa-horizontal animated-hover fas fa-envelope faa-vertical animated faa-vertical animated-hover fas fa-thumbs-up faa-flash animated faa-flash animated-hover fas fa-thumbs-up faa-bounce animated faa-bounce animated-hover fas fa-thumbs-up faa-spin animated faa-spin animated-hover fas fa-spinner faa-float animated faa-float animated-hover fas fa-plane faa-pulse animated faa-pulse animated-hover fas fa-heart faa-shake animated faa-shake animated-hover fas fa-envelope faa-tada animated faa-tada animated-hover fas fa-trophy faa-passing animated faa-passing animated-hover fas fa-space-shuttle faa-passing-reverse animated faa-passing-reverse animated-hover fas fa-space-shuttle faa-burst animated faa-burst animated-hover fas fa-circle faa-falling animated faa-falling animated-hover fas fa-star faa-rising animated faa-rising animated-hover fas fa-rocket 然后在 DOM 元素的类名添加相应的动画即可 例如网址导航栏可以写为主页: / || fas fa-home faa-wrench animated 时间线语法格式示例代码效果演示源码查看 官方文档：https://volantis.js.org/v3/tag-plugins/ 123456789101112131415&#123;% timeline 时间线标题 %&#125;&#123;% timenode 时间节点（标题） %&#125;正文内容&#123;% endtimenode %&#125;&#123;% timenode 时间节点（标题） %&#125;正文内容&#123;% endtimenode %&#125;&#123;% endtimeline %&#125;123456789101112131415161718192021222324252627&#123;% timeline 升级小助手 %&#125;&#123;% timenode 2020-07-24 [2.6.6 -&gt; 3.0](https:&#x2F;&#x2F;github.com&#x2F;volantis-x&#x2F;hexo-theme-volantis&#x2F;releases) %&#125;1. 如果有 &#96;hexo-lazyload-image&#96; 插件，需要删除并重新安装最新版本，设置 &#96;lazyload.isSPA: true&#96;。2. 2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 &#96;use_cdn: true&#96; 则需要删除。3. 2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。4. 2.x 版本的置顶 &#96;top: true&#96; 改为了 &#96;pin: true&#96;，并且同样适用于 &#96;layout: page&#96; 的页面。5. 如果使用了 &#96;hexo-offline&#96; 插件，建议卸载，3.0 版本默认开启了 pjax 服务。&#123;% endtimenode %&#125;&#123;% timenode 2020-05-15 [2.6.3 -&gt; 2.6.6](https:&#x2F;&#x2F;github.com&#x2F;volantis-x&#x2F;hexo-theme-volantis&#x2F;releases&#x2F;tag&#x2F;2.6.6) %&#125;不需要额外处理。&#123;% endtimenode %&#125;&#123;% timenode 2020-04-20 [2.6.2 -&gt; 2.6.3](https:&#x2F;&#x2F;github.com&#x2F;volantis-x&#x2F;hexo-theme-volantis&#x2F;releases&#x2F;tag&#x2F;2.6.3) %&#125;1. 全局搜索 &#96;seotitle&#96; 并替换为 &#96;seo_title&#96;。2. group 组件的索引规则有变，使用 group 组件的文章内，&#96;group: group_name&#96; 对应的组件名必须是 &#96;group_name&#96;。2. group 组件的列表名优先显示文章的 &#96;short_title&#96; 其次是 &#96;title&#96;。&#123;% endtimenode %&#125;&#123;% endtimeline %&#125;升级小助手 2020-07-24 2.6.6 -&gt; 3.0 如果有 hexo-lazyload-image 插件，需要删除并重新安装最新版本，设置 lazyload.isSPA: true。2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 use_cdn: true 则需要删除。2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。2.x 版本的置顶 top: true 改为了 pin: true，并且同样适用于 layout: page 的页面。如果使用了 hexo-offline 插件，建议卸载，3.0 版本默认开启了 pjax 服务。 2020-05-15 2.6.3 -&gt; 2.6.6 不需要额外处理。 2020-04-20 2.6.2 -&gt; 2.6.3 全局搜索 seotitle 并替换为 seo_title。group 组件的索引规则有变，使用 group 组件的文章内，group: group_name 对应的组件名必须是 group_name。group 组件的列表名优先显示文章的 short_title 其次是 title。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111div.timenode &#123; position: relative;&#125;div.timenode:before,div.timenode:after &#123; content: &quot;&quot;; z-index: 1; position: absolute; background: rgba(68, 215, 182, 0.5); width: 2px; left: 7px;&#125;div.timenode:before &#123; top: 0; height: 6px;&#125;div.timenode:after &#123; top: 26px; height: calc(100% - 26px);&#125;div.timenode:last-child:after &#123; height: calc(100% - 26px - 16px); border-bottom-left-radius: 2px; border-bottom-right-radius: 2px;&#125;div.timenode .meta,div.timenode .body &#123; max-width: calc(100% - 24px);&#125;div.timenode .meta &#123; position: relative; color: var(--tab-botton-color); font-size: 0.375rem; line-height: 32px; height: 32px;&#125;div.timenode .meta:before,div.timenode .meta:after &#123; content: &quot;&quot;; position: absolute; top: 8px; z-index: 2;&#125;div.timenode .meta:before &#123; background: rgba(68, 215, 182, 0.5); width: 16px; height: 16px; border-radius: 8px;&#125;div.timenode .meta:after &#123; background: #44d7b6; margin-left: 2px; margin-top: 2px; width: 12px; height: 12px; border-radius: 6px; transform: scale(0.5);&#125;div.timenode .meta p &#123; font-weight: bold !important; margin: 0 0 0 24px !important;&#125;div.timenode .body &#123; margin: 4px 0 10px 24px; padding: 10px; border-radius: 12px; background: #efeded; display: inline-block;&#125;div.timenode .body p:first-child &#123; margin-top: 0 !important;&#125;div.timenode .body p:last-child &#123; margin-bottom: 0 !important;&#125;div.timenode .body .highlight &#123; background: #fff7ea; filter: grayscale(0%);&#125;div.timenode .body .highlight figcaption &#123; background: #ffeed2;&#125;div.timenode .body .highlight .gutter &#123; background: #ffedd0;&#125;div.timenode:hover .meta &#123; color: #444;&#125;div.timenode:hover .meta:before &#123; background: rgba(255, 87, 34, 0.5);&#125;div.timenode:hover .meta:after &#123; background: #ff5722; transform: scale(1);&#125;[data-theme=&quot;dark&quot;] div.timenode .body &#123; background: #2c2c2c;&#125;[data-theme=&quot;dark&quot;] div.timenode:hover .meta &#123; color: #ccd0d7;&#125;[data-theme=&quot;dark&quot;] div.timenode .meta &#123; color: rgba(255, 255, 255, 0.6);&#125;[data-theme=&quot;dark&quot;] div.timeline p.p.h2 &#123; color: rgba(255, 255, 255, 0.6);&#125; Friend Link语法格式示例代码效果演示源码查看1&#123;% link 标题, 链接, 图片 %&#125;1&#123;% link 小李博客, https://xiaoliblog.cn, https://cdn.jsdelivr.net/gh/xiaoliblog/image@6b5e7ef72be1c8973d94e5a9c49accbf775ad820/2021/02/01/c485da031fe0e464d04eaba8a66c4a8f.png %&#125;小李博客https://xiaoliblog.cn1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#article-container a.link-card &#123; margin: 0.25rem auto; background: #f6f6f6; display: inline-flex; align-items: center; cursor: pointer; text-align: center; min-width: 200px; max-width: 361px; color: #444; border-radius: 12px; text-decoration: none;&#125;@media screen and (max-width: 425px) &#123; #article-container a.link-card &#123; max-width: 100%; &#125;&#125;@media screen and (max-width: 375px) &#123; #article-container a.link-card &#123; width: 100%; &#125;&#125;#article-container a.link-card:hover &#123; box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.1);&#125;#article-container a.link-card div.left,#article-container a.link-card div.right &#123; pointer-events: none;&#125;#article-container a.link-card div.left &#123; width: 48px; height: 48px; margin: 12px; overflow: hidden; flex-shrink: 0; position: relative;&#125;#article-container a.link-card div.left i &#123; font-size: 32px; line-height: 48px; margin-left: 4px;&#125;#article-container a.link-card div.left img &#123; display: block; position: absolute; border-radius: 8px / 4; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125;#article-container a.link-card div.right &#123; overflow: hidden; margin-right: 12px;&#125;#article-container a.link-card p &#123; margin: 0;&#125;#article-container a.link-card p.text &#123; font-weight: bold;&#125;#article-container a.link-card p.url &#123; flex-shrink: 0; color: rgba(68, 68, 68, 0.65); font-size: 13px;&#125;[data-theme=&quot;dark&quot;] #article-container a.link-card img &#123; filter: brightness(1);&#125;[data-theme=&quot;dark&quot;] #article-container a.link-card &#123; filter: brightness(0.7);&#125;","path":"page/butterfly04.html","date":"12-03","excerpt":"","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://xiaoliblog.cn/tags/Hexo/"}]},{"title":"Butterfly魔改系列🦋基础视觉美化","text":"样式引入 下载源码 密码:eayb 在[BlogRoot]\\themes\\butterfly\\source\\css\\引入下载的MyStyle\\MyStyle.css文件 在主题配置文件引入 1234inject: head: # 美化和标签CSS - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/MyStyle/MyStyle.css&quot; media=&quot;defer&quot; onload=&quot;this.media=&#x27;all&#x27;&quot;/&gt; 视觉美化阿里云Iconfont 打开iconfont的网站，点击导航栏的人像图标，会跳出注册界面，按要求注册账户。 选择自己需要的图标，把鼠标移到图标上，会显示三個个按钮（依次是添加入库、收藏和下载），而我们需要的是把图标添加入库 加入购物车后，点击购物车，并把图标加入项目 添加到项目之后，点击Font class，然后再点击暂无代码，点击生成文字，网站会自动生产CSS链接，我们只需要复制链接就行 可以点开链接把代码引入自己的CSS文件中，也可以复制链接，在主题配置文件中引入CDN 使用格式为iconfont icon名字 修改图标大小和颜色：引入以下CSS即可 123456789101112131415161718192021222324252627282930313233343536373839/*.icon-bilibili:before &#123; content: &quot;\\e600&quot;;&#125; *//* 卡片处小图标 */.card_icon_bilibili &#123; /* 修改颜色 */ color: #FF69B4; /* 修改大小 */ font-size: 24px; &#125;.card_icon_git&#123; /* 修改颜色 */ color: #6495ED; /* 修改大小 */ font-size: 24px;&#125;.card_icon_qq&#123; /* 修改颜色 */ color:#FF8C00 ; /* 修改大小 */ font-size: 24px;&#125;.card_icon_csdn&#123; /* 修改颜色 */ color: #FF0000; /* 修改大小 */ font-size: 24px;&#125;.card_icon_zhihu&#123; /* 修改颜色 */ color: #00BFFF; /* 修改大小 */ font-size: 24px;&#125; fontawesome 引入CDN：https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css 格式 任意元素动画 参考任意元素添加动效动画 鼠标样式 在主题配置文件中引入CSS 123456789/*设置鼠标样式*/body &#123; cursor: url(https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/img/default.cur), default;&#125;a,img &#123; cursor: url(https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/img/pointer.cur), default;&#125; 页脚渐变123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/* 页脚footer *//* 渐变色滚动动画 */@-webkit-keyframes Gradient &#123; 0% &#123; background-position: 0 50%; &#125; 50% &#123; background-position: 100% 50%; &#125; 100% &#123; background-position: 0 50%; &#125;&#125;@-moz-keyframes Gradient &#123; 0% &#123; background-position: 0 50%; &#125; 50% &#123; background-position: 100% 50%; &#125; 100% &#123; background-position: 0 50%; &#125;&#125;@keyframes Gradient &#123; 0% &#123; background-position: 0 50%; &#125; 50% &#123; background-position: 100% 50%; &#125; 100% &#123; background-position: 0 50%; &#125;&#125;#footer &#123; background: linear-gradient(-45deg, #ee7752, #ce3e75, #23a6d5, #23d5ab); background-size: 400% 400%; -webkit-animation: Gradient 10s ease infinite; -moz-animation: Gradient 10s ease infinite; animation: Gradient 10s ease infinite; -o-user-select: none; -ms-user-select: none; -webkit-user-select: none; -moz-user-select: none; user-select: none; border-top-left-radius: 10px; border-top-right-radius: 10px;&#125;#footer:before &#123; background-color: rgba(0, 0, 0, 0);&#125; 1234/*页脚a标签字体颜色*/#footer-wrap a &#123; color: #00c4b6;&#125; 背景渐变123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#web_bg &#123; background: -webkit-linear-gradient( 0deg, rgba(247, 149, 51, 0.1) 0, rgba(243, 112, 85, 0.1) 15%, rgba(239, 78, 123, 0.1) 30%, rgba(161, 102, 171, 0.1) 44%, rgba(80, 115, 184, 0.1) 58%, rgba(16, 152, 173, 0.1) 72%, rgba(7, 179, 155, 0.1) 86%, rgba(109, 186, 130, 0.1) 100% ); background: -moz-linear-gradient( 0deg, rgba(247, 149, 51, 0.1) 0, rgba(243, 112, 85, 0.1) 15%, rgba(239, 78, 123, 0.1) 30%, rgba(161, 102, 171, 0.1) 44%, rgba(80, 115, 184, 0.1) 58%, rgba(16, 152, 173, 0.1) 72%, rgba(7, 179, 155, 0.1) 86%, rgba(109, 186, 130, 0.1) 100% ); background: -o-linear-gradient( 0deg, rgba(247, 149, 51, 0.1) 0, rgba(243, 112, 85, 0.1) 15%, rgba(239, 78, 123, 0.1) 30%, rgba(161, 102, 171, 0.1) 44%, rgba(80, 115, 184, 0.1) 58%, rgba(16, 152, 173, 0.1) 72%, rgba(7, 179, 155, 0.1) 86%, rgba(109, 186, 130, 0.1) 100% ); background: -ms-linear-gradient( 0deg, rgba(247, 149, 51, 0.1) 0, rgba(243, 112, 85, 0.1) 15%, rgba(239, 78, 123, 0.1) 30%, rgba(161, 102, 171, 0.1) 44%, rgba(80, 115, 184, 0.1) 58%, rgba(16, 152, 173, 0.1) 72%, rgba(7, 179, 155, 0.1) 86%, rgba(109, 186, 130, 0.1) 100% ); background: linear-gradient( 90deg, rgba(247, 149, 51, 0.1) 0, rgba(243, 112, 85, 0.1) 15%, rgba(239, 78, 123, 0.1) 30%, rgba(161, 102, 171, 0.1) 44%, rgba(80, 115, 184, 0.1) 58%, rgba(16, 152, 173, 0.1) 72%, rgba(7, 179, 155, 0.1) 86%, rgba(109, 186, 130, 0.1) 100% );&#125; 并把主题配置文件中的background设置为 &quot;#efefef&quot; ，否则有可能不会生效 文章透明度12345678910* 文章页背景 */.layout&gt;#post &#123; /* 以下代表白色透明度为0.3*/ background: rgba(255,255,255,.3);&#125;/* 所有背景（包括首页卡片、文章页、页面页等） */#aside_content .card-widget, #recent-posts&gt;.recent-post-item, .layout_page&gt;div:first-child:not(.recent-posts), .layout_post&gt;#page, .layout_post&gt;#post, .read-mode .layout_post&gt;#post&#123; /* 以下代表白色透明度为0.3 */ background: rgba(255,255,255,.3);&#125; 关于选择器名称可能不同，解决方法是通过F12调试查看对应的选择器名称 昵称颜色12345678910111213/* 博主昵称颜色 */.author-info__name &#123; color: #ff7242;&#125;/* 首页中间打字效果上方 博客昵称颜色*/#page-header #site_title &#123; color: #80bdab;&#125;/* 顶部导航栏 博客昵称颜色*/#nav a &#123; color: #f9f2f4;&#125; 图片虚影特效 引入以下CSS样式即可 123456789101112131415161718192021/*图片虚影*/.post_bg&#123; -webkit-animation: imgblur 2s 1 ease-in-out; animation: imgblur 2s 1 ease-in-out;&#125;@-webkit-keyframes imgblur &#123; 0% &#123; -webkit-filter: blur(5px); &#125; 100% &#123; -webkit-filter: blur(0px); &#125;&#125;@keyframes imgblur &#123; 0% &#123; filter: blur(5px); &#125; 100% &#123; filter: blur(0px); &#125;&#125; MAC代码框美化 将 butterfly.yml 的 highlight_theme 配置项改为 mac 后任意引入下方一个 css 即可。（也可加入到自己的 css 文件中） 白色代码框 https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/macWhite.css 黑色美化版 https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/macblack.css Mono本地字体 字体推荐：https://www.jetbrains.com/zh-cn/lp/mono/ 下载后解压到博客根目录\\themes\\butterfly\\source\\css\\fonts下 然后退回到\\css目录下创建JetBrainsMono.css引入 12345678910111213141516171819202122232425262728293031323334/*以下是本地字体引入*/@font-face &#123; font-family : &#x27;JetBrains Mono&#x27; ; /*字体名称*/ src : url(&#x27;https://cdn.jsdelivr.net/gh/xiaoliblog/xiaoliblog.github.io/css/fonts/JetBrainsMono/fonts/webfonts/JetBrainsMono-Medium.woff2&#x27;);/*字体资源*/ &#125;#article-container pre, #article-container code&#123; font-family: &#x27;JetBrains Mono&#x27; !important; font-size:16px !important; &#125; /*以下是代码颜色搭配，自行引入CSS*/ /*代码颜色，代码框背景*/#article-container figure.highlight,#article-container pre&#123; color:#a9a9a9;background:#f6f8fa&#125;/*顶部栏代码种类字体颜色和背景*/#article-container figure.highlight .highlight-tools&#123; color:#a9a9a9;background:#f3f3f3&#125;/*侧边栏行数颜色和背景*/#article-container figure.highlight .gutter pre&#123; color:#999;background:#f6f8fa&#125;/*HTML属性颜色*/#article-container figure.highlight .attr&#123; color:#39adb5;&#125;/*HTML属性值*/#article-container figure.highlight .string&#123; color:#f6aa43;&#125; 然后找的主题配置文件_config.xml引入CSS即可 123inject: head: - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/JetBrainsMono.css&quot;&gt; 主题颜色 找到主题配置文件里theme_color 1234567891011121314theme_color: #(自定义主题色) enable: true main: &quot;#49B1F5&quot; #文章颜色 paginator: &quot;#00c4b6&quot; #分页器颜色 button_hover: &quot;#FF7242&quot; # 鼠标移动到按钮上的显示的颜色 text_selection: &quot;#00c4b6&quot; #选择文字的背景颜色 link_color: &quot;#99a9bf&quot; #链接颜色 meta_color: &quot;#858585&quot; hr_color: &quot;#A4D8FA&quot; # 小剪刀颜色、小摩托颜色 code_foreground: &quot;#F47466&quot; # 代码`code`的颜色 code_background: &quot;rgba(27, 31, 35, .05)&quot; # 代码`code`的背景颜色 toc_color: &quot;#00c4b6&quot; blockquote_padding_color: &quot;#49b1f5&quot; # &gt; &gt;&gt; &gt;&gt;&gt; 描述颜色 blockquote_background_color: &quot;#49b1f5&quot; 公告栏装饰 在 C:\\lzyblog\\themes\\Butterfly\\_config.yml 里找到 card_announcement: 下的 content: 后面添加 123card_announcement: #公告栏 enable: true content: 城市的轮廓，你的孤独&lt;img src=&quot;https://cdn.jsdelivr.net/gh/lzyblog/image@main/2020/11/19/33a1542ce0a798e62e404f0bd948149f.png&quot;&gt;","path":"page/butterfly01.html","date":"12-02","excerpt":"","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://xiaoliblog.cn/tags/Hexo/"}]},{"title":"LeetCode每日一道","text":"参考最新的官方解答，精品阅读推荐 || 人人都能看得懂的Leetcode力扣刷题教程合集 || Leetcode力扣 1-300题视频讲解合集 || Leetcode力扣 301+题视频讲解合集 算法性能分析参考👉一个视频教会你算法的时间复杂度 || 一个视频教会你算法的空间复杂度 时间复杂度 时间复杂度 算法的执行效率，算法的执行时间与算法的输入值之间的关系 以下例子，设语句执行时间为a,b,c，假设循环10次，则此代码的执行时间为a+10b+c，通常省略成10b，为nb，b为系数可以省略不计，所以时间复杂度为O(n) 1234567funtion ON(num)&#123; var total = 0; //a fot(var i=0;i&lt;num;i++)&#123; total += i; //b &#125; return total; //c&#125; 以下代码，a+b都是常数，与输入num无关，所以时间复杂度为O(1) 12345function O1(num)&#123; var i=num; //a var j=num*2; //b return i+j;&#125; 以下代码，while循环logN次，时间复杂度为O(logN) 1234567function OlogN(num)&#123; var i=1; while(i&lt;num)&#123; //num=N i = i*2; // N*a &#125; return i;&#125; 以下代码，外层循环m次，内层循环了alogN次，去掉常数系数，则时间复杂度为O(MlogN) 123456789101112function ONLogN(num1,num2)&#123; var total = 0; var j = 0; for(var i=0;i&lt;num1;i++)&#123; //num1=m while(j &lt; num2)&#123; //num2=n //以下两个语言时间为a total += i + j; j = j*2; &#125; &#125; return total;&#125; 下列代码，并列两个循环，执行时间Mb+Nc，去掉固定常数，则时间复杂度为O(M+N) 123456789function OMN(num1,num2)&#123; var total = 0; for(var i=0;i&lt;num1;i++)&#123; //num1=M total += i; //b -&gt; M*b &#125; for(var j=0;j&lt;num2;j++)&#123; //num2=N total += j; //c -&gt; N*c &#125;&#125; 以下代码，外层执行N次，内存执行aN次，去掉常数系数，则时间复杂度O(N2) 123456789function ON2(num)&#123; var total = 0; for(var i=0;i&lt;num;i++)&#123; //num=N for(var j=0;j&lt;num;j++)&#123; total += i + j; //a &#125; &#125; return total;&#125; 对比 O(1)&lt;O(logN)&lt;O(N)&lt;O(MlogN)&lt;O(n2)&lt;O(2n)&lt;O(n!) 空间复杂度 空间复杂度 算法的存储空间与输入值之间的关系 以下代码，定义一个整型变量为4个字节，是不变的，空间复杂度为O(1) 1234567funtion test(num)&#123; var total = 0; fot(var i=0;i&lt;num;i++)&#123; total += i; &#125; return total; &#125; 以下代码，定义一个整型数组，每一个元素所占4个字节，数组大小随参数nums变化，则所占空间为nums*4，则空间复杂度为O(n) 1234567function test(nums)&#123; var array[]; for(var i=0;i&lt;nums;i++)&#123; array.append(i); &#125; return array;&#125; 两数之和 题目：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍 你可以按任意顺序返回答案 官方解题答案：https://leetcode-cn.com/articles/two-sum/ 123输入：nums &#x3D; [2,7,11,15], target &#x3D; 9输出：[0,1]解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 暴力法 两个两个一组，双层循环遍历所有可能，判断之和是否相等，即可找出答案，比如找到数组第一个数和后面所有的数两两相加判断是否等于目标值； 执行用68ms，内存消耗38.3MB 123456789var twoSum = function(nums, target) &#123; for(var i=0;i&lt;nums.length;i++)&#123; for(var j=i+1;j&lt;nums.length;j++)&#123; if(nums[i]+nums[j]==target)&#123; return [i,j]; &#125; &#125; &#125;&#125;; 哈希表法 首先构造哈希表map，哈希表是一种key:value的数据结构，用来存放数组的值和索引 遍历数组 nums，i 为当前下标，每个值都判断map中是否存在 target-nums[i] 的 key 值，也就是给定值的另一半数字，比如9-2=7，查看map.key是否存在数字7 如果存在则找到了两个值并判断索引不相等，如果不存在则将当前的 (nums[i],i) 存入 map 中，继续遍历直到找到为止 123456789var twoSum = function(nums, target) &#123; var map=new Map(); //构造哈希表 for(var i = 0; i&lt; nums.length; i++) &#123; //遍历 if(map.has(target - nums[i])) &#123; //查看是否存在目标值的另一个数字 return [map.get(target-nums[i]),i]; //返回下标 &#125; map.set(nums[i], i); //不存在就放入哈希表 &#125; &#125; 动画演示地址 两数相加 给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位 数字，如果为两位数，取个位数并向后一位数进一 请你将两个数相加，并以相同形式返回一个表示和的链表 你可以假设除了数字 0 之外，这两个数都不会以 0 开头 例如6+4=10，取个位数0并进一，4+3=7加上进的一位为7+1=8 官方解题答案：https://leetcode-cn.com/articles/add-two-numbers/ 1234567输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]输出：[7,0,8]解释：342 + 465 &#x3D; 807.&#x2F;&#x2F;极端进位清空输入：l1 &#x3D; [9,9,9], l2 &#x3D; [9,9]输出：[8,9,0,1]解释：999+99&#x3D;1098 解题思路 除法运算除10可以得到十位上的数(12/10=1)，对10取余运算可以得到个位数(12%10=2) 使用变量carry标记下一个数进位多少，并从包含最低有效位的表头开始模拟逐位相加的过程 例如，5 + 7 = 12在这种情况下，我们会将当前位的数值设置为 2，并将进位 carry = 1带入下一次迭代。进位 carry必定是 0 或 1，这是因为两个数字相加（考虑到进位）可能出现的最大和为 9 + 9 + 1 = 19 算法思路如下 创建一个dummy头结点，然后相加的结果依次添加串起来 curr指针指向头结点，用于往后遍历，并将指向的当前结点初始化为返回链表的哑结点 将进位carry初始为0 遍历链表L1和L2直至到达它们的尾端 设定sum=l1.val+l2.val+carry 更新进位的值，carry=sum/10 创建一个数值为(sum%10) 的新结点，并将其设置为当前结点的下一个结点，然后将当前结点前进到下一个结点 同时，将l1和l2前进到下一个结点 检查最后 carry=1 是否成立，如果成立，则向返回列表追加一个含有数字 1 的新结点 返回哑结点的下一个结点 123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */ class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode doummy = new ListNode(0); //初始一个返回链表的头结点 ListNode curr = doummy; //curr指针用来遍历链表 int carry=0; //定义进位变量，无进位为0，有进位为1 while( l1 != null || l2 != null)&#123; //两个链表都不为空 int sum=0; if( l1 != null)&#123; sum += l1.val; //求和 l1 = l1.next; //移到下一位 &#125; if( l2 != null)&#123; sum += l2.val; //求和 l2 = l2.next; //移到下一位 &#125; sum += carry; //再加上carry进位的值 curr.next=new ListNode(sum%10); //取个位上的数作为新结点加到当前指向的结点后面 carry = sum/10; //计算是否进位 curr = curr.next; //遍历指针移动到下一位 &#125; if(carry&gt;0)&#123; //判断最后carry进位是否为1 curr.next = new ListNode(carry); //如果为1，就作为结点加到后面 &#125; return doummy.next; //返回结果链表 &#125;&#125; 动画演示地址 无重复字符的最长子串 给定一个字符串，请你找出其中不含有重复字符的最长子串的长度 官方解题答案：https://leetcode-cn.com/articles/longest-substring-without-repeating-characters/ 12345678输入: s &#x3D; &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，因为往后会遇到a，a会重复，所以其长度为 3。-----输入: s &#x3D; &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是子串的长度，&quot;pwke&quot; 是一个子序列，不是子串。&quot;pw&quot;也不是，因为不是最长 滑动窗口 滑动窗口sliding window 其实就是一个队列，比如例题中的 abcabcbb，进入这个队列（窗口）为 abc 满足题目要求，当再进入 a，队列变成了 abca，这时候不满足要求。所以，我们要移动这个队列！ 如何移动？ 我们只要把队列的左边的元素移出就行了，直到满足题目要求！一直维持这样的队列，找出队列出现最长的长度时候，求出解！ 算法思路 创建一个set 两个指针，第一个指向字符串的开头j，第二个随着for循环遍历字符串i 如果set里没有s[i]， 说明目前为止还没有重复的字符,把s[i]添加到set里，然后更新最大不重复字符的数量，用maxLength变量存储，如果maxLength&lt;set.size就更新，否则不更新 如果set里有s[i]，则从set里开始删除s[j]，并且递增，再检查set里是否有s[i]，如此反复直到set里没有s[i]为止 重复步骤3和4，直到遍历完整个字符串 123456789101112131415161718192021222324/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLongestSubstring = function(s) &#123; const set = new Set(); //创建一个set集合 let i = 0,j = 0,maxLength = 0; //创建两个指针和记录最大不重复字符数量的变量 if(s.length === 0)&#123; //字符串为空 return 0; &#125; for(i;i&lt;s.length;i++)&#123; //遍历字符串 if( ! set.has(s[i]))&#123; //不重复情况，即set里没有s[i]，则添加到set里 set.add(s[i]); maxLength = Math.max(maxLength,set.size); //更新maxLength的值，保证为最大值 &#125;else&#123; //出现重复情况 while(set.has(s[i]))&#123; //如果set里有s[i]，则从set里开始删除s[j] set.delete(s[j]); j++; //j后移一位 &#125; set.add(s[i]); &#125; &#125; return maxLength;&#125;; 动画演示 最长回文子串 给你一个字符串 s，找到 s 中最长的回文子串，即一个字符串正序和逆序都是一样的 123456输入：s &#x3D; &quot;babad&quot;输出：&quot;bab&quot;解释：&quot;aba&quot; 同样是符合题意的答案---输入：s &#x3D; &quot;ac&quot;输出：&quot;a&quot; 采用从中心向两边扩散的方法，例如babad，但不是每个字符串都有中心点，例如cabbad 算法思路 如果字符串长度小于2，直接返回原字符串 定义两个变量，一个start存储当前找到的最大回文字符串的起始位置，另一个maxLength记录字符串的长度(终止位置就是start+ maxLength) 创建一个helper function，判断左边和右边是否越界，同时最左边的字符是否等于最右边的字符。如果以上三个条件都满足，则判断是否需要更新回文字符串最大长度及最大字符串的起始位置。然后将left--，right++向两边扩散，继续判断，直到不满足三个条件之一。 遍历字符串，每个位置调用helper function两遍，第一遍检查i-1,i+1, 第二遍检查i;i+1，第一遍查询处理存在中心的情况(babad)，第二遍查询处理不存在中心的情况(cabbad) 123456789101112131415161718192021222324252627/** * @param &#123;string&#125; s * @return &#123;string&#125; */var longestPalindrome = function(s) &#123; if(s.length &lt; 2)&#123; return s; &#125; let start = 0; //存储当前找到的最大回文字符串的起始位置 let maxLength = 1; //记录字符串的长度 function expandAroundCenter(left,right)&#123; //helper function函数 while(left &gt;= 0 &amp;&amp; right &lt;= s.length-1 &amp;&amp; s[left] === s[right])&#123; if(right - left + 1 &gt; maxLength)&#123; //找到更大的回文字符串 maxLength = right - left +1; start = left; &#125; //向两边扩散 left --; right ++; &#125; &#125; for(let i = 0;i &lt; s.length; i ++ )&#123; //每个元素都当作中心调用函数 expandAroundCenter(i-1,i+1); expandAroundCenter(i,i+1); &#125; return s.substring(start,start+maxLength); //截取字符串&#125;; 三数之和 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组 注意：答案中不可以包含重复的三元组 12345输入：nums &#x3D; [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]--- 输入：nums &#x3D; [0]输出：[] 算法思路 给数组排序 遍历数组，从0遍历到小于length-2 ，防止越界 如果当前的数字等于前一个数字，则跳过这个数，去掉重复 如果数字不同，则设置start= i+1，end=length-1，查看i，start和end三个数的和此零大还是小，如果比0小，start++，如果比0大，end--，如果等于0，把这三个数加入到结果里。 返回结果 12345678910111213141516171819202122232425262728293031323334353637/** * @param &#123;number[]&#125; nums * @return &#123;number[][]&#125; */var threeSum = function (nums) &#123; const result = []; //存放结果 nums.sort(function (a, b) &#123; //数组排序 return a - b; &#125;); for (let i = 0; i &lt; nums.length - 2; i++) &#123; //遍历数组至length-2，防止越界 if (i === 0 || nums[i] !== nums[i - 1]) &#123; //去重操作，重复就跳过 let start = i + 1; let end = nums.length - 1; while (start &lt; end) &#123; //两边指针向里面缩 if (nums[i] + nums[start] + nums[end] === 0) &#123; //找到正确结果 result.push([nums[i], nums[start], nums[end]]); //存放到result数组里 start++; end--; //去重操作 while (start &lt; end &amp;&amp; nums[start] === nums[start - 1]) &#123; start++; &#125; while (start &lt; end &amp;&amp; nums[end] === nums[end + 1]) &#123; end--; &#125; &#125; else if (nums[i] + nums[start] + nums[end] &lt; 0) &#123; start++; &#125; else &#123; end--; &#125; &#125; &#125; &#125; return result;&#125;; 算法演示","path":"page/leetcode01.html","date":"11-24","excerpt":"","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://xiaoliblog.cn/tags/LeetCode/"}]},{"title":"Hexo+GitHub搭建个人博客","text":"背景知识 什么是GitHub？ GitHub Pages 是由 GitHub 官方提供的一种免费的静态站点托管服务，让我们可以在 GitHub 仓库里托管和发布自己的静态网站页面。 About GitHub Pages 什么是Hexo？ Hexo 是一个快速、简洁且高效的静态博客框架，它基于 Node.js 运行，可以将我们撰写的 Markdown 文档解析渲染成静态的 HTML 网页。 Hexo官网||Hexo工作原理 什么是Git? GIT(分布式版本控制系统),git支持分布式部署，可以有效、高速的处理从很小到非常大的项目版本管理。分布式相比于集中式的最大区别在于开发者可以提交到本地，每个开发者通过克隆（git clone），在本地机器上拷贝一个完整的Git仓库。 Git教程 什么是Node.js Node.js就是一个用于创建服务器端应用程序的运行系统，它可以轻松构建网络或其他事件驱动的应用程序服务器。 Hexo+GitHub文章发布原理 在本地撰写 Markdown 格式文章后，通过 Hexo 解析文档，渲染生成具有主题样式的 HTML 静态网页，再推送到 GitHub 上完成博文的发布。 SSH运行原理及应用 需要使用SSH提供的公钥，可以省去hexo d命令时的密码登录. SSH运行原理及应用 Markdown标记语言 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。文档后缀为 .md, .markdown。 Markdown API||Markdown语法手册 环境搭建Node.js Hexo 基于 Node.js，搭建过程中还需要使用 npm（Node.js 已带） 和 git，因此先搭建本地操作环境，安装 Node.js 和 Git。 Node.js下载网址 Node.js安装教程 Git Git下载地址 -Git安装及配置 安装完成后，任意位置右击鼠标Git Bash Here(全程用Git Bash,git为linux命令) 1$ node -v 1$ npm -v 1$ git --version 回车，出现程序版本号即可。 注意:如果出现&quot;npm&quot;不是内部指定，说明环境变量没配好,Node.js文件目录复制路径到Path中即可 安装Hexo 使用换源指令从阿里源下载Hexo 1$ npm config set registry https://registry.npm.taobao.org 12$ cnpm install -g hexo-cli$ hexo -v Hexo搭建 创建文件夹，名字随便取，比如我的是C:\\blog\\lzyblog，这个文件夹就是存放代码的地方。 1$ cd /c/blog/lzyblog 在文件夹下右击“Git Bash Here”执行以下命令 1$ hexo init #创建一个新的hexo项目放在所创建文件夹下 hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图： 12$ hexo g #生成$ hexo s #为hexo在本地起一个http server 执行后在浏览器中输入”localhost:4000/“,就可以看到博客界面，按ctrl+c关闭本地服务器若出现端口被占用，请戳Windows下如何查看某个端口被谁占用 修改博客文件名/source/_posts/xxxx.md 中修改博客，修改后操作 1234$ hexo new xxx #新建一篇标题为xxx的文章$ hexo clean #清除缓存$ hexo g #生成将要发布的博客网站包含html在内的静态资源$ hexo s 部署到GitHub 注册登录GuiHub 注意用户名与网址访问域名要一致 创建GuiHub库(new repository)新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 http://test.github.io 了。创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。 配置SSH key 为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题，利用SSH登录远程主机。 登录方式有两种： 口令登录 公钥登录 区别:口令登录每次都要输入密码，公钥登录不需要输入密码. 安装了 Git Bash，自带了 SSH。检验一下是否安装 SSH，我们在新建的文件夹中右键打开 Git Bash输入命令: 1$ cd ~/. ssh #检查本机已存在的ssh密钥 如果提示：No such file or directory 说明你是第一次使用git。 12$ git config --global user.name &quot;Gitub用户名&quot;$ git config --global user.email &quot;GitHub邮箱&quot; 然后检查SSH安装和生成密匙 12$ ssh$ ssh-keygen -t rsa -C &quot;GitHub邮箱&quot; 敲四次回车就会生成两个文件，分别为秘钥 id_rsa 和公钥 id_rsa.pub. （注意：git中的复制粘贴不是 Ctrl+C 和 Ctrl+V，而是 Ctrl+insert 和 Shift+insert.）文件的位置在 Git Bash 上面都有显示，默认生成在以下目录： Linux 系统：~/.ssh Mac 系统：~/.ssh Windows 10 ：C:/Users/ASUS/.ssh 然后复制公钥 id_rsa.pub 文件里的内容,如果找不到可以通过命令查找 123$ cd ~/.ssh #检查本机已存在的ssh密钥$ ls$ cat id_rsa.pub 添加到Github 进入GitHub主页，点击右上角。再点击setting-&gt;SSH and GPG keys-&gt;New SSH key-&gt;将复制的id_rsa.pub内容粘贴到key内点击Add SSH key 1$ ssh -T git@github.com #验证是否成功 部署插件1$ cnpm install --save hexo-deployer-git _config.yml 配置_config.yml中有关deploy的部分：(推荐使用sublime Text) 1234deploy: type: git repo: https://github.com/lzyblog/lzyblog.github.io （仓库url） branch: master 1$ hexo d #部署到Github 修改博客目录构成 打开文件夹,可以看到博客的目录结构如下： node_modules是node.js各种库的目录 public是生成的网页文件目录 scaffolds里面就三个文件，存储着新文章和新页面的初始设置 source是我们最常用到的一个目录，里面存放着文章、各类页面、图像等文件 themes存放着主题文件，一般也用不到。 我们平时写文章只需要关注source/_posts这个文件夹就行了。 通过文件名\\source\\_posts目录下xxx.md文件修改 1234$ hexo clean #清除缓存$ hexo s #可在本地预览$ hexo g #部署$ hexo d #提交Github 修改提交时创常见问题 发现peployer不存在,需要重新引入部署插件： 1$ cnpm install --save hexo-deployer-git 修改主题 登录Hexo网址：https://hexo.io/themes/ 本人比较喜欢：hexo-theme-butterfly 1234567$ cd /c/blog/lzyblog#git clone 主题url.git themes/主题名$ git clone https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly$ hexo clean$ hexo g$ hexo s #预览$ hexo d 部署完后需要在博客主文件_config.yml中配置: 1theme: butterfly #主题名 常见问题 Hexo更改主题后启动服务器，界面显如下字符: 1extends includes/layout.pug block content include includes/recent-posts.pug include includes/partial 解决方案 1$ npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive 清除缓存 1$ hexo clean 生成静态文件即可 1$ hexo g 安装或者切换主题后 hexo s 打开 http://localhost:4000/ 后抱错 1extends includes&#x2F;layout.pug block content #recent-posts.recent-posts include includes&#x2F;recent-posts.pug include includes&#x2F;pagination.pug 原因：未安装 pug 依赖和渲染插件依赖 1$ npm install hexo-renderer-pug hexo-renderer-stylus --save 关于Butterfly主题优化可以看我的另一篇文章！Butterfly主题魔改！ Hexo错误：spawn failed参考Hexo错误：spawn failed的解决方法：https://blog.zhheo.com/p/128998ac.html 参考感谢CodeSheep大佬带我入坑","path":"page/hexoblog.html","date":"11-14","excerpt":"","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://xiaoliblog.cn/tags/Hexo/"}]}],"categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://xiaoliblog.cn/tags/SpringBoot/"},{"name":"企业常用技术","slug":"企业常用技术","permalink":"http://xiaoliblog.cn/tags/%E4%BC%81%E4%B8%9A%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF/"},{"name":"SSM","slug":"SSM","permalink":"http://xiaoliblog.cn/tags/SSM/"},{"name":"项目案例","slug":"项目案例","permalink":"http://xiaoliblog.cn/tags/%E9%A1%B9%E7%9B%AE%E6%A1%88%E4%BE%8B/"},{"name":"ECMAScript 6","slug":"ECMAScript-6","permalink":"http://xiaoliblog.cn/tags/ECMAScript-6/"},{"name":"jQuery","slug":"jQuery","permalink":"http://xiaoliblog.cn/tags/jQuery/"},{"name":"Ajax","slug":"Ajax","permalink":"http://xiaoliblog.cn/tags/Ajax/"},{"name":"分页","slug":"分页","permalink":"http://xiaoliblog.cn/tags/%E5%88%86%E9%A1%B5/"},{"name":"Vue.js","slug":"Vue-js","permalink":"http://xiaoliblog.cn/tags/Vue-js/"},{"name":"Axios","slug":"Axios","permalink":"http://xiaoliblog.cn/tags/Axios/"},{"name":"跨域问题","slug":"跨域问题","permalink":"http://xiaoliblog.cn/tags/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"},{"name":"Nginx","slug":"Nginx","permalink":"http://xiaoliblog.cn/tags/Nginx/"},{"name":"Webpack","slug":"Webpack","permalink":"http://xiaoliblog.cn/tags/Webpack/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://xiaoliblog.cn/tags/SpringMVC/"},{"name":"Spring","slug":"Spring","permalink":"http://xiaoliblog.cn/tags/Spring/"},{"name":"设计模式","slug":"设计模式","permalink":"http://xiaoliblog.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://xiaoliblog.cn/tags/Mybatis/"},{"name":"MySQL","slug":"MySQL","permalink":"http://xiaoliblog.cn/tags/MySQL/"},{"name":"Maven","slug":"Maven","permalink":"http://xiaoliblog.cn/tags/Maven/"},{"name":"Linux","slug":"Linux","permalink":"http://xiaoliblog.cn/tags/Linux/"},{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"http://xiaoliblog.cn/tags/IntelliJ-IDEA/"},{"name":"Git","slug":"Git","permalink":"http://xiaoliblog.cn/tags/Git/"},{"name":"Node.js","slug":"Node-js","permalink":"http://xiaoliblog.cn/tags/Node-js/"},{"name":"Canvas","slug":"Canvas","permalink":"http://xiaoliblog.cn/tags/Canvas/"},{"name":"SVG","slug":"SVG","permalink":"http://xiaoliblog.cn/tags/SVG/"},{"name":"数据结构","slug":"数据结构","permalink":"http://xiaoliblog.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://xiaoliblog.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"http://xiaoliblog.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"乐理","slug":"乐理","permalink":"http://xiaoliblog.cn/tags/%E4%B9%90%E7%90%86/"},{"name":"Bootstrap响应式","slug":"Bootstrap响应式","permalink":"http://xiaoliblog.cn/tags/Bootstrap%E5%93%8D%E5%BA%94%E5%BC%8F/"},{"name":"Web移动开发","slug":"Web移动开发","permalink":"http://xiaoliblog.cn/tags/Web%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"},{"name":"Hexo","slug":"Hexo","permalink":"http://xiaoliblog.cn/tags/Hexo/"},{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"http://xiaoliblog.cn/tags/HTML-CSS/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://xiaoliblog.cn/tags/JavaWeb/"},{"name":"操作系统","slug":"操作系统","permalink":"http://xiaoliblog.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://xiaoliblog.cn/tags/JavaScript/"},{"name":"图床","slug":"图床","permalink":"http://xiaoliblog.cn/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"JavaSE","slug":"JavaSE","permalink":"http://xiaoliblog.cn/tags/JavaSE/"},{"name":"工具","slug":"工具","permalink":"http://xiaoliblog.cn/tags/%E5%B7%A5%E5%85%B7/"},{"name":"杂谈","slug":"杂谈","permalink":"http://xiaoliblog.cn/tags/%E6%9D%82%E8%B0%88/"},{"name":"Pug","slug":"Pug","permalink":"http://xiaoliblog.cn/tags/Pug/"},{"name":"Stylus","slug":"Stylus","permalink":"http://xiaoliblog.cn/tags/Stylus/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://xiaoliblog.cn/tags/LeetCode/"}]}